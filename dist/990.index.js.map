{"version":3,"file":"990.index.js","mappings":";;;;;;;;;;;;AAAA;;;;;;;;;;;AAWA;AAEA;AAwBA;AAKA;AAJA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxGA;;;;;;;;;;;AAWA;;;;;;;;;;AAEA;AACA;AAGA;AACA;AAMA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAOA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1GA;;;;;;;;;;;AAWA;;;;;;;;;;AAEA;AACA;AAUA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA","sources":["webpack://github-helpers/./src/core/multisigs-collector.ts","webpack://github-helpers/./src/helpers/backstage-multisig-metrics.ts","webpack://github-helpers/./src/utils/get-backstage-entities.ts"],"sourcesContent":["/*\nCopyright 2022 Aurora Labs\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { Entity, isApiEntity, stringifyEntityRef, RELATION_OWNED_BY, RELATION_HAS_PART, parseEntityRef } from '@backstage/catalog-model';\n\ntype MultisigSigner = {\n  signer: Entity;\n  owner?: Entity;\n};\n\ntype MultisigInfo = {\n  entity: Entity;\n  signers: MultisigSigner[];\n};\n\ntype ComponentMultisigs = {\n  title: string;\n  component: Entity;\n  multisigs: MultisigInfo[];\n};\n\ntype SystemComponents = {\n  title: string;\n  system: Entity;\n  components: ComponentMultisigs[];\n};\n\nexport class MultisigsCollector {\n  systemComponents: SystemComponents[] = [];\n  private entities: Entity[] = [];\n  private multisigs: Entity[] = [];\n\n  constructor(entities: Entity[]) {\n    this.entities = entities;\n    this.multisigs = this.entities.filter(item => isApiEntity(item) && item.spec.type === 'multisig-deployment');\n    this.systemComponents = this.collectSystems();\n  }\n\n  normalizeEntities(list: string[]) {\n    return [...new Set(list)].sort((a, b) => a.localeCompare(b));\n  }\n\n  collectSystems() {\n    const systemRefs = this.normalizeEntities(this.multisigs.map(item => item.spec!.system! as string));\n    return systemRefs\n      .map(systemRef => {\n        const system = this.entities.find(item => stringifyEntityRef(item) === systemRef)!;\n        const components = this.collectComponents(system);\n\n        return {\n          title: system.metadata.title || system.metadata.name,\n          system,\n          components\n        };\n      })\n      .sort((a, b) => a.system.metadata.name.localeCompare(b.system.metadata.name));\n  }\n\n  collectComponents(system: Entity) {\n    const componentRefs = system.relations!.filter(r => r.type === RELATION_HAS_PART && parseEntityRef(r.targetRef).kind === 'component');\n    return componentRefs\n      .map(componentRef => {\n        const component = this.entities.find(item => stringifyEntityRef(item) === componentRef.targetRef)!;\n        return {\n          title: component.metadata.title || component.metadata.name,\n          component,\n          multisigs: this.multisigs\n            .filter(item => item.relations!.some(r => r.type === 'apiProvidedBy' && r.targetRef === componentRef.targetRef))\n            .map(ms => ({\n              entity: ms,\n              signers: this.collectSigners(ms)\n            }))\n        };\n      })\n      .sort((a, b) => a.component.metadata.name.localeCompare(b.component.metadata.name));\n  }\n\n  collectSigners(multisig: Entity) {\n    return multisig\n      .relations!.filter(r => r.type === RELATION_OWNED_BY && parseEntityRef(r.targetRef).kind !== 'group')\n      .map(r => {\n        const signer = this.entities.find(e => stringifyEntityRef(e) === r.targetRef)!;\n        const owner = this.entities.find(e => stringifyEntityRef(e) === signer.spec!.owner)!;\n        return {\n          signer,\n          owner\n        };\n      })\n      .sort((a, b) => a.owner.metadata.name.localeCompare(b.owner.metadata.name));\n  }\n\n  getMultisigs() {\n    return this.systemComponents.flatMap(system => system.components.flatMap(component => component.multisigs));\n  }\n}\n","/*\nCopyright 2022 Aurora Labs\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport * as core from '@actions/core';\nimport { client, v2 } from '@datadog/datadog-api-client';\nimport { MetricSeries } from '@datadog/datadog-api-client/dist/packages/datadog-api-client-v2';\n\nimport { MultisigsCollector } from '../core/multisigs-collector';\nimport { getBackstageEntities } from '../utils/get-backstage-entities';\n\ntype MultisigMetricsParams = {\n  backstage_url?: string;\n};\n\nconst configuration = client.createConfiguration();\nconst apiInstance = new v2.MetricsApi(configuration);\n\nexport const backstageMultisigMetrics = async ({ backstage_url }: MultisigMetricsParams) => {\n  if (!backstage_url) return;\n  const entities = await getBackstageEntities({ backstage_url });\n\n  const multisigsCollector = new MultisigsCollector(entities);\n  const series: MetricSeries[] = multisigsCollector.getMultisigs().map(ms => {\n    // entities are typically emitted as API kind,\n    // tracking for inconsistencies\n    const { kind, metadata } = ms.entity;\n    const { name } = metadata;\n    // name follows this format: <network>-<type>-<address>\n    const titleParts = name?.split('-');\n    const [network, type] = titleParts;\n\n    // inferred type is JsonObject, this converts to any\n    const spec = JSON.parse(JSON.stringify(ms.entity.spec));\n    const version = spec.multisig.version;\n    const timestamp = Math.round(new Date(spec.multisig.fetchDate).getTime() / 1000);\n\n    // this tags timeseries with distinguishing\n    // properties for filtering purposes\n    const resources = [\n      {\n        type: 'host',\n        name: backstage_url.split('@')[1]\n      },\n      { type: 'api', name },\n      { type: 'kind', name: kind },\n      { type: 'network', name: network },\n      { type: 'type', name: type }\n    ];\n    // datadog requires point value to be scalar\n    const value = getCompliance({ version, network });\n    const points = [{ timestamp, value }];\n    return {\n      metric: 'backstage.multisigs.versions',\n      type: 0,\n      points,\n      resources\n    };\n  });\n\n  const params: v2.MetricsApiSubmitMetricsRequest = {\n    body: {\n      series\n    }\n  };\n  core.info(`Data uploaded: ${JSON.stringify(params)}`);\n\n  try {\n    const data = await apiInstance.submitMetrics(params);\n    core.info(`API called successfully. Returned data: ${JSON.stringify(data)}`);\n    return data;\n  } catch (error: unknown) {\n    core.error(error as Error);\n    return;\n  }\n};\n\ntype getComplianceArgs = {\n  version: string;\n  network: string;\n};\n\n/**\n * Helper function that checks multisig version and returns a compliance value.\n * `1` representing compliance and `0` for non compliance.\n */\nfunction getCompliance({ version, network }: getComplianceArgs): number {\n  if (network === 'near') {\n    if (parseFloat(version) >= 2) {\n      return 1;\n    }\n  } else if (network === 'ethereum' || network === 'aurora') {\n    if (parseFloat(version) >= 1.3) {\n      return 1;\n    }\n  }\n  return 0;\n}\n","/*\nCopyright 2022 Aurora Labs\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport * as core from '@actions/core';\nimport { CatalogClient } from '@backstage/catalog-client';\n\ntype DiscoveryApi = {\n  getBaseUrl(pluginId: string): Promise<string>;\n};\n\ninterface GetBackstageEntities {\n  backstage_url?: string;\n}\n\nexport const getBackstageEntities = async ({ backstage_url }: GetBackstageEntities) => {\n  if (!backstage_url) {\n    throw new Error('BACKSTAGE_URL is required, make sure to set the secret');\n  }\n\n  core.info('Connecting to Backstage to fetch available entities');\n\n  const discoveryApi: DiscoveryApi = {\n    async getBaseUrl() {\n      return `${backstage_url}/api/catalog`;\n    }\n  };\n  const catalogClient = new CatalogClient({\n    discoveryApi\n  });\n\n  const entities = await catalogClient.getEntities({});\n  core.info(`Total backstage entities: ${entities.items.length}`);\n\n  return entities.items;\n};\n"],"names":[],"sourceRoot":""}