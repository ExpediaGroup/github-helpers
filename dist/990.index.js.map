{"version":3,"file":"990.index.js","mappings":";;;;;;;;;;;;AAAA;;;;;;;;;;;AAWA;AAEA;AAwBA;AAKA;AAJA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpHA;;;;;;;;;;;AAWA;;;;;;;;;;AAEA;AACA;AAEA;AACA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzIA;;;;;;;;;;;AAWA;;;;;;;;;;AAEA;AACA;AAEA;AACA;AAWA;;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;;AACA;AAEA;AACA;;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA","sources":["webpack://github-helpers/./src/core/multisigs-collector.ts","webpack://github-helpers/./src/helpers/backstage-multisig-metrics.ts","webpack://github-helpers/./src/utils/get-backstage-entities.ts"],"sourcesContent":["/*\nCopyright 2022 Aurora Labs\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { Entity, isApiEntity, stringifyEntityRef, RELATION_OWNED_BY, RELATION_HAS_PART, parseEntityRef } from '@backstage/catalog-model';\n\ntype MultisigSigner = {\n  signer: Entity;\n  owner?: Entity;\n};\n\ntype MultisigInfo = {\n  entity: Entity;\n  signers: MultisigSigner[];\n};\n\ntype ComponentMultisigs = {\n  title: string;\n  component: Entity;\n  multisigs: MultisigInfo[];\n};\n\ntype SystemComponents = {\n  title: string;\n  system: Entity;\n  components: ComponentMultisigs[];\n};\n\nexport class MultisigsCollector {\n  systemComponents: SystemComponents[] = [];\n  private entities: Entity[] = [];\n  private multisigs: Entity[] = [];\n\n  constructor(entities: Entity[]) {\n    this.entities = entities;\n    this.multisigs = this.entities.filter(item => isApiEntity(item) && item.spec.type === 'multisig-deployment');\n    this.systemComponents = this.collectSystems();\n  }\n\n  normalizeEntities(list: string[]) {\n    return [...new Set(list)].sort((a, b) => a.localeCompare(b));\n  }\n\n  collectSystems() {\n    const systemRefs = this.normalizeEntities(this.multisigs.map(item => item.spec!.system! as string));\n    return systemRefs\n      .map(systemRef => {\n        const system = this.entities.find(item => stringifyEntityRef(item) === systemRef)!;\n        const components = this.collectComponents(system);\n\n        return {\n          title: system.metadata.title || system.metadata.name,\n          system,\n          components\n        };\n      })\n      .sort((a, b) => a.system.metadata.name.localeCompare(b.system.metadata.name));\n  }\n\n  collectComponents(system: Entity) {\n    const componentRefs = system.relations!.filter(r => r.type === RELATION_HAS_PART && parseEntityRef(r.targetRef).kind === 'component');\n    return componentRefs\n      .map(componentRef => {\n        const component = this.entities.find(item => stringifyEntityRef(item) === componentRef.targetRef)!;\n        return {\n          title: component.metadata.title || component.metadata.name,\n          component,\n          multisigs: this.multisigs\n            .filter(item => item.relations!.some(r => r.type === 'apiProvidedBy' && r.targetRef === componentRef.targetRef))\n            .map(ms => ({\n              entity: ms,\n              signers: this.collectSigners(ms)\n            }))\n        };\n      })\n      .sort((a, b) => a.component.metadata.name.localeCompare(b.component.metadata.name));\n  }\n\n  collectSigners(multisig: Entity) {\n    return multisig\n      .relations!.filter(r => r.type === RELATION_OWNED_BY && parseEntityRef(r.targetRef).kind !== 'group')\n      .map(r => {\n        const signer = this.entities.find(e => stringifyEntityRef(e) === r.targetRef)!;\n        const owner = this.entities.find(e => stringifyEntityRef(e) === signer.spec!.owner)!;\n        return {\n          signer,\n          owner\n        };\n      })\n      .sort((a, b) => a.owner.metadata.name.localeCompare(b.owner.metadata.name));\n  }\n\n  getMultisigs() {\n    return this.systemComponents.flatMap(system => system.components.flatMap(component => component.multisigs));\n  }\n\n  getSigners() {\n    const allSigners = this.getMultisigs().flatMap(ms => ms.signers);\n    const uniqueSigners = allSigners.reduce<{ [uid: string]: MultisigSigner }>((acc, signer) => {\n      const uid = signer.signer.metadata.uid;\n      if (uid && uid in allSigners) {\n        return acc;\n      }\n      return { ...acc, [uid as string]: signer };\n    }, {});\n    return Object.values(uniqueSigners);\n  }\n}\n","/*\nCopyright 2022 Aurora Labs\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport * as core from '@actions/core';\nimport { client, v2 } from '@datadog/datadog-api-client';\n\nimport { MultisigsCollector } from '../core/multisigs-collector';\nimport { getBackstageEntities } from '../utils/get-backstage-entities';\n\ntype MultisigMetricsParams = {\n  backstage_url?: string;\n};\n\nconst configuration = client.createConfiguration();\nclient.setServerVariables(configuration, {\n  site: 'datadoghq.eu'\n});\nconst apiInstance = new v2.MetricsApi(configuration);\n\nexport const backstageMultisigMetrics = async ({ backstage_url }: MultisigMetricsParams) => {\n  if (!backstage_url) return;\n  const entities = await getBackstageEntities({ backstage_url });\n\n  const multisigsCollector = new MultisigsCollector(entities);\n  const multisigSeries = generateMultisigMetrics(multisigsCollector, backstage_url);\n  await submitMetrics(multisigSeries);\n\n  const signerSeries = generateSignerMetrics(multisigsCollector, backstage_url);\n  await submitMetrics(signerSeries);\n};\n\nasync function submitMetrics(series: v2.MetricSeries[]) {\n  const params = {\n    body: {\n      series\n    }\n  };\n  core.info(`Data uploaded: ${JSON.stringify(params)}`);\n\n  try {\n    const data = await apiInstance.submitMetrics(params);\n    core.info(`API called successfully. Returned data: ${JSON.stringify(data)}`);\n  } catch (error: unknown) {\n    core.error(error as Error);\n  }\n}\n\nfunction generateMultisigMetrics(collector: MultisigsCollector, backstageUrl: string) {\n  const series = collector.getMultisigs().map<v2.MetricSeries>(multisig => {\n    // entities are typically emitted as API kind,\n    // tracking for inconsistencies\n    const { kind, metadata } = multisig.entity;\n    const { name } = metadata;\n\n    // inferred type is JsonObject, this converts to any\n    const spec = JSON.parse(JSON.stringify(multisig.entity.spec));\n    const { address, network, networkType, system: rawSystem, owner: rawOwner } = spec;\n    const system = rawSystem.split(':')[1];\n    const owner = rawOwner.split(':')[1];\n    const timestamp = Math.round(new Date(spec.multisig.fetchDate).getTime() / 1000);\n\n    // this tags timeseries with distinguishing\n    // properties for filtering purposes\n    const resources = [\n      {\n        type: 'host',\n        name: backstageUrl.split('@')[1]\n      },\n      { type: 'api', name },\n      { type: 'address', name: address },\n      { type: 'kind', name: kind },\n      { type: 'network', name: network },\n      { type: 'networkType', name: networkType },\n      { type: 'system', name: system },\n      { type: 'owner', name: owner }\n    ];\n\n    const { version } = spec.multisig;\n    // datadog requires point value to be scalar\n    const value = parseFloat(version);\n    const points = [{ timestamp, value }];\n    return {\n      metric: 'backstage.multisigs.version',\n      type: 3,\n      points,\n      resources\n    };\n  });\n  return series;\n}\n\nfunction generateSignerMetrics(collector: MultisigsCollector, backstageUrl: string) {\n  const series = collector.getSigners().map<v2.MetricSeries>(signer => {\n    // entities are typically emitted as API kind,\n    // tracking for inconsistencies\n    const { kind, metadata } = signer.signer;\n    const { name, namespace } = metadata;\n    // inferred type is JsonObject, this converts to any\n    const spec = JSON.parse(JSON.stringify(signer.signer.spec));\n    const { address, network, networkType, owner: rawOwner } = spec;\n    const owner = rawOwner.split(':')[1].split('/')[1];\n    // this tags timeseries with distinguishing\n    // properties for filtering purposes\n    const resources = [\n      {\n        type: 'host',\n        name: backstageUrl.split('@')[1]\n      },\n      { type: 'kind', name: kind },\n      { type: 'name', name },\n      { type: 'namespace', name: namespace },\n      { type: 'address', name: address },\n      { type: 'network', name: network },\n      { type: 'networkType', name: networkType },\n      { type: 'owner', name: owner }\n    ];\n    // datadog requires point value to be scalar, 0 means unknown ownership\n    const value = namespace === 'stub' ? 0 : 1;\n    const points = [{ timestamp: new Date().getTime(), value }];\n    return {\n      metric: 'backstage.signers',\n      type: 3,\n      points,\n      resources\n    };\n  });\n  return series;\n}\n","/*\nCopyright 2022 Aurora Labs\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport * as core from '@actions/core';\nimport { CatalogClient } from '@backstage/catalog-client';\nimport { Entity } from '@backstage/catalog-model';\nimport { simpleGit } from 'simple-git';\nimport { now } from 'lodash';\n\ntype DiscoveryApi = {\n  getBaseUrl(pluginId: string): Promise<string>;\n};\n\ninterface GetBackstageEntities {\n  backstage_url?: string;\n  backstage_entities_repo?: string;\n}\n\nasync function getFileContentFromRepo(repoUrl: string, filePath: string): Promise<string> {\n  const cloneDir = `/tmp/github-helpers-${now()}`;\n  const git = simpleGit();\n\n  try {\n    await git.clone(repoUrl, cloneDir, ['--depth=1']);\n    await git.cwd(cloneDir);\n\n    const { current } = await git.branch();\n    const defaultBranch = current || 'main';\n    const fileContent: string = await git.show([`${defaultBranch}:${filePath}`]);\n\n    await git.raw(['rm', '-rf', '.']);\n    return fileContent;\n  } catch (error) {\n    throw new Error(`Failed to fetch ${repoUrl}/${filePath}: ${error}`);\n  }\n}\n\nasync function fetchBackstageEntitiesFromURL(backstage_url: string) {\n  core.info('Connecting to Backstage to fetch available entities');\n\n  const discoveryApi: DiscoveryApi = {\n    async getBaseUrl() {\n      return `${backstage_url}/api/catalog`;\n    }\n  };\n  const catalogClient = new CatalogClient({\n    discoveryApi\n  });\n\n  const entities = await catalogClient.getEntities({});\n  core.info(`Total backstage entities: ${entities.items.length}`);\n\n  return entities.items;\n}\n\nasync function fetchBackstageEntitiesFromRepo(backstage_entities_repo: string) {\n  const serverUrl = process.env.GITHUB_SERVER_URL || 'https://github.com';\n  const repoUrl = `${serverUrl}/${backstage_entities_repo}`;\n  core.info(`Cloning ${repoUrl}`);\n  const content = await getFileContentFromRepo(repoUrl, 'filteredEntities.json');\n  return JSON.parse(content) as Entity[];\n}\n\nexport const getBackstageEntities = async ({ backstage_url, backstage_entities_repo }: GetBackstageEntities) => {\n  // repo takes a priority over the URL in order to avoid unnecessary runtime\n  // dependency\n  if (backstage_entities_repo) {\n    return fetchBackstageEntitiesFromRepo(backstage_entities_repo);\n  } else if (backstage_url) {\n    return fetchBackstageEntitiesFromURL(backstage_url);\n  }\n  throw new Error(\n    'Backstage URL or entities repo is required. Set BACKSTAGE_URL (github secret) or pass backstage_entities_repo argument to this action'\n  );\n};\n"],"names":[],"sourceRoot":""}