{"version":3,"file":"990.index.js","mappings":";;;;;;;;;;;;AAAA;;;;;;;;;;;AAWA;AAEA;AAqCA;AASA;AARA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC7OA;;;;;;;;;;;AAWA;;;;;;;;;;AAEA;AACA;AAGA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnfA;;;;;;;;;;;AAWA;;;;;;;;;;AAEA;AACA;AAEA;AACA;AAWA;;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;;AACA;AAEA;AACA;;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA","sources":["webpack://github-helpers/./src/core/multisigs-collector.ts","webpack://github-helpers/./src/helpers/backstage-multisig-metrics.ts","webpack://github-helpers/./src/utils/get-backstage-entities.ts"],"sourcesContent":["/*\nCopyright 2022 Aurora Labs\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {\n  Entity,\n  isApiEntity,\n  isResourceEntity,\n  stringifyEntityRef,\n  RELATION_OWNED_BY,\n  RELATION_API_CONSUMED_BY,\n  RELATION_HAS_PART,\n  parseEntityRef\n} from '@backstage/catalog-model';\n\ntype MultisigSigner = {\n  signer: Entity;\n  owner?: Entity;\n};\ntype MultisigSignerAndKeysComposed = MultisigSigner & { keys: Entity[] };\ntype MultisigSignerAndKeys = {\n  [K in keyof MultisigSignerAndKeysComposed]: MultisigSignerAndKeysComposed[K];\n};\n\ntype MultisigInfo = {\n  entity: Entity;\n  signers: MultisigSigner[];\n};\n\ntype ComponentMultisigs = {\n  title: string;\n  component: Entity;\n  multisigs: MultisigInfo[];\n};\n\ntype SystemComponents = {\n  title: string;\n  system: Entity;\n  components: ComponentMultisigs[];\n};\n\nexport class MultisigsCollector {\n  systemComponents: SystemComponents[] = [];\n  private entities: Entity[] = [];\n  private apiEntities: Entity[] = [];\n  private resourceEntities: Entity[] = [];\n  private multisigs: Entity[] = [];\n  private contracts: Entity[] = [];\n  private accessKeys: Entity[] = [];\n\n  constructor(entities: Entity[]) {\n    this.entities = entities;\n    this.apiEntities = this.entities.filter(isApiEntity);\n    this.resourceEntities = this.entities.filter(isResourceEntity);\n    this.multisigs = this.apiEntities.filter(item => item.spec?.type === 'multisig-deployment');\n    this.contracts = this.apiEntities.filter(item => item.spec?.type === 'contract-deployment');\n    this.accessKeys = this.resourceEntities.filter(item => item.spec?.type === 'access-key');\n    this.systemComponents = this.collectSystems();\n  }\n\n  normalizeEntities(list: string[]) {\n    return [...new Set(list)].sort((a, b) => a.localeCompare(b));\n  }\n\n  collectSystems() {\n    const systemRefs = this.normalizeEntities(this.multisigs.map(item => item.spec!.system! as string));\n    return systemRefs\n      .map(systemRef => {\n        const system = this.entities.find(item => stringifyEntityRef(item) === systemRef)!;\n        const components = this.collectComponents(system);\n\n        return {\n          title: system.metadata.title || system.metadata.name,\n          system,\n          components\n        };\n      })\n      .sort((a, b) => a.system.metadata.name.localeCompare(b.system.metadata.name));\n  }\n\n  collectComponents(system: Entity) {\n    const componentRefs = system.relations!.filter(r => r.type === RELATION_HAS_PART && parseEntityRef(r.targetRef).kind === 'component');\n    return componentRefs\n      .map(componentRef => {\n        const component = this.entities.find(item => stringifyEntityRef(item) === componentRef.targetRef)!;\n        return {\n          title: component.metadata.title || component.metadata.name,\n          component,\n          multisigs: this.multisigs\n            .filter(item => item.relations!.some(r => r.type === 'apiProvidedBy' && r.targetRef === componentRef.targetRef))\n            .map(ms => ({\n              entity: ms,\n              signers: this.collectSigners(ms)\n            }))\n        };\n      })\n      .sort((a, b) => a.component.metadata.name.localeCompare(b.component.metadata.name));\n  }\n\n  collectSigners(multisig: Entity) {\n    return multisig\n      .relations!.filter(r => r.type === RELATION_OWNED_BY && parseEntityRef(r.targetRef).kind !== 'group')\n      .map(r => {\n        const signer = this.entities.find(e => stringifyEntityRef(e) === r.targetRef)!;\n        const owner = this.entities.find(e => stringifyEntityRef(e) === signer.spec!.owner)!;\n        return {\n          signer,\n          owner\n        };\n      })\n      .sort((a, b) => a.owner.metadata.name.localeCompare(b.owner.metadata.name));\n  }\n\n  getAllApis() {\n    return this.apiEntities;\n  }\n\n  getAllResources() {\n    return this.resourceEntities;\n  }\n\n  getMultisigs() {\n    return this.systemComponents.flatMap(system => system.components.flatMap(component => component.multisigs));\n  }\n\n  getNearContracts() {\n    return this.contracts.filter(entity => entity.spec?.network === 'near');\n  }\n\n  getSigners() {\n    const allSigners = this.getMultisigs().flatMap(ms => ms.signers);\n    const uniqueSigners = allSigners.reduce<{ [uid: string]: MultisigSigner }>((acc, signer) => {\n      const uid = signer.signer.metadata.uid;\n      if (uid && uid in allSigners) {\n        return acc;\n      }\n      if (!this.isQualifiedEntity(signer.signer)) {\n        return acc;\n      }\n      return { ...acc, [uid as string]: signer };\n    }, {});\n    return Object.values(uniqueSigners);\n  }\n\n  getMultisigAccessKeys(): Entity[] {\n    const signers = this.getSigners().filter(value => value.signer.spec?.network === 'near');\n    const keys = signers.flatMap(value => {\n      if (!value.signer.relations) {\n        return [];\n      }\n      return value.signer.relations\n        .filter(r => r.type === RELATION_API_CONSUMED_BY && parseEntityRef(r.targetRef).kind === 'resource')\n        .map(relation => {\n          const key = this.entities.find(e => stringifyEntityRef(e) === relation.targetRef);\n          return key;\n        });\n    });\n\n    return keys.filter<Entity>(this.isEntity).filter(this.isQualifiedEntity);\n  }\n\n  getAccessKeysPerSigner() {\n    const signers = this.getSigners().filter(value => value.signer.spec?.network === 'near');\n    const keysPerSigner = signers.reduce<{ [s: string]: MultisigSignerAndKeys }>((acc, value) => {\n      if (!value.signer.relations) {\n        return acc;\n      }\n      const spec = JSON.parse(JSON.stringify(value.signer.spec));\n      const signer: string = spec.address;\n      const keys = value.signer.relations\n        .filter(r => r.type === RELATION_API_CONSUMED_BY && parseEntityRef(r.targetRef).kind === 'resource')\n        .map(relation => {\n          const key = this.entities.find(e => stringifyEntityRef(e) === relation.targetRef);\n          return key;\n        })\n        .filter<Entity>(this.isEntity);\n\n      return {\n        ...acc,\n        [signer]: {\n          owner: value.owner,\n          signer: value.signer,\n          keys\n        }\n      };\n    }, {});\n\n    return keysPerSigner;\n  }\n\n  getContractAccessKeys(): Entity[] {\n    const keys = this.contracts.flatMap(value => {\n      if (!value.relations) {\n        return [];\n      }\n      return value.relations\n        .filter(r => r.type === RELATION_API_CONSUMED_BY && parseEntityRef(r.targetRef).kind === 'resource')\n        .map(relation => {\n          const key = this.entities.find(e => stringifyEntityRef(e) === relation.targetRef);\n          return key;\n        });\n    });\n    return keys.filter<Entity>(this.isEntity);\n  }\n\n  getAllAccessKeys(): Entity[] {\n    return this.accessKeys;\n  }\n\n  getDeprecatedAccessKeys(): Entity[] {\n    const keys = this.getAllAccessKeys();\n    const deprecated = keys.filter(entity => entity.metadata.tags?.includes('deprecated'));\n    return deprecated;\n  }\n\n  getUnknownAccessKeys(): Entity[] {\n    const keys = this.getAllAccessKeys();\n    const unknown = keys.filter(entity => entity.metadata.tags?.includes('unknown'));\n    return unknown;\n  }\n\n  private isQualifiedEntity(entity: Entity) {\n    return !entity.metadata.tags?.includes('retired') && !entity.metadata.tags?.includes('allow-unknown');\n  }\n\n  private isEntity(entity: Entity | undefined): entity is Entity {\n    return entity !== undefined;\n  }\n}\n","/*\nCopyright 2022 Aurora Labs\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport * as core from '@actions/core';\nimport { client, v2 } from '@datadog/datadog-api-client';\nimport { Entity } from '@backstage/catalog-model';\n\nimport { MultisigsCollector } from '../core/multisigs-collector';\nimport { getBackstageEntities } from '../utils/get-backstage-entities';\n\ntype MultisigMetricsParams = {\n  backstage_url?: string;\n};\ntype KeysByOwner = {\n  [owner: string]: Entity[];\n};\n\nconst configuration = client.createConfiguration();\nclient.setServerVariables(configuration, {\n  site: 'datadoghq.eu'\n});\nconst apiInstance = new v2.MetricsApi(configuration);\nconst DATADOG_GAUGE_TYPE = 3;\nconst SIGNER_POLICY_LIMIT_MS = 180 * 86400 * 1000; // amount of days * seconds in day * milliseconds in second\n\nexport const backstageMultisigMetrics = async ({ backstage_url }: MultisigMetricsParams) => {\n  if (!backstage_url) return;\n  const entities = await getBackstageEntities({ backstage_url });\n\n  const multisigsCollector = new MultisigsCollector(entities);\n\n  try {\n    const multisigSeries = generateMultisigMetrics(multisigsCollector, backstage_url);\n    const signerSeries = generateSignerMetrics(multisigsCollector, backstage_url);\n    const keySeries = generateAccessKeyMetrics(multisigsCollector, backstage_url);\n    const keyCountByOwnerSeries = generateUserAccessKeyMetrics(multisigsCollector, backstage_url);\n    const keyCountByContractSeries = generateContractAccessKeyMetrics(multisigsCollector, backstage_url);\n    const deprecatedKeysSeries = generateDeprecatedAccessKeyMetrics(multisigsCollector, backstage_url);\n    const unknownAccessKeysSeries = generateUnknownAccessKeyMetrics(multisigsCollector, backstage_url);\n    const unknownSignerSeries = generateUnknownSignerMetrics(multisigsCollector, backstage_url);\n    const unknownAddressSeries = generateUnknownAddressMetrics(multisigsCollector, backstage_url);\n    const inactiveSignerSeries = generateInactiveSignerMetrics(multisigsCollector, backstage_url);\n    // const unverifiedContractSeries = generateUnverifiedContractsMetrics(multisigsCollector, backstage_url);\n    const data = await Promise.all([\n      submitMetrics(multisigSeries),\n      submitMetrics(signerSeries),\n      submitMetrics(keySeries),\n      submitMetrics(keyCountByOwnerSeries),\n      submitMetrics(keyCountByContractSeries),\n      submitMetrics(deprecatedKeysSeries),\n      submitMetrics(unknownAccessKeysSeries),\n      submitMetrics(unknownSignerSeries),\n      submitMetrics(unknownAddressSeries),\n      submitMetrics(inactiveSignerSeries)\n      // submitMetrics(unverifiedContractSeries)\n    ]);\n\n    core.info(`API called successfully. Returned data: ${JSON.stringify(data)}`);\n    return data;\n  } catch (error: unknown) {\n    core.error(error as Error);\n  }\n};\n\nasync function submitMetrics(series: v2.MetricSeries[]) {\n  const params = {\n    body: {\n      series\n    }\n  };\n  core.info(`Data to upload: ${JSON.stringify(params)}`);\n\n  return apiInstance.submitMetrics(params);\n}\n\nfunction generateMultisigMetrics(collector: MultisigsCollector, backstageUrl: string) {\n  const series = collector.getMultisigs().map<v2.MetricSeries>(multisig => {\n    // entities are typically emitted as API kind,\n    // tracking for inconsistencies\n    const { kind, metadata } = multisig.entity;\n    const { name } = metadata;\n\n    // inferred type is JsonObject, this converts to any\n    const spec = JSON.parse(JSON.stringify(multisig.entity.spec));\n    const { address, network, networkType, system: rawSystem, owner: rawOwner } = spec;\n    const system = rawSystem.split(':')[1];\n    const owner = rawOwner.split(':')[1];\n    const timestamp = Math.round(new Date(spec.multisig.fetchDate).getTime() / 1000);\n\n    // this tags timeseries with distinguishing\n    // properties for filtering purposes\n    const resources = [\n      {\n        type: 'host',\n        name: backstageUrl.split('@')[1]\n      },\n      { type: 'api', name },\n      { type: 'address', name: address },\n      { type: 'kind', name: kind },\n      { type: 'network', name: network },\n      { type: 'networkType', name: networkType },\n      { type: 'system', name: system },\n      { type: 'owner', name: owner }\n    ];\n\n    const { version } = spec.multisig;\n    // datadog requires point value to be scalar\n    const value = parseFloat(version);\n    const points = [{ timestamp, value }];\n    return {\n      metric: 'backstage.multisigs.version',\n      type: DATADOG_GAUGE_TYPE,\n      points,\n      resources\n    };\n  });\n  return series;\n}\n\nfunction generateSignerMetrics(collector: MultisigsCollector, backstageUrl: string) {\n  const series = collector.getSigners().map<v2.MetricSeries>(signer => {\n    // entities are typically emitted as API kind,\n    // tracking for inconsistencies\n    const { kind, metadata } = signer.signer;\n    const { name, namespace } = metadata;\n    // inferred type is JsonObject, this converts to any\n    const spec = JSON.parse(JSON.stringify(signer.signer.spec));\n    const { address, network, networkType, owner: rawOwner } = spec;\n    const owner = rawOwner.split(':')[1].split('/')[1];\n    // this tags timeseries with distinguishing\n    // properties for filtering purposes\n    const resources = [\n      {\n        type: 'host',\n        name: backstageUrl.split('@')[1]\n      },\n      { type: 'kind', name: kind },\n      { type: 'name', name },\n      { type: 'namespace', name: namespace },\n      { type: 'address', name: address },\n      { type: 'network', name: network },\n      { type: 'networkType', name: networkType },\n      { type: 'owner', name: owner }\n    ];\n    // datadog requires point value to be scalar, 0 means unknown ownership\n    const value = namespace === 'stub' ? 0 : 1;\n    const timestamp = Math.round(new Date().getTime() / 1000);\n    const points = [{ timestamp, value }];\n    return {\n      metric: 'backstage.signers',\n      type: DATADOG_GAUGE_TYPE,\n      points,\n      resources\n    };\n  });\n  return series;\n}\n\nfunction generateUnknownSignerMetrics(collector: MultisigsCollector, backstageUrl: string) {\n  const unknownSigners = collector\n    .getSigners()\n    .filter(entry => entry.signer.metadata.tags?.includes('stub') || entry.signer.metadata.namespace === 'stub');\n  const series = unknownSigners.map<v2.MetricSeries>(signer => {\n    // entities are typically emitted as API kind,\n    // tracking for inconsistencies\n    const { kind, metadata } = signer.signer;\n    const { name, namespace } = metadata;\n    // inferred type is JsonObject, this converts to any\n    const spec = JSON.parse(JSON.stringify(signer.signer.spec));\n    const { address, network, networkType, owner: rawOwner } = spec;\n    const owner = rawOwner.split(':')[1].split('/')[1];\n    // this tags timeseries with distinguishing\n    // properties for filtering purposes\n    const resources = [\n      {\n        type: 'host',\n        name: backstageUrl.split('@')[1]\n      },\n      { type: 'kind', name: kind },\n      { type: 'name', name },\n      { type: 'namespace', name: namespace },\n      { type: 'address', name: address },\n      { type: 'network', name: network },\n      { type: 'networkType', name: networkType },\n      { type: 'owner', name: owner }\n    ];\n    // datadog requires point value to be scalar, 0 means unknown ownership\n    const value = 1;\n    const timestamp = Math.round(new Date().getTime() / 1000);\n    const points = [{ timestamp, value }];\n    return {\n      metric: 'backstage.signers.unknown',\n      type: DATADOG_GAUGE_TYPE,\n      points,\n      resources\n    };\n  });\n  return series;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction generateUnverifiedContractsMetrics(collector: MultisigsCollector, backstageUrl: string) {\n  const unverifiedContracts = collector.getAllApis().filter(entity => entity.metadata.tags?.includes('unverified'));\n  const series = unverifiedContracts.map<v2.MetricSeries>(entity => {\n    // entities are typically emitted as API kind,\n    // tracking for inconsistencies\n    const { kind, metadata } = entity;\n    const { name, namespace } = metadata;\n    // inferred type is JsonObject, this converts to any\n    const spec = JSON.parse(JSON.stringify(entity.spec));\n    const { address, network, networkType, owner: rawOwner } = spec;\n    const owner = rawOwner.split(':')[1].split('/')[1];\n    // this tags timeseries with distinguishing\n    // properties for filtering purposes\n    const resources = [\n      {\n        type: 'host',\n        name: backstageUrl.split('@')[1]\n      },\n      { type: 'kind', name: kind },\n      { type: 'name', name },\n      { type: 'namespace', name: namespace },\n      { type: 'address', name: address },\n      { type: 'network', name: network },\n      { type: 'networkType', name: networkType },\n      { type: 'owner', name: owner }\n    ];\n    // datadog requires point value to be scalar, 0 means unknown ownership\n    const value = 1;\n    const timestamp = Math.round(new Date().getTime() / 1000);\n    const points = [{ timestamp, value }];\n    return {\n      metric: 'backstage.reports.unverified=contracts',\n      type: DATADOG_GAUGE_TYPE,\n      points,\n      resources\n    };\n  });\n  return series;\n}\n\nfunction generateUnknownAddressMetrics(collector: MultisigsCollector, backstageUrl: string) {\n  const stubAndStateEntities = collector\n    .getAllResources()\n    .filter(entry => entry.metadata.tags?.includes('stub') && entry.metadata.tags?.includes('contract-state'));\n  const series = stubAndStateEntities.map<v2.MetricSeries>(entity => {\n    // entities are typically emitted as API kind,\n    // tracking for inconsistencies\n    const { kind, metadata } = entity;\n    const { name, namespace } = metadata;\n    // inferred type is JsonObject, this converts to any\n    const spec = JSON.parse(JSON.stringify(entity.spec));\n    const { address, network, networkType, owner: rawOwner } = spec;\n    const owner = rawOwner.split(':')[1].split('/')[1];\n    // this tags timeseries with distinguishing\n    // properties for filtering purposes\n    const resources = [\n      {\n        type: 'host',\n        name: backstageUrl.split('@')[1]\n      },\n      { type: 'kind', name: kind },\n      { type: 'name', name },\n      { type: 'namespace', name: namespace },\n      { type: 'address', name: address },\n      { type: 'network', name: network },\n      { type: 'networkType', name: networkType },\n      { type: 'owner', name: owner }\n    ];\n    // datadog requires point value to be scalar, 0 means unknown ownership\n    const value = 1;\n    const timestamp = Math.round(new Date().getTime() / 1000);\n    const points = [{ timestamp, value }];\n    return {\n      metric: 'backstage.reports.unknown-addresses',\n      type: DATADOG_GAUGE_TYPE,\n      points,\n      resources\n    };\n  });\n  return series;\n}\n\nfunction generateAccessKeyMetrics(collector: MultisigsCollector, backstageUrl: string) {\n  const series = collector.getMultisigAccessKeys().map<v2.MetricSeries>(key => {\n    // entities are typically emitted as Resource kind,\n    // tracking for inconsistencies\n    const { kind, metadata } = key;\n    const { name, namespace } = metadata;\n    // inferred type is JsonObject, this converts to any\n    const spec = JSON.parse(JSON.stringify(key.spec));\n    const { owner: rawOwner } = spec;\n    const [ownerKind, ownerRef] = rawOwner.split(':');\n    const ownerName = ownerRef.split('/')[1];\n    // this tags timeseries with distinguishing\n    // properties for filtering purposes\n    const resources = [\n      {\n        type: 'host',\n        name: backstageUrl.split('@')[1]\n      },\n      { type: 'kind', name: kind },\n      { type: 'name', name },\n      { type: 'namespace', name: namespace },\n      { type: 'owner', name: ownerName },\n      { type: 'ownerKind', name: ownerKind }\n    ];\n    const value = namespace === 'stub' || ownerKind !== 'user' ? 0 : 1;\n    const timestamp = Math.round(new Date().getTime() / 1000);\n    const points = [{ timestamp, value }];\n    return {\n      metric: 'backstage.access_keys',\n      type: DATADOG_GAUGE_TYPE,\n      points,\n      resources\n    };\n  });\n  return series;\n}\n\nfunction generateDeprecatedAccessKeyMetrics(collector: MultisigsCollector, backstageUrl: string) {\n  const series = collector.getDeprecatedAccessKeys().map<v2.MetricSeries>(key => {\n    // entities are typically emitted as Resource kind,\n    // tracking for inconsistencies\n    const { kind, metadata } = key;\n    const { name, namespace } = metadata;\n    // inferred type is JsonObject, this converts to any\n    const spec = JSON.parse(JSON.stringify(key.spec));\n    const { owner: rawOwner } = spec;\n    const [ownerKind, ownerRef] = rawOwner.split(':');\n    const ownerName = ownerRef.split('/')[1];\n    // this tags timeseries with distinguishing\n    // properties for filtering purposes\n    const resources = [\n      {\n        type: 'host',\n        name: backstageUrl.split('@')[1]\n      },\n      { type: 'kind', name: kind },\n      { type: 'name', name },\n      { type: 'namespace', name: namespace },\n      { type: 'owner', name: ownerName },\n      { type: 'ownerKind', name: ownerKind }\n    ];\n    const value = ownerKind !== 'user' ? 0 : 1;\n    const timestamp = Math.round(new Date().getTime() / 1000);\n    const points = [{ timestamp, value }];\n    return {\n      metric: 'backstage.access_keys.deprecated',\n      type: DATADOG_GAUGE_TYPE,\n      points,\n      resources\n    };\n  });\n  return series;\n}\n\nfunction generateUnknownAccessKeyMetrics(collector: MultisigsCollector, backstageUrl: string) {\n  const series = collector.getUnknownAccessKeys().map<v2.MetricSeries>(key => {\n    // entities are typically emitted as Resource kind,\n    // tracking for inconsistencies\n    const { kind, metadata } = key;\n    const { name, namespace } = metadata;\n    // inferred type is JsonObject, this converts to any\n    const spec = JSON.parse(JSON.stringify(key.spec));\n    const { owner: rawOwner } = spec;\n    const [ownerKind, ownerRef] = rawOwner.split(':');\n    const ownerName = ownerRef.split('/')[1];\n    // this tags timeseries with distinguishing\n    // properties for filtering purposes\n    const resources = [\n      {\n        type: 'host',\n        name: backstageUrl.split('@')[1]\n      },\n      { type: 'kind', name: kind },\n      { type: 'name', name },\n      { type: 'namespace', name: namespace },\n      { type: 'owner', name: ownerName },\n      { type: 'ownerKind', name: ownerKind }\n    ];\n    const value = 1;\n    const timestamp = Math.round(new Date().getTime() / 1000);\n    const points = [{ timestamp, value }];\n    return {\n      metric: 'backstage.access_keys.unknown',\n      type: DATADOG_GAUGE_TYPE,\n      points,\n      resources\n    };\n  });\n  return series;\n}\n\nfunction generateUserAccessKeyMetrics(collector: MultisigsCollector, backstageUrl: string) {\n  const series = Object.entries(collector.getAccessKeysPerSigner()).map<v2.MetricSeries>(([signer, entry]) => {\n    const spec = JSON.parse(JSON.stringify(entry.signer.spec));\n    const { owner } = spec;\n    const ownerName = `${owner}/${signer}`;\n    const resources = [\n      {\n        type: 'host',\n        name: backstageUrl.split('@')[1]\n      },\n      { type: 'owner', name: ownerName },\n      { type: 'user', name: owner },\n      { type: 'signer', name: signer }\n    ];\n    const value = entry.keys.length;\n    const timestamp = Math.round(new Date().getTime() / 1000);\n    const points = [{ timestamp, value }];\n    return {\n      metric: 'backstage.access_keys_owned_count',\n      type: DATADOG_GAUGE_TYPE,\n      points,\n      resources\n    };\n  });\n  return series;\n}\n\nfunction generateContractAccessKeyMetrics(collector: MultisigsCollector, backstageUrl: string) {\n  const accessKeysPerContract = collector.getContractAccessKeys().reduce<KeysByOwner>((acc, key) => {\n    // inferred type is JsonObject, this converts to any\n    const spec = JSON.parse(JSON.stringify(key.spec));\n    const { owner } = spec;\n    return {\n      ...acc,\n      [owner]: [...(acc[owner] || []), key]\n    };\n  }, {});\n  const series = Object.entries(accessKeysPerContract).map<v2.MetricSeries>(([owner, keys]) => {\n    const resources = [\n      {\n        type: 'host',\n        name: backstageUrl.split('@')[1]\n      },\n      { type: 'owner', name: owner }\n    ];\n    const value = keys.length;\n    const timestamp = Math.round(new Date().getTime() / 1000);\n    const points = [{ timestamp, value }];\n    return {\n      metric: 'backstage.access_keys_by_contract_count',\n      type: DATADOG_GAUGE_TYPE,\n      points,\n      resources\n    };\n  });\n  return series;\n}\n\nfunction generateInactiveSignerMetrics(collector: MultisigsCollector, backstageUrl: string) {\n  const series = collector.getSigners().map<v2.MetricSeries>(entity => {\n    // entities are typically emitted as API kind,\n    // tracking for inconsistencies\n    const { kind, metadata } = entity.signer;\n    const { name, namespace } = metadata;\n    // inferred type is JsonObject, this converts to any\n    const spec = JSON.parse(JSON.stringify(entity.signer.spec));\n    const { address, network, networkType, owner: rawOwner } = spec;\n    const owner = rawOwner.split(':')[1].split('/')[1];\n    // this tags timeseries with distinguishing\n    // properties for filtering purposes\n    const resources = [\n      {\n        type: 'host',\n        name: backstageUrl.split('@')[1]\n      },\n      { type: 'kind', name: kind },\n      { type: 'name', name },\n      { type: 'namespace', name: namespace },\n      { type: 'address', name: address },\n      { type: 'network', name: network },\n      { type: 'networkType', name: networkType },\n      { type: 'owner', name: owner }\n    ];\n    const now = new Date().getTime();\n    const isPastThreshold = now - Number(spec.lastSigned) > SIGNER_POLICY_LIMIT_MS;\n    const value = isPastThreshold ? 1 : 0;\n    const points = [{ timestamp: now, value }];\n    return {\n      metric: 'backstage.signers.inactive',\n      type: DATADOG_GAUGE_TYPE,\n      points,\n      resources\n    };\n  });\n  return series;\n}\n","/*\nCopyright 2022 Aurora Labs\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport * as core from '@actions/core';\nimport { CatalogClient } from '@backstage/catalog-client';\nimport { Entity } from '@backstage/catalog-model';\nimport { simpleGit } from 'simple-git';\nimport { now } from 'lodash';\n\ntype DiscoveryApi = {\n  getBaseUrl(pluginId: string): Promise<string>;\n};\n\ninterface GetBackstageEntities {\n  backstage_url?: string;\n  backstage_entities_repo?: string;\n}\n\nasync function getFileContentFromRepo(repoUrl: string, filePath: string): Promise<string> {\n  const cloneDir = `/tmp/github-helpers-${now()}`;\n  const git = simpleGit();\n\n  try {\n    await git.clone(repoUrl, cloneDir, ['--depth=1']);\n    await git.cwd(cloneDir);\n\n    const { current } = await git.branch();\n    const defaultBranch = current || 'main';\n    const fileContent: string = await git.show([`${defaultBranch}:${filePath}`]);\n\n    await git.raw(['rm', '-rf', '.']);\n    return fileContent;\n  } catch (error) {\n    throw new Error(`Failed to fetch ${repoUrl}/${filePath}: ${error}`);\n  }\n}\n\nasync function fetchBackstageEntitiesFromURL(backstage_url: string) {\n  core.info('Connecting to Backstage to fetch available entities');\n\n  const discoveryApi: DiscoveryApi = {\n    async getBaseUrl() {\n      return `${backstage_url}/api/catalog`;\n    }\n  };\n  const catalogClient = new CatalogClient({\n    discoveryApi\n  });\n\n  const entities = await catalogClient.getEntities({});\n  core.info(`Total backstage entities: ${entities.items.length}`);\n\n  return entities.items;\n}\n\nasync function fetchBackstageEntitiesFromRepo(backstage_entities_repo: string) {\n  const serverUrl = process.env.GITHUB_SERVER_URL || 'https://github.com';\n  const repoUrl = `${serverUrl}/${backstage_entities_repo}`;\n  core.info(`Cloning ${repoUrl}`);\n  const content = await getFileContentFromRepo(repoUrl, 'filteredEntities.json');\n  return JSON.parse(content) as Entity[];\n}\n\nexport const getBackstageEntities = async ({ backstage_url, backstage_entities_repo }: GetBackstageEntities) => {\n  // repo takes a priority over the URL in order to avoid unnecessary runtime\n  // dependency\n  if (backstage_entities_repo) {\n    return fetchBackstageEntitiesFromRepo(backstage_entities_repo);\n  } else if (backstage_url) {\n    return fetchBackstageEntitiesFromURL(backstage_url);\n  }\n  throw new Error(\n    'Backstage URL or entities repo is required. Set BACKSTAGE_URL (github secret) or pass backstage_entities_repo argument to this action'\n  );\n};\n"],"names":[],"sourceRoot":""}