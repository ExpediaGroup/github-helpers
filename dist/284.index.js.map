{"version":3,"file":"284.index.js","mappings":";;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;AAWA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;ACxCA;;;;;;;;;;;AAWA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1CA;;;;;;;;;;;AAWA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpGA;;;;;;;;;;;AAWA;AAEA;AACA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AAEA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AAEA;AACA;AACA;;AAEA;;;;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;ACvLA;;;;;;;;;;;AAWA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC1EA;;;;;;;;;;;AAWA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACrCA;;;;;;;;;;;AAWA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrDA;;;;;;;;;;;AAWA;AAEA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChDA;;;;;;;;;;;AAWA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":[".././src/helpers/get-email-on-user-profile.ts",".././src/helpers/is-user-in-team.ts",".././src/utils/update-merge-queue.ts",".././src/helpers/manage-merge-queue.ts",".././src/helpers/prepare-queued-pr-for-merge.ts",".././src/helpers/remove-label.ts",".././src/helpers/set-commit-status.ts",".././src/utils/notify-user.ts",".././src/utils/paginate-open-pull-requests.ts"],"sourcesContent":["/*\nCopyright 2021 Expedia, Inc.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\nhttps://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { HelperInputs } from '../types/generated';\nimport { octokit } from '../octokit';\nimport { setFailed } from '@actions/core';\n\nexport class GetEmailOnUserProfile extends HelperInputs {\n  login = '';\n  declare pattern?: string;\n}\n\nexport const getEmailOnUserProfile = async ({ login, pattern }: GetEmailOnUserProfile) => {\n  const {\n    data: { email }\n  } = await octokit.users.getByUsername({ username: login });\n\n  if (!email) {\n    setFailed(`User ${login} does not have an email address on their GitHub profile!`);\n    return;\n  }\n\n  if (pattern && !new RegExp(pattern).test(email)) {\n    setFailed(\n      `Email ${email} does not match regex pattern ${pattern}. Please update the email on your GitHub profile to match this pattern!`\n    );\n    return;\n  }\n\n  return email;\n};\n","/*\nCopyright 2023 Expedia, Inc.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { HelperInputs } from '../types/generated';\nimport { context } from '@actions/github';\nimport { octokit } from '../octokit';\nimport * as core from '@actions/core';\nimport { MembersInOrg } from '../types/github';\n\nexport class IsUserInTeam extends HelperInputs {\n  team = '';\n  declare login?: string;\n}\n\nexport const isUserInTeam = async ({ login = context.actor, team }: IsUserInTeam) => {\n  const members = await paginateAllMembersInOrg(team);\n  core.info(`Checking if ${login} is in team ${team}`);\n  core.info(`Team members: ${members.map(({ login }) => login).join(', ')}`);\n  return members.some(({ login: memberLogin }) => memberLogin === login);\n};\n\nasync function paginateAllMembersInOrg(team: string, page = 1): Promise<MembersInOrg> {\n  const response = await octokit.teams.listMembersInOrg({\n    org: context.repo.owner,\n    team_slug: team,\n    page,\n    per_page: 100\n  });\n  if (!response.data.length) {\n    return [];\n  }\n  return response.data.concat(await paginateAllMembersInOrg(team, page + 1));\n}\n","/*\nCopyright 2021 Expedia, Inc.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { JUMP_THE_QUEUE_PR_LABEL, MERGE_QUEUE_STATUS, QUEUED_FOR_MERGE_PREFIX } from '../constants';\nimport { PullRequestList } from '../types/github';\nimport { context } from '@actions/github';\nimport { map } from 'bluebird';\nimport { octokit } from '../octokit';\nimport { removeLabelIfExists } from '../helpers/remove-label';\nimport { updatePrWithDefaultBranch } from '../helpers/prepare-queued-pr-for-merge';\nimport { setCommitStatus } from '../helpers/set-commit-status';\n\nexport const updateMergeQueue = (queuedPrs: PullRequestList) => {\n  const sortedPrs = sortPrsByQueuePosition(queuedPrs);\n  return map(sortedPrs, updateQueuePosition);\n};\n\nconst sortPrsByQueuePosition = (queuedPrs: PullRequestList) =>\n  queuedPrs\n    .map(pr => {\n      const label = pr.labels.find(label => label.name?.startsWith(QUEUED_FOR_MERGE_PREFIX))?.name;\n      const hasJumpTheQueueLabel = Boolean(pr.labels.find(label => label.name === JUMP_THE_QUEUE_PR_LABEL));\n      const queuePosition = Number(label?.split('#')?.[1]);\n      return {\n        number: pr.number,\n        label,\n        hasJumpTheQueueLabel,\n        queuePosition,\n        sha: pr.head.sha\n      };\n    })\n    .sort((pr1, pr2) => {\n      if (pr1.hasJumpTheQueueLabel) {\n        return -1;\n      }\n      if (pr2.hasJumpTheQueueLabel) {\n        return 1;\n      }\n      return pr1.queuePosition - pr2.queuePosition;\n    });\n\nconst updateQueuePosition = async (pr: ReturnType<typeof sortPrsByQueuePosition>[number], index: number) => {\n  const { number, label, queuePosition, sha, hasJumpTheQueueLabel } = pr;\n  const newQueuePosition = index + 1;\n  if (!label || isNaN(queuePosition) || queuePosition === newQueuePosition) {\n    return;\n  }\n  if (hasJumpTheQueueLabel) {\n    await removeLabelIfExists(JUMP_THE_QUEUE_PR_LABEL, number);\n  }\n\n  const prIsNowFirstInQueue = newQueuePosition === 1;\n  if (prIsNowFirstInQueue) {\n    const { data: firstPrInQueue } = await octokit.pulls.get({ pull_number: number, ...context.repo });\n    await updatePrWithDefaultBranch(firstPrInQueue);\n    const {\n      data: {\n        head: { sha: updatedHeadSha }\n      }\n    } = await octokit.pulls.get({ pull_number: number, ...context.repo });\n    return Promise.all([\n      octokit.issues.addLabels({\n        labels: [`${QUEUED_FOR_MERGE_PREFIX} #${newQueuePosition}`],\n        issue_number: number,\n        ...context.repo\n      }),\n      removeLabelIfExists(label, number),\n      setCommitStatus({\n        sha: updatedHeadSha,\n        context: MERGE_QUEUE_STATUS,\n        state: 'success',\n        description: 'This PR is next to merge.'\n      })\n    ]);\n  }\n\n  return Promise.all([\n    octokit.issues.addLabels({\n      labels: [`${QUEUED_FOR_MERGE_PREFIX} #${newQueuePosition}`],\n      issue_number: number,\n      ...context.repo\n    }),\n    removeLabelIfExists(label, number),\n    setCommitStatus({\n      sha,\n      context: MERGE_QUEUE_STATUS,\n      state: 'pending',\n      description: 'This PR is in line to merge.'\n    })\n  ]);\n};\n","/*\nCopyright 2021 Expedia, Inc.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport * as core from '@actions/core';\nimport {\n  FIRST_QUEUED_PR_LABEL,\n  JUMP_THE_QUEUE_PR_LABEL,\n  MERGE_QUEUE_STATUS,\n  QUEUED_FOR_MERGE_PREFIX,\n  READY_FOR_MERGE_PR_LABEL\n} from '../constants';\nimport { HelperInputs } from '../types/generated';\nimport { PullRequest, PullRequestList } from '../types/github';\nimport { context } from '@actions/github';\nimport { notifyUser } from '../utils/notify-user';\nimport { octokit, octokitGraphql } from '../octokit';\nimport { removeLabelIfExists } from './remove-label';\nimport { setCommitStatus } from './set-commit-status';\nimport { updateMergeQueue } from '../utils/update-merge-queue';\nimport { paginateAllOpenPullRequests } from '../utils/paginate-open-pull-requests';\nimport { updatePrWithDefaultBranch } from './prepare-queued-pr-for-merge';\nimport { approvalsSatisfied } from './approvals-satisfied';\nimport { createPrComment } from './create-pr-comment';\nimport { isUserInTeam } from './is-user-in-team';\nimport { getEmailOnUserProfile } from './get-email-on-user-profile';\n\nexport class ManageMergeQueue extends HelperInputs {\n  declare max_queue_size?: string;\n  declare login?: string;\n  declare slack_webhook_url?: string;\n  declare skip_auto_merge?: string;\n  declare team?: string;\n  declare allow_only_for_maintainers?: string;\n  declare pattern?: string;\n}\n\nexport const manageMergeQueue = async ({\n  max_queue_size,\n  login,\n  slack_webhook_url,\n  skip_auto_merge,\n  team = '',\n  allow_only_for_maintainers,\n  pattern\n}: ManageMergeQueue = {}) => {\n  const { data: pullRequest } = await octokit.pulls.get({ pull_number: context.issue.number, ...context.repo });\n  if (pullRequest.merged || !pullRequest.labels.find(label => label.name === READY_FOR_MERGE_PR_LABEL)) {\n    core.info('This PR is not in the merge queue.');\n    return removePrFromQueue(pullRequest);\n  }\n  const prMeetsRequiredApprovals = await approvalsSatisfied({\n    body: 'PRs must meet all required approvals before entering the merge queue.'\n  });\n  if (!prMeetsRequiredApprovals) {\n    return removePrFromQueue(pullRequest);\n  }\n  if (slack_webhook_url && login) {\n    const email = await getEmailOnUserProfile({ login, pattern });\n    if (!email) {\n      const patternText = pattern ? `, and it must match the regex pattern \\`${pattern}\\`` : '';\n      await createPrComment({\n        body: `@${login} Your PR cannot be added to the queue because your email must be set on your GitHub profile${patternText}. Follow the instructions [here](${githubEmailDocsLink}) to add or fix your email on ${context.serverUrl}!`\n      });\n      return removePrFromQueue(pullRequest);\n    }\n  }\n\n  const queuedPrs = await getQueuedPullRequests();\n  const queuePosition = queuedPrs.length + 1;\n  const prAttemptingToJoinQueue = pullRequest.labels.every(label => !label.name?.startsWith(QUEUED_FOR_MERGE_PREFIX));\n\n  if (prAttemptingToJoinQueue && queuePosition > Number(max_queue_size)) {\n    await createPrComment({\n      body: `The merge queue is full! Only ${max_queue_size} PRs are allowed in the queue at a time.\\n\\nIf you would like to merge your PR, please monitor the PRs in the queue and make sure the authors are around to merge them.`\n    });\n    return removePrFromQueue(pullRequest);\n  }\n\n  if (pullRequest.labels.find(label => label.name === JUMP_THE_QUEUE_PR_LABEL)) {\n    if (allow_only_for_maintainers === 'true') {\n      core.info(`Checking if user ${login} is a maintainer...`);\n      const isMaintainer = await isUserInTeam({ login: context.actor, team: team });\n      if (!isMaintainer) {\n        await removeLabelIfExists(JUMP_THE_QUEUE_PR_LABEL, pullRequest.number);\n        return await createPrComment({\n          body: `@${context.actor} Only core maintainers can jump the queue. Please have a core maintainer jump the queue for you.`\n        });\n      }\n    }\n\n    return updateMergeQueue(queuedPrs);\n  }\n\n  if (prAttemptingToJoinQueue) {\n    await addPrToQueue(pullRequest, queuePosition, skip_auto_merge);\n  }\n\n  const isFirstQueuePosition = queuePosition === 1 || pullRequest.labels.find(label => label.name === FIRST_QUEUED_PR_LABEL);\n\n  if (isFirstQueuePosition) {\n    await updatePrWithDefaultBranch(pullRequest);\n  }\n\n  await setCommitStatus({\n    sha: pullRequest.head.sha,\n    context: MERGE_QUEUE_STATUS,\n    state: isFirstQueuePosition ? 'success' : 'pending',\n    description: isFirstQueuePosition ? 'This PR is next to merge.' : 'This PR is in line to merge.'\n  });\n\n  if (isFirstQueuePosition && slack_webhook_url && login) {\n    await notifyUser({\n      login,\n      pull_number: context.issue.number,\n      slack_webhook_url,\n      queuePosition\n    });\n  }\n};\n\nexport const removePrFromQueue = async (pullRequest: PullRequest) => {\n  await removeLabelIfExists(READY_FOR_MERGE_PR_LABEL, pullRequest.number);\n  const queueLabel = pullRequest.labels.find(label => label.name?.startsWith(QUEUED_FOR_MERGE_PREFIX))?.name;\n  if (queueLabel) {\n    await removeLabelIfExists(queueLabel, pullRequest.number);\n  }\n  await setCommitStatus({\n    sha: pullRequest.head.sha,\n    context: MERGE_QUEUE_STATUS,\n    state: 'pending',\n    description: 'This PR is not in the merge queue.'\n  });\n  const queuedPrs = await getQueuedPullRequests();\n  return updateMergeQueue(queuedPrs);\n};\n\nconst addPrToQueue = async (pullRequest: PullRequest, queuePosition: number, skip_auto_merge?: string) => {\n  await octokit.issues.addLabels({\n    labels: [`${QUEUED_FOR_MERGE_PREFIX} #${queuePosition}`],\n    issue_number: context.issue.number,\n    ...context.repo\n  });\n  if (skip_auto_merge == 'true') {\n    core.info('Skipping auto merge per configuration.');\n    return;\n  }\n  await enableAutoMerge(pullRequest.node_id);\n};\n\nconst getQueuedPullRequests = async (): Promise<PullRequestList> => {\n  const openPullRequests = await paginateAllOpenPullRequests();\n  return openPullRequests.filter(\n    pr =>\n      pr.labels.some(label => label.name === READY_FOR_MERGE_PR_LABEL) &&\n      pr.labels.some(label => label.name.startsWith(QUEUED_FOR_MERGE_PREFIX))\n  );\n};\n\nexport const enableAutoMerge = async (pullRequestId: string, mergeMethod = 'SQUASH') => {\n  try {\n    await octokitGraphql(`\n    mutation {\n      enablePullRequestAutoMerge(input: { pullRequestId: \"${pullRequestId}\", mergeMethod: ${mergeMethod} }) {\n        clientMutationId\n      }\n    }\n  `);\n  } catch (error) {\n    core.warning('Auto merge could not be enabled. Perhaps you need to enable auto-merge on your repo?');\n    core.warning(error as Error);\n  }\n};\n\nconst githubEmailDocsLink =\n  'https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-personal-account-on-github/managing-email-preferences/changing-your-primary-email-address';\n","/*\nCopyright 2021 Expedia, Inc.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport * as core from '@actions/core';\nimport { FIRST_QUEUED_PR_LABEL, JUMP_THE_QUEUE_PR_LABEL, READY_FOR_MERGE_PR_LABEL } from '../constants';\nimport { GithubError, PullRequest, PullRequestList, SinglePullRequest } from '../types/github';\nimport { context } from '@actions/github';\nimport { octokit } from '../octokit';\nimport { removePrFromQueue } from './manage-merge-queue';\n\nexport const prepareQueuedPrForMerge = async () => {\n  const { data } = await octokit.pulls.list({\n    state: 'open',\n    per_page: 100,\n    ...context.repo\n  });\n  const pullRequest = findNextPrToMerge(data);\n  if (pullRequest) {\n    return updatePrWithDefaultBranch(pullRequest as PullRequest);\n  }\n};\n\nconst findNextPrToMerge = (pullRequests: PullRequestList) =>\n  pullRequests.find(pr => hasRequiredLabels(pr, [READY_FOR_MERGE_PR_LABEL, JUMP_THE_QUEUE_PR_LABEL])) ??\n  pullRequests.find(pr => hasRequiredLabels(pr, [READY_FOR_MERGE_PR_LABEL, FIRST_QUEUED_PR_LABEL]));\n\nconst hasRequiredLabels = (pr: SinglePullRequest, requiredLabels: string[]) =>\n  requiredLabels.every(mergeQueueLabel => pr.labels.some(label => label.name === mergeQueueLabel));\n\nexport const updatePrWithDefaultBranch = async (pullRequest: PullRequest) => {\n  if (pullRequest.head.user?.login && pullRequest.base.user?.login && pullRequest.head.user?.login !== pullRequest.base.user?.login) {\n    try {\n      // update fork default branch with upstream\n      await octokit.repos.mergeUpstream({\n        ...context.repo,\n        branch: pullRequest.base.repo.default_branch\n      });\n    } catch (error) {\n      if ((error as GithubError).status === 409) {\n        core.setFailed('Attempt to update fork branch with upstream failed; conflict on default branch between fork and upstream.');\n      } else core.setFailed((error as GithubError).message);\n    }\n  }\n  try {\n    await octokit.repos.merge({\n      base: pullRequest.head.ref,\n      head: 'HEAD',\n      ...context.repo\n    });\n  } catch (error) {\n    const noEvictUponConflict = core.getInput('no_evict_upon_conflict');\n    const githubError = error as GithubError;\n    if (githubError.status !== 409) {\n      core.setFailed(githubError.message);\n      return;\n    }\n    if (noEvictUponConflict === 'true') {\n      core.info('The first PR in the queue has a merge conflict. PR was not removed from the queue due to no_evict_upon_conflict input.');\n      return;\n    }\n\n    await removePrFromQueue(pullRequest);\n    core.setFailed('The first PR in the queue has a merge conflict, and it was removed from the queue.');\n  }\n};\n","/*\nCopyright 2021 Expedia, Inc.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport * as core from '@actions/core';\nimport { GithubError } from '../types/github';\nimport { HelperInputs } from '../types/generated';\nimport { context } from '@actions/github';\nimport { octokit } from '../octokit';\n\nexport class RemoveLabel extends HelperInputs {\n  label = '';\n}\n\nexport const removeLabel = async ({ label }: RemoveLabel) => removeLabelIfExists(label, context.issue.number);\n\nexport const removeLabelIfExists = async (labelName: string, issue_number: number) => {\n  try {\n    await octokit.issues.removeLabel({\n      name: labelName,\n      issue_number,\n      ...context.repo\n    });\n  } catch (error) {\n    if ((error as GithubError).status === 404) {\n      core.info('Label is not present on PR.');\n    }\n  }\n};\n","/*\nCopyright 2021 Expedia, Inc.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport * as core from '@actions/core';\nimport { PipelineState } from '../types/github';\nimport { HelperInputs } from '../types/generated';\nimport { context as githubContext } from '@actions/github';\nimport { map } from 'bluebird';\nimport { octokit } from '../octokit';\n\nexport class SetCommitStatus extends HelperInputs {\n  sha = '';\n  context = '';\n  state = '';\n  declare description?: string;\n  declare target_url?: string;\n  declare skip_if_already_set?: string;\n}\n\nexport const setCommitStatus = async ({ sha, context, state, description, target_url, skip_if_already_set }: SetCommitStatus) => {\n  await map(context.split('\\n').filter(Boolean), async context => {\n    if (skip_if_already_set === 'true') {\n      const check_runs = await octokit.checks.listForRef({\n        ...githubContext.repo,\n        ref: sha\n      });\n      const run = check_runs.data.check_runs.find(({ name }) => name === context);\n      const runCompletedAndIsValid = run?.status === 'completed' && (run?.conclusion === 'failure' || run?.conclusion === 'success');\n      if (runCompletedAndIsValid) {\n        core.info(`${context} already completed with a ${run.conclusion} conclusion.`);\n        return;\n      }\n    }\n\n    octokit.repos.createCommitStatus({\n      sha,\n      context,\n      state: state as PipelineState,\n      description,\n      target_url,\n      ...githubContext.repo\n    });\n  });\n};\n","/*\nCopyright 2021 Expedia, Inc.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport * as core from '@actions/core';\nimport axios from 'axios';\nimport { context } from '@actions/github';\nimport { octokit } from '../octokit';\nimport { getEmailOnUserProfile } from '../helpers/get-email-on-user-profile';\n\ninterface NotifyUser {\n  login: string;\n  pull_number: number;\n  slack_webhook_url: string;\n  queuePosition?: number;\n}\n\nexport const notifyUser = async ({ login, pull_number, slack_webhook_url, queuePosition }: NotifyUser) => {\n  const email = await getEmailOnUserProfile({ login });\n  if (!email) {\n    return;\n  }\n  core.info(`Notifying user ${login}...`);\n  const {\n    data: { title, html_url }\n  } = await octokit.pulls.get({ pull_number, ...context.repo });\n\n  const result = await axios.post(slack_webhook_url, {\n    assignee: email,\n    title,\n    html_url,\n    repo: context.repo.repo,\n    queuePosition\n  });\n  if (result.status !== 200) {\n    core.error(result.statusText);\n    core.setFailed(`User notification failed for login: ${login} and email: ${email}`);\n  }\n  return result;\n};\n","/*\nCopyright 2022 Expedia, Inc.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { PullRequestList } from '../types/github';\nimport { octokit } from '../octokit';\nimport { context } from '@actions/github';\n\nexport const paginateAllOpenPullRequests = async (page = 1): Promise<PullRequestList> => {\n  const response = await octokit.pulls.list({\n    state: 'open',\n    sort: 'updated',\n    direction: 'desc',\n    per_page: 100,\n    page,\n    ...context.repo\n  });\n  if (!response.data.length) {\n    return [];\n  }\n  return response.data.concat(await paginateAllOpenPullRequests(page + 1));\n};\n"],"names":[],"sourceRoot":""}