{"version":3,"file":"571.index.js","mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC5BA;;;;;;;;;;;AAWA;;;;;;;;;;AAEA;AACA;AACA;AACA;AAEA;AAAA;;AACA;AACA;AAAA;AAEA;AACA;AAKA;;;;;;;;;;;;;;;;;;AC5BA;;;;;;;;;;;AAWA;AAEA;AACA;AAEA;AAEA;AACA;;;;;;;;;;;;ACnBA;;;;;;;;;;;AAWA;AAEA;AAkCA","sources":["webpack://github-helpers/./node_modules/github-cherry-pick/lib/index.js","webpack://github-helpers/./node_modules/github-rebase/lib/autosquashing.js","webpack://github-helpers/./node_modules/github-rebase/lib/index.js","webpack://github-helpers/./node_modules/shared-github-internals/lib/git.js","webpack://github-helpers/./node_modules/uuid/lib/bytesToUuid.js","webpack://github-helpers/./node_modules/uuid/lib/rng.js","webpack://github-helpers/./node_modules/uuid/v4.js","webpack://github-helpers/./src/helpers/rebase-pr.ts","webpack://github-helpers/./src/octokit.ts","webpack://github-helpers/./src/types/generated.ts"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst createDebug = require(\"debug\");\nconst git_1 = require(\"shared-github-internals/lib/git\");\nconst debug = createDebug(\"github-cherry-pick\");\n// See https://github.com/tibdex/github-rebase/issues/13\nconst getCommitMessageToSkipCI = (title) => `${title} [skip ci]\n\n\nskip-checks: true\n`;\nconst createCommit = ({ author, committer, message, octokit, owner, parent, repo, tree, }) => __awaiter(this, void 0, void 0, function* () {\n    const { data: { sha }, } = yield octokit.git.createCommit({\n        author,\n        committer,\n        message,\n        owner,\n        parents: [parent],\n        repo,\n        // No PGP signature support for now.\n        // See https://developer.github.com/v3/git/commits/#create-a-commit.\n        tree,\n    });\n    return sha;\n});\nconst merge = ({ base, commit, octokit, owner, repo, }) => __awaiter(this, void 0, void 0, function* () {\n    const { data: { commit: { tree: { sha: tree }, }, }, } = yield octokit.repos.merge({\n        base,\n        commit_message: getCommitMessageToSkipCI(`Merge ${commit} into ${base}`),\n        head: commit,\n        owner,\n        repo,\n    });\n    return tree;\n});\nconst retrieveCommitDetails = ({ commit, octokit, owner, repo, }) => __awaiter(this, void 0, void 0, function* () {\n    const { data: { author, committer, message, parents }, } = yield octokit.git.getCommit({\n        commit_sha: commit,\n        owner,\n        repo,\n    });\n    if (parents.length > 1) {\n        throw new Error(`Commit ${commit} has ${parents.length} parents.` +\n            ` github-cherry-pick is designed for the rebase workflow and doesn't support merge commits.`);\n    }\n    return { author, committer, message, parent: parents[0].sha };\n});\nconst createSiblingCommit = ({ commit, head: { author, committer, ref, tree }, octokit, owner, parent, repo, }) => __awaiter(this, void 0, void 0, function* () {\n    const sha = yield createCommit({\n        author,\n        committer,\n        message: getCommitMessageToSkipCI(`Sibling of ${commit}`),\n        octokit,\n        owner,\n        parent,\n        repo,\n        tree,\n    });\n    yield git_1.updateRef({\n        force: true,\n        octokit,\n        owner,\n        ref,\n        repo,\n        sha,\n    });\n});\nconst cherryPickCommit = ({ commit, head: { ref, sha, tree }, octokit, owner, repo, }) => __awaiter(this, void 0, void 0, function* () {\n    const { author, committer, message, parent } = yield retrieveCommitDetails({\n        commit,\n        octokit,\n        owner,\n        repo,\n    });\n    debug(\"creating sibling commit\");\n    yield createSiblingCommit({\n        commit,\n        head: { author, committer, ref, tree },\n        octokit,\n        owner,\n        parent,\n        repo,\n    });\n    debug(\"merging\");\n    const newHeadTree = yield merge({\n        base: ref,\n        commit,\n        octokit,\n        owner,\n        repo,\n    });\n    debug(\"creating commit with different tree\", newHeadTree);\n    const newHeadSha = yield createCommit({\n        author,\n        committer,\n        message,\n        octokit,\n        owner,\n        parent: sha,\n        repo,\n        tree: newHeadTree,\n    });\n    debug(\"updating ref\", newHeadSha);\n    yield git_1.updateRef({\n        // Overwrite the merge commit and its parent on the branch by a single commit.\n        // The result will be equivalent to what would have happened with a fast-forward merge.\n        force: true,\n        octokit,\n        owner,\n        ref,\n        repo,\n        sha: newHeadSha,\n    });\n    return {\n        sha: newHeadSha,\n        tree: newHeadTree,\n    };\n});\nconst cherryPickCommitsOnRef = ({ commits, initialHeadSha, octokit, owner, ref, repo, }) => __awaiter(this, void 0, void 0, function* () {\n    const { data: { tree: { sha: initialHeadTree }, }, } = yield octokit.git.getCommit({\n        commit_sha: initialHeadSha,\n        owner,\n        repo,\n    });\n    const { sha: newHeadSha } = yield commits.reduce((previousCherryPick, commit) => __awaiter(this, void 0, void 0, function* () {\n        const { sha, tree } = yield previousCherryPick;\n        debug(\"cherry-picking\", { commit, ref, sha });\n        return cherryPickCommit({\n            commit,\n            head: { ref, sha, tree },\n            octokit,\n            owner,\n            repo,\n        });\n    }), Promise.resolve({\n        sha: initialHeadSha,\n        tree: initialHeadTree,\n    }));\n    return newHeadSha;\n});\n// eslint-disable-next-line max-lines-per-function\nconst cherryPickCommits = ({ \n// Should only be used in tests.\n_intercept = () => Promise.resolve(), commits, head, octokit, owner, repo, }) => __awaiter(this, void 0, void 0, function* () {\n    debug(\"starting\", { commits, head, owner, repo });\n    const initialHeadSha = yield git_1.fetchRefSha({\n        octokit,\n        owner,\n        ref: head,\n        repo,\n    });\n    yield _intercept({ initialHeadSha });\n    return git_1.withTemporaryRef({\n        action: (temporaryRef) => __awaiter(this, void 0, void 0, function* () {\n            debug({ temporaryRef });\n            const newSha = yield cherryPickCommitsOnRef({\n                commits,\n                initialHeadSha,\n                octokit,\n                owner,\n                ref: temporaryRef,\n                repo,\n            });\n            debug(\"updating ref with new SHA\", newSha);\n            yield git_1.updateRef({\n                // Make sure it's a fast-forward update.\n                force: false,\n                octokit,\n                owner,\n                ref: head,\n                repo,\n                sha: newSha,\n            });\n            debug(\"ref updated\");\n            return newSha;\n        }),\n        octokit,\n        owner,\n        ref: `cherry-pick-${head}`,\n        repo,\n        sha: initialHeadSha,\n    });\n});\nexports.cherryPickCommits = cherryPickCommits;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst getCommitSubjectAndBody = (commitMessage) => {\n    const [subject, ...rest] = commitMessage.split(/(\\r\\n|\\r|\\n){2}/u);\n    return {\n        body: rest\n            .map(line => line.trim())\n            .filter(line => line !== \"\")\n            .join(\"\\n\"),\n        subject,\n    };\n};\nconst getAutosquashMode = ({ commitDetails, message, }) => {\n    // It's fine, the data is coming from the GitHub API,\n    // it won't have a weird shape.\n    // eslint-disable-next-line security/detect-non-literal-regexp\n    const matches = new RegExp(`^(fixup|squash)! (fixup! |squash! )*(${getCommitSubjectAndBody(commitDetails.message).subject}|${commitDetails.sha}|${commitDetails.sha.substr(7)})$`, \"u\").exec(getCommitSubjectAndBody(message).subject);\n    if (!matches) {\n        return null;\n    }\n    return matches[1] === \"fixup\" ? \"fixup\" : \"squash\";\n};\nconst getNewAutosquashMessage = ({ commitsDetails, message, mode, step, }) => {\n    const previousMessage = step.autosquashMessage === null\n        ? // We know that the commit details will be found.\n            // @ts-ignore\n            commitsDetails.find(({ sha }) => sha === step.shas[0]).message\n        : step.autosquashMessage;\n    return mode === \"squash\"\n        ? `${previousMessage}\\n\\n${message}`\n        : previousMessage;\n};\nconst groupNonAutosquashingSteps = ({ newStep, steps, }) => newStep.autosquashMessage === null &&\n    steps.length > 0 &&\n    steps[steps.length - 1].autosquashMessage === null\n    ? [\n        ...steps.slice(0, -1),\n        {\n            autosquashMessage: null,\n            shas: [...steps[steps.length - 1].shas, ...newStep.shas],\n        },\n    ]\n    : [...steps, newStep];\nconst getAutosquashingSteps = (commitsDetails) => {\n    const alreadyHandledShas = new Set();\n    const initialSteps = [];\n    return commitsDetails.reduce((steps, commitDetails) => {\n        if (alreadyHandledShas.has(commitDetails.sha)) {\n            return steps;\n        }\n        alreadyHandledShas.add(commitDetails.sha);\n        const initialStep = {\n            autosquashMessage: null,\n            shas: [commitDetails.sha],\n        };\n        const newStep = commitsDetails\n            .filter(({ sha }) => !alreadyHandledShas.has(sha))\n            .reduce((step, { message, sha }) => {\n            const mode = getAutosquashMode({ commitDetails, message });\n            if (mode === null) {\n                return step;\n            }\n            alreadyHandledShas.add(sha);\n            return {\n                autosquashMessage: getNewAutosquashMessage({\n                    commitsDetails,\n                    message,\n                    mode,\n                    step,\n                }),\n                shas: [...step.shas, sha],\n            };\n        }, initialStep);\n        return groupNonAutosquashingSteps({ newStep, steps });\n    }, initialSteps);\n};\nexports.getAutosquashingSteps = getAutosquashingSteps;\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst createDebug = require(\"debug\");\nconst github_cherry_pick_1 = require(\"github-cherry-pick\");\nconst git_1 = require(\"shared-github-internals/lib/git\");\nconst autosquashing_1 = require(\"./autosquashing\");\nconst debug = createDebug(\"github-rebase\");\nconst needAutosquashing = ({ octokit, owner, pullRequestNumber, repo, }) => __awaiter(this, void 0, void 0, function* () {\n    const commitsDetails = yield git_1.fetchCommitsDetails({\n        octokit,\n        owner,\n        pullRequestNumber,\n        repo,\n    });\n    const steps = autosquashing_1.getAutosquashingSteps(commitsDetails);\n    return steps.length > 1 || (steps[0] && steps[0].autosquashMessage !== null);\n});\nexports.needAutosquashing = needAutosquashing;\nconst autosquash = ({ commitsDetails, octokit, owner, parent, ref, refSha, repo, step, }) => __awaiter(this, void 0, void 0, function* () {\n    // @ts-ignore We know that the commit details will be found.\n    const { author, committer } = commitsDetails.find(({ sha: commitSha }) => commitSha === step.shas[0]);\n    const { data: { tree: { sha: tree }, }, } = yield octokit.git.getCommit({ commit_sha: refSha, owner, repo });\n    const { data: { sha }, } = yield octokit.git.createCommit({\n        author,\n        committer,\n        message: String(step.autosquashMessage),\n        owner,\n        parents: [parent],\n        repo,\n        tree,\n    });\n    yield git_1.updateRef({\n        // Autosquashing is not a fast-forward operation.\n        force: true,\n        octokit,\n        owner,\n        ref,\n        repo,\n        sha,\n    });\n    return sha;\n});\nconst performRebase = ({ commitsDetails, octokit, owner, ref, repo, }) => __awaiter(this, void 0, void 0, function* () {\n    const initialRefSha = yield git_1.fetchRefSha({\n        octokit,\n        owner,\n        ref,\n        repo,\n    });\n    const newRefSha = yield autosquashing_1.getAutosquashingSteps(commitsDetails).reduce((promise, step) => __awaiter(this, void 0, void 0, function* () {\n        const parent = yield promise;\n        const sha = yield github_cherry_pick_1.cherryPickCommits({\n            commits: step.shas,\n            head: ref,\n            octokit,\n            owner,\n            repo,\n        });\n        if (step.autosquashMessage === null) {\n            return sha;\n        }\n        return autosquash({\n            commitsDetails,\n            octokit,\n            owner,\n            parent,\n            ref,\n            refSha: sha,\n            repo,\n            step,\n        });\n    }), Promise.resolve(initialRefSha));\n    return newRefSha;\n});\nconst checkSameHead = ({ octokit, owner, ref, repo, sha: expectedSha, }) => __awaiter(this, void 0, void 0, function* () {\n    const actualSha = yield git_1.fetchRefSha({ octokit, owner, ref, repo });\n    if (actualSha !== expectedSha) {\n        throw new Error([\n            `Rebase aborted because the head branch changed.`,\n            `The current SHA of ${ref} is ${actualSha} but it was expected to still be ${expectedSha}.`,\n        ].join(\"\\n\"));\n    }\n});\n// eslint-disable-next-line max-lines-per-function\nconst rebasePullRequest = ({ \n// Should only be used in tests.\n_intercept = () => Promise.resolve(), octokit, owner, pullRequestNumber, repo, }) => __awaiter(this, void 0, void 0, function* () {\n    debug(\"starting\", { pullRequestNumber, owner, repo });\n    const { data: { base: { ref: baseRef }, head: { ref: headRef, sha: initialHeadSha }, }, } = yield octokit.pulls.get({\n        owner,\n        pull_number: pullRequestNumber,\n        repo,\n    });\n    // The SHA given by GitHub for the base branch is not always up to date.\n    // A request is made to fetch the actual one.\n    const baseInitialSha = yield git_1.fetchRefSha({\n        octokit,\n        owner,\n        ref: baseRef,\n        repo,\n    });\n    const commitsDetails = yield git_1.fetchCommitsDetails({\n        octokit,\n        owner,\n        pullRequestNumber,\n        repo,\n    });\n    debug(\"commits details fetched\", {\n        baseInitialSha,\n        commitsDetails,\n        headRef,\n        initialHeadSha,\n    });\n    yield _intercept({ initialHeadSha });\n    return git_1.withTemporaryRef({\n        action: (temporaryRef) => __awaiter(this, void 0, void 0, function* () {\n            debug({ temporaryRef });\n            const newSha = yield performRebase({\n                commitsDetails,\n                octokit,\n                owner,\n                ref: temporaryRef,\n                repo,\n            });\n            yield checkSameHead({\n                octokit,\n                owner,\n                ref: headRef,\n                repo,\n                sha: initialHeadSha,\n            });\n            debug(\"updating ref with new SHA\", newSha);\n            yield git_1.updateRef({\n                // Rebase operations are not fast-forwards.\n                force: true,\n                octokit,\n                owner,\n                ref: headRef,\n                repo,\n                sha: newSha,\n            });\n            debug(\"ref updated\");\n            return newSha;\n        }),\n        octokit,\n        owner,\n        ref: `rebase-pull-request-${pullRequestNumber}`,\n        repo,\n        sha: baseInitialSha,\n    });\n});\nexports.rebasePullRequest = rebasePullRequest;\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst generateUuid = require(\"uuid/v4\");\nconst generateUniqueRef = (ref) => `${ref}-${generateUuid()}`;\nexports.generateUniqueRef = generateUniqueRef;\nconst getHeadRef = (ref) => `heads/${ref}`;\nexports.getHeadRef = getHeadRef;\nconst getFullyQualifiedRef = (ref) => `refs/${getHeadRef(ref)}`;\nconst fetchRefSha = ({ octokit, owner, ref, repo, }) => __awaiter(this, void 0, void 0, function* () {\n    const { data: { object: { sha }, }, } = yield octokit.git.getRef({\n        owner,\n        ref: getHeadRef(ref),\n        repo,\n    });\n    return sha;\n});\nexports.fetchRefSha = fetchRefSha;\nconst updateRef = ({ force, octokit, owner, ref, repo, sha, }) => __awaiter(this, void 0, void 0, function* () {\n    yield octokit.git.updateRef({\n        force,\n        owner,\n        ref: getHeadRef(ref),\n        repo,\n        sha,\n    });\n});\nexports.updateRef = updateRef;\nconst deleteRef = ({ octokit, owner, ref, repo, }) => __awaiter(this, void 0, void 0, function* () {\n    yield octokit.git.deleteRef({\n        owner,\n        ref: getHeadRef(ref),\n        repo,\n    });\n});\nexports.deleteRef = deleteRef;\nconst createRef = ({ octokit, owner, ref, repo, sha, }) => __awaiter(this, void 0, void 0, function* () {\n    yield octokit.git.createRef({\n        owner,\n        ref: getFullyQualifiedRef(ref),\n        repo,\n        sha,\n    });\n});\nexports.createRef = createRef;\nconst createTemporaryRef = ({ octokit, owner, ref, repo, sha, }) => __awaiter(this, void 0, void 0, function* () {\n    const temporaryRef = generateUniqueRef(ref);\n    yield createRef({\n        octokit,\n        owner,\n        ref: temporaryRef,\n        repo,\n        sha,\n    });\n    return {\n        deleteTemporaryRef() {\n            return __awaiter(this, void 0, void 0, function* () {\n                yield deleteRef({\n                    octokit,\n                    owner,\n                    ref: temporaryRef,\n                    repo,\n                });\n            });\n        },\n        temporaryRef,\n    };\n});\nexports.createTemporaryRef = createTemporaryRef;\nconst withTemporaryRef = ({ action, octokit, owner, ref, repo, sha, }) => __awaiter(this, void 0, void 0, function* () {\n    const { deleteTemporaryRef, temporaryRef } = yield createTemporaryRef({\n        octokit,\n        owner,\n        ref,\n        repo,\n        sha,\n    });\n    try {\n        return yield action(temporaryRef);\n    }\n    finally {\n        yield deleteTemporaryRef();\n    }\n});\nexports.withTemporaryRef = withTemporaryRef;\nconst getCommitsDetails = ({ commit: { author, committer, message, tree: { sha: tree }, }, sha, }) => ({\n    author,\n    committer,\n    message,\n    sha,\n    tree,\n});\nconst fetchCommitsDetails = ({ octokit, owner, pullRequestNumber, repo, }) => __awaiter(this, void 0, void 0, function* () {\n    const options = octokit.pulls.listCommits.endpoint.merge({\n        owner,\n        pull_number: pullRequestNumber,\n        repo,\n    });\n    const commits = yield octokit.paginate(options);\n    return commits.map(getCommitsDetails);\n});\nexports.fetchCommitsDetails = fetchCommitsDetails;\nconst fetchCommits = ({ octokit, owner, pullRequestNumber, repo, }) => __awaiter(this, void 0, void 0, function* () {\n    const details = yield fetchCommitsDetails({\n        octokit,\n        owner,\n        pullRequestNumber,\n        repo,\n    });\n    return details.map(({ sha }) => sha);\n});\nexports.fetchCommits = fetchCommits;\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]], '-',\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]],\n    bth[buf[i++]], bth[buf[i++]]\n  ]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In node.js\n// this is pretty straight-forward - we use the crypto API.\n\nvar crypto = require('crypto');\n\nmodule.exports = function nodeRNG() {\n  return crypto.randomBytes(16);\n};\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","/*\nCopyright 2021 Expedia, Inc.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { HelperInputs } from '../types/generated';\nimport { context } from '@actions/github';\nimport { octokit } from '../octokit';\nimport { rebasePullRequest } from 'github-rebase';\n\nexport class RebasePr extends HelperInputs {\n  pull_number = '';\n}\n\nexport const rebasePr = async ({ pull_number }: RebasePr) => {\n  await rebasePullRequest({\n    pullRequestNumber: Number(pull_number),\n    octokit,\n    ...context.repo\n  });\n};\n","/*\nCopyright 2021 Expedia, Inc.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport * as core from '@actions/core';\nimport * as fetch from '@adobe/node-fetch-retry';\nimport { Octokit } from '@octokit/rest';\nimport { getOctokit } from '@actions/github';\n\nconst githubToken = core.getInput('github_token', { required: true });\nexport const octokit = getOctokit(githubToken, { request: { fetch } }).rest as unknown as Octokit;\n","/*\nCopyright 2021 Expedia, Inc.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport class HelperInputs {\n  helper?: string;\n  github_token?: string;\n  body?: string;\n  project_name?: string;\n  project_destination_column_name?: string;\n  note?: string;\n  project_origin_column_name?: string;\n  sha?: string;\n  context?: string;\n  state?: string;\n  description?: string;\n  target_url?: string;\n  environment?: string;\n  environment_url?: string;\n  label?: string;\n  labels?: string;\n  paths?: string;\n  extensions?: string;\n  override_filter_paths?: string;\n  batches?: string;\n  pattern?: string;\n  teams?: string;\n  login?: string;\n  paths_no_filter?: string;\n  slack_webhook_url?: string;\n  number_of_assignees?: string;\n  globs?: string;\n  override_filter_globs?: string;\n  title?: string;\n  seconds?: string;\n  pull_number?: string;\n  base?: string;\n  head?: string;\n}\n"],"names":[],"sourceRoot":""}