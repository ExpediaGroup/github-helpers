exports.id = 128;
exports.ids = [128];
exports.modules = {

/***/ 53128:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.client = exports.v2 = exports.v1 = void 0;
exports.v1 = __importStar(__webpack_require__(46649));
exports.v2 = __importStar(__webpack_require__(23687));
exports.client = __importStar(__webpack_require__(87818));
__exportStar(__webpack_require__(1141), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1141:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.logger = void 0;
const loglevel_1 = __importDefault(__webpack_require__(78063));
const logger = loglevel_1.default.noConflict();
exports.logger = logger;
logger.setLevel((typeof process !== "undefined" && process.env && process.env.DEBUG) ? logger.levels.DEBUG : logger.levels.INFO);
//# sourceMappingURL=logger.js.map

/***/ }),

/***/ 27139:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.configureAuthMethods = exports.AppKeyAuthAuthentication = exports.ApiKeyAuthAuthentication = exports.AuthZAuthentication = void 0;
/**
 * Applies oauth2 authentication to the request context.
 */
class AuthZAuthentication {
    /**
     * Configures OAuth2 with the necessary properties
     *
     * @param accessToken: The access token to be used for every request
     */
    constructor(accessToken) {
        this.accessToken = accessToken;
    }
    getName() {
        return "AuthZ";
    }
    applySecurityAuthentication(context) {
        context.setHeaderParam("Authorization", "Bearer " + this.accessToken);
    }
}
exports.AuthZAuthentication = AuthZAuthentication;
/**
 * Applies apiKey authentication to the request context.
 */
class ApiKeyAuthAuthentication {
    /**
     * Configures this api key authentication with the necessary properties
     *
     * @param apiKey: The api key to be used for every request
     */
    constructor(apiKey) {
        this.apiKey = apiKey;
    }
    getName() {
        return "apiKeyAuth";
    }
    applySecurityAuthentication(context) {
        context.setHeaderParam("DD-API-KEY", this.apiKey);
    }
}
exports.ApiKeyAuthAuthentication = ApiKeyAuthAuthentication;
/**
 * Applies apiKey authentication to the request context.
 */
class AppKeyAuthAuthentication {
    /**
     * Configures this api key authentication with the necessary properties
     *
     * @param apiKey: The api key to be used for every request
     */
    constructor(apiKey) {
        this.apiKey = apiKey;
    }
    getName() {
        return "appKeyAuth";
    }
    applySecurityAuthentication(context) {
        context.setHeaderParam("DD-APPLICATION-KEY", this.apiKey);
    }
}
exports.AppKeyAuthAuthentication = AppKeyAuthAuthentication;
/**
 * Creates the authentication methods from a swagger description.
 *
 */
function configureAuthMethods(config) {
    const authMethods = {};
    if (!config) {
        return authMethods;
    }
    if (config["AuthZ"]) {
        authMethods["AuthZ"] = new AuthZAuthentication(config["AuthZ"]["accessToken"]);
    }
    if (config["apiKeyAuth"]) {
        authMethods["apiKeyAuth"] = new ApiKeyAuthAuthentication(config["apiKeyAuth"]);
    }
    if (config["appKeyAuth"]) {
        authMethods["appKeyAuth"] = new AppKeyAuthAuthentication(config["appKeyAuth"]);
    }
    return authMethods;
}
exports.configureAuthMethods = configureAuthMethods;
//# sourceMappingURL=auth.js.map

/***/ }),

/***/ 62279:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequiredError = exports.BaseAPIRequestFactory = exports.COLLECTION_FORMATS = void 0;
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPIRequestFactory {
    constructor(configuration) {
        this.configuration = configuration;
    }
}
exports.BaseAPIRequestFactory = BaseAPIRequestFactory;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, operation) {
        super(`Required parameter ${field} was null or undefined when calling ${operation}.`);
        this.field = field;
        this.name = "RequiredError";
    }
}
exports.RequiredError = RequiredError;
//# sourceMappingURL=baseapi.js.map

/***/ }),

/***/ 34130:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.applySecurityAuthentication = exports.setServerVariables = exports.getServer = exports.createConfiguration = void 0;
const isomorphic_fetch_1 = __webpack_require__(28084);
const servers_1 = __webpack_require__(80720);
const auth_1 = __webpack_require__(27139);
/**
 * Configuration factory function
 *
 * If a property is not included in conf, a default is used:
 *    - baseServer: null
 *    - serverIndex: 0
 *    - operationServerIndices: {}
 *    - httpApi: IsomorphicFetchHttpLibrary
 *    - authMethods: {}
 *    - httpConfig: {}
 *    - debug: false
 *
 * @param conf partial configuration
 */
function createConfiguration(conf = {}) {
    if (typeof process !== "undefined" && process.env && process.env.DD_SITE) {
        const serverConf = servers_1.server1.getConfiguration();
        servers_1.server1.setVariables({ site: process.env.DD_SITE });
        for (const op in servers_1.operationServers) {
            servers_1.operationServers[op][0].setVariables({ site: process.env.DD_SITE });
        }
    }
    const authMethods = conf.authMethods || {};
    if (!("apiKeyAuth" in authMethods) &&
        typeof process !== "undefined" &&
        process.env &&
        process.env.DD_API_KEY) {
        authMethods["apiKeyAuth"] = process.env.DD_API_KEY;
    }
    if (!("appKeyAuth" in authMethods) &&
        typeof process !== "undefined" &&
        process.env &&
        process.env.DD_APP_KEY) {
        authMethods["appKeyAuth"] = process.env.DD_APP_KEY;
    }
    const configuration = {
        baseServer: conf.baseServer,
        serverIndex: conf.serverIndex || 0,
        operationServerIndices: conf.operationServerIndices || {},
        unstableOperations: {
            "v1.searchSLO": false,
            "v2.listEvents": false,
            "v2.searchEvents": false,
            "v2.createIncident": false,
            "v2.deleteIncident": false,
            "v2.getIncident": false,
            "v2.listIncidentAttachments": false,
            "v2.listIncidents": false,
            "v2.searchIncidents": false,
            "v2.updateIncident": false,
            "v2.updateIncidentAttachments": false,
            "v2.queryScalarData": false,
            "v2.queryTimeseriesData": false,
            "v2.createIncidentService": false,
            "v2.deleteIncidentService": false,
            "v2.getIncidentService": false,
            "v2.listIncidentServices": false,
            "v2.updateIncidentService": false,
            "v2.createIncidentTeam": false,
            "v2.deleteIncidentTeam": false,
            "v2.getIncidentTeam": false,
            "v2.listIncidentTeams": false,
            "v2.updateIncidentTeam": false,
        },
        httpApi: conf.httpApi || new isomorphic_fetch_1.IsomorphicFetchHttpLibrary(),
        authMethods: (0, auth_1.configureAuthMethods)(authMethods),
        httpConfig: conf.httpConfig || {},
        debug: conf.debug,
    };
    configuration.httpApi.zstdCompressorCallback = conf.zstdCompressorCallback;
    configuration.httpApi.debug = configuration.debug;
    return configuration;
}
exports.createConfiguration = createConfiguration;
function getServer(conf, endpoint) {
    if (conf.baseServer !== undefined) {
        return conf.baseServer;
    }
    const index = endpoint in conf.operationServerIndices
        ? conf.operationServerIndices[endpoint]
        : conf.serverIndex;
    return endpoint in servers_1.operationServers
        ? servers_1.operationServers[endpoint][index]
        : servers_1.servers[index];
}
exports.getServer = getServer;
/**
 * Sets the server variables.
 *
 * @param serverVariables key/value object representing the server variables (site, name, protocol, ...)
 */
function setServerVariables(conf, serverVariables) {
    if (conf.baseServer !== undefined) {
        conf.baseServer.setVariables(serverVariables);
        return;
    }
    const index = conf.serverIndex;
    servers_1.servers[index].setVariables(serverVariables);
    for (const op in servers_1.operationServers) {
        servers_1.operationServers[op][0].setVariables(serverVariables);
    }
}
exports.setServerVariables = setServerVariables;
/**
 * Apply given security authentication method if avaiable in configuration.
 */
function applySecurityAuthentication(conf, requestContext, authMethods) {
    for (const authMethodName of authMethods) {
        const authMethod = conf.authMethods[authMethodName];
        if (authMethod) {
            authMethod.applySecurityAuthentication(requestContext);
        }
    }
}
exports.applySecurityAuthentication = applySecurityAuthentication;
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ 41001:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiException = void 0;
/**
 * Represents an error caused by an api call i.e. it has attributes for a HTTP status code
 * and the returned body object.
 *
 * Example
 * API returns a ErrorMessageObject whenever HTTP status code is not in [200, 299]
 * => ApiException(404, someErrorMessageObject)
 *
 */
class ApiException extends Error {
    constructor(code, body) {
        super("HTTP-Code: " + code + "\nMessage: " + JSON.stringify(body));
        this.code = code;
        this.body = body;
        Object.setPrototypeOf(this, ApiException.prototype);
        this.code = code;
        this.body = body;
    }
}
exports.ApiException = ApiException;
//# sourceMappingURL=exception.js.map

/***/ }),

/***/ 69942:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ResponseContext = exports.SelfDecodingBody = exports.RequestContext = exports.HttpException = exports.HttpMethod = void 0;
const userAgent_1 = __webpack_require__(55180);
const url_parse_1 = __importDefault(__webpack_require__(25682));
const util_1 = __webpack_require__(25009);
/**
 * Represents an HTTP method.
 */
var HttpMethod;
(function (HttpMethod) {
    HttpMethod["GET"] = "GET";
    HttpMethod["HEAD"] = "HEAD";
    HttpMethod["POST"] = "POST";
    HttpMethod["PUT"] = "PUT";
    HttpMethod["DELETE"] = "DELETE";
    HttpMethod["CONNECT"] = "CONNECT";
    HttpMethod["OPTIONS"] = "OPTIONS";
    HttpMethod["TRACE"] = "TRACE";
    HttpMethod["PATCH"] = "PATCH";
})(HttpMethod = exports.HttpMethod || (exports.HttpMethod = {}));
class HttpException extends Error {
    constructor(msg) {
        super(msg);
    }
}
exports.HttpException = HttpException;
/**
 * Represents an HTTP request context
 */
class RequestContext {
    /**
     * Creates the request context using a http method and request resource url
     *
     * @param url url of the requested resource
     * @param httpMethod http method
     */
    constructor(url, httpMethod) {
        this.httpMethod = httpMethod;
        this.headers = {};
        this.body = undefined;
        this.httpConfig = {};
        this.url = new url_parse_1.default(url, true);
        if (!util_1.isBrowser) {
            this.headers = { "user-agent": userAgent_1.userAgent };
        }
    }
    /*
     * Returns the url set in the constructor including the query string
     *
     */
    getUrl() {
        return this.url.toString();
    }
    /**
     * Replaces the url set in the constructor with this url.
     *
     */
    setUrl(url) {
        this.url = new url_parse_1.default(url, true);
    }
    /**
     * Sets the body of the http request either as a string or FormData
     *
     * Note that setting a body on a HTTP GET, HEAD, DELETE, CONNECT or TRACE
     * request is discouraged.
     * https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#rfc.section.7.3.1
     *
     * @param body the body of the request
     */
    setBody(body) {
        this.body = body;
    }
    getHttpMethod() {
        return this.httpMethod;
    }
    getHeaders() {
        return this.headers;
    }
    getBody() {
        return this.body;
    }
    setQueryParam(name, value) {
        const queryObj = this.url.query;
        queryObj[name] = value;
        this.url.set("query", queryObj);
    }
    /**
     * Sets a cookie with the name and value. NO check  for duplicate cookies is performed
     *
     */
    addCookie(name, value) {
        if (!this.headers["Cookie"]) {
            this.headers["Cookie"] = "";
        }
        this.headers["Cookie"] += name + "=" + value + "; ";
    }
    setHeaderParam(key, value) {
        this.headers[key] = value;
    }
    setHttpConfig(conf) {
        this.httpConfig = conf;
    }
    getHttpConfig() {
        return this.httpConfig;
    }
}
exports.RequestContext = RequestContext;
/**
 * Helper class to generate a `ResponseBody` from binary data
 */
class SelfDecodingBody {
    constructor(dataSource) {
        this.dataSource = dataSource;
    }
    binary() {
        return this.dataSource;
    }
    text() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.dataSource;
            return data.toString();
        });
    }
}
exports.SelfDecodingBody = SelfDecodingBody;
class ResponseContext {
    constructor(httpStatusCode, headers, body) {
        this.httpStatusCode = httpStatusCode;
        this.headers = headers;
        this.body = body;
    }
    /**
     * Parse header value in the form `value; param1="value1"`
     *
     * E.g. for Content-Type or Content-Disposition
     * Parameter names are converted to lower case
     * The first parameter is returned with the key `""`
     */
    getParsedHeader(headerName) {
        const result = {};
        if (!this.headers[headerName]) {
            return result;
        }
        const parameters = this.headers[headerName].split(";");
        for (const parameter of parameters) {
            let [key, value] = parameter.split("=", 2);
            key = key.toLowerCase().trim();
            if (value === undefined) {
                result[""] = key;
            }
            else {
                value = value.trim();
                if (value.startsWith('"') && value.endsWith('"')) {
                    value = value.substring(1, value.length - 1);
                }
                result[key] = value;
            }
        }
        return result;
    }
    getBodyAsFile() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.body.binary();
            const fileName = this.getParsedHeader("content-disposition")["filename"] || "";
            return { data, name: fileName };
        });
    }
}
exports.ResponseContext = ResponseContext;
//# sourceMappingURL=http.js.map

/***/ }),

/***/ 28084:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IsomorphicFetchHttpLibrary = void 0;
const http_1 = __webpack_require__(69942);
const cross_fetch_1 = __webpack_require__(19805);
const pako_1 = __importDefault(__webpack_require__(31726));
const buffer_from_1 = __importDefault(__webpack_require__(93018));
const util_1 = __webpack_require__(25009);
class IsomorphicFetchHttpLibrary {
    constructor() {
        this.debug = false;
    }
    send(request) {
        if (this.debug) {
            this.logRequest(request);
        }
        const method = request.getHttpMethod().toString();
        let body = request.getBody();
        let compress = request.getHttpConfig().compress;
        if (compress === undefined) {
            compress = true;
        }
        const headers = request.getHeaders();
        if (typeof body === "string") {
            if (headers["Content-Encoding"] == "gzip") {
                body = (0, buffer_from_1.default)(pako_1.default.gzip(body).buffer);
            }
            else if (headers["Content-Encoding"] == "deflate") {
                body = (0, buffer_from_1.default)(pako_1.default.deflate(body).buffer);
            }
            else if (headers["Content-Encoding"] == "zstd1") {
                if (this.zstdCompressorCallback) {
                    body = this.zstdCompressorCallback(body);
                }
                else {
                    throw new Error("zstdCompressorCallback method missing");
                }
            }
        }
        if (!util_1.isBrowser) {
            if (!headers["Accept-Encoding"]) {
                if (compress) {
                    headers["Accept-Encoding"] = "gzip,deflate";
                }
                else {
                    // We need to enforce it otherwise node-fetch will set a default
                    headers["Accept-Encoding"] = "identity";
                }
            }
        }
        let resultPromise;
        // On non-node environments, use native fetch if available.
        // `cross-fetch` incorrectly assumes all browsers have XHR available.
        // See https://github.com/lquixada/cross-fetch/issues/78
        // TODO: Remove once once above issue is resolved.
        if (!util_1.isNode && typeof fetch === "function") {
            resultPromise = fetch(request.getUrl(), {
                method: method,
                body: body,
                headers: headers,
                signal: request.getHttpConfig().signal,
            }).then((resp) => {
                const headers = {};
                resp.headers.forEach((value, name) => {
                    headers[name] = value;
                });
                const body = {
                    text: () => resp.text(),
                    binary: () => resp.buffer(),
                };
                const response = new http_1.ResponseContext(resp.status, headers, body);
                if (this.debug) {
                    this.logResponse(response);
                }
                return response;
            });
        }
        else {
            resultPromise = (0, cross_fetch_1.fetch)(request.getUrl(), {
                method: method,
                body: body,
                headers: headers,
                signal: request.getHttpConfig().signal,
            }).then((resp) => {
                const headers = {};
                resp.headers.forEach((value, name) => {
                    headers[name] = value;
                });
                const body = {
                    text: () => resp.text(),
                    binary: () => resp.buffer(),
                };
                const response = new http_1.ResponseContext(resp.status, headers, body);
                if (this.debug) {
                    this.logResponse(response);
                }
                return response;
            });
        }
        return resultPromise;
    }
    logRequest(request) {
        var _a;
        const headers = {};
        const originalHeaders = request.getHeaders();
        for (const header in originalHeaders) {
            headers[header] = originalHeaders[header];
        }
        if (headers["DD-API-KEY"]) {
            headers["DD-API-KEY"] = headers["DD-API-KEY"].replace(/./g, "x");
        }
        if (headers["DD-APPLICATION-KEY"]) {
            headers["DD-APPLICATION-KEY"] = headers["DD-APPLICATION-KEY"].replace(/./g, "x");
        }
        const headersJSON = JSON.stringify(headers, null, 2).replace(/\n/g, "\n\t");
        const method = request.getHttpMethod().toString();
        const url = request.getUrl().toString();
        const body = request.getBody()
            ? JSON.stringify(request.getBody(), null, 2).replace(/\n/g, "\n\t")
            : "";
        const compress = (_a = request.getHttpConfig().compress) !== null && _a !== void 0 ? _a : true;
        console.debug("\nrequest: {\n", `\turl: ${url}\n`, `\tmethod: ${method}\n`, `\theaders: ${headersJSON}\n`, `\tcompress: ${compress}\n`, `\tbody: ${body}\n}\n`);
    }
    logResponse(response) {
        const httpStatusCode = response.httpStatusCode;
        const headers = JSON.stringify(response.headers, null, 2).replace(/\n/g, "\n\t");
        console.debug("response: {\n", `\tstatus: ${httpStatusCode}\n`, `\theaders: ${headers}\n`);
    }
}
exports.IsomorphicFetchHttpLibrary = IsomorphicFetchHttpLibrary;
//# sourceMappingURL=isomorphic-fetch.js.map

/***/ }),

/***/ 87818:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setServerVariables = exports.createConfiguration = void 0;
__exportStar(__webpack_require__(69942), exports);
__exportStar(__webpack_require__(28084), exports);
__exportStar(__webpack_require__(27139), exports);
var configuration_1 = __webpack_require__(34130);
Object.defineProperty(exports, "createConfiguration", ({ enumerable: true, get: function () { return configuration_1.createConfiguration; } }));
var configuration_2 = __webpack_require__(34130);
Object.defineProperty(exports, "setServerVariables", ({ enumerable: true, get: function () { return configuration_2.setServerVariables; } }));
__exportStar(__webpack_require__(41001), exports);
__exportStar(__webpack_require__(80720), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 80720:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.operationServers = exports.servers = exports.server3 = exports.server2 = exports.server1 = exports.ServerConfiguration = exports.BaseServerConfiguration = void 0;
const http_1 = __webpack_require__(69942);
/**
 *
 * Represents the configuration of a server
 *
 */
class BaseServerConfiguration {
    constructor(url, variableConfiguration) {
        this.url = url;
        this.variableConfiguration = variableConfiguration;
    }
    /**
     * Sets the value of the variables of this server.
     *
     * @param variableConfiguration a partial variable configuration for the variables contained in the url
     */
    setVariables(variableConfiguration) {
        Object.assign(this.variableConfiguration, variableConfiguration);
    }
    getConfiguration() {
        return this.variableConfiguration;
    }
    getUrl() {
        let replacedUrl = this.url;
        for (const key in this.variableConfiguration) {
            const re = new RegExp("{" + key + "}", "g");
            replacedUrl = replacedUrl.replace(re, this.variableConfiguration[key]);
        }
        return replacedUrl;
    }
    /**
     * Creates a new request context for this server using the url with variables
     * replaced with their respective values and the endpoint of the request appended.
     *
     * @param endpoint the endpoint to be queried on the server
     * @param httpMethod httpMethod to be used
     *
     */
    makeRequestContext(endpoint, httpMethod) {
        return new http_1.RequestContext(this.getUrl() + endpoint, httpMethod);
    }
}
exports.BaseServerConfiguration = BaseServerConfiguration;
/**
 *
 * Represents the configuration of a server including its
 * url template and variable configuration based on the url.
 *
 */
class ServerConfiguration extends BaseServerConfiguration {
}
exports.ServerConfiguration = ServerConfiguration;
exports.server1 = new ServerConfiguration("https://{subdomain}.{site}", {
    site: "datadoghq.com",
    subdomain: "api",
});
exports.server2 = new ServerConfiguration("{protocol}://{name}", {
    name: "api.datadoghq.com",
    protocol: "https",
});
exports.server3 = new ServerConfiguration("https://{subdomain}.{site}", {
    site: "datadoghq.com",
    subdomain: "api",
});
exports.servers = [exports.server1, exports.server2, exports.server3];
exports.operationServers = {
    "v1.IPRangesApi.getIPRanges": [
        new ServerConfiguration("https://{subdomain}.{site}", {
            site: "datadoghq.com",
            subdomain: "ip-ranges",
        }),
        new ServerConfiguration("{protocol}://{name}", {
            name: "ip-ranges.datadoghq.com",
            protocol: "https",
        }),
        new ServerConfiguration("https://{subdomain}.datadoghq.com", {
            subdomain: "ip-ranges",
        }),
    ],
    "v1.LogsApi.submitLog": [
        new ServerConfiguration("https://{subdomain}.{site}", {
            site: "datadoghq.com",
            subdomain: "http-intake.logs",
        }),
        new ServerConfiguration("{protocol}://{name}", {
            name: "http-intake.logs.datadoghq.com",
            protocol: "https",
        }),
        new ServerConfiguration("https://{subdomain}.{site}", {
            site: "datadoghq.com",
            subdomain: "http-intake.logs",
        }),
    ],
    "v1.ServiceLevelObjectivesApi.searchSLO": [
        new ServerConfiguration("https://{subdomain}.{site}", {
            site: "datadoghq.com",
            subdomain: "api",
        }),
        new ServerConfiguration("{protocol}://{name}", {
            name: "api.datadoghq.com",
            protocol: "https",
        }),
        new ServerConfiguration("https://{subdomain}.{site}", {
            site: "datadoghq.com",
            subdomain: "api",
        }),
    ],
    "v2.LogsApi.submitLog": [
        new ServerConfiguration("https://{subdomain}.{site}", {
            site: "datadoghq.com",
            subdomain: "http-intake.logs",
        }),
        new ServerConfiguration("{protocol}://{name}", {
            name: "http-intake.logs.datadoghq.com",
            protocol: "https",
        }),
        new ServerConfiguration("https://{subdomain}.{site}", {
            site: "datadoghq.com",
            subdomain: "http-intake.logs",
        }),
    ],
};
//# sourceMappingURL=servers.js.map

/***/ }),

/***/ 25009:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dateToRFC3339String = exports.dateFromRFC3339String = exports.DDate = exports.isNode = exports.isBrowser = exports.UnparsedObject = void 0;
class UnparsedObject {
    constructor(data) {
        this._data = data;
    }
}
exports.UnparsedObject = UnparsedObject;
exports.isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
exports.isNode = typeof process !== "undefined" &&
    process.release &&
    process.release.name === "node";
class DDate extends Date {
}
exports.DDate = DDate;
const RFC3339Re = /^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})\.?(\d+)?(?:(?:([+-]\d{2}):?(\d{2}))|Z)?$/;
function dateFromRFC3339String(date) {
    const m = RFC3339Re.exec(date);
    if (m) {
        const _date = new DDate(date);
        if (m[8] === undefined && m[9] === undefined) {
            _date.rfc3339TzOffset = "Z";
        }
        else {
            _date.rfc3339TzOffset = `${m[8]}:${m[9]}`;
        }
        return _date;
    }
    else {
        throw new Error("unexpected date format: " + date);
    }
}
exports.dateFromRFC3339String = dateFromRFC3339String;
function dateToRFC3339String(date) {
    const offSetArr = getRFC3339TimezoneOffset(date).split(":");
    const tzHour = offSetArr.length == 1 ? 0 : +offSetArr[0];
    const tzMin = offSetArr.length == 1 ? 0 : +offSetArr[1];
    const year = date.getFullYear();
    const month = date.getMonth();
    const day = date.getUTCDate();
    const hour = date.getUTCHours() + +tzHour;
    const minute = date.getUTCMinutes() + +tzMin;
    const second = date.getUTCSeconds();
    let msec = date.getUTCMilliseconds().toString();
    msec = +msec === 0 ? "" : `.${pad(+msec, 3)}`;
    return (year +
        "-" +
        pad(month + 1) +
        "-" +
        pad(day) +
        "T" +
        pad(hour) +
        ":" +
        pad(minute) +
        ":" +
        pad(second) +
        msec +
        offSetArr.join(":"));
}
exports.dateToRFC3339String = dateToRFC3339String;
// Helpers
function pad(num, len = 2) {
    let paddedNum = num.toString();
    if (paddedNum.length < len) {
        paddedNum = "0".repeat(len - paddedNum.length) + paddedNum;
    }
    else if (paddedNum.length > len) {
        paddedNum = paddedNum.slice(0, len);
    }
    return paddedNum;
}
function getRFC3339TimezoneOffset(date) {
    if (date instanceof DDate && date.rfc3339TzOffset) {
        return date.rfc3339TzOffset;
    }
    let offset = date.getTimezoneOffset();
    if (offset === 0) {
        return "Z";
    }
    const offsetSign = offset > 0 ? "+" : "-";
    offset = Math.abs(offset);
    return offsetSign + pad(Math.floor(offset / 60)) + ":" + pad(offset % 60);
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ 50502:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AWSIntegrationApi = exports.AWSIntegrationApiResponseProcessor = exports.AWSIntegrationApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class AWSIntegrationApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createAWSAccount(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createAWSAccount");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/aws";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AWSIntegrationApi.createAWSAccount").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "AWSAccount", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createAWSTagFilter(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createAWSTagFilter");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/aws/filtering";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AWSIntegrationApi.createAWSTagFilter").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "AWSTagFilterCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createNewAWSExternalID(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createNewAWSExternalID");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/aws/generate_new_external_id";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AWSIntegrationApi.createNewAWSExternalID").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "AWSAccount", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteAWSAccount(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "deleteAWSAccount");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/aws";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AWSIntegrationApi.deleteAWSAccount").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "AWSAccountDeleteRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteAWSTagFilter(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "deleteAWSTagFilter");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/aws/filtering";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AWSIntegrationApi.deleteAWSTagFilter").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "AWSTagFilterDeleteRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listAvailableAWSNamespaces(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/integration/aws/available_namespace_rules";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AWSIntegrationApi.listAvailableAWSNamespaces").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listAWSAccounts(accountId, roleName, accessKeyId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/integration/aws";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AWSIntegrationApi.listAWSAccounts").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (accountId !== undefined) {
                requestContext.setQueryParam("account_id", ObjectSerializer_1.ObjectSerializer.serialize(accountId, "string", ""));
            }
            if (roleName !== undefined) {
                requestContext.setQueryParam("role_name", ObjectSerializer_1.ObjectSerializer.serialize(roleName, "string", ""));
            }
            if (accessKeyId !== undefined) {
                requestContext.setQueryParam("access_key_id", ObjectSerializer_1.ObjectSerializer.serialize(accessKeyId, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listAWSTagFilters(accountId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new baseapi_1.RequiredError("accountId", "listAWSTagFilters");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/aws/filtering";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AWSIntegrationApi.listAWSTagFilters").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (accountId !== undefined) {
                requestContext.setQueryParam("account_id", ObjectSerializer_1.ObjectSerializer.serialize(accountId, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateAWSAccount(body, accountId, roleName, accessKeyId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateAWSAccount");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/aws";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AWSIntegrationApi.updateAWSAccount").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (accountId !== undefined) {
                requestContext.setQueryParam("account_id", ObjectSerializer_1.ObjectSerializer.serialize(accountId, "string", ""));
            }
            if (roleName !== undefined) {
                requestContext.setQueryParam("role_name", ObjectSerializer_1.ObjectSerializer.serialize(roleName, "string", ""));
            }
            if (accessKeyId !== undefined) {
                requestContext.setQueryParam("access_key_id", ObjectSerializer_1.ObjectSerializer.serialize(accessKeyId, "string", ""));
            }
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "AWSAccount", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.AWSIntegrationApiRequestFactory = AWSIntegrationApiRequestFactory;
class AWSIntegrationApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createAWSAccount
     * @throws ApiException if the response code was not in [200, 299]
     */
    createAWSAccount(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AWSAccountCreateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 409 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AWSAccountCreateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createAWSTagFilter
     * @throws ApiException if the response code was not in [200, 299]
     */
    createAWSTagFilter(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createNewAWSExternalID
     * @throws ApiException if the response code was not in [200, 299]
     */
    createNewAWSExternalID(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AWSAccountCreateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AWSAccountCreateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteAWSAccount
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteAWSAccount(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 409 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteAWSTagFilter
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteAWSTagFilter(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listAvailableAWSNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    listAvailableAWSNamespaces(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Array<string>");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Array<string>", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listAWSAccounts
     * @throws ApiException if the response code was not in [200, 299]
     */
    listAWSAccounts(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AWSAccountListResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AWSAccountListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listAWSTagFilters
     * @throws ApiException if the response code was not in [200, 299]
     */
    listAWSTagFilters(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AWSTagFilterListResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AWSTagFilterListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateAWSAccount
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateAWSAccount(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 409 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.AWSIntegrationApiResponseProcessor = AWSIntegrationApiResponseProcessor;
class AWSIntegrationApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new AWSIntegrationApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new AWSIntegrationApiResponseProcessor();
    }
    /**
     * Create a Datadog-Amazon Web Services integration.
     * Using the `POST` method updates your integration configuration
     * by adding your new configuration to the existing one in your Datadog organization.
     * A unique AWS Account ID for role based authentication.
     * @param param The request object
     */
    createAWSAccount(param, options) {
        const requestContextPromise = this.requestFactory.createAWSAccount(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createAWSAccount(responseContext);
            });
        });
    }
    /**
     * Set an AWS tag filter.
     * @param param The request object
     */
    createAWSTagFilter(param, options) {
        const requestContextPromise = this.requestFactory.createAWSTagFilter(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createAWSTagFilter(responseContext);
            });
        });
    }
    /**
     * Generate a new AWS external ID for a given AWS account ID and role name pair.
     * @param param The request object
     */
    createNewAWSExternalID(param, options) {
        const requestContextPromise = this.requestFactory.createNewAWSExternalID(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createNewAWSExternalID(responseContext);
            });
        });
    }
    /**
     * Delete a Datadog-AWS integration matching the specified `account_id` and `role_name parameters`.
     * @param param The request object
     */
    deleteAWSAccount(param, options) {
        const requestContextPromise = this.requestFactory.deleteAWSAccount(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteAWSAccount(responseContext);
            });
        });
    }
    /**
     * Delete a tag filtering entry.
     * @param param The request object
     */
    deleteAWSTagFilter(param, options) {
        const requestContextPromise = this.requestFactory.deleteAWSTagFilter(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteAWSTagFilter(responseContext);
            });
        });
    }
    /**
     * List all namespace rules for a given Datadog-AWS integration. This endpoint takes no arguments.
     * @param param The request object
     */
    listAvailableAWSNamespaces(options) {
        const requestContextPromise = this.requestFactory.listAvailableAWSNamespaces(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listAvailableAWSNamespaces(responseContext);
            });
        });
    }
    /**
     * List all Datadog-AWS integrations available in your Datadog organization.
     * @param param The request object
     */
    listAWSAccounts(param = {}, options) {
        const requestContextPromise = this.requestFactory.listAWSAccounts(param.accountId, param.roleName, param.accessKeyId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listAWSAccounts(responseContext);
            });
        });
    }
    /**
     * Get all AWS tag filters.
     * @param param The request object
     */
    listAWSTagFilters(param, options) {
        const requestContextPromise = this.requestFactory.listAWSTagFilters(param.accountId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listAWSTagFilters(responseContext);
            });
        });
    }
    /**
     * Update a Datadog-Amazon Web Services integration.
     * @param param The request object
     */
    updateAWSAccount(param, options) {
        const requestContextPromise = this.requestFactory.updateAWSAccount(param.body, param.accountId, param.roleName, param.accessKeyId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateAWSAccount(responseContext);
            });
        });
    }
}
exports.AWSIntegrationApi = AWSIntegrationApi;
//# sourceMappingURL=AWSIntegrationApi.js.map

/***/ }),

/***/ 60149:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AWSLogsIntegrationApi = exports.AWSLogsIntegrationApiResponseProcessor = exports.AWSLogsIntegrationApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class AWSLogsIntegrationApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    checkAWSLogsLambdaAsync(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "checkAWSLogsLambdaAsync");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/aws/logs/check_async";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AWSLogsIntegrationApi.checkAWSLogsLambdaAsync").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "AWSAccountAndLambdaRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    checkAWSLogsServicesAsync(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "checkAWSLogsServicesAsync");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/aws/logs/services_async";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AWSLogsIntegrationApi.checkAWSLogsServicesAsync").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "AWSLogsServicesRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createAWSLambdaARN(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createAWSLambdaARN");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/aws/logs";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AWSLogsIntegrationApi.createAWSLambdaARN").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "AWSAccountAndLambdaRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteAWSLambdaARN(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "deleteAWSLambdaARN");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/aws/logs";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AWSLogsIntegrationApi.deleteAWSLambdaARN").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "AWSAccountAndLambdaRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    enableAWSLogServices(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "enableAWSLogServices");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/aws/logs/services";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AWSLogsIntegrationApi.enableAWSLogServices").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "AWSLogsServicesRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listAWSLogsIntegrations(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/integration/aws/logs";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AWSLogsIntegrationApi.listAWSLogsIntegrations").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listAWSLogsServices(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/integration/aws/logs/services";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AWSLogsIntegrationApi.listAWSLogsServices").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.AWSLogsIntegrationApiRequestFactory = AWSLogsIntegrationApiRequestFactory;
class AWSLogsIntegrationApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to checkAWSLogsLambdaAsync
     * @throws ApiException if the response code was not in [200, 299]
     */
    checkAWSLogsLambdaAsync(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AWSLogsAsyncResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AWSLogsAsyncResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to checkAWSLogsServicesAsync
     * @throws ApiException if the response code was not in [200, 299]
     */
    checkAWSLogsServicesAsync(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AWSLogsAsyncResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AWSLogsAsyncResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createAWSLambdaARN
     * @throws ApiException if the response code was not in [200, 299]
     */
    createAWSLambdaARN(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteAWSLambdaARN
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteAWSLambdaARN(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to enableAWSLogServices
     * @throws ApiException if the response code was not in [200, 299]
     */
    enableAWSLogServices(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listAWSLogsIntegrations
     * @throws ApiException if the response code was not in [200, 299]
     */
    listAWSLogsIntegrations(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Array<AWSLogsListResponse>");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Array<AWSLogsListResponse>", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listAWSLogsServices
     * @throws ApiException if the response code was not in [200, 299]
     */
    listAWSLogsServices(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Array<AWSLogsListServicesResponse>");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Array<AWSLogsListServicesResponse>", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.AWSLogsIntegrationApiResponseProcessor = AWSLogsIntegrationApiResponseProcessor;
class AWSLogsIntegrationApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new AWSLogsIntegrationApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new AWSLogsIntegrationApiResponseProcessor();
    }
    /**
     * Test if permissions are present to add a log-forwarding triggers for the given services and AWS account. The input
     * is the same as for Enable an AWS service log collection. Subsequent requests will always repeat the above, so this
     * endpoint can be polled intermittently instead of blocking.
     *
     * - Returns a status of 'created' when it's checking if the Lambda exists in the account.
     * - Returns a status of 'waiting' while checking.
     * - Returns a status of 'checked and ok' if the Lambda exists.
     * - Returns a status of 'error' if the Lambda does not exist.
     * @param param The request object
     */
    checkAWSLogsLambdaAsync(param, options) {
        const requestContextPromise = this.requestFactory.checkAWSLogsLambdaAsync(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.checkAWSLogsLambdaAsync(responseContext);
            });
        });
    }
    /**
     * Test if permissions are present to add log-forwarding triggers for the
     * given services and AWS account. Input is the same as for `EnableAWSLogServices`.
     * Done async, so can be repeatedly polled in a non-blocking fashion until
     * the async request completes.
     *
     * - Returns a status of `created` when it's checking if the permissions exists
     *   in the AWS account.
     * - Returns a status of `waiting` while checking.
     * - Returns a status of `checked and ok` if the Lambda exists.
     * - Returns a status of `error` if the Lambda does not exist.
     * @param param The request object
     */
    checkAWSLogsServicesAsync(param, options) {
        const requestContextPromise = this.requestFactory.checkAWSLogsServicesAsync(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.checkAWSLogsServicesAsync(responseContext);
            });
        });
    }
    /**
     * Attach the Lambda ARN of the Lambda created for the Datadog-AWS log collection to your AWS account ID to enable log collection.
     * @param param The request object
     */
    createAWSLambdaARN(param, options) {
        const requestContextPromise = this.requestFactory.createAWSLambdaARN(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createAWSLambdaARN(responseContext);
            });
        });
    }
    /**
     * Delete a Datadog-AWS logs configuration by removing the specific Lambda ARN associated with a given AWS account.
     * @param param The request object
     */
    deleteAWSLambdaARN(param, options) {
        const requestContextPromise = this.requestFactory.deleteAWSLambdaARN(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteAWSLambdaARN(responseContext);
            });
        });
    }
    /**
     * Enable automatic log collection for a list of services. This should be run after running `CreateAWSLambdaARN` to save the configuration.
     * @param param The request object
     */
    enableAWSLogServices(param, options) {
        const requestContextPromise = this.requestFactory.enableAWSLogServices(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.enableAWSLogServices(responseContext);
            });
        });
    }
    /**
     * List all Datadog-AWS Logs integrations configured in your Datadog account.
     * @param param The request object
     */
    listAWSLogsIntegrations(options) {
        const requestContextPromise = this.requestFactory.listAWSLogsIntegrations(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listAWSLogsIntegrations(responseContext);
            });
        });
    }
    /**
     * Get the list of current AWS services that Datadog offers automatic log collection. Use returned service IDs with the services parameter for the Enable an AWS service log collection API endpoint.
     * @param param The request object
     */
    listAWSLogsServices(options) {
        const requestContextPromise = this.requestFactory.listAWSLogsServices(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listAWSLogsServices(responseContext);
            });
        });
    }
}
exports.AWSLogsIntegrationApi = AWSLogsIntegrationApi;
//# sourceMappingURL=AWSLogsIntegrationApi.js.map

/***/ }),

/***/ 34507:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthenticationApi = exports.AuthenticationApiResponseProcessor = exports.AuthenticationApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class AuthenticationApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    validate(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/validate";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AuthenticationApi.validate").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.AuthenticationApiRequestFactory = AuthenticationApiRequestFactory;
class AuthenticationApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to validate
     * @throws ApiException if the response code was not in [200, 299]
     */
    validate(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AuthenticationValidationResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AuthenticationValidationResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.AuthenticationApiResponseProcessor = AuthenticationApiResponseProcessor;
class AuthenticationApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new AuthenticationApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new AuthenticationApiResponseProcessor();
    }
    /**
     * Check if the API key (not the APP key) is valid. If invalid, a 403 is returned.
     * @param param The request object
     */
    validate(options) {
        const requestContextPromise = this.requestFactory.validate(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.validate(responseContext);
            });
        });
    }
}
exports.AuthenticationApi = AuthenticationApi;
//# sourceMappingURL=AuthenticationApi.js.map

/***/ }),

/***/ 89924:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AzureIntegrationApi = exports.AzureIntegrationApiResponseProcessor = exports.AzureIntegrationApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class AzureIntegrationApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createAzureIntegration(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createAzureIntegration");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/azure";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AzureIntegrationApi.createAzureIntegration").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "AzureAccount", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteAzureIntegration(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "deleteAzureIntegration");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/azure";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AzureIntegrationApi.deleteAzureIntegration").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "AzureAccount", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listAzureIntegration(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/integration/azure";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AzureIntegrationApi.listAzureIntegration").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateAzureHostFilters(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateAzureHostFilters");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/azure/host_filters";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AzureIntegrationApi.updateAzureHostFilters").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "AzureAccount", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateAzureIntegration(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateAzureIntegration");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/azure";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.AzureIntegrationApi.updateAzureIntegration").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "AzureAccount", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.AzureIntegrationApiRequestFactory = AzureIntegrationApiRequestFactory;
class AzureIntegrationApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createAzureIntegration
     * @throws ApiException if the response code was not in [200, 299]
     */
    createAzureIntegration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteAzureIntegration
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteAzureIntegration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listAzureIntegration
     * @throws ApiException if the response code was not in [200, 299]
     */
    listAzureIntegration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Array<AzureAccount>");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Array<AzureAccount>", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateAzureHostFilters
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateAzureHostFilters(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateAzureIntegration
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateAzureIntegration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.AzureIntegrationApiResponseProcessor = AzureIntegrationApiResponseProcessor;
class AzureIntegrationApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new AzureIntegrationApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new AzureIntegrationApiResponseProcessor();
    }
    /**
     * Create a Datadog-Azure integration.
     *
     * Using the `POST` method updates your integration configuration by adding your new
     * configuration to the existing one in your Datadog organization.
     *
     * Using the `PUT` method updates your integration configuration by replacing your
     * current configuration with the new one sent to your Datadog organization.
     * @param param The request object
     */
    createAzureIntegration(param, options) {
        const requestContextPromise = this.requestFactory.createAzureIntegration(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createAzureIntegration(responseContext);
            });
        });
    }
    /**
     * Delete a given Datadog-Azure integration from your Datadog account.
     * @param param The request object
     */
    deleteAzureIntegration(param, options) {
        const requestContextPromise = this.requestFactory.deleteAzureIntegration(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteAzureIntegration(responseContext);
            });
        });
    }
    /**
     * List all Datadog-Azure integrations configured in your Datadog account.
     * @param param The request object
     */
    listAzureIntegration(options) {
        const requestContextPromise = this.requestFactory.listAzureIntegration(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listAzureIntegration(responseContext);
            });
        });
    }
    /**
     * Update the defined list of host filters for a given Datadog-Azure integration.
     * @param param The request object
     */
    updateAzureHostFilters(param, options) {
        const requestContextPromise = this.requestFactory.updateAzureHostFilters(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateAzureHostFilters(responseContext);
            });
        });
    }
    /**
     * Update a Datadog-Azure integration. Requires an existing `tenant_name` and `client_id`.
     * Any other fields supplied will overwrite existing values. To overwrite `tenant_name` or `client_id`,
     * use `new_tenant_name` and `new_client_id`. To leave a field unchanged, do not supply that field in the payload.
     * @param param The request object
     */
    updateAzureIntegration(param, options) {
        const requestContextPromise = this.requestFactory.updateAzureIntegration(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateAzureIntegration(responseContext);
            });
        });
    }
}
exports.AzureIntegrationApi = AzureIntegrationApi;
//# sourceMappingURL=AzureIntegrationApi.js.map

/***/ }),

/***/ 6094:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardListsApi = exports.DashboardListsApiResponseProcessor = exports.DashboardListsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class DashboardListsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createDashboardList(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createDashboardList");
            }
            // Path Params
            const localVarPath = "/api/v1/dashboard/lists/manual";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.DashboardListsApi.createDashboardList").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "DashboardList", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteDashboardList(listId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'listId' is not null or undefined
            if (listId === null || listId === undefined) {
                throw new baseapi_1.RequiredError("listId", "deleteDashboardList");
            }
            // Path Params
            const localVarPath = "/api/v1/dashboard/lists/manual/{list_id}".replace("{list_id}", encodeURIComponent(String(listId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.DashboardListsApi.deleteDashboardList").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getDashboardList(listId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'listId' is not null or undefined
            if (listId === null || listId === undefined) {
                throw new baseapi_1.RequiredError("listId", "getDashboardList");
            }
            // Path Params
            const localVarPath = "/api/v1/dashboard/lists/manual/{list_id}".replace("{list_id}", encodeURIComponent(String(listId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.DashboardListsApi.getDashboardList").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listDashboardLists(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/dashboard/lists/manual";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.DashboardListsApi.listDashboardLists").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateDashboardList(listId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'listId' is not null or undefined
            if (listId === null || listId === undefined) {
                throw new baseapi_1.RequiredError("listId", "updateDashboardList");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateDashboardList");
            }
            // Path Params
            const localVarPath = "/api/v1/dashboard/lists/manual/{list_id}".replace("{list_id}", encodeURIComponent(String(listId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.DashboardListsApi.updateDashboardList").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "DashboardList", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.DashboardListsApiRequestFactory = DashboardListsApiRequestFactory;
class DashboardListsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createDashboardList
     * @throws ApiException if the response code was not in [200, 299]
     */
    createDashboardList(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardList");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardList", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteDashboardList
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteDashboardList(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardListDeleteResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardListDeleteResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getDashboardList
     * @throws ApiException if the response code was not in [200, 299]
     */
    getDashboardList(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardList");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardList", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listDashboardLists
     * @throws ApiException if the response code was not in [200, 299]
     */
    listDashboardLists(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardListListResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardListListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateDashboardList
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateDashboardList(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardList");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardList", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.DashboardListsApiResponseProcessor = DashboardListsApiResponseProcessor;
class DashboardListsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new DashboardListsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new DashboardListsApiResponseProcessor();
    }
    /**
     * Create an empty dashboard list.
     * @param param The request object
     */
    createDashboardList(param, options) {
        const requestContextPromise = this.requestFactory.createDashboardList(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createDashboardList(responseContext);
            });
        });
    }
    /**
     * Delete a dashboard list.
     * @param param The request object
     */
    deleteDashboardList(param, options) {
        const requestContextPromise = this.requestFactory.deleteDashboardList(param.listId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteDashboardList(responseContext);
            });
        });
    }
    /**
     * Fetch an existing dashboard list's definition.
     * @param param The request object
     */
    getDashboardList(param, options) {
        const requestContextPromise = this.requestFactory.getDashboardList(param.listId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getDashboardList(responseContext);
            });
        });
    }
    /**
     * Fetch all of your existing dashboard list definitions.
     * @param param The request object
     */
    listDashboardLists(options) {
        const requestContextPromise = this.requestFactory.listDashboardLists(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listDashboardLists(responseContext);
            });
        });
    }
    /**
     * Update the name of a dashboard list.
     * @param param The request object
     */
    updateDashboardList(param, options) {
        const requestContextPromise = this.requestFactory.updateDashboardList(param.listId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateDashboardList(responseContext);
            });
        });
    }
}
exports.DashboardListsApi = DashboardListsApi;
//# sourceMappingURL=DashboardListsApi.js.map

/***/ }),

/***/ 24177:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardsApi = exports.DashboardsApiResponseProcessor = exports.DashboardsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class DashboardsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createDashboard(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createDashboard");
            }
            // Path Params
            const localVarPath = "/api/v1/dashboard";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.DashboardsApi.createDashboard").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "Dashboard", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteDashboard(dashboardId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'dashboardId' is not null or undefined
            if (dashboardId === null || dashboardId === undefined) {
                throw new baseapi_1.RequiredError("dashboardId", "deleteDashboard");
            }
            // Path Params
            const localVarPath = "/api/v1/dashboard/{dashboard_id}".replace("{dashboard_id}", encodeURIComponent(String(dashboardId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.DashboardsApi.deleteDashboard").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteDashboards(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "deleteDashboards");
            }
            // Path Params
            const localVarPath = "/api/v1/dashboard";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.DashboardsApi.deleteDashboards").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "DashboardBulkDeleteRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getDashboard(dashboardId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'dashboardId' is not null or undefined
            if (dashboardId === null || dashboardId === undefined) {
                throw new baseapi_1.RequiredError("dashboardId", "getDashboard");
            }
            // Path Params
            const localVarPath = "/api/v1/dashboard/{dashboard_id}".replace("{dashboard_id}", encodeURIComponent(String(dashboardId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.DashboardsApi.getDashboard").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listDashboards(filterShared, filterDeleted, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/dashboard";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.DashboardsApi.listDashboards").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (filterShared !== undefined) {
                requestContext.setQueryParam("filter[shared]", ObjectSerializer_1.ObjectSerializer.serialize(filterShared, "boolean", ""));
            }
            if (filterDeleted !== undefined) {
                requestContext.setQueryParam("filter[deleted]", ObjectSerializer_1.ObjectSerializer.serialize(filterDeleted, "boolean", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    restoreDashboards(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "restoreDashboards");
            }
            // Path Params
            const localVarPath = "/api/v1/dashboard";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.DashboardsApi.restoreDashboards").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "DashboardRestoreRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateDashboard(dashboardId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'dashboardId' is not null or undefined
            if (dashboardId === null || dashboardId === undefined) {
                throw new baseapi_1.RequiredError("dashboardId", "updateDashboard");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateDashboard");
            }
            // Path Params
            const localVarPath = "/api/v1/dashboard/{dashboard_id}".replace("{dashboard_id}", encodeURIComponent(String(dashboardId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.DashboardsApi.updateDashboard").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "Dashboard", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.DashboardsApiRequestFactory = DashboardsApiRequestFactory;
class DashboardsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createDashboard
     * @throws ApiException if the response code was not in [200, 299]
     */
    createDashboard(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Dashboard");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Dashboard", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteDashboard
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteDashboard(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardDeleteResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardDeleteResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteDashboards
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteDashboards(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getDashboard
     * @throws ApiException if the response code was not in [200, 299]
     */
    getDashboard(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Dashboard");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Dashboard", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listDashboards
     * @throws ApiException if the response code was not in [200, 299]
     */
    listDashboards(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardSummary");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardSummary", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to restoreDashboards
     * @throws ApiException if the response code was not in [200, 299]
     */
    restoreDashboards(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateDashboard
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateDashboard(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Dashboard");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Dashboard", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.DashboardsApiResponseProcessor = DashboardsApiResponseProcessor;
class DashboardsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new DashboardsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new DashboardsApiResponseProcessor();
    }
    /**
     * Create a dashboard using the specified options. When defining queries in your widgets, take note of which queries should have the `as_count()` or `as_rate()` modifiers appended.
     * Refer to the following [documentation](https://docs.datadoghq.com/developers/metrics/type_modifiers/?tab=count#in-application-modifiers) for more information on these modifiers.
     * @param param The request object
     */
    createDashboard(param, options) {
        const requestContextPromise = this.requestFactory.createDashboard(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createDashboard(responseContext);
            });
        });
    }
    /**
     * Delete a dashboard using the specified ID.
     * @param param The request object
     */
    deleteDashboard(param, options) {
        const requestContextPromise = this.requestFactory.deleteDashboard(param.dashboardId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteDashboard(responseContext);
            });
        });
    }
    /**
     * Delete dashboards using the specified IDs. If there are any failures, no dashboards will be deleted (partial success is not allowed).
     * @param param The request object
     */
    deleteDashboards(param, options) {
        const requestContextPromise = this.requestFactory.deleteDashboards(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteDashboards(responseContext);
            });
        });
    }
    /**
     * Get a dashboard using the specified ID.
     * @param param The request object
     */
    getDashboard(param, options) {
        const requestContextPromise = this.requestFactory.getDashboard(param.dashboardId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getDashboard(responseContext);
            });
        });
    }
    /**
     * Get all dashboards.
     *
     * **Note**: This query will only return custom created or cloned dashboards.
     * This query will not return preset dashboards.
     * @param param The request object
     */
    listDashboards(param = {}, options) {
        const requestContextPromise = this.requestFactory.listDashboards(param.filterShared, param.filterDeleted, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listDashboards(responseContext);
            });
        });
    }
    /**
     * Restore dashboards using the specified IDs. If there are any failures, no dashboards will be restored (partial success is not allowed).
     * @param param The request object
     */
    restoreDashboards(param, options) {
        const requestContextPromise = this.requestFactory.restoreDashboards(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.restoreDashboards(responseContext);
            });
        });
    }
    /**
     * Update a dashboard using the specified ID.
     * @param param The request object
     */
    updateDashboard(param, options) {
        const requestContextPromise = this.requestFactory.updateDashboard(param.dashboardId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateDashboard(responseContext);
            });
        });
    }
}
exports.DashboardsApi = DashboardsApi;
//# sourceMappingURL=DashboardsApi.js.map

/***/ }),

/***/ 6602:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DowntimesApi = exports.DowntimesApiResponseProcessor = exports.DowntimesApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class DowntimesApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    cancelDowntime(downtimeId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'downtimeId' is not null or undefined
            if (downtimeId === null || downtimeId === undefined) {
                throw new baseapi_1.RequiredError("downtimeId", "cancelDowntime");
            }
            // Path Params
            const localVarPath = "/api/v1/downtime/{downtime_id}".replace("{downtime_id}", encodeURIComponent(String(downtimeId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.DowntimesApi.cancelDowntime").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    cancelDowntimesByScope(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "cancelDowntimesByScope");
            }
            // Path Params
            const localVarPath = "/api/v1/downtime/cancel/by_scope";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.DowntimesApi.cancelDowntimesByScope").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "CancelDowntimesByScopeRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createDowntime(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createDowntime");
            }
            // Path Params
            const localVarPath = "/api/v1/downtime";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.DowntimesApi.createDowntime").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "Downtime", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getDowntime(downtimeId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'downtimeId' is not null or undefined
            if (downtimeId === null || downtimeId === undefined) {
                throw new baseapi_1.RequiredError("downtimeId", "getDowntime");
            }
            // Path Params
            const localVarPath = "/api/v1/downtime/{downtime_id}".replace("{downtime_id}", encodeURIComponent(String(downtimeId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.DowntimesApi.getDowntime").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listDowntimes(currentOnly, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/downtime";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.DowntimesApi.listDowntimes").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (currentOnly !== undefined) {
                requestContext.setQueryParam("current_only", ObjectSerializer_1.ObjectSerializer.serialize(currentOnly, "boolean", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listMonitorDowntimes(monitorId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'monitorId' is not null or undefined
            if (monitorId === null || monitorId === undefined) {
                throw new baseapi_1.RequiredError("monitorId", "listMonitorDowntimes");
            }
            // Path Params
            const localVarPath = "/api/v1/monitor/{monitor_id}/downtimes".replace("{monitor_id}", encodeURIComponent(String(monitorId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.DowntimesApi.listMonitorDowntimes").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateDowntime(downtimeId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'downtimeId' is not null or undefined
            if (downtimeId === null || downtimeId === undefined) {
                throw new baseapi_1.RequiredError("downtimeId", "updateDowntime");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateDowntime");
            }
            // Path Params
            const localVarPath = "/api/v1/downtime/{downtime_id}".replace("{downtime_id}", encodeURIComponent(String(downtimeId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.DowntimesApi.updateDowntime").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "Downtime", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.DowntimesApiRequestFactory = DowntimesApiRequestFactory;
class DowntimesApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to cancelDowntime
     * @throws ApiException if the response code was not in [200, 299]
     */
    cancelDowntime(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to cancelDowntimesByScope
     * @throws ApiException if the response code was not in [200, 299]
     */
    cancelDowntimesByScope(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CanceledDowntimesIds");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CanceledDowntimesIds", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createDowntime
     * @throws ApiException if the response code was not in [200, 299]
     */
    createDowntime(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Downtime");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Downtime", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getDowntime
     * @throws ApiException if the response code was not in [200, 299]
     */
    getDowntime(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Downtime");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Downtime", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listDowntimes
     * @throws ApiException if the response code was not in [200, 299]
     */
    listDowntimes(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Array<Downtime>");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Array<Downtime>", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listMonitorDowntimes
     * @throws ApiException if the response code was not in [200, 299]
     */
    listMonitorDowntimes(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Array<Downtime>");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Array<Downtime>", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateDowntime
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateDowntime(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Downtime");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Downtime", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.DowntimesApiResponseProcessor = DowntimesApiResponseProcessor;
class DowntimesApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new DowntimesApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new DowntimesApiResponseProcessor();
    }
    /**
     * Cancel a downtime.
     * @param param The request object
     */
    cancelDowntime(param, options) {
        const requestContextPromise = this.requestFactory.cancelDowntime(param.downtimeId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.cancelDowntime(responseContext);
            });
        });
    }
    /**
     * Delete all downtimes that match the scope of `X`.
     * @param param The request object
     */
    cancelDowntimesByScope(param, options) {
        const requestContextPromise = this.requestFactory.cancelDowntimesByScope(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.cancelDowntimesByScope(responseContext);
            });
        });
    }
    /**
     * Schedule a downtime.
     * @param param The request object
     */
    createDowntime(param, options) {
        const requestContextPromise = this.requestFactory.createDowntime(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createDowntime(responseContext);
            });
        });
    }
    /**
     * Get downtime detail by `downtime_id`.
     * @param param The request object
     */
    getDowntime(param, options) {
        const requestContextPromise = this.requestFactory.getDowntime(param.downtimeId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getDowntime(responseContext);
            });
        });
    }
    /**
     * Get all scheduled downtimes.
     * @param param The request object
     */
    listDowntimes(param = {}, options) {
        const requestContextPromise = this.requestFactory.listDowntimes(param.currentOnly, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listDowntimes(responseContext);
            });
        });
    }
    /**
     * Get all active downtimes for the specified monitor.
     * @param param The request object
     */
    listMonitorDowntimes(param, options) {
        const requestContextPromise = this.requestFactory.listMonitorDowntimes(param.monitorId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listMonitorDowntimes(responseContext);
            });
        });
    }
    /**
     * Update a single downtime by `downtime_id`.
     * @param param The request object
     */
    updateDowntime(param, options) {
        const requestContextPromise = this.requestFactory.updateDowntime(param.downtimeId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateDowntime(responseContext);
            });
        });
    }
}
exports.DowntimesApi = DowntimesApi;
//# sourceMappingURL=DowntimesApi.js.map

/***/ }),

/***/ 58715:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventsApi = exports.EventsApiResponseProcessor = exports.EventsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class EventsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createEvent(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createEvent");
            }
            // Path Params
            const localVarPath = "/api/v1/events";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.EventsApi.createEvent").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "EventCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, ["apiKeyAuth"]);
            return requestContext;
        });
    }
    getEvent(eventId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new baseapi_1.RequiredError("eventId", "getEvent");
            }
            // Path Params
            const localVarPath = "/api/v1/events/{event_id}".replace("{event_id}", encodeURIComponent(String(eventId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.EventsApi.getEvent").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listEvents(start, end, priority, sources, tags, unaggregated, excludeAggregate, page, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'start' is not null or undefined
            if (start === null || start === undefined) {
                throw new baseapi_1.RequiredError("start", "listEvents");
            }
            // verify required parameter 'end' is not null or undefined
            if (end === null || end === undefined) {
                throw new baseapi_1.RequiredError("end", "listEvents");
            }
            // Path Params
            const localVarPath = "/api/v1/events";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.EventsApi.listEvents").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (start !== undefined) {
                requestContext.setQueryParam("start", ObjectSerializer_1.ObjectSerializer.serialize(start, "number", "int64"));
            }
            if (end !== undefined) {
                requestContext.setQueryParam("end", ObjectSerializer_1.ObjectSerializer.serialize(end, "number", "int64"));
            }
            if (priority !== undefined) {
                requestContext.setQueryParam("priority", ObjectSerializer_1.ObjectSerializer.serialize(priority, "EventPriority", ""));
            }
            if (sources !== undefined) {
                requestContext.setQueryParam("sources", ObjectSerializer_1.ObjectSerializer.serialize(sources, "string", ""));
            }
            if (tags !== undefined) {
                requestContext.setQueryParam("tags", ObjectSerializer_1.ObjectSerializer.serialize(tags, "string", ""));
            }
            if (unaggregated !== undefined) {
                requestContext.setQueryParam("unaggregated", ObjectSerializer_1.ObjectSerializer.serialize(unaggregated, "boolean", ""));
            }
            if (excludeAggregate !== undefined) {
                requestContext.setQueryParam("exclude_aggregate", ObjectSerializer_1.ObjectSerializer.serialize(excludeAggregate, "boolean", ""));
            }
            if (page !== undefined) {
                requestContext.setQueryParam("page", ObjectSerializer_1.ObjectSerializer.serialize(page, "number", "int32"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.EventsApiRequestFactory = EventsApiRequestFactory;
class EventsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createEvent
     * @throws ApiException if the response code was not in [200, 299]
     */
    createEvent(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 202) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "EventCreateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "EventCreateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getEvent
     * @throws ApiException if the response code was not in [200, 299]
     */
    getEvent(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "EventResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "EventResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listEvents
     * @throws ApiException if the response code was not in [200, 299]
     */
    listEvents(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "EventListResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "EventListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.EventsApiResponseProcessor = EventsApiResponseProcessor;
class EventsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new EventsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new EventsApiResponseProcessor();
    }
    /**
     * This endpoint allows you to post events to the stream.
     * Tag them, set priority and event aggregate them with other events.
     * @param param The request object
     */
    createEvent(param, options) {
        const requestContextPromise = this.requestFactory.createEvent(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createEvent(responseContext);
            });
        });
    }
    /**
     * This endpoint allows you to query for event details.
     *
     * **Note**: If the event youre querying contains markdown formatting of any kind,
     * you may see characters such as `%`,`\`,`n` in your output.
     * @param param The request object
     */
    getEvent(param, options) {
        const requestContextPromise = this.requestFactory.getEvent(param.eventId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getEvent(responseContext);
            });
        });
    }
    /**
     * The event stream can be queried and filtered by time, priority, sources and tags.
     *
     * **Notes**:
     * - If the event youre querying contains markdown formatting of any kind,
     * you may see characters such as `%`,`\`,`n` in your output.
     *
     * - This endpoint returns a maximum of `1000` most recent results. To return additional results,
     * identify the last timestamp of the last result and set that as the `end` query time to
     * paginate the results. You can also use the page parameter to specify which set of `1000` results to return.
     * @param param The request object
     */
    listEvents(param, options) {
        const requestContextPromise = this.requestFactory.listEvents(param.start, param.end, param.priority, param.sources, param.tags, param.unaggregated, param.excludeAggregate, param.page, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listEvents(responseContext);
            });
        });
    }
}
exports.EventsApi = EventsApi;
//# sourceMappingURL=EventsApi.js.map

/***/ }),

/***/ 4665:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GCPIntegrationApi = exports.GCPIntegrationApiResponseProcessor = exports.GCPIntegrationApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class GCPIntegrationApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createGCPIntegration(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createGCPIntegration");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/gcp";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.GCPIntegrationApi.createGCPIntegration").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "GCPAccount", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteGCPIntegration(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "deleteGCPIntegration");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/gcp";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.GCPIntegrationApi.deleteGCPIntegration").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "GCPAccount", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listGCPIntegration(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/integration/gcp";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.GCPIntegrationApi.listGCPIntegration").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateGCPIntegration(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateGCPIntegration");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/gcp";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.GCPIntegrationApi.updateGCPIntegration").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "GCPAccount", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.GCPIntegrationApiRequestFactory = GCPIntegrationApiRequestFactory;
class GCPIntegrationApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createGCPIntegration
     * @throws ApiException if the response code was not in [200, 299]
     */
    createGCPIntegration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteGCPIntegration
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteGCPIntegration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listGCPIntegration
     * @throws ApiException if the response code was not in [200, 299]
     */
    listGCPIntegration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Array<GCPAccount>");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Array<GCPAccount>", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateGCPIntegration
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateGCPIntegration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.GCPIntegrationApiResponseProcessor = GCPIntegrationApiResponseProcessor;
class GCPIntegrationApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new GCPIntegrationApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new GCPIntegrationApiResponseProcessor();
    }
    /**
     * Create a Datadog-GCP integration.
     * @param param The request object
     */
    createGCPIntegration(param, options) {
        const requestContextPromise = this.requestFactory.createGCPIntegration(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createGCPIntegration(responseContext);
            });
        });
    }
    /**
     * Delete a given Datadog-GCP integration.
     * @param param The request object
     */
    deleteGCPIntegration(param, options) {
        const requestContextPromise = this.requestFactory.deleteGCPIntegration(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteGCPIntegration(responseContext);
            });
        });
    }
    /**
     * List all Datadog-GCP integrations configured in your Datadog account.
     * @param param The request object
     */
    listGCPIntegration(options) {
        const requestContextPromise = this.requestFactory.listGCPIntegration(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listGCPIntegration(responseContext);
            });
        });
    }
    /**
     * Update a Datadog-GCP integrations host_filters and/or auto-mute.
     * Requires a `project_id` and `client_email`, however these fields cannot be updated.
     * If you need to update these fields, delete and use the create (`POST`) endpoint.
     * The unspecified fields will keep their original values.
     * @param param The request object
     */
    updateGCPIntegration(param, options) {
        const requestContextPromise = this.requestFactory.updateGCPIntegration(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateGCPIntegration(responseContext);
            });
        });
    }
}
exports.GCPIntegrationApi = GCPIntegrationApi;
//# sourceMappingURL=GCPIntegrationApi.js.map

/***/ }),

/***/ 89523:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HostsApi = exports.HostsApiResponseProcessor = exports.HostsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class HostsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    getHostTotals(from, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/hosts/totals";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.HostsApi.getHostTotals").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (from !== undefined) {
                requestContext.setQueryParam("from", ObjectSerializer_1.ObjectSerializer.serialize(from, "number", "int64"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listHosts(filter, sortField, sortDir, start, count, from, includeMutedHostsData, includeHostsMetadata, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/hosts";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.HostsApi.listHosts").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (filter !== undefined) {
                requestContext.setQueryParam("filter", ObjectSerializer_1.ObjectSerializer.serialize(filter, "string", ""));
            }
            if (sortField !== undefined) {
                requestContext.setQueryParam("sort_field", ObjectSerializer_1.ObjectSerializer.serialize(sortField, "string", ""));
            }
            if (sortDir !== undefined) {
                requestContext.setQueryParam("sort_dir", ObjectSerializer_1.ObjectSerializer.serialize(sortDir, "string", ""));
            }
            if (start !== undefined) {
                requestContext.setQueryParam("start", ObjectSerializer_1.ObjectSerializer.serialize(start, "number", "int64"));
            }
            if (count !== undefined) {
                requestContext.setQueryParam("count", ObjectSerializer_1.ObjectSerializer.serialize(count, "number", "int64"));
            }
            if (from !== undefined) {
                requestContext.setQueryParam("from", ObjectSerializer_1.ObjectSerializer.serialize(from, "number", "int64"));
            }
            if (includeMutedHostsData !== undefined) {
                requestContext.setQueryParam("include_muted_hosts_data", ObjectSerializer_1.ObjectSerializer.serialize(includeMutedHostsData, "boolean", ""));
            }
            if (includeHostsMetadata !== undefined) {
                requestContext.setQueryParam("include_hosts_metadata", ObjectSerializer_1.ObjectSerializer.serialize(includeHostsMetadata, "boolean", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    muteHost(hostName, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'hostName' is not null or undefined
            if (hostName === null || hostName === undefined) {
                throw new baseapi_1.RequiredError("hostName", "muteHost");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "muteHost");
            }
            // Path Params
            const localVarPath = "/api/v1/host/{host_name}/mute".replace("{host_name}", encodeURIComponent(String(hostName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.HostsApi.muteHost").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "HostMuteSettings", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    unmuteHost(hostName, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'hostName' is not null or undefined
            if (hostName === null || hostName === undefined) {
                throw new baseapi_1.RequiredError("hostName", "unmuteHost");
            }
            // Path Params
            const localVarPath = "/api/v1/host/{host_name}/unmute".replace("{host_name}", encodeURIComponent(String(hostName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.HostsApi.unmuteHost").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.HostsApiRequestFactory = HostsApiRequestFactory;
class HostsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getHostTotals
     * @throws ApiException if the response code was not in [200, 299]
     */
    getHostTotals(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "HostTotals");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "HostTotals", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listHosts
     * @throws ApiException if the response code was not in [200, 299]
     */
    listHosts(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "HostListResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "HostListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to muteHost
     * @throws ApiException if the response code was not in [200, 299]
     */
    muteHost(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "HostMuteResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "HostMuteResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to unmuteHost
     * @throws ApiException if the response code was not in [200, 299]
     */
    unmuteHost(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "HostMuteResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "HostMuteResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.HostsApiResponseProcessor = HostsApiResponseProcessor;
class HostsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new HostsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new HostsApiResponseProcessor();
    }
    /**
     * This endpoint returns the total number of active and up hosts in your Datadog account.
     * Active means the host has reported in the past hour, and up means it has reported in the past two hours.
     * @param param The request object
     */
    getHostTotals(param = {}, options) {
        const requestContextPromise = this.requestFactory.getHostTotals(param.from, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getHostTotals(responseContext);
            });
        });
    }
    /**
     * This endpoint allows searching for hosts by name, alias, or tag.
     * Hosts live within the past 3 hours are included by default.
     * Retention is 7 days.
     * Results are paginated with a max of 1000 results at a time.
     * @param param The request object
     */
    listHosts(param = {}, options) {
        const requestContextPromise = this.requestFactory.listHosts(param.filter, param.sortField, param.sortDir, param.start, param.count, param.from, param.includeMutedHostsData, param.includeHostsMetadata, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listHosts(responseContext);
            });
        });
    }
    /**
     * Mute a host.
     * @param param The request object
     */
    muteHost(param, options) {
        const requestContextPromise = this.requestFactory.muteHost(param.hostName, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.muteHost(responseContext);
            });
        });
    }
    /**
     * Unmutes a host. This endpoint takes no JSON arguments.
     * @param param The request object
     */
    unmuteHost(param, options) {
        const requestContextPromise = this.requestFactory.unmuteHost(param.hostName, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.unmuteHost(responseContext);
            });
        });
    }
}
exports.HostsApi = HostsApi;
//# sourceMappingURL=HostsApi.js.map

/***/ }),

/***/ 53075:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IPRangesApi = exports.IPRangesApiResponseProcessor = exports.IPRangesApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class IPRangesApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    getIPRanges(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.IPRangesApi.getIPRanges").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            return requestContext;
        });
    }
}
exports.IPRangesApiRequestFactory = IPRangesApiRequestFactory;
class IPRangesApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getIPRanges
     * @throws ApiException if the response code was not in [200, 299]
     */
    getIPRanges(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IPRanges");
                return body;
            }
            if (response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IPRanges", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.IPRangesApiResponseProcessor = IPRangesApiResponseProcessor;
class IPRangesApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new IPRangesApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new IPRangesApiResponseProcessor();
    }
    /**
     * Get information about Datadog IP ranges.
     * @param param The request object
     */
    getIPRanges(options) {
        const requestContextPromise = this.requestFactory.getIPRanges(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getIPRanges(responseContext);
            });
        });
    }
}
exports.IPRangesApi = IPRangesApi;
//# sourceMappingURL=IPRangesApi.js.map

/***/ }),

/***/ 40263:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeyManagementApi = exports.KeyManagementApiResponseProcessor = exports.KeyManagementApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class KeyManagementApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createAPIKey(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createAPIKey");
            }
            // Path Params
            const localVarPath = "/api/v1/api_key";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.KeyManagementApi.createAPIKey").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "ApiKey", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createApplicationKey(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createApplicationKey");
            }
            // Path Params
            const localVarPath = "/api/v1/application_key";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.KeyManagementApi.createApplicationKey").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "ApplicationKey", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteAPIKey(key, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new baseapi_1.RequiredError("key", "deleteAPIKey");
            }
            // Path Params
            const localVarPath = "/api/v1/api_key/{key}".replace("{key}", encodeURIComponent(String(key)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.KeyManagementApi.deleteAPIKey").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteApplicationKey(key, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new baseapi_1.RequiredError("key", "deleteApplicationKey");
            }
            // Path Params
            const localVarPath = "/api/v1/application_key/{key}".replace("{key}", encodeURIComponent(String(key)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.KeyManagementApi.deleteApplicationKey").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getAPIKey(key, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new baseapi_1.RequiredError("key", "getAPIKey");
            }
            // Path Params
            const localVarPath = "/api/v1/api_key/{key}".replace("{key}", encodeURIComponent(String(key)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.KeyManagementApi.getAPIKey").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getApplicationKey(key, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new baseapi_1.RequiredError("key", "getApplicationKey");
            }
            // Path Params
            const localVarPath = "/api/v1/application_key/{key}".replace("{key}", encodeURIComponent(String(key)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.KeyManagementApi.getApplicationKey").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listAPIKeys(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/api_key";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.KeyManagementApi.listAPIKeys").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listApplicationKeys(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/application_key";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.KeyManagementApi.listApplicationKeys").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateAPIKey(key, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new baseapi_1.RequiredError("key", "updateAPIKey");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateAPIKey");
            }
            // Path Params
            const localVarPath = "/api/v1/api_key/{key}".replace("{key}", encodeURIComponent(String(key)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.KeyManagementApi.updateAPIKey").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "ApiKey", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateApplicationKey(key, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new baseapi_1.RequiredError("key", "updateApplicationKey");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateApplicationKey");
            }
            // Path Params
            const localVarPath = "/api/v1/application_key/{key}".replace("{key}", encodeURIComponent(String(key)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.KeyManagementApi.updateApplicationKey").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "ApplicationKey", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.KeyManagementApiRequestFactory = KeyManagementApiRequestFactory;
class KeyManagementApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createAPIKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    createAPIKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApiKeyResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApiKeyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createApplicationKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    createApplicationKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 409 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteAPIKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteAPIKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApiKeyResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApiKeyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteApplicationKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteApplicationKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAPIKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    getAPIKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApiKeyResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApiKeyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getApplicationKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    getApplicationKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listAPIKeys
     * @throws ApiException if the response code was not in [200, 299]
     */
    listAPIKeys(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApiKeyListResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApiKeyListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listApplicationKeys
     * @throws ApiException if the response code was not in [200, 299]
     */
    listApplicationKeys(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyListResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateAPIKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateAPIKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApiKeyResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApiKeyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateApplicationKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateApplicationKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 409 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.KeyManagementApiResponseProcessor = KeyManagementApiResponseProcessor;
class KeyManagementApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new KeyManagementApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new KeyManagementApiResponseProcessor();
    }
    /**
     * Creates an API key with a given name.
     * @param param The request object
     */
    createAPIKey(param, options) {
        const requestContextPromise = this.requestFactory.createAPIKey(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createAPIKey(responseContext);
            });
        });
    }
    /**
     * Create an application key with a given name.
     * @param param The request object
     */
    createApplicationKey(param, options) {
        const requestContextPromise = this.requestFactory.createApplicationKey(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createApplicationKey(responseContext);
            });
        });
    }
    /**
     * Delete a given API key.
     * @param param The request object
     */
    deleteAPIKey(param, options) {
        const requestContextPromise = this.requestFactory.deleteAPIKey(param.key, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteAPIKey(responseContext);
            });
        });
    }
    /**
     * Delete a given application key.
     * @param param The request object
     */
    deleteApplicationKey(param, options) {
        const requestContextPromise = this.requestFactory.deleteApplicationKey(param.key, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteApplicationKey(responseContext);
            });
        });
    }
    /**
     * Get a given API key.
     * @param param The request object
     */
    getAPIKey(param, options) {
        const requestContextPromise = this.requestFactory.getAPIKey(param.key, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getAPIKey(responseContext);
            });
        });
    }
    /**
     * Get a given application key.
     * @param param The request object
     */
    getApplicationKey(param, options) {
        const requestContextPromise = this.requestFactory.getApplicationKey(param.key, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getApplicationKey(responseContext);
            });
        });
    }
    /**
     * Get all API keys available for your account.
     * @param param The request object
     */
    listAPIKeys(options) {
        const requestContextPromise = this.requestFactory.listAPIKeys(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listAPIKeys(responseContext);
            });
        });
    }
    /**
     * Get all application keys available for your Datadog account.
     * @param param The request object
     */
    listApplicationKeys(options) {
        const requestContextPromise = this.requestFactory.listApplicationKeys(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listApplicationKeys(responseContext);
            });
        });
    }
    /**
     * Edit an API key name.
     * @param param The request object
     */
    updateAPIKey(param, options) {
        const requestContextPromise = this.requestFactory.updateAPIKey(param.key, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateAPIKey(responseContext);
            });
        });
    }
    /**
     * Edit an application key name.
     * @param param The request object
     */
    updateApplicationKey(param, options) {
        const requestContextPromise = this.requestFactory.updateApplicationKey(param.key, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateApplicationKey(responseContext);
            });
        });
    }
}
exports.KeyManagementApi = KeyManagementApi;
//# sourceMappingURL=KeyManagementApi.js.map

/***/ }),

/***/ 19068:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsApi = exports.LogsApiResponseProcessor = exports.LogsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class LogsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    listLogs(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "listLogs");
            }
            // Path Params
            const localVarPath = "/api/v1/logs-queries/list";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.LogsApi.listLogs").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "LogsListRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    submitLog(body, contentEncoding, ddtags, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "submitLog");
            }
            // Path Params
            const localVarPath = "/v1/input";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.LogsApi.submitLog").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (ddtags !== undefined) {
                requestContext.setQueryParam("ddtags", ObjectSerializer_1.ObjectSerializer.serialize(ddtags, "string", ""));
            }
            // Header Params
            if (contentEncoding !== undefined) {
                requestContext.setHeaderParam("Content-Encoding", ObjectSerializer_1.ObjectSerializer.serialize(contentEncoding, "ContentEncoding", ""));
            }
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
                "application/json;simple",
                "application/logplex-1",
                "text/plain",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "Array<HTTPLogItem>", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, ["apiKeyAuth"]);
            return requestContext;
        });
    }
}
exports.LogsApiRequestFactory = LogsApiRequestFactory;
class LogsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listLogs
     * @throws ApiException if the response code was not in [200, 299]
     */
    listLogs(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsListResponse");
                return body;
            }
            if (response.httpStatusCode == 400) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "LogsAPIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to submitLog
     * @throws ApiException if the response code was not in [200, 299]
     */
    submitLog(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any");
                return body;
            }
            if (response.httpStatusCode == 400) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "HTTPLogError");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            if (response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.LogsApiResponseProcessor = LogsApiResponseProcessor;
class LogsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new LogsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new LogsApiResponseProcessor();
    }
    /**
     * List endpoint returns logs that match a log search query.
     * [Results are paginated][1].
     *
     * **If you are considering archiving logs for your organization,
     * consider use of the Datadog archive capabilities instead of the log list API.
     * See [Datadog Logs Archive documentation][2].**
     *
     * [1]: /logs/guide/collect-multiple-logs-with-pagination
     * [2]: https://docs.datadoghq.com/logs/archives
     * @param param The request object
     */
    listLogs(param, options) {
        const requestContextPromise = this.requestFactory.listLogs(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listLogs(responseContext);
            });
        });
    }
    /**
     * Send your logs to your Datadog platform over HTTP. Limits per HTTP request are:
     *
     * - Maximum content size per payload (uncompressed): 5MB
     * - Maximum size for a single log: 1MB
     * - Maximum array size if sending multiple logs in an array: 1000 entries
     *
     * Any log exceeding 1MB is accepted and truncated by Datadog:
     * - For a single log request, the API truncates the log at 1MB and returns a 2xx.
     * - For a multi-logs request, the API processes all logs, truncates only logs larger than 1MB, and returns a 2xx.
     *
     * Datadog recommends sending your logs compressed.
     * Add the `Content-Encoding: gzip` header to the request when sending compressed logs.
     *
     * The status codes answered by the HTTP API are:
     * - 200: OK
     * - 400: Bad request (likely an issue in the payload formatting)
     * - 403: Permission issue (likely using an invalid API Key)
     * - 413: Payload too large (batch is above 5MB uncompressed)
     * - 5xx: Internal error, request should be retried after some time
     * @param param The request object
     */
    submitLog(param, options) {
        const requestContextPromise = this.requestFactory.submitLog(param.body, param.contentEncoding, param.ddtags, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.submitLog(responseContext);
            });
        });
    }
}
exports.LogsApi = LogsApi;
//# sourceMappingURL=LogsApi.js.map

/***/ }),

/***/ 19669:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsIndexesApi = exports.LogsIndexesApiResponseProcessor = exports.LogsIndexesApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class LogsIndexesApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createLogsIndex(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createLogsIndex");
            }
            // Path Params
            const localVarPath = "/api/v1/logs/config/indexes";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.LogsIndexesApi.createLogsIndex").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "LogsIndex", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getLogsIndex(name, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new baseapi_1.RequiredError("name", "getLogsIndex");
            }
            // Path Params
            const localVarPath = "/api/v1/logs/config/indexes/{name}".replace("{name}", encodeURIComponent(String(name)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.LogsIndexesApi.getLogsIndex").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getLogsIndexOrder(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/logs/config/index-order";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.LogsIndexesApi.getLogsIndexOrder").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listLogIndexes(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/logs/config/indexes";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.LogsIndexesApi.listLogIndexes").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateLogsIndex(name, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new baseapi_1.RequiredError("name", "updateLogsIndex");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateLogsIndex");
            }
            // Path Params
            const localVarPath = "/api/v1/logs/config/indexes/{name}".replace("{name}", encodeURIComponent(String(name)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.LogsIndexesApi.updateLogsIndex").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "LogsIndexUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateLogsIndexOrder(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateLogsIndexOrder");
            }
            // Path Params
            const localVarPath = "/api/v1/logs/config/index-order";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.LogsIndexesApi.updateLogsIndexOrder").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "LogsIndexesOrder", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.LogsIndexesApiRequestFactory = LogsIndexesApiRequestFactory;
class LogsIndexesApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createLogsIndex
     * @throws ApiException if the response code was not in [200, 299]
     */
    createLogsIndex(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsIndex");
                return body;
            }
            if (response.httpStatusCode == 400) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "LogsAPIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsIndex", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getLogsIndex
     * @throws ApiException if the response code was not in [200, 299]
     */
    getLogsIndex(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsIndex");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            if (response.httpStatusCode == 404) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "LogsAPIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsIndex", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getLogsIndexOrder
     * @throws ApiException if the response code was not in [200, 299]
     */
    getLogsIndexOrder(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsIndexesOrder");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsIndexesOrder", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listLogIndexes
     * @throws ApiException if the response code was not in [200, 299]
     */
    listLogIndexes(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsIndexListResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsIndexListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateLogsIndex
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateLogsIndex(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsIndex");
                return body;
            }
            if (response.httpStatusCode == 400 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "LogsAPIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            if (response.httpStatusCode == 403) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsIndex", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateLogsIndexOrder
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateLogsIndexOrder(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsIndexesOrder");
                return body;
            }
            if (response.httpStatusCode == 400) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "LogsAPIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsIndexesOrder", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.LogsIndexesApiResponseProcessor = LogsIndexesApiResponseProcessor;
class LogsIndexesApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new LogsIndexesApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new LogsIndexesApiResponseProcessor();
    }
    /**
     * Creates a new index. Returns the Index object passed in the request body when the request is successful.
     * @param param The request object
     */
    createLogsIndex(param, options) {
        const requestContextPromise = this.requestFactory.createLogsIndex(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createLogsIndex(responseContext);
            });
        });
    }
    /**
     * Get one log index from your organization. This endpoint takes no JSON arguments.
     * @param param The request object
     */
    getLogsIndex(param, options) {
        const requestContextPromise = this.requestFactory.getLogsIndex(param.name, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getLogsIndex(responseContext);
            });
        });
    }
    /**
     * Get the current order of your log indexes. This endpoint takes no JSON arguments.
     * @param param The request object
     */
    getLogsIndexOrder(options) {
        const requestContextPromise = this.requestFactory.getLogsIndexOrder(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getLogsIndexOrder(responseContext);
            });
        });
    }
    /**
     * The Index object describes the configuration of a log index.
     * This endpoint returns an array of the `LogIndex` objects of your organization.
     * @param param The request object
     */
    listLogIndexes(options) {
        const requestContextPromise = this.requestFactory.listLogIndexes(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listLogIndexes(responseContext);
            });
        });
    }
    /**
     * Update an index as identified by its name.
     * Returns the Index object passed in the request body when the request is successful.
     *
     * Using the `PUT` method updates your indexs configuration by **replacing**
     * your current configuration with the new one sent to your Datadog organization.
     * @param param The request object
     */
    updateLogsIndex(param, options) {
        const requestContextPromise = this.requestFactory.updateLogsIndex(param.name, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateLogsIndex(responseContext);
            });
        });
    }
    /**
     * This endpoint updates the index order of your organization.
     * It returns the index order object passed in the request body when the request is successful.
     * @param param The request object
     */
    updateLogsIndexOrder(param, options) {
        const requestContextPromise = this.requestFactory.updateLogsIndexOrder(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateLogsIndexOrder(responseContext);
            });
        });
    }
}
exports.LogsIndexesApi = LogsIndexesApi;
//# sourceMappingURL=LogsIndexesApi.js.map

/***/ }),

/***/ 94917:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsPipelinesApi = exports.LogsPipelinesApiResponseProcessor = exports.LogsPipelinesApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class LogsPipelinesApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createLogsPipeline(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createLogsPipeline");
            }
            // Path Params
            const localVarPath = "/api/v1/logs/config/pipelines";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.LogsPipelinesApi.createLogsPipeline").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "LogsPipeline", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteLogsPipeline(pipelineId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'pipelineId' is not null or undefined
            if (pipelineId === null || pipelineId === undefined) {
                throw new baseapi_1.RequiredError("pipelineId", "deleteLogsPipeline");
            }
            // Path Params
            const localVarPath = "/api/v1/logs/config/pipelines/{pipeline_id}".replace("{pipeline_id}", encodeURIComponent(String(pipelineId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.LogsPipelinesApi.deleteLogsPipeline").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getLogsPipeline(pipelineId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'pipelineId' is not null or undefined
            if (pipelineId === null || pipelineId === undefined) {
                throw new baseapi_1.RequiredError("pipelineId", "getLogsPipeline");
            }
            // Path Params
            const localVarPath = "/api/v1/logs/config/pipelines/{pipeline_id}".replace("{pipeline_id}", encodeURIComponent(String(pipelineId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.LogsPipelinesApi.getLogsPipeline").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getLogsPipelineOrder(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/logs/config/pipeline-order";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.LogsPipelinesApi.getLogsPipelineOrder").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listLogsPipelines(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/logs/config/pipelines";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.LogsPipelinesApi.listLogsPipelines").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateLogsPipeline(pipelineId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'pipelineId' is not null or undefined
            if (pipelineId === null || pipelineId === undefined) {
                throw new baseapi_1.RequiredError("pipelineId", "updateLogsPipeline");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateLogsPipeline");
            }
            // Path Params
            const localVarPath = "/api/v1/logs/config/pipelines/{pipeline_id}".replace("{pipeline_id}", encodeURIComponent(String(pipelineId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.LogsPipelinesApi.updateLogsPipeline").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "LogsPipeline", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateLogsPipelineOrder(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateLogsPipelineOrder");
            }
            // Path Params
            const localVarPath = "/api/v1/logs/config/pipeline-order";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.LogsPipelinesApi.updateLogsPipelineOrder").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "LogsPipelinesOrder", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.LogsPipelinesApiRequestFactory = LogsPipelinesApiRequestFactory;
class LogsPipelinesApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createLogsPipeline
     * @throws ApiException if the response code was not in [200, 299]
     */
    createLogsPipeline(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsPipeline");
                return body;
            }
            if (response.httpStatusCode == 400) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "LogsAPIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsPipeline", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteLogsPipeline
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteLogsPipeline(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                return;
            }
            if (response.httpStatusCode == 400) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "LogsAPIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getLogsPipeline
     * @throws ApiException if the response code was not in [200, 299]
     */
    getLogsPipeline(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsPipeline");
                return body;
            }
            if (response.httpStatusCode == 400) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "LogsAPIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsPipeline", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getLogsPipelineOrder
     * @throws ApiException if the response code was not in [200, 299]
     */
    getLogsPipelineOrder(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsPipelinesOrder");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsPipelinesOrder", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listLogsPipelines
     * @throws ApiException if the response code was not in [200, 299]
     */
    listLogsPipelines(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Array<LogsPipeline>");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Array<LogsPipeline>", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateLogsPipeline
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateLogsPipeline(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsPipeline");
                return body;
            }
            if (response.httpStatusCode == 400) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "LogsAPIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsPipeline", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateLogsPipelineOrder
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateLogsPipelineOrder(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsPipelinesOrder");
                return body;
            }
            if (response.httpStatusCode == 400 || response.httpStatusCode == 422) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "LogsAPIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsPipelinesOrder", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.LogsPipelinesApiResponseProcessor = LogsPipelinesApiResponseProcessor;
class LogsPipelinesApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new LogsPipelinesApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new LogsPipelinesApiResponseProcessor();
    }
    /**
     * Create a pipeline in your organization.
     * @param param The request object
     */
    createLogsPipeline(param, options) {
        const requestContextPromise = this.requestFactory.createLogsPipeline(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createLogsPipeline(responseContext);
            });
        });
    }
    /**
     * Delete a given pipeline from your organization.
     * This endpoint takes no JSON arguments.
     * @param param The request object
     */
    deleteLogsPipeline(param, options) {
        const requestContextPromise = this.requestFactory.deleteLogsPipeline(param.pipelineId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteLogsPipeline(responseContext);
            });
        });
    }
    /**
     * Get a specific pipeline from your organization.
     * This endpoint takes no JSON arguments.
     * @param param The request object
     */
    getLogsPipeline(param, options) {
        const requestContextPromise = this.requestFactory.getLogsPipeline(param.pipelineId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getLogsPipeline(responseContext);
            });
        });
    }
    /**
     * Get the current order of your pipelines.
     * This endpoint takes no JSON arguments.
     * @param param The request object
     */
    getLogsPipelineOrder(options) {
        const requestContextPromise = this.requestFactory.getLogsPipelineOrder(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getLogsPipelineOrder(responseContext);
            });
        });
    }
    /**
     * Get all pipelines from your organization.
     * This endpoint takes no JSON arguments.
     * @param param The request object
     */
    listLogsPipelines(options) {
        const requestContextPromise = this.requestFactory.listLogsPipelines(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listLogsPipelines(responseContext);
            });
        });
    }
    /**
     * Update a given pipeline configuration to change its processors or their order.
     *
     * **Note**: Using this method updates your pipeline configuration by **replacing**
     * your current configuration with the new one sent to your Datadog organization.
     * @param param The request object
     */
    updateLogsPipeline(param, options) {
        const requestContextPromise = this.requestFactory.updateLogsPipeline(param.pipelineId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateLogsPipeline(responseContext);
            });
        });
    }
    /**
     * Update the order of your pipelines. Since logs are processed sequentially, reordering a pipeline may change
     * the structure and content of the data processed by other pipelines and their processors.
     *
     * **Note**: Using the `PUT` method updates your pipeline order by replacing your current order
     * with the new one sent to your Datadog organization.
     * @param param The request object
     */
    updateLogsPipelineOrder(param, options) {
        const requestContextPromise = this.requestFactory.updateLogsPipelineOrder(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateLogsPipelineOrder(responseContext);
            });
        });
    }
}
exports.LogsPipelinesApi = LogsPipelinesApi;
//# sourceMappingURL=LogsPipelinesApi.js.map

/***/ }),

/***/ 74433:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricsApi = exports.MetricsApiResponseProcessor = exports.MetricsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class MetricsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    getMetricMetadata(metricName, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'metricName' is not null or undefined
            if (metricName === null || metricName === undefined) {
                throw new baseapi_1.RequiredError("metricName", "getMetricMetadata");
            }
            // Path Params
            const localVarPath = "/api/v1/metrics/{metric_name}".replace("{metric_name}", encodeURIComponent(String(metricName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.MetricsApi.getMetricMetadata").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listActiveMetrics(from, host, tagFilter, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new baseapi_1.RequiredError("from", "listActiveMetrics");
            }
            // Path Params
            const localVarPath = "/api/v1/metrics";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.MetricsApi.listActiveMetrics").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (from !== undefined) {
                requestContext.setQueryParam("from", ObjectSerializer_1.ObjectSerializer.serialize(from, "number", "int64"));
            }
            if (host !== undefined) {
                requestContext.setQueryParam("host", ObjectSerializer_1.ObjectSerializer.serialize(host, "string", ""));
            }
            if (tagFilter !== undefined) {
                requestContext.setQueryParam("tag_filter", ObjectSerializer_1.ObjectSerializer.serialize(tagFilter, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listMetrics(q, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'q' is not null or undefined
            if (q === null || q === undefined) {
                throw new baseapi_1.RequiredError("q", "listMetrics");
            }
            // Path Params
            const localVarPath = "/api/v1/search";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.MetricsApi.listMetrics").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (q !== undefined) {
                requestContext.setQueryParam("q", ObjectSerializer_1.ObjectSerializer.serialize(q, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    queryMetrics(from, to, query, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new baseapi_1.RequiredError("from", "queryMetrics");
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new baseapi_1.RequiredError("to", "queryMetrics");
            }
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new baseapi_1.RequiredError("query", "queryMetrics");
            }
            // Path Params
            const localVarPath = "/api/v1/query";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.MetricsApi.queryMetrics").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (from !== undefined) {
                requestContext.setQueryParam("from", ObjectSerializer_1.ObjectSerializer.serialize(from, "number", "int64"));
            }
            if (to !== undefined) {
                requestContext.setQueryParam("to", ObjectSerializer_1.ObjectSerializer.serialize(to, "number", "int64"));
            }
            if (query !== undefined) {
                requestContext.setQueryParam("query", ObjectSerializer_1.ObjectSerializer.serialize(query, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    submitDistributionPoints(body, contentEncoding, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "submitDistributionPoints");
            }
            // Path Params
            const localVarPath = "/api/v1/distribution_points";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.MetricsApi.submitDistributionPoints").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "text/json, application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Header Params
            if (contentEncoding !== undefined) {
                requestContext.setHeaderParam("Content-Encoding", ObjectSerializer_1.ObjectSerializer.serialize(contentEncoding, "DistributionPointsContentEncoding", ""));
            }
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType(["text/json"]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "DistributionPointsPayload", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, ["apiKeyAuth"]);
            return requestContext;
        });
    }
    submitMetrics(body, contentEncoding, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "submitMetrics");
            }
            // Path Params
            const localVarPath = "/api/v1/series";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.MetricsApi.submitMetrics").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "text/json, application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Header Params
            if (contentEncoding !== undefined) {
                requestContext.setHeaderParam("Content-Encoding", ObjectSerializer_1.ObjectSerializer.serialize(contentEncoding, "MetricContentEncoding", ""));
            }
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType(["text/json"]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "MetricsPayload", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, ["apiKeyAuth"]);
            return requestContext;
        });
    }
    updateMetricMetadata(metricName, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'metricName' is not null or undefined
            if (metricName === null || metricName === undefined) {
                throw new baseapi_1.RequiredError("metricName", "updateMetricMetadata");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateMetricMetadata");
            }
            // Path Params
            const localVarPath = "/api/v1/metrics/{metric_name}".replace("{metric_name}", encodeURIComponent(String(metricName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.MetricsApi.updateMetricMetadata").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "MetricMetadata", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.MetricsApiRequestFactory = MetricsApiRequestFactory;
class MetricsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getMetricMetadata
     * @throws ApiException if the response code was not in [200, 299]
     */
    getMetricMetadata(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricMetadata");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricMetadata", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listActiveMetrics
     * @throws ApiException if the response code was not in [200, 299]
     */
    listActiveMetrics(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricsListResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricsListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listMetrics
     * @throws ApiException if the response code was not in [200, 299]
     */
    listMetrics(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricSearchResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricSearchResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to queryMetrics
     * @throws ApiException if the response code was not in [200, 299]
     */
    queryMetrics(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricsQueryResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricsQueryResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to submitDistributionPoints
     * @throws ApiException if the response code was not in [200, 299]
     */
    submitDistributionPoints(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 202) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IntakePayloadAccepted");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 408 ||
                response.httpStatusCode == 413 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IntakePayloadAccepted", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to submitMetrics
     * @throws ApiException if the response code was not in [200, 299]
     */
    submitMetrics(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 202) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IntakePayloadAccepted");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 408 ||
                response.httpStatusCode == 413 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IntakePayloadAccepted", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateMetricMetadata
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateMetricMetadata(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricMetadata");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricMetadata", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.MetricsApiResponseProcessor = MetricsApiResponseProcessor;
class MetricsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new MetricsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new MetricsApiResponseProcessor();
    }
    /**
     * Get metadata about a specific metric.
     * @param param The request object
     */
    getMetricMetadata(param, options) {
        const requestContextPromise = this.requestFactory.getMetricMetadata(param.metricName, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getMetricMetadata(responseContext);
            });
        });
    }
    /**
     * Get the list of actively reporting metrics from a given time until now.
     * @param param The request object
     */
    listActiveMetrics(param, options) {
        const requestContextPromise = this.requestFactory.listActiveMetrics(param.from, param.host, param.tagFilter, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listActiveMetrics(responseContext);
            });
        });
    }
    /**
     * Search for metrics from the last 24 hours in Datadog.
     * @param param The request object
     */
    listMetrics(param, options) {
        const requestContextPromise = this.requestFactory.listMetrics(param.q, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listMetrics(responseContext);
            });
        });
    }
    /**
     * Query timeseries points.
     * @param param The request object
     */
    queryMetrics(param, options) {
        const requestContextPromise = this.requestFactory.queryMetrics(param.from, param.to, param.query, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.queryMetrics(responseContext);
            });
        });
    }
    /**
     * The distribution points end-point allows you to post distribution data that can be graphed on Datadogs dashboards.
     * @param param The request object
     */
    submitDistributionPoints(param, options) {
        const requestContextPromise = this.requestFactory.submitDistributionPoints(param.body, param.contentEncoding, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.submitDistributionPoints(responseContext);
            });
        });
    }
    /**
     * The metrics end-point allows you to post time-series data that can be graphed on Datadogs dashboards.
     * The maximum payload size is 3.2 megabytes (3200000 bytes). Compressed payloads must have a decompressed size of less than 62 megabytes (62914560 bytes).
     *
     * If youre submitting metrics directly to the Datadog API without using DogStatsD, expect:
     *
     * - 64 bits for the timestamp
     * - 64 bits for the value
     * - 40 bytes for the metric names
     * - 50 bytes for the timeseries
     * - The full payload is approximately 100 bytes. However, with the DogStatsD API,
     * compression is applied, which reduces the payload size.
     * @param param The request object
     */
    submitMetrics(param, options) {
        const requestContextPromise = this.requestFactory.submitMetrics(param.body, param.contentEncoding, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.submitMetrics(responseContext);
            });
        });
    }
    /**
     * Edit metadata of a specific metric. Find out more about [supported types](https://docs.datadoghq.com/developers/metrics).
     * @param param The request object
     */
    updateMetricMetadata(param, options) {
        const requestContextPromise = this.requestFactory.updateMetricMetadata(param.metricName, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateMetricMetadata(responseContext);
            });
        });
    }
}
exports.MetricsApi = MetricsApi;
//# sourceMappingURL=MetricsApi.js.map

/***/ }),

/***/ 80638:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorsApi = exports.MonitorsApiResponseProcessor = exports.MonitorsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class MonitorsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    checkCanDeleteMonitor(monitorIds, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'monitorIds' is not null or undefined
            if (monitorIds === null || monitorIds === undefined) {
                throw new baseapi_1.RequiredError("monitorIds", "checkCanDeleteMonitor");
            }
            // Path Params
            const localVarPath = "/api/v1/monitor/can_delete";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.MonitorsApi.checkCanDeleteMonitor").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (monitorIds !== undefined) {
                requestContext.setQueryParam("monitor_ids", ObjectSerializer_1.ObjectSerializer.serialize(monitorIds, "Array<number>", "int64"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createMonitor(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createMonitor");
            }
            // Path Params
            const localVarPath = "/api/v1/monitor";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.MonitorsApi.createMonitor").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "Monitor", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteMonitor(monitorId, force, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'monitorId' is not null or undefined
            if (monitorId === null || monitorId === undefined) {
                throw new baseapi_1.RequiredError("monitorId", "deleteMonitor");
            }
            // Path Params
            const localVarPath = "/api/v1/monitor/{monitor_id}".replace("{monitor_id}", encodeURIComponent(String(monitorId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.MonitorsApi.deleteMonitor").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (force !== undefined) {
                requestContext.setQueryParam("force", ObjectSerializer_1.ObjectSerializer.serialize(force, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getMonitor(monitorId, groupStates, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'monitorId' is not null or undefined
            if (monitorId === null || monitorId === undefined) {
                throw new baseapi_1.RequiredError("monitorId", "getMonitor");
            }
            // Path Params
            const localVarPath = "/api/v1/monitor/{monitor_id}".replace("{monitor_id}", encodeURIComponent(String(monitorId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.MonitorsApi.getMonitor").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (groupStates !== undefined) {
                requestContext.setQueryParam("group_states", ObjectSerializer_1.ObjectSerializer.serialize(groupStates, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listMonitors(groupStates, name, tags, monitorTags, withDowntimes, idOffset, page, pageSize, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/monitor";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.MonitorsApi.listMonitors").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (groupStates !== undefined) {
                requestContext.setQueryParam("group_states", ObjectSerializer_1.ObjectSerializer.serialize(groupStates, "string", ""));
            }
            if (name !== undefined) {
                requestContext.setQueryParam("name", ObjectSerializer_1.ObjectSerializer.serialize(name, "string", ""));
            }
            if (tags !== undefined) {
                requestContext.setQueryParam("tags", ObjectSerializer_1.ObjectSerializer.serialize(tags, "string", ""));
            }
            if (monitorTags !== undefined) {
                requestContext.setQueryParam("monitor_tags", ObjectSerializer_1.ObjectSerializer.serialize(monitorTags, "string", ""));
            }
            if (withDowntimes !== undefined) {
                requestContext.setQueryParam("with_downtimes", ObjectSerializer_1.ObjectSerializer.serialize(withDowntimes, "boolean", ""));
            }
            if (idOffset !== undefined) {
                requestContext.setQueryParam("id_offset", ObjectSerializer_1.ObjectSerializer.serialize(idOffset, "number", "int64"));
            }
            if (page !== undefined) {
                requestContext.setQueryParam("page", ObjectSerializer_1.ObjectSerializer.serialize(page, "number", "int64"));
            }
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page_size", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "number", "int32"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    searchMonitorGroups(query, page, perPage, sort, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/monitor/groups/search";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.MonitorsApi.searchMonitorGroups").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (query !== undefined) {
                requestContext.setQueryParam("query", ObjectSerializer_1.ObjectSerializer.serialize(query, "string", ""));
            }
            if (page !== undefined) {
                requestContext.setQueryParam("page", ObjectSerializer_1.ObjectSerializer.serialize(page, "number", "int64"));
            }
            if (perPage !== undefined) {
                requestContext.setQueryParam("per_page", ObjectSerializer_1.ObjectSerializer.serialize(perPage, "number", "int64"));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    searchMonitors(query, page, perPage, sort, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/monitor/search";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.MonitorsApi.searchMonitors").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (query !== undefined) {
                requestContext.setQueryParam("query", ObjectSerializer_1.ObjectSerializer.serialize(query, "string", ""));
            }
            if (page !== undefined) {
                requestContext.setQueryParam("page", ObjectSerializer_1.ObjectSerializer.serialize(page, "number", "int64"));
            }
            if (perPage !== undefined) {
                requestContext.setQueryParam("per_page", ObjectSerializer_1.ObjectSerializer.serialize(perPage, "number", "int64"));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateMonitor(monitorId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'monitorId' is not null or undefined
            if (monitorId === null || monitorId === undefined) {
                throw new baseapi_1.RequiredError("monitorId", "updateMonitor");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateMonitor");
            }
            // Path Params
            const localVarPath = "/api/v1/monitor/{monitor_id}".replace("{monitor_id}", encodeURIComponent(String(monitorId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.MonitorsApi.updateMonitor").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "MonitorUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    validateExistingMonitor(monitorId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'monitorId' is not null or undefined
            if (monitorId === null || monitorId === undefined) {
                throw new baseapi_1.RequiredError("monitorId", "validateExistingMonitor");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "validateExistingMonitor");
            }
            // Path Params
            const localVarPath = "/api/v1/monitor/{monitor_id}/validate".replace("{monitor_id}", encodeURIComponent(String(monitorId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.MonitorsApi.validateExistingMonitor").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "Monitor", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    validateMonitor(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "validateMonitor");
            }
            // Path Params
            const localVarPath = "/api/v1/monitor/validate";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.MonitorsApi.validateMonitor").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "Monitor", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.MonitorsApiRequestFactory = MonitorsApiRequestFactory;
class MonitorsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to checkCanDeleteMonitor
     * @throws ApiException if the response code was not in [200, 299]
     */
    checkCanDeleteMonitor(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200 || response.httpStatusCode == 409) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CheckCanDeleteMonitorResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CheckCanDeleteMonitorResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createMonitor
     * @throws ApiException if the response code was not in [200, 299]
     */
    createMonitor(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Monitor");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Monitor", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteMonitor
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteMonitor(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DeletedMonitor");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DeletedMonitor", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getMonitor
     * @throws ApiException if the response code was not in [200, 299]
     */
    getMonitor(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Monitor");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Monitor", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listMonitors
     * @throws ApiException if the response code was not in [200, 299]
     */
    listMonitors(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Array<Monitor>");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Array<Monitor>", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to searchMonitorGroups
     * @throws ApiException if the response code was not in [200, 299]
     */
    searchMonitorGroups(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MonitorGroupSearchResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MonitorGroupSearchResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to searchMonitors
     * @throws ApiException if the response code was not in [200, 299]
     */
    searchMonitors(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MonitorSearchResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MonitorSearchResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateMonitor
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateMonitor(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Monitor");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Monitor", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to validateExistingMonitor
     * @throws ApiException if the response code was not in [200, 299]
     */
    validateExistingMonitor(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to validateMonitor
     * @throws ApiException if the response code was not in [200, 299]
     */
    validateMonitor(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.MonitorsApiResponseProcessor = MonitorsApiResponseProcessor;
class MonitorsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new MonitorsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new MonitorsApiResponseProcessor();
    }
    /**
     * Check if the given monitors can be deleted.
     * @param param The request object
     */
    checkCanDeleteMonitor(param, options) {
        const requestContextPromise = this.requestFactory.checkCanDeleteMonitor(param.monitorIds, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.checkCanDeleteMonitor(responseContext);
            });
        });
    }
    /**
     * Create a monitor using the specified options.
     *
     * #### Monitor Types
     *
     * The type of monitor chosen from:
     *
     * - anomaly: `query alert`
     * - APM: `query alert` or `trace-analytics alert`
     * - composite: `composite`
     * - custom: `service check`
     * - event: `event alert`
     * - forecast: `query alert`
     * - host: `service check`
     * - integration: `query alert` or `service check`
     * - live process: `process alert`
     * - logs: `log alert`
     * - metric: `query alert`
     * - network: `service check`
     * - outlier: `query alert`
     * - process: `service check`
     * - rum: `rum alert`
     * - SLO: `slo alert`
     * - watchdog: `event alert`
     * - event-v2: `event-v2 alert`
     * - audit: `audit alert`
     * - error-tracking: `error-tracking alert`
     *
     * **Note**: Synthetic monitors are created through the Synthetics API. See the [Synthetics API] (https://docs.datadoghq.com/api/latest/synthetics/) documentation for more information.
     *
     * #### Query Types
     *
     * **Metric Alert Query**
     *
     * Example: `time_aggr(time_window):space_aggr:metric{tags} [by {key}] operator #`
     *
     * - `time_aggr`: avg, sum, max, min, change, or pct_change
     * - `time_window`: `last_#m` (with `#` between 1 and 10080 depending on the monitor type) or `last_#h`(with `#` between 1 and 168 depending on the monitor type) or `last_1d`, or `last_1w`
     * - `space_aggr`: avg, sum, min, or max
     * - `tags`: one or more tags (comma-separated), or *
     * - `key`: a 'key' in key:value tag syntax; defines a separate alert for each tag in the group (multi-alert)
     * - `operator`: <, <=, >, >=, ==, or !=
     * - `#`: an integer or decimal number used to set the threshold
     *
     * If you are using the `_change_` or `_pct_change_` time aggregator, instead use `change_aggr(time_aggr(time_window),
     * timeshift):space_aggr:metric{tags} [by {key}] operator #` with:
     *
     * - `change_aggr` change, pct_change
     * - `time_aggr` avg, sum, max, min [Learn more](https://docs.datadoghq.com/monitors/create/types/#define-the-conditions)
     * - `time_window` last\_#m (between 1 and 2880 depending on the monitor type), last\_#h (between 1 and 48 depending on the monitor type), or last_#d (1 or 2)
     * - `timeshift` #m_ago (5, 10, 15, or 30), #h_ago (1, 2, or 4), or 1d_ago
     *
     * Use this to create an outlier monitor using the following query:
     * `avg(last_30m):outliers(avg:system.cpu.user{role:es-events-data} by {host}, 'dbscan', 7) > 0`
     *
     * **Service Check Query**
     *
     * Example: `"check".over(tags).last(count).by(group).count_by_status()`
     *
     * - `check` name of the check, for example `datadog.agent.up`
     * - `tags` one or more quoted tags (comma-separated), or "*". for example: `.over("env:prod", "role:db")`; `over` cannot be blank.
     * - `count` must be at greater than or equal to your max threshold (defined in the `options`). It is limited to 100.
     * For example, if you've specified to notify on 1 critical, 3 ok, and 2 warn statuses, `count` should be at least 3.
     * - `group` must be specified for check monitors. Per-check grouping is already explicitly known for some service checks.
     * For example, Postgres integration monitors are tagged by `db`, `host`, and `port`, and Network monitors by `host`, `instance`, and `url`. See [Service Checks](https://docs.datadoghq.com/api/latest/service-checks/) documentation for more information.
     *
     * **Event Alert Query**
     *
     * Example: `events('sources:nagios status:error,warning priority:normal tags: "string query"').rollup("count").last("1h")"`
     *
     * - `event`, the event query string:
     * - `string_query` free text query to match against event title and text.
     * - `sources` event sources (comma-separated).
     * - `status` event statuses (comma-separated). Valid options: error, warn, and info.
     * - `priority` event priorities (comma-separated). Valid options: low, normal, all.
     * - `host` event reporting host (comma-separated).
     * - `tags` event tags (comma-separated).
     * - `excluded_tags` excluded event tags (comma-separated).
     * - `rollup` the stats roll-up method. `count` is the only supported method now.
     * - `last` the timeframe to roll up the counts. Examples: 45m, 4h. Supported timeframes: m, h and d. This value should not exceed 48 hours.
     *
     * **NOTE** The Event Alert Query is being deprecated and replaced by the Event V2 Alert Query. For more information, see the [Event Migration guide](https://docs.datadoghq.com/events/guides/migrating_to_new_events_features/).
     *
     * **Event V2 Alert Query**
     *
     * Example: `events(query).rollup(rollup_method[, measure]).last(time_window) operator #`
     *
     * - `query` The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
     * - `rollup_method` The stats roll-up method - supports `count`, `avg` and `cardinality`.
     * - `measure` For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
     * - `time_window` #m (between 1 and 2880), #h (between 1 and 48).
     * - `operator` `<`, `<=`, `>`, `>=`, `==`, or `!=`.
     * - `#` an integer or decimal number used to set the threshold.
     *
     * **Process Alert Query**
     *
     * Example: `processes(search).over(tags).rollup('count').last(timeframe) operator #`
     *
     * - `search` free text search string for querying processes.
     * Matching processes match results on the [Live Processes](https://docs.datadoghq.com/infrastructure/process/?tab=linuxwindows) page.
     * - `tags` one or more tags (comma-separated)
     * - `timeframe` the timeframe to roll up the counts. Examples: 10m, 4h. Supported timeframes: s, m, h and d
     * - `operator` <, <=, >, >=, ==, or !=
     * - `#` an integer or decimal number used to set the threshold
     *
     * **Logs Alert Query**
     *
     * Example: `logs(query).index(index_name).rollup(rollup_method[, measure]).last(time_window) operator #`
     *
     * - `query` The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
     * - `index_name` For multi-index organizations, the log index in which the request is performed.
     * - `rollup_method` The stats roll-up method - supports `count`, `avg` and `cardinality`.
     * - `measure` For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
     * - `time_window` #m (between 1 and 2880), #h (between 1 and 48).
     * - `operator` `<`, `<=`, `>`, `>=`, `==`, or `!=`.
     * - `#` an integer or decimal number used to set the threshold.
     *
     * **Composite Query**
     *
     * Example: `12345 && 67890`, where `12345` and `67890` are the IDs of non-composite monitors
     *
     * * `name` [*required*, *default* = **dynamic, based on query**]: The name of the alert.
     * * `message` [*required*, *default* = **dynamic, based on query**]: A message to include with notifications for this monitor.
     * Email notifications can be sent to specific users by using the same '@username' notation as events.
     * * `tags` [*optional*, *default* = **empty list**]: A list of tags to associate with your monitor.
     * When getting all monitor details via the API, use the `monitor_tags` argument to filter results by these tags.
     * It is only available via the API and isn't visible or editable in the Datadog UI.
     *
     * **SLO Alert Query**
     *
     * Example: `error_budget("slo_id").over("time_window") operator #`
     *
     * - `slo_id`: The alphanumeric SLO ID of the SLO you are configuring the alert for.
     * - `time_window`: The time window of the SLO target you wish to alert on. Valid options: `7d`, `30d`, `90d`.
     * - `operator`: `>=` or `>`
     *
     * **Audit Alert Query**
     *
     * Example: `audits(query).rollup(rollup_method[, measure]).last(time_window) operator #`
     *
     * - `query` The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
     * - `rollup_method` The stats roll-up method - supports `count`, `avg` and `cardinality`.
     * - `measure` For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
     * - `time_window` #m (between 1 and 2880), #h (between 1 and 48).
     * - `operator` `<`, `<=`, `>`, `>=`, `==`, or `!=`.
     * - `#` an integer or decimal number used to set the threshold.
     *
     * **NOTE** Only available on US1-FED and in closed beta on US1, EU, US3, and US5.
     *
     * **CI Pipelines Alert Query**
     *
     * Example: `ci-pipelines(query).rollup(rollup_method[, measure]).last(time_window) operator #`
     *
     * - `query` The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
     * - `rollup_method` The stats roll-up method - supports `count`, `avg`, and `cardinality`.
     * - `measure` For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
     * - `time_window` #m (between 1 and 2880), #h (between 1 and 48).
     * - `operator` `<`, `<=`, `>`, `>=`, `==`, or `!=`.
     * - `#` an integer or decimal number used to set the threshold.
     *
     * **NOTE** CI Pipeline monitors are in alpha on US1, EU, US3 and US5.
     *
     * **CI Tests Alert Query**
     *
     * Example: `ci-tests(query).rollup(rollup_method[, measure]).last(time_window) operator #`
     *
     * - `query` The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
     * - `rollup_method` The stats roll-up method - supports `count`, `avg`, and `cardinality`.
     * - `measure` For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
     * - `time_window` #m (between 1 and 2880), #h (between 1 and 48).
     * - `operator` `<`, `<=`, `>`, `>=`, `==`, or `!=`.
     * - `#` an integer or decimal number used to set the threshold.
     *
     * **NOTE** CI Test monitors are available only in closed beta on US1, EU, US3 and US5.
     *
     * **Error Tracking Alert Query**
     *
     * Example(RUM): `error-tracking-rum(query).rollup(rollup_method[, measure]).last(time_window) operator #`
     * Example(APM Traces): `error-tracking-traces(query).rollup(rollup_method[, measure]).last(time_window) operator #`
     *
     * - `query` The search query - following the [Log search syntax](https://docs.datadoghq.com/logs/search_syntax/).
     * - `rollup_method` The stats roll-up method - supports `count`, `avg`, and `cardinality`.
     * - `measure` For `avg` and cardinality `rollup_method` - specify the measure or the facet name you want to use.
     * - `time_window` #m (between 1 and 2880), #h (between 1 and 48).
     * - `operator` `<`, `<=`, `>`, `>=`, `==`, or `!=`.
     * - `#` an integer or decimal number used to set the threshold.
     * @param param The request object
     */
    createMonitor(param, options) {
        const requestContextPromise = this.requestFactory.createMonitor(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createMonitor(responseContext);
            });
        });
    }
    /**
     * Delete the specified monitor
     * @param param The request object
     */
    deleteMonitor(param, options) {
        const requestContextPromise = this.requestFactory.deleteMonitor(param.monitorId, param.force, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteMonitor(responseContext);
            });
        });
    }
    /**
     * Get details about the specified monitor from your organization.
     * @param param The request object
     */
    getMonitor(param, options) {
        const requestContextPromise = this.requestFactory.getMonitor(param.monitorId, param.groupStates, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getMonitor(responseContext);
            });
        });
    }
    /**
     * Get details about the specified monitor from your organization.
     * @param param The request object
     */
    listMonitors(param = {}, options) {
        const requestContextPromise = this.requestFactory.listMonitors(param.groupStates, param.name, param.tags, param.monitorTags, param.withDowntimes, param.idOffset, param.page, param.pageSize, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listMonitors(responseContext);
            });
        });
    }
    /**
     * Search and filter your monitor groups details.
     * @param param The request object
     */
    searchMonitorGroups(param = {}, options) {
        const requestContextPromise = this.requestFactory.searchMonitorGroups(param.query, param.page, param.perPage, param.sort, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.searchMonitorGroups(responseContext);
            });
        });
    }
    /**
     * Search and filter your monitors details.
     * @param param The request object
     */
    searchMonitors(param = {}, options) {
        const requestContextPromise = this.requestFactory.searchMonitors(param.query, param.page, param.perPage, param.sort, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.searchMonitors(responseContext);
            });
        });
    }
    /**
     * Edit the specified monitor.
     * @param param The request object
     */
    updateMonitor(param, options) {
        const requestContextPromise = this.requestFactory.updateMonitor(param.monitorId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateMonitor(responseContext);
            });
        });
    }
    /**
     * Validate the monitor provided in the request.
     * @param param The request object
     */
    validateExistingMonitor(param, options) {
        const requestContextPromise = this.requestFactory.validateExistingMonitor(param.monitorId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.validateExistingMonitor(responseContext);
            });
        });
    }
    /**
     * Validate the monitor provided in the request.
     * @param param The request object
     */
    validateMonitor(param, options) {
        const requestContextPromise = this.requestFactory.validateMonitor(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.validateMonitor(responseContext);
            });
        });
    }
}
exports.MonitorsApi = MonitorsApi;
//# sourceMappingURL=MonitorsApi.js.map

/***/ }),

/***/ 61958:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebooksApi = exports.NotebooksApiResponseProcessor = exports.NotebooksApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class NotebooksApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createNotebook(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createNotebook");
            }
            // Path Params
            const localVarPath = "/api/v1/notebooks";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.NotebooksApi.createNotebook").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "NotebookCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteNotebook(notebookId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'notebookId' is not null or undefined
            if (notebookId === null || notebookId === undefined) {
                throw new baseapi_1.RequiredError("notebookId", "deleteNotebook");
            }
            // Path Params
            const localVarPath = "/api/v1/notebooks/{notebook_id}".replace("{notebook_id}", encodeURIComponent(String(notebookId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.NotebooksApi.deleteNotebook").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getNotebook(notebookId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'notebookId' is not null or undefined
            if (notebookId === null || notebookId === undefined) {
                throw new baseapi_1.RequiredError("notebookId", "getNotebook");
            }
            // Path Params
            const localVarPath = "/api/v1/notebooks/{notebook_id}".replace("{notebook_id}", encodeURIComponent(String(notebookId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.NotebooksApi.getNotebook").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listNotebooks(authorHandle, excludeAuthorHandle, start, count, sortField, sortDir, query, includeCells, isTemplate, type, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/notebooks";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.NotebooksApi.listNotebooks").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (authorHandle !== undefined) {
                requestContext.setQueryParam("author_handle", ObjectSerializer_1.ObjectSerializer.serialize(authorHandle, "string", ""));
            }
            if (excludeAuthorHandle !== undefined) {
                requestContext.setQueryParam("exclude_author_handle", ObjectSerializer_1.ObjectSerializer.serialize(excludeAuthorHandle, "string", ""));
            }
            if (start !== undefined) {
                requestContext.setQueryParam("start", ObjectSerializer_1.ObjectSerializer.serialize(start, "number", "int64"));
            }
            if (count !== undefined) {
                requestContext.setQueryParam("count", ObjectSerializer_1.ObjectSerializer.serialize(count, "number", "int64"));
            }
            if (sortField !== undefined) {
                requestContext.setQueryParam("sort_field", ObjectSerializer_1.ObjectSerializer.serialize(sortField, "string", ""));
            }
            if (sortDir !== undefined) {
                requestContext.setQueryParam("sort_dir", ObjectSerializer_1.ObjectSerializer.serialize(sortDir, "string", ""));
            }
            if (query !== undefined) {
                requestContext.setQueryParam("query", ObjectSerializer_1.ObjectSerializer.serialize(query, "string", ""));
            }
            if (includeCells !== undefined) {
                requestContext.setQueryParam("include_cells", ObjectSerializer_1.ObjectSerializer.serialize(includeCells, "boolean", ""));
            }
            if (isTemplate !== undefined) {
                requestContext.setQueryParam("is_template", ObjectSerializer_1.ObjectSerializer.serialize(isTemplate, "boolean", ""));
            }
            if (type !== undefined) {
                requestContext.setQueryParam("type", ObjectSerializer_1.ObjectSerializer.serialize(type, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateNotebook(notebookId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'notebookId' is not null or undefined
            if (notebookId === null || notebookId === undefined) {
                throw new baseapi_1.RequiredError("notebookId", "updateNotebook");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateNotebook");
            }
            // Path Params
            const localVarPath = "/api/v1/notebooks/{notebook_id}".replace("{notebook_id}", encodeURIComponent(String(notebookId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.NotebooksApi.updateNotebook").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "NotebookUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.NotebooksApiRequestFactory = NotebooksApiRequestFactory;
class NotebooksApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createNotebook
     * @throws ApiException if the response code was not in [200, 299]
     */
    createNotebook(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "NotebookResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "NotebookResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteNotebook
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteNotebook(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getNotebook
     * @throws ApiException if the response code was not in [200, 299]
     */
    getNotebook(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "NotebookResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "NotebookResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listNotebooks
     * @throws ApiException if the response code was not in [200, 299]
     */
    listNotebooks(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "NotebooksResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "NotebooksResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateNotebook
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateNotebook(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "NotebookResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 409 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "NotebookResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.NotebooksApiResponseProcessor = NotebooksApiResponseProcessor;
class NotebooksApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new NotebooksApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new NotebooksApiResponseProcessor();
    }
    /**
     * Create a notebook using the specified options.
     * @param param The request object
     */
    createNotebook(param, options) {
        const requestContextPromise = this.requestFactory.createNotebook(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createNotebook(responseContext);
            });
        });
    }
    /**
     * Delete a notebook using the specified ID.
     * @param param The request object
     */
    deleteNotebook(param, options) {
        const requestContextPromise = this.requestFactory.deleteNotebook(param.notebookId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteNotebook(responseContext);
            });
        });
    }
    /**
     * Get a notebook using the specified notebook ID.
     * @param param The request object
     */
    getNotebook(param, options) {
        const requestContextPromise = this.requestFactory.getNotebook(param.notebookId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getNotebook(responseContext);
            });
        });
    }
    /**
     * Get all notebooks. This can also be used to search for notebooks with a particular `query` in the notebook
     * `name` or author `handle`.
     * @param param The request object
     */
    listNotebooks(param = {}, options) {
        const requestContextPromise = this.requestFactory.listNotebooks(param.authorHandle, param.excludeAuthorHandle, param.start, param.count, param.sortField, param.sortDir, param.query, param.includeCells, param.isTemplate, param.type, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listNotebooks(responseContext);
            });
        });
    }
    /**
     * Update a notebook using the specified ID.
     * @param param The request object
     */
    updateNotebook(param, options) {
        const requestContextPromise = this.requestFactory.updateNotebook(param.notebookId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateNotebook(responseContext);
            });
        });
    }
}
exports.NotebooksApi = NotebooksApi;
//# sourceMappingURL=NotebooksApi.js.map

/***/ }),

/***/ 83497:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrganizationsApi = exports.OrganizationsApiResponseProcessor = exports.OrganizationsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const form_data_1 = __importDefault(__webpack_require__(64334));
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class OrganizationsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createChildOrg(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createChildOrg");
            }
            // Path Params
            const localVarPath = "/api/v1/org";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.OrganizationsApi.createChildOrg").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "OrganizationCreateBody", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    downgradeOrg(publicId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'publicId' is not null or undefined
            if (publicId === null || publicId === undefined) {
                throw new baseapi_1.RequiredError("publicId", "downgradeOrg");
            }
            // Path Params
            const localVarPath = "/api/v1/org/{public_id}/downgrade".replace("{public_id}", encodeURIComponent(String(publicId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.OrganizationsApi.downgradeOrg").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getOrg(publicId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'publicId' is not null or undefined
            if (publicId === null || publicId === undefined) {
                throw new baseapi_1.RequiredError("publicId", "getOrg");
            }
            // Path Params
            const localVarPath = "/api/v1/org/{public_id}".replace("{public_id}", encodeURIComponent(String(publicId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.OrganizationsApi.getOrg").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listOrgs(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/org";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.OrganizationsApi.listOrgs").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateOrg(publicId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'publicId' is not null or undefined
            if (publicId === null || publicId === undefined) {
                throw new baseapi_1.RequiredError("publicId", "updateOrg");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateOrg");
            }
            // Path Params
            const localVarPath = "/api/v1/org/{public_id}".replace("{public_id}", encodeURIComponent(String(publicId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.OrganizationsApi.updateOrg").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "Organization", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    uploadIdPForOrg(publicId, idpFile, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'publicId' is not null or undefined
            if (publicId === null || publicId === undefined) {
                throw new baseapi_1.RequiredError("publicId", "uploadIdPForOrg");
            }
            // verify required parameter 'idpFile' is not null or undefined
            if (idpFile === null || idpFile === undefined) {
                throw new baseapi_1.RequiredError("idpFile", "uploadIdPForOrg");
            }
            // Path Params
            const localVarPath = "/api/v1/org/{public_id}/idp_metadata".replace("{public_id}", encodeURIComponent(String(publicId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.OrganizationsApi.uploadIdPForOrg").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Form Params
            const localVarFormParams = new form_data_1.default();
            if (idpFile !== undefined) {
                // TODO: replace .append with .set
                localVarFormParams.append("idp_file", idpFile.data, idpFile.name);
            }
            requestContext.setBody(localVarFormParams);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.OrganizationsApiRequestFactory = OrganizationsApiRequestFactory;
class OrganizationsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createChildOrg
     * @throws ApiException if the response code was not in [200, 299]
     */
    createChildOrg(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "OrganizationCreateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "OrganizationCreateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to downgradeOrg
     * @throws ApiException if the response code was not in [200, 299]
     */
    downgradeOrg(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "OrgDowngradedResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "OrgDowngradedResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getOrg
     * @throws ApiException if the response code was not in [200, 299]
     */
    getOrg(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "OrganizationResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "OrganizationResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listOrgs
     * @throws ApiException if the response code was not in [200, 299]
     */
    listOrgs(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "OrganizationListResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "OrganizationListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateOrg
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateOrg(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "OrganizationResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "OrganizationResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to uploadIdPForOrg
     * @throws ApiException if the response code was not in [200, 299]
     */
    uploadIdPForOrg(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IdpResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 415 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IdpResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.OrganizationsApiResponseProcessor = OrganizationsApiResponseProcessor;
class OrganizationsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new OrganizationsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new OrganizationsApiResponseProcessor();
    }
    /**
     * Create a child organization.
     *
     * This endpoint requires the
     * [multi-organization account](https://docs.datadoghq.com/account_management/multi_organization/)
     * feature and must be enabled by
     * [contacting support](https://docs.datadoghq.com/help/).
     *
     * Once a new child organization is created, you can interact with it
     * by using the `org.public_id`, `api_key.key`, and
     * `application_key.hash` provided in the response.
     * @param param The request object
     */
    createChildOrg(param, options) {
        const requestContextPromise = this.requestFactory.createChildOrg(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createChildOrg(responseContext);
            });
        });
    }
    /**
     * Only available for MSP customers. Removes a child organization from the hierarchy of the master organization and places the child organization on a 30-day trial.
     * @param param The request object
     */
    downgradeOrg(param, options) {
        const requestContextPromise = this.requestFactory.downgradeOrg(param.publicId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.downgradeOrg(responseContext);
            });
        });
    }
    /**
     * Get organization information.
     * @param param The request object
     */
    getOrg(param, options) {
        const requestContextPromise = this.requestFactory.getOrg(param.publicId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getOrg(responseContext);
            });
        });
    }
    /**
     * This endpoint returns data on your top-level organization.
     * @param param The request object
     */
    listOrgs(options) {
        const requestContextPromise = this.requestFactory.listOrgs(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listOrgs(responseContext);
            });
        });
    }
    /**
     * Update your organization.
     * @param param The request object
     */
    updateOrg(param, options) {
        const requestContextPromise = this.requestFactory.updateOrg(param.publicId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateOrg(responseContext);
            });
        });
    }
    /**
     * There are a couple of options for updating the Identity Provider (IdP)
     * metadata from your SAML IdP.
     *
     * * **Multipart Form-Data**: Post the IdP metadata file using a form post.
     *
     * * **XML Body:** Post the IdP metadata file as the body of the request.
     * @param param The request object
     */
    uploadIdPForOrg(param, options) {
        const requestContextPromise = this.requestFactory.uploadIdPForOrg(param.publicId, param.idpFile, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.uploadIdPForOrg(responseContext);
            });
        });
    }
}
exports.OrganizationsApi = OrganizationsApi;
//# sourceMappingURL=OrganizationsApi.js.map

/***/ }),

/***/ 35724:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PagerDutyIntegrationApi = exports.PagerDutyIntegrationApiResponseProcessor = exports.PagerDutyIntegrationApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class PagerDutyIntegrationApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createPagerDutyIntegrationService(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createPagerDutyIntegrationService");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/pagerduty/configuration/services";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.PagerDutyIntegrationApi.createPagerDutyIntegrationService").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "PagerDutyService", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deletePagerDutyIntegrationService(serviceName, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'serviceName' is not null or undefined
            if (serviceName === null || serviceName === undefined) {
                throw new baseapi_1.RequiredError("serviceName", "deletePagerDutyIntegrationService");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/pagerduty/configuration/services/{service_name}".replace("{service_name}", encodeURIComponent(String(serviceName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.PagerDutyIntegrationApi.deletePagerDutyIntegrationService").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getPagerDutyIntegrationService(serviceName, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'serviceName' is not null or undefined
            if (serviceName === null || serviceName === undefined) {
                throw new baseapi_1.RequiredError("serviceName", "getPagerDutyIntegrationService");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/pagerduty/configuration/services/{service_name}".replace("{service_name}", encodeURIComponent(String(serviceName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.PagerDutyIntegrationApi.getPagerDutyIntegrationService").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updatePagerDutyIntegrationService(serviceName, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'serviceName' is not null or undefined
            if (serviceName === null || serviceName === undefined) {
                throw new baseapi_1.RequiredError("serviceName", "updatePagerDutyIntegrationService");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updatePagerDutyIntegrationService");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/pagerduty/configuration/services/{service_name}".replace("{service_name}", encodeURIComponent(String(serviceName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.PagerDutyIntegrationApi.updatePagerDutyIntegrationService").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "PagerDutyServiceKey", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.PagerDutyIntegrationApiRequestFactory = PagerDutyIntegrationApiRequestFactory;
class PagerDutyIntegrationApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createPagerDutyIntegrationService
     * @throws ApiException if the response code was not in [200, 299]
     */
    createPagerDutyIntegrationService(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "PagerDutyServiceName");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "PagerDutyServiceName", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deletePagerDutyIntegrationService
     * @throws ApiException if the response code was not in [200, 299]
     */
    deletePagerDutyIntegrationService(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getPagerDutyIntegrationService
     * @throws ApiException if the response code was not in [200, 299]
     */
    getPagerDutyIntegrationService(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "PagerDutyServiceName");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "PagerDutyServiceName", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updatePagerDutyIntegrationService
     * @throws ApiException if the response code was not in [200, 299]
     */
    updatePagerDutyIntegrationService(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.PagerDutyIntegrationApiResponseProcessor = PagerDutyIntegrationApiResponseProcessor;
class PagerDutyIntegrationApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory ||
                new PagerDutyIntegrationApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new PagerDutyIntegrationApiResponseProcessor();
    }
    /**
     * Create a new service object in the PagerDuty integration.
     * @param param The request object
     */
    createPagerDutyIntegrationService(param, options) {
        const requestContextPromise = this.requestFactory.createPagerDutyIntegrationService(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createPagerDutyIntegrationService(responseContext);
            });
        });
    }
    /**
     * Delete a single service object in the Datadog-PagerDuty integration.
     * @param param The request object
     */
    deletePagerDutyIntegrationService(param, options) {
        const requestContextPromise = this.requestFactory.deletePagerDutyIntegrationService(param.serviceName, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deletePagerDutyIntegrationService(responseContext);
            });
        });
    }
    /**
     * Get service name in the Datadog-PagerDuty integration.
     * @param param The request object
     */
    getPagerDutyIntegrationService(param, options) {
        const requestContextPromise = this.requestFactory.getPagerDutyIntegrationService(param.serviceName, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getPagerDutyIntegrationService(responseContext);
            });
        });
    }
    /**
     * Update a single service object in the Datadog-PagerDuty integration.
     * @param param The request object
     */
    updatePagerDutyIntegrationService(param, options) {
        const requestContextPromise = this.requestFactory.updatePagerDutyIntegrationService(param.serviceName, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updatePagerDutyIntegrationService(responseContext);
            });
        });
    }
}
exports.PagerDutyIntegrationApi = PagerDutyIntegrationApi;
//# sourceMappingURL=PagerDutyIntegrationApi.js.map

/***/ }),

/***/ 75362:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringApi = exports.SecurityMonitoringApiResponseProcessor = exports.SecurityMonitoringApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class SecurityMonitoringApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    addSecurityMonitoringSignalToIncident(signalId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'signalId' is not null or undefined
            if (signalId === null || signalId === undefined) {
                throw new baseapi_1.RequiredError("signalId", "addSecurityMonitoringSignalToIncident");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "addSecurityMonitoringSignalToIncident");
            }
            // Path Params
            const localVarPath = "/api/v1/security_analytics/signals/{signal_id}/add_to_incident".replace("{signal_id}", encodeURIComponent(String(signalId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SecurityMonitoringApi.addSecurityMonitoringSignalToIncident").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "AddSignalToIncidentRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    editSecurityMonitoringSignalAssignee(signalId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'signalId' is not null or undefined
            if (signalId === null || signalId === undefined) {
                throw new baseapi_1.RequiredError("signalId", "editSecurityMonitoringSignalAssignee");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "editSecurityMonitoringSignalAssignee");
            }
            // Path Params
            const localVarPath = "/api/v1/security_analytics/signals/{signal_id}/assignee".replace("{signal_id}", encodeURIComponent(String(signalId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SecurityMonitoringApi.editSecurityMonitoringSignalAssignee").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SignalAssigneeUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    editSecurityMonitoringSignalState(signalId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'signalId' is not null or undefined
            if (signalId === null || signalId === undefined) {
                throw new baseapi_1.RequiredError("signalId", "editSecurityMonitoringSignalState");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "editSecurityMonitoringSignalState");
            }
            // Path Params
            const localVarPath = "/api/v1/security_analytics/signals/{signal_id}/state".replace("{signal_id}", encodeURIComponent(String(signalId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SecurityMonitoringApi.editSecurityMonitoringSignalState").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SignalStateUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.SecurityMonitoringApiRequestFactory = SecurityMonitoringApiRequestFactory;
class SecurityMonitoringApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to addSecurityMonitoringSignalToIncident
     * @throws ApiException if the response code was not in [200, 299]
     */
    addSecurityMonitoringSignalToIncident(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SuccessfulSignalUpdateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SuccessfulSignalUpdateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to editSecurityMonitoringSignalAssignee
     * @throws ApiException if the response code was not in [200, 299]
     */
    editSecurityMonitoringSignalAssignee(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SuccessfulSignalUpdateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SuccessfulSignalUpdateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to editSecurityMonitoringSignalState
     * @throws ApiException if the response code was not in [200, 299]
     */
    editSecurityMonitoringSignalState(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SuccessfulSignalUpdateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SuccessfulSignalUpdateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.SecurityMonitoringApiResponseProcessor = SecurityMonitoringApiResponseProcessor;
class SecurityMonitoringApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new SecurityMonitoringApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new SecurityMonitoringApiResponseProcessor();
    }
    /**
     * Add a security signal to an incident. This makes it possible to search for signals by incident within the signal explorer and to view the signals on the incident timeline.
     * @param param The request object
     */
    addSecurityMonitoringSignalToIncident(param, options) {
        const requestContextPromise = this.requestFactory.addSecurityMonitoringSignalToIncident(param.signalId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.addSecurityMonitoringSignalToIncident(responseContext);
            });
        });
    }
    /**
     * Modify the triage assignee of a security signal.
     * @param param The request object
     */
    editSecurityMonitoringSignalAssignee(param, options) {
        const requestContextPromise = this.requestFactory.editSecurityMonitoringSignalAssignee(param.signalId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.editSecurityMonitoringSignalAssignee(responseContext);
            });
        });
    }
    /**
     * Change the triage state of a security signal.
     * @param param The request object
     */
    editSecurityMonitoringSignalState(param, options) {
        const requestContextPromise = this.requestFactory.editSecurityMonitoringSignalState(param.signalId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.editSecurityMonitoringSignalState(responseContext);
            });
        });
    }
}
exports.SecurityMonitoringApi = SecurityMonitoringApi;
//# sourceMappingURL=SecurityMonitoringApi.js.map

/***/ }),

/***/ 72017:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceChecksApi = exports.ServiceChecksApiResponseProcessor = exports.ServiceChecksApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class ServiceChecksApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    submitServiceCheck(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "submitServiceCheck");
            }
            // Path Params
            const localVarPath = "/api/v1/check_run";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.ServiceChecksApi.submitServiceCheck").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "text/json, application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "Array<ServiceCheck>", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, ["apiKeyAuth"]);
            return requestContext;
        });
    }
}
exports.ServiceChecksApiRequestFactory = ServiceChecksApiRequestFactory;
class ServiceChecksApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to submitServiceCheck
     * @throws ApiException if the response code was not in [200, 299]
     */
    submitServiceCheck(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 202) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IntakePayloadAccepted");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 408 ||
                response.httpStatusCode == 413 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IntakePayloadAccepted", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.ServiceChecksApiResponseProcessor = ServiceChecksApiResponseProcessor;
class ServiceChecksApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new ServiceChecksApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new ServiceChecksApiResponseProcessor();
    }
    /**
     * Submit a list of Service Checks.
     *
     * **Notes**:
     * - A valid API key is required.
     * - Service checks can be submitted up to 10 minutes in the past.
     * @param param The request object
     */
    submitServiceCheck(param, options) {
        const requestContextPromise = this.requestFactory.submitServiceCheck(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.submitServiceCheck(responseContext);
            });
        });
    }
}
exports.ServiceChecksApi = ServiceChecksApi;
//# sourceMappingURL=ServiceChecksApi.js.map

/***/ }),

/***/ 80224:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceLevelObjectiveCorrectionsApi = exports.ServiceLevelObjectiveCorrectionsApiResponseProcessor = exports.ServiceLevelObjectiveCorrectionsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class ServiceLevelObjectiveCorrectionsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createSLOCorrection(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createSLOCorrection");
            }
            // Path Params
            const localVarPath = "/api/v1/slo/correction";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.ServiceLevelObjectiveCorrectionsApi.createSLOCorrection").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SLOCorrectionCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteSLOCorrection(sloCorrectionId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'sloCorrectionId' is not null or undefined
            if (sloCorrectionId === null || sloCorrectionId === undefined) {
                throw new baseapi_1.RequiredError("sloCorrectionId", "deleteSLOCorrection");
            }
            // Path Params
            const localVarPath = "/api/v1/slo/correction/{slo_correction_id}".replace("{slo_correction_id}", encodeURIComponent(String(sloCorrectionId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.ServiceLevelObjectiveCorrectionsApi.deleteSLOCorrection").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getSLOCorrection(sloCorrectionId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'sloCorrectionId' is not null or undefined
            if (sloCorrectionId === null || sloCorrectionId === undefined) {
                throw new baseapi_1.RequiredError("sloCorrectionId", "getSLOCorrection");
            }
            // Path Params
            const localVarPath = "/api/v1/slo/correction/{slo_correction_id}".replace("{slo_correction_id}", encodeURIComponent(String(sloCorrectionId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.ServiceLevelObjectiveCorrectionsApi.getSLOCorrection").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listSLOCorrection(offset, limit, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/slo/correction";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.ServiceLevelObjectiveCorrectionsApi.listSLOCorrection").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (offset !== undefined) {
                requestContext.setQueryParam("offset", ObjectSerializer_1.ObjectSerializer.serialize(offset, "number", "int64"));
            }
            if (limit !== undefined) {
                requestContext.setQueryParam("limit", ObjectSerializer_1.ObjectSerializer.serialize(limit, "number", "int64"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateSLOCorrection(sloCorrectionId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'sloCorrectionId' is not null or undefined
            if (sloCorrectionId === null || sloCorrectionId === undefined) {
                throw new baseapi_1.RequiredError("sloCorrectionId", "updateSLOCorrection");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateSLOCorrection");
            }
            // Path Params
            const localVarPath = "/api/v1/slo/correction/{slo_correction_id}".replace("{slo_correction_id}", encodeURIComponent(String(sloCorrectionId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.ServiceLevelObjectiveCorrectionsApi.updateSLOCorrection").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SLOCorrectionUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.ServiceLevelObjectiveCorrectionsApiRequestFactory = ServiceLevelObjectiveCorrectionsApiRequestFactory;
class ServiceLevelObjectiveCorrectionsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createSLOCorrection
     * @throws ApiException if the response code was not in [200, 299]
     */
    createSLOCorrection(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOCorrectionResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOCorrectionResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteSLOCorrection
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteSLOCorrection(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getSLOCorrection
     * @throws ApiException if the response code was not in [200, 299]
     */
    getSLOCorrection(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOCorrectionResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOCorrectionResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listSLOCorrection
     * @throws ApiException if the response code was not in [200, 299]
     */
    listSLOCorrection(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOCorrectionListResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOCorrectionListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateSLOCorrection
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateSLOCorrection(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOCorrectionResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOCorrectionResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.ServiceLevelObjectiveCorrectionsApiResponseProcessor = ServiceLevelObjectiveCorrectionsApiResponseProcessor;
class ServiceLevelObjectiveCorrectionsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory ||
                new ServiceLevelObjectiveCorrectionsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor ||
                new ServiceLevelObjectiveCorrectionsApiResponseProcessor();
    }
    /**
     * Create an SLO Correction.
     * @param param The request object
     */
    createSLOCorrection(param, options) {
        const requestContextPromise = this.requestFactory.createSLOCorrection(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createSLOCorrection(responseContext);
            });
        });
    }
    /**
     * Permanently delete the specified SLO correction object.
     * @param param The request object
     */
    deleteSLOCorrection(param, options) {
        const requestContextPromise = this.requestFactory.deleteSLOCorrection(param.sloCorrectionId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteSLOCorrection(responseContext);
            });
        });
    }
    /**
     * Get an SLO correction.
     * @param param The request object
     */
    getSLOCorrection(param, options) {
        const requestContextPromise = this.requestFactory.getSLOCorrection(param.sloCorrectionId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getSLOCorrection(responseContext);
            });
        });
    }
    /**
     * Get all Service Level Objective corrections.
     * @param param The request object
     */
    listSLOCorrection(param = {}, options) {
        const requestContextPromise = this.requestFactory.listSLOCorrection(param.offset, param.limit, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listSLOCorrection(responseContext);
            });
        });
    }
    /**
     * Update the specified SLO correction object.
     * @param param The request object
     */
    updateSLOCorrection(param, options) {
        const requestContextPromise = this.requestFactory.updateSLOCorrection(param.sloCorrectionId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateSLOCorrection(responseContext);
            });
        });
    }
}
exports.ServiceLevelObjectiveCorrectionsApi = ServiceLevelObjectiveCorrectionsApi;
//# sourceMappingURL=ServiceLevelObjectiveCorrectionsApi.js.map

/***/ }),

/***/ 19863:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceLevelObjectivesApi = exports.ServiceLevelObjectivesApiResponseProcessor = exports.ServiceLevelObjectivesApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class ServiceLevelObjectivesApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    checkCanDeleteSLO(ids, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new baseapi_1.RequiredError("ids", "checkCanDeleteSLO");
            }
            // Path Params
            const localVarPath = "/api/v1/slo/can_delete";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.ServiceLevelObjectivesApi.checkCanDeleteSLO").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (ids !== undefined) {
                requestContext.setQueryParam("ids", ObjectSerializer_1.ObjectSerializer.serialize(ids, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createSLO(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createSLO");
            }
            // Path Params
            const localVarPath = "/api/v1/slo";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.ServiceLevelObjectivesApi.createSLO").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "ServiceLevelObjectiveRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteSLO(sloId, force, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'sloId' is not null or undefined
            if (sloId === null || sloId === undefined) {
                throw new baseapi_1.RequiredError("sloId", "deleteSLO");
            }
            // Path Params
            const localVarPath = "/api/v1/slo/{slo_id}".replace("{slo_id}", encodeURIComponent(String(sloId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.ServiceLevelObjectivesApi.deleteSLO").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (force !== undefined) {
                requestContext.setQueryParam("force", ObjectSerializer_1.ObjectSerializer.serialize(force, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteSLOTimeframeInBulk(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "deleteSLOTimeframeInBulk");
            }
            // Path Params
            const localVarPath = "/api/v1/slo/bulk_delete";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.ServiceLevelObjectivesApi.deleteSLOTimeframeInBulk").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "{ [key: string]: Array<SLOTimeframe>; }", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getSLO(sloId, withConfiguredAlertIds, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'sloId' is not null or undefined
            if (sloId === null || sloId === undefined) {
                throw new baseapi_1.RequiredError("sloId", "getSLO");
            }
            // Path Params
            const localVarPath = "/api/v1/slo/{slo_id}".replace("{slo_id}", encodeURIComponent(String(sloId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.ServiceLevelObjectivesApi.getSLO").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (withConfiguredAlertIds !== undefined) {
                requestContext.setQueryParam("with_configured_alert_ids", ObjectSerializer_1.ObjectSerializer.serialize(withConfiguredAlertIds, "boolean", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getSLOCorrections(sloId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'sloId' is not null or undefined
            if (sloId === null || sloId === undefined) {
                throw new baseapi_1.RequiredError("sloId", "getSLOCorrections");
            }
            // Path Params
            const localVarPath = "/api/v1/slo/{slo_id}/corrections".replace("{slo_id}", encodeURIComponent(String(sloId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.ServiceLevelObjectivesApi.getSLOCorrections").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getSLOHistory(sloId, fromTs, toTs, target, applyCorrection, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'sloId' is not null or undefined
            if (sloId === null || sloId === undefined) {
                throw new baseapi_1.RequiredError("sloId", "getSLOHistory");
            }
            // verify required parameter 'fromTs' is not null or undefined
            if (fromTs === null || fromTs === undefined) {
                throw new baseapi_1.RequiredError("fromTs", "getSLOHistory");
            }
            // verify required parameter 'toTs' is not null or undefined
            if (toTs === null || toTs === undefined) {
                throw new baseapi_1.RequiredError("toTs", "getSLOHistory");
            }
            // Path Params
            const localVarPath = "/api/v1/slo/{slo_id}/history".replace("{slo_id}", encodeURIComponent(String(sloId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.ServiceLevelObjectivesApi.getSLOHistory").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (fromTs !== undefined) {
                requestContext.setQueryParam("from_ts", ObjectSerializer_1.ObjectSerializer.serialize(fromTs, "number", "int64"));
            }
            if (toTs !== undefined) {
                requestContext.setQueryParam("to_ts", ObjectSerializer_1.ObjectSerializer.serialize(toTs, "number", "int64"));
            }
            if (target !== undefined) {
                requestContext.setQueryParam("target", ObjectSerializer_1.ObjectSerializer.serialize(target, "number", "double"));
            }
            if (applyCorrection !== undefined) {
                requestContext.setQueryParam("apply_correction", ObjectSerializer_1.ObjectSerializer.serialize(applyCorrection, "boolean", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listSLOs(ids, query, tagsQuery, metricsQuery, limit, offset, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/slo";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.ServiceLevelObjectivesApi.listSLOs").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (ids !== undefined) {
                requestContext.setQueryParam("ids", ObjectSerializer_1.ObjectSerializer.serialize(ids, "string", ""));
            }
            if (query !== undefined) {
                requestContext.setQueryParam("query", ObjectSerializer_1.ObjectSerializer.serialize(query, "string", ""));
            }
            if (tagsQuery !== undefined) {
                requestContext.setQueryParam("tags_query", ObjectSerializer_1.ObjectSerializer.serialize(tagsQuery, "string", ""));
            }
            if (metricsQuery !== undefined) {
                requestContext.setQueryParam("metrics_query", ObjectSerializer_1.ObjectSerializer.serialize(metricsQuery, "string", ""));
            }
            if (limit !== undefined) {
                requestContext.setQueryParam("limit", ObjectSerializer_1.ObjectSerializer.serialize(limit, "number", "int64"));
            }
            if (offset !== undefined) {
                requestContext.setQueryParam("offset", ObjectSerializer_1.ObjectSerializer.serialize(offset, "number", "int64"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    searchSLO(query, pageSize, pageNumber, includeFacets, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'searchSLO'");
            if (!_config.unstableOperations["v1.searchSLO"]) {
                throw new Error("Unstable operation 'searchSLO' is disabled");
            }
            // Path Params
            const localVarPath = "/api/v1/slo/search";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.ServiceLevelObjectivesApi.searchSLO").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (query !== undefined) {
                requestContext.setQueryParam("query", ObjectSerializer_1.ObjectSerializer.serialize(query, "string", ""));
            }
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page[size]", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "number", "int64"));
            }
            if (pageNumber !== undefined) {
                requestContext.setQueryParam("page[number]", ObjectSerializer_1.ObjectSerializer.serialize(pageNumber, "number", "int64"));
            }
            if (includeFacets !== undefined) {
                requestContext.setQueryParam("include_facets", ObjectSerializer_1.ObjectSerializer.serialize(includeFacets, "boolean", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateSLO(sloId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'sloId' is not null or undefined
            if (sloId === null || sloId === undefined) {
                throw new baseapi_1.RequiredError("sloId", "updateSLO");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateSLO");
            }
            // Path Params
            const localVarPath = "/api/v1/slo/{slo_id}".replace("{slo_id}", encodeURIComponent(String(sloId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.ServiceLevelObjectivesApi.updateSLO").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "ServiceLevelObjective", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.ServiceLevelObjectivesApiRequestFactory = ServiceLevelObjectivesApiRequestFactory;
class ServiceLevelObjectivesApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to checkCanDeleteSLO
     * @throws ApiException if the response code was not in [200, 299]
     */
    checkCanDeleteSLO(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200 || response.httpStatusCode == 409) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CheckCanDeleteSLOResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CheckCanDeleteSLOResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createSLO
     * @throws ApiException if the response code was not in [200, 299]
     */
    createSLO(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOListResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteSLO
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteSLO(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200 || response.httpStatusCode == 409) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLODeleteResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLODeleteResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteSLOTimeframeInBulk
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteSLOTimeframeInBulk(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOBulkDeleteResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOBulkDeleteResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getSLO
     * @throws ApiException if the response code was not in [200, 299]
     */
    getSLO(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getSLOCorrections
     * @throws ApiException if the response code was not in [200, 299]
     */
    getSLOCorrections(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOCorrectionListResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOCorrectionListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getSLOHistory
     * @throws ApiException if the response code was not in [200, 299]
     */
    getSLOHistory(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOHistoryResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOHistoryResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listSLOs
     * @throws ApiException if the response code was not in [200, 299]
     */
    listSLOs(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOListResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to searchSLO
     * @throws ApiException if the response code was not in [200, 299]
     */
    searchSLO(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SearchSLOResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SearchSLOResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateSLO
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateSLO(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOListResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SLOListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.ServiceLevelObjectivesApiResponseProcessor = ServiceLevelObjectivesApiResponseProcessor;
class ServiceLevelObjectivesApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory ||
                new ServiceLevelObjectivesApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new ServiceLevelObjectivesApiResponseProcessor();
    }
    /**
     * Check if an SLO can be safely deleted. For example,
     * assure an SLO can be deleted without disrupting a dashboard.
     * @param param The request object
     */
    checkCanDeleteSLO(param, options) {
        const requestContextPromise = this.requestFactory.checkCanDeleteSLO(param.ids, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.checkCanDeleteSLO(responseContext);
            });
        });
    }
    /**
     * Create a service level objective object.
     * @param param The request object
     */
    createSLO(param, options) {
        const requestContextPromise = this.requestFactory.createSLO(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createSLO(responseContext);
            });
        });
    }
    /**
     * Permanently delete the specified service level objective object.
     *
     * If an SLO is used in a dashboard, the `DELETE /v1/slo/` endpoint returns
     * a 409 conflict error because the SLO is referenced in a dashboard.
     * @param param The request object
     */
    deleteSLO(param, options) {
        const requestContextPromise = this.requestFactory.deleteSLO(param.sloId, param.force, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteSLO(responseContext);
            });
        });
    }
    /**
     * Delete (or partially delete) multiple service level objective objects.
     *
     * This endpoint facilitates deletion of one or more thresholds for one or more
     * service level objective objects. If all thresholds are deleted, the service level
     * objective object is deleted as well.
     * @param param The request object
     */
    deleteSLOTimeframeInBulk(param, options) {
        const requestContextPromise = this.requestFactory.deleteSLOTimeframeInBulk(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteSLOTimeframeInBulk(responseContext);
            });
        });
    }
    /**
     * Get a service level objective object.
     * @param param The request object
     */
    getSLO(param, options) {
        const requestContextPromise = this.requestFactory.getSLO(param.sloId, param.withConfiguredAlertIds, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getSLO(responseContext);
            });
        });
    }
    /**
     * Get corrections applied to an SLO
     * @param param The request object
     */
    getSLOCorrections(param, options) {
        const requestContextPromise = this.requestFactory.getSLOCorrections(param.sloId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getSLOCorrections(responseContext);
            });
        });
    }
    /**
     * Get a specific SLOs history, regardless of its SLO type.
     *
     * The detailed history data is structured according to the source data type.
     * For example, metric data is included for event SLOs that use
     * the metric source, and monitor SLO types include the monitor transition history.
     *
     * **Note:** There are different response formats for event based and time based SLOs.
     * Examples of both are shown.
     * @param param The request object
     */
    getSLOHistory(param, options) {
        const requestContextPromise = this.requestFactory.getSLOHistory(param.sloId, param.fromTs, param.toTs, param.target, param.applyCorrection, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getSLOHistory(responseContext);
            });
        });
    }
    /**
     * Get a list of service level objective objects for your organization.
     * @param param The request object
     */
    listSLOs(param = {}, options) {
        const requestContextPromise = this.requestFactory.listSLOs(param.ids, param.query, param.tagsQuery, param.metricsQuery, param.limit, param.offset, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listSLOs(responseContext);
            });
        });
    }
    /**
     * Get a list of service level objective objects for your organization.
     * @param param The request object
     */
    searchSLO(param = {}, options) {
        const requestContextPromise = this.requestFactory.searchSLO(param.query, param.pageSize, param.pageNumber, param.includeFacets, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.searchSLO(responseContext);
            });
        });
    }
    /**
     * Update the specified service level objective object.
     * @param param The request object
     */
    updateSLO(param, options) {
        const requestContextPromise = this.requestFactory.updateSLO(param.sloId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateSLO(responseContext);
            });
        });
    }
}
exports.ServiceLevelObjectivesApi = ServiceLevelObjectivesApi;
//# sourceMappingURL=ServiceLevelObjectivesApi.js.map

/***/ }),

/***/ 52597:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SlackIntegrationApi = exports.SlackIntegrationApiResponseProcessor = exports.SlackIntegrationApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class SlackIntegrationApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createSlackIntegrationChannel(accountName, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountName' is not null or undefined
            if (accountName === null || accountName === undefined) {
                throw new baseapi_1.RequiredError("accountName", "createSlackIntegrationChannel");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createSlackIntegrationChannel");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/slack/configuration/accounts/{account_name}/channels".replace("{account_name}", encodeURIComponent(String(accountName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SlackIntegrationApi.createSlackIntegrationChannel").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SlackIntegrationChannel", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getSlackIntegrationChannel(accountName, channelName, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountName' is not null or undefined
            if (accountName === null || accountName === undefined) {
                throw new baseapi_1.RequiredError("accountName", "getSlackIntegrationChannel");
            }
            // verify required parameter 'channelName' is not null or undefined
            if (channelName === null || channelName === undefined) {
                throw new baseapi_1.RequiredError("channelName", "getSlackIntegrationChannel");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/slack/configuration/accounts/{account_name}/channels/{channel_name}"
                .replace("{account_name}", encodeURIComponent(String(accountName)))
                .replace("{channel_name}", encodeURIComponent(String(channelName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SlackIntegrationApi.getSlackIntegrationChannel").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getSlackIntegrationChannels(accountName, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountName' is not null or undefined
            if (accountName === null || accountName === undefined) {
                throw new baseapi_1.RequiredError("accountName", "getSlackIntegrationChannels");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/slack/configuration/accounts/{account_name}/channels".replace("{account_name}", encodeURIComponent(String(accountName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SlackIntegrationApi.getSlackIntegrationChannels").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    removeSlackIntegrationChannel(accountName, channelName, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountName' is not null or undefined
            if (accountName === null || accountName === undefined) {
                throw new baseapi_1.RequiredError("accountName", "removeSlackIntegrationChannel");
            }
            // verify required parameter 'channelName' is not null or undefined
            if (channelName === null || channelName === undefined) {
                throw new baseapi_1.RequiredError("channelName", "removeSlackIntegrationChannel");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/slack/configuration/accounts/{account_name}/channels/{channel_name}"
                .replace("{account_name}", encodeURIComponent(String(accountName)))
                .replace("{channel_name}", encodeURIComponent(String(channelName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SlackIntegrationApi.removeSlackIntegrationChannel").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateSlackIntegrationChannel(accountName, channelName, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountName' is not null or undefined
            if (accountName === null || accountName === undefined) {
                throw new baseapi_1.RequiredError("accountName", "updateSlackIntegrationChannel");
            }
            // verify required parameter 'channelName' is not null or undefined
            if (channelName === null || channelName === undefined) {
                throw new baseapi_1.RequiredError("channelName", "updateSlackIntegrationChannel");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateSlackIntegrationChannel");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/slack/configuration/accounts/{account_name}/channels/{channel_name}"
                .replace("{account_name}", encodeURIComponent(String(accountName)))
                .replace("{channel_name}", encodeURIComponent(String(channelName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SlackIntegrationApi.updateSlackIntegrationChannel").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SlackIntegrationChannel", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.SlackIntegrationApiRequestFactory = SlackIntegrationApiRequestFactory;
class SlackIntegrationApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createSlackIntegrationChannel
     * @throws ApiException if the response code was not in [200, 299]
     */
    createSlackIntegrationChannel(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SlackIntegrationChannel");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SlackIntegrationChannel", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getSlackIntegrationChannel
     * @throws ApiException if the response code was not in [200, 299]
     */
    getSlackIntegrationChannel(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SlackIntegrationChannel");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SlackIntegrationChannel", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getSlackIntegrationChannels
     * @throws ApiException if the response code was not in [200, 299]
     */
    getSlackIntegrationChannels(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Array<SlackIntegrationChannel>");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "Array<SlackIntegrationChannel>", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to removeSlackIntegrationChannel
     * @throws ApiException if the response code was not in [200, 299]
     */
    removeSlackIntegrationChannel(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateSlackIntegrationChannel
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateSlackIntegrationChannel(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SlackIntegrationChannel");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SlackIntegrationChannel", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.SlackIntegrationApiResponseProcessor = SlackIntegrationApiResponseProcessor;
class SlackIntegrationApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new SlackIntegrationApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new SlackIntegrationApiResponseProcessor();
    }
    /**
     * Add a channel to your Datadog-Slack integration.
     * @param param The request object
     */
    createSlackIntegrationChannel(param, options) {
        const requestContextPromise = this.requestFactory.createSlackIntegrationChannel(param.accountName, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createSlackIntegrationChannel(responseContext);
            });
        });
    }
    /**
     * Get a channel configured for your Datadog-Slack integration.
     * @param param The request object
     */
    getSlackIntegrationChannel(param, options) {
        const requestContextPromise = this.requestFactory.getSlackIntegrationChannel(param.accountName, param.channelName, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getSlackIntegrationChannel(responseContext);
            });
        });
    }
    /**
     * Get a list of all channels configured for your Datadog-Slack integration.
     * @param param The request object
     */
    getSlackIntegrationChannels(param, options) {
        const requestContextPromise = this.requestFactory.getSlackIntegrationChannels(param.accountName, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getSlackIntegrationChannels(responseContext);
            });
        });
    }
    /**
     * Remove a channel from your Datadog-Slack integration.
     * @param param The request object
     */
    removeSlackIntegrationChannel(param, options) {
        const requestContextPromise = this.requestFactory.removeSlackIntegrationChannel(param.accountName, param.channelName, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.removeSlackIntegrationChannel(responseContext);
            });
        });
    }
    /**
     * Update a channel used in your Datadog-Slack integration.
     * @param param The request object
     */
    updateSlackIntegrationChannel(param, options) {
        const requestContextPromise = this.requestFactory.updateSlackIntegrationChannel(param.accountName, param.channelName, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateSlackIntegrationChannel(responseContext);
            });
        });
    }
}
exports.SlackIntegrationApi = SlackIntegrationApi;
//# sourceMappingURL=SlackIntegrationApi.js.map

/***/ }),

/***/ 38840:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SnapshotsApi = exports.SnapshotsApiResponseProcessor = exports.SnapshotsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class SnapshotsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    getGraphSnapshot(start, end, metricQuery, eventQuery, graphDef, title, height, width, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'start' is not null or undefined
            if (start === null || start === undefined) {
                throw new baseapi_1.RequiredError("start", "getGraphSnapshot");
            }
            // verify required parameter 'end' is not null or undefined
            if (end === null || end === undefined) {
                throw new baseapi_1.RequiredError("end", "getGraphSnapshot");
            }
            // Path Params
            const localVarPath = "/api/v1/graph/snapshot";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SnapshotsApi.getGraphSnapshot").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (metricQuery !== undefined) {
                requestContext.setQueryParam("metric_query", ObjectSerializer_1.ObjectSerializer.serialize(metricQuery, "string", ""));
            }
            if (start !== undefined) {
                requestContext.setQueryParam("start", ObjectSerializer_1.ObjectSerializer.serialize(start, "number", "int64"));
            }
            if (end !== undefined) {
                requestContext.setQueryParam("end", ObjectSerializer_1.ObjectSerializer.serialize(end, "number", "int64"));
            }
            if (eventQuery !== undefined) {
                requestContext.setQueryParam("event_query", ObjectSerializer_1.ObjectSerializer.serialize(eventQuery, "string", ""));
            }
            if (graphDef !== undefined) {
                requestContext.setQueryParam("graph_def", ObjectSerializer_1.ObjectSerializer.serialize(graphDef, "string", ""));
            }
            if (title !== undefined) {
                requestContext.setQueryParam("title", ObjectSerializer_1.ObjectSerializer.serialize(title, "string", ""));
            }
            if (height !== undefined) {
                requestContext.setQueryParam("height", ObjectSerializer_1.ObjectSerializer.serialize(height, "number", "int64"));
            }
            if (width !== undefined) {
                requestContext.setQueryParam("width", ObjectSerializer_1.ObjectSerializer.serialize(width, "number", "int64"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.SnapshotsApiRequestFactory = SnapshotsApiRequestFactory;
class SnapshotsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getGraphSnapshot
     * @throws ApiException if the response code was not in [200, 299]
     */
    getGraphSnapshot(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "GraphSnapshot");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "GraphSnapshot", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.SnapshotsApiResponseProcessor = SnapshotsApiResponseProcessor;
class SnapshotsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new SnapshotsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new SnapshotsApiResponseProcessor();
    }
    /**
     * Take graph snapshots.
     * **Note**: When a snapshot is created, there is some delay before it is available.
     * @param param The request object
     */
    getGraphSnapshot(param, options) {
        const requestContextPromise = this.requestFactory.getGraphSnapshot(param.start, param.end, param.metricQuery, param.eventQuery, param.graphDef, param.title, param.height, param.width, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getGraphSnapshot(responseContext);
            });
        });
    }
}
exports.SnapshotsApi = SnapshotsApi;
//# sourceMappingURL=SnapshotsApi.js.map

/***/ }),

/***/ 99457:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsApi = exports.SyntheticsApiResponseProcessor = exports.SyntheticsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class SyntheticsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createGlobalVariable(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createGlobalVariable");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/variables";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.createGlobalVariable").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SyntheticsGlobalVariable", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createPrivateLocation(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createPrivateLocation");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/private-locations";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.createPrivateLocation").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SyntheticsPrivateLocation", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createSyntheticsAPITest(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createSyntheticsAPITest");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/tests/api";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.createSyntheticsAPITest").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SyntheticsAPITest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createSyntheticsBrowserTest(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createSyntheticsBrowserTest");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/tests/browser";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.createSyntheticsBrowserTest").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SyntheticsBrowserTest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteGlobalVariable(variableId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'variableId' is not null or undefined
            if (variableId === null || variableId === undefined) {
                throw new baseapi_1.RequiredError("variableId", "deleteGlobalVariable");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/variables/{variable_id}".replace("{variable_id}", encodeURIComponent(String(variableId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.deleteGlobalVariable").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deletePrivateLocation(locationId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new baseapi_1.RequiredError("locationId", "deletePrivateLocation");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/private-locations/{location_id}".replace("{location_id}", encodeURIComponent(String(locationId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.deletePrivateLocation").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteTests(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "deleteTests");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/tests/delete";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.deleteTests").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SyntheticsDeleteTestsPayload", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    editGlobalVariable(variableId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'variableId' is not null or undefined
            if (variableId === null || variableId === undefined) {
                throw new baseapi_1.RequiredError("variableId", "editGlobalVariable");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "editGlobalVariable");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/variables/{variable_id}".replace("{variable_id}", encodeURIComponent(String(variableId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.editGlobalVariable").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SyntheticsGlobalVariable", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getAPITest(publicId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'publicId' is not null or undefined
            if (publicId === null || publicId === undefined) {
                throw new baseapi_1.RequiredError("publicId", "getAPITest");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/tests/api/{public_id}".replace("{public_id}", encodeURIComponent(String(publicId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.getAPITest").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getAPITestLatestResults(publicId, fromTs, toTs, probeDc, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'publicId' is not null or undefined
            if (publicId === null || publicId === undefined) {
                throw new baseapi_1.RequiredError("publicId", "getAPITestLatestResults");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/tests/{public_id}/results".replace("{public_id}", encodeURIComponent(String(publicId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.getAPITestLatestResults").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (fromTs !== undefined) {
                requestContext.setQueryParam("from_ts", ObjectSerializer_1.ObjectSerializer.serialize(fromTs, "number", "int64"));
            }
            if (toTs !== undefined) {
                requestContext.setQueryParam("to_ts", ObjectSerializer_1.ObjectSerializer.serialize(toTs, "number", "int64"));
            }
            if (probeDc !== undefined) {
                requestContext.setQueryParam("probe_dc", ObjectSerializer_1.ObjectSerializer.serialize(probeDc, "Array<string>", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getAPITestResult(publicId, resultId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'publicId' is not null or undefined
            if (publicId === null || publicId === undefined) {
                throw new baseapi_1.RequiredError("publicId", "getAPITestResult");
            }
            // verify required parameter 'resultId' is not null or undefined
            if (resultId === null || resultId === undefined) {
                throw new baseapi_1.RequiredError("resultId", "getAPITestResult");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/tests/{public_id}/results/{result_id}"
                .replace("{public_id}", encodeURIComponent(String(publicId)))
                .replace("{result_id}", encodeURIComponent(String(resultId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.getAPITestResult").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getBrowserTest(publicId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'publicId' is not null or undefined
            if (publicId === null || publicId === undefined) {
                throw new baseapi_1.RequiredError("publicId", "getBrowserTest");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/tests/browser/{public_id}".replace("{public_id}", encodeURIComponent(String(publicId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.getBrowserTest").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getBrowserTestLatestResults(publicId, fromTs, toTs, probeDc, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'publicId' is not null or undefined
            if (publicId === null || publicId === undefined) {
                throw new baseapi_1.RequiredError("publicId", "getBrowserTestLatestResults");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/tests/browser/{public_id}/results".replace("{public_id}", encodeURIComponent(String(publicId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.getBrowserTestLatestResults").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (fromTs !== undefined) {
                requestContext.setQueryParam("from_ts", ObjectSerializer_1.ObjectSerializer.serialize(fromTs, "number", "int64"));
            }
            if (toTs !== undefined) {
                requestContext.setQueryParam("to_ts", ObjectSerializer_1.ObjectSerializer.serialize(toTs, "number", "int64"));
            }
            if (probeDc !== undefined) {
                requestContext.setQueryParam("probe_dc", ObjectSerializer_1.ObjectSerializer.serialize(probeDc, "Array<string>", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getBrowserTestResult(publicId, resultId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'publicId' is not null or undefined
            if (publicId === null || publicId === undefined) {
                throw new baseapi_1.RequiredError("publicId", "getBrowserTestResult");
            }
            // verify required parameter 'resultId' is not null or undefined
            if (resultId === null || resultId === undefined) {
                throw new baseapi_1.RequiredError("resultId", "getBrowserTestResult");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/tests/browser/{public_id}/results/{result_id}"
                .replace("{public_id}", encodeURIComponent(String(publicId)))
                .replace("{result_id}", encodeURIComponent(String(resultId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.getBrowserTestResult").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getGlobalVariable(variableId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'variableId' is not null or undefined
            if (variableId === null || variableId === undefined) {
                throw new baseapi_1.RequiredError("variableId", "getGlobalVariable");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/variables/{variable_id}".replace("{variable_id}", encodeURIComponent(String(variableId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.getGlobalVariable").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getPrivateLocation(locationId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new baseapi_1.RequiredError("locationId", "getPrivateLocation");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/private-locations/{location_id}".replace("{location_id}", encodeURIComponent(String(locationId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.getPrivateLocation").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getSyntheticsCIBatch(batchId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'batchId' is not null or undefined
            if (batchId === null || batchId === undefined) {
                throw new baseapi_1.RequiredError("batchId", "getSyntheticsCIBatch");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/ci/batch/{batch_id}".replace("{batch_id}", encodeURIComponent(String(batchId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.getSyntheticsCIBatch").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getTest(publicId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'publicId' is not null or undefined
            if (publicId === null || publicId === undefined) {
                throw new baseapi_1.RequiredError("publicId", "getTest");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/tests/{public_id}".replace("{public_id}", encodeURIComponent(String(publicId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.getTest").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listGlobalVariables(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/synthetics/variables";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.listGlobalVariables").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listLocations(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/synthetics/locations";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.listLocations").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listTests(pageSize, pageNumber, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/synthetics/tests";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.listTests").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page_size", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "string", ""));
            }
            if (pageNumber !== undefined) {
                requestContext.setQueryParam("page_number", ObjectSerializer_1.ObjectSerializer.serialize(pageNumber, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    triggerCITests(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "triggerCITests");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/tests/trigger/ci";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.triggerCITests").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SyntheticsCITestBody", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    triggerTests(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "triggerTests");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/tests/trigger";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.triggerTests").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SyntheticsTriggerBody", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateAPITest(publicId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'publicId' is not null or undefined
            if (publicId === null || publicId === undefined) {
                throw new baseapi_1.RequiredError("publicId", "updateAPITest");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateAPITest");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/tests/api/{public_id}".replace("{public_id}", encodeURIComponent(String(publicId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.updateAPITest").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SyntheticsAPITest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateBrowserTest(publicId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'publicId' is not null or undefined
            if (publicId === null || publicId === undefined) {
                throw new baseapi_1.RequiredError("publicId", "updateBrowserTest");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateBrowserTest");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/tests/browser/{public_id}".replace("{public_id}", encodeURIComponent(String(publicId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.updateBrowserTest").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SyntheticsBrowserTest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updatePrivateLocation(locationId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new baseapi_1.RequiredError("locationId", "updatePrivateLocation");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updatePrivateLocation");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/private-locations/{location_id}".replace("{location_id}", encodeURIComponent(String(locationId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.updatePrivateLocation").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SyntheticsPrivateLocation", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateTestPauseStatus(publicId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'publicId' is not null or undefined
            if (publicId === null || publicId === undefined) {
                throw new baseapi_1.RequiredError("publicId", "updateTestPauseStatus");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateTestPauseStatus");
            }
            // Path Params
            const localVarPath = "/api/v1/synthetics/tests/{public_id}/status".replace("{public_id}", encodeURIComponent(String(publicId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.SyntheticsApi.updateTestPauseStatus").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SyntheticsUpdateTestPauseStatusPayload", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.SyntheticsApiRequestFactory = SyntheticsApiRequestFactory;
class SyntheticsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createGlobalVariable
     * @throws ApiException if the response code was not in [200, 299]
     */
    createGlobalVariable(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsGlobalVariable");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsGlobalVariable", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createPrivateLocation
     * @throws ApiException if the response code was not in [200, 299]
     */
    createPrivateLocation(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsPrivateLocationCreationResponse");
                return body;
            }
            if (response.httpStatusCode == 402 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsPrivateLocationCreationResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createSyntheticsAPITest
     * @throws ApiException if the response code was not in [200, 299]
     */
    createSyntheticsAPITest(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsAPITest");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 402 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsAPITest", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createSyntheticsBrowserTest
     * @throws ApiException if the response code was not in [200, 299]
     */
    createSyntheticsBrowserTest(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsBrowserTest");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 402 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsBrowserTest", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteGlobalVariable
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteGlobalVariable(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deletePrivateLocation
     * @throws ApiException if the response code was not in [200, 299]
     */
    deletePrivateLocation(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 404 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteTests
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteTests(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsDeleteTestsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsDeleteTestsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to editGlobalVariable
     * @throws ApiException if the response code was not in [200, 299]
     */
    editGlobalVariable(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsGlobalVariable");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsGlobalVariable", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAPITest
     * @throws ApiException if the response code was not in [200, 299]
     */
    getAPITest(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsAPITest");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsAPITest", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAPITestLatestResults
     * @throws ApiException if the response code was not in [200, 299]
     */
    getAPITestLatestResults(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsGetAPITestLatestResultsResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsGetAPITestLatestResultsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAPITestResult
     * @throws ApiException if the response code was not in [200, 299]
     */
    getAPITestResult(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsAPITestResultFull");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsAPITestResultFull", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getBrowserTest
     * @throws ApiException if the response code was not in [200, 299]
     */
    getBrowserTest(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsBrowserTest");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsBrowserTest", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getBrowserTestLatestResults
     * @throws ApiException if the response code was not in [200, 299]
     */
    getBrowserTestLatestResults(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsGetBrowserTestLatestResultsResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsGetBrowserTestLatestResultsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getBrowserTestResult
     * @throws ApiException if the response code was not in [200, 299]
     */
    getBrowserTestResult(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsBrowserTestResultFull");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsBrowserTestResultFull", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getGlobalVariable
     * @throws ApiException if the response code was not in [200, 299]
     */
    getGlobalVariable(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsGlobalVariable");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsGlobalVariable", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getPrivateLocation
     * @throws ApiException if the response code was not in [200, 299]
     */
    getPrivateLocation(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsPrivateLocation");
                return body;
            }
            if (response.httpStatusCode == 404 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsPrivateLocation", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getSyntheticsCIBatch
     * @throws ApiException if the response code was not in [200, 299]
     */
    getSyntheticsCIBatch(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsBatchDetails");
                return body;
            }
            if (response.httpStatusCode == 404 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsBatchDetails", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getTest
     * @throws ApiException if the response code was not in [200, 299]
     */
    getTest(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsTestDetails");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsTestDetails", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listGlobalVariables
     * @throws ApiException if the response code was not in [200, 299]
     */
    listGlobalVariables(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsListGlobalVariablesResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsListGlobalVariablesResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listLocations
     * @throws ApiException if the response code was not in [200, 299]
     */
    listLocations(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsLocations");
                return body;
            }
            if (response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsLocations", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listTests
     * @throws ApiException if the response code was not in [200, 299]
     */
    listTests(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsListTestsResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsListTestsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to triggerCITests
     * @throws ApiException if the response code was not in [200, 299]
     */
    triggerCITests(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsTriggerCITestsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsTriggerCITestsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to triggerTests
     * @throws ApiException if the response code was not in [200, 299]
     */
    triggerTests(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsTriggerCITestsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsTriggerCITestsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateAPITest
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateAPITest(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsAPITest");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsAPITest", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateBrowserTest
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateBrowserTest(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsBrowserTest");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsBrowserTest", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updatePrivateLocation
     * @throws ApiException if the response code was not in [200, 299]
     */
    updatePrivateLocation(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsPrivateLocation");
                return body;
            }
            if (response.httpStatusCode == 404 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SyntheticsPrivateLocation", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateTestPauseStatus
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateTestPauseStatus(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "boolean");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "boolean", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.SyntheticsApiResponseProcessor = SyntheticsApiResponseProcessor;
class SyntheticsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new SyntheticsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new SyntheticsApiResponseProcessor();
    }
    /**
     * Create a Synthetics global variable.
     * @param param The request object
     */
    createGlobalVariable(param, options) {
        const requestContextPromise = this.requestFactory.createGlobalVariable(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createGlobalVariable(responseContext);
            });
        });
    }
    /**
     * Create a new Synthetics private location.
     * @param param The request object
     */
    createPrivateLocation(param, options) {
        const requestContextPromise = this.requestFactory.createPrivateLocation(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createPrivateLocation(responseContext);
            });
        });
    }
    /**
     * Create a Synthetic API test.
     * @param param The request object
     */
    createSyntheticsAPITest(param, options) {
        const requestContextPromise = this.requestFactory.createSyntheticsAPITest(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createSyntheticsAPITest(responseContext);
            });
        });
    }
    /**
     * Create a Synthetic browser test.
     * @param param The request object
     */
    createSyntheticsBrowserTest(param, options) {
        const requestContextPromise = this.requestFactory.createSyntheticsBrowserTest(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createSyntheticsBrowserTest(responseContext);
            });
        });
    }
    /**
     * Delete a Synthetics global variable.
     * @param param The request object
     */
    deleteGlobalVariable(param, options) {
        const requestContextPromise = this.requestFactory.deleteGlobalVariable(param.variableId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteGlobalVariable(responseContext);
            });
        });
    }
    /**
     * Delete a Synthetics private location.
     * @param param The request object
     */
    deletePrivateLocation(param, options) {
        const requestContextPromise = this.requestFactory.deletePrivateLocation(param.locationId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deletePrivateLocation(responseContext);
            });
        });
    }
    /**
     * Delete multiple Synthetic tests by ID.
     * @param param The request object
     */
    deleteTests(param, options) {
        const requestContextPromise = this.requestFactory.deleteTests(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteTests(responseContext);
            });
        });
    }
    /**
     * Edit a Synthetics global variable.
     * @param param The request object
     */
    editGlobalVariable(param, options) {
        const requestContextPromise = this.requestFactory.editGlobalVariable(param.variableId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.editGlobalVariable(responseContext);
            });
        });
    }
    /**
     * Get the detailed configuration associated with
     * a Synthetic API test.
     * @param param The request object
     */
    getAPITest(param, options) {
        const requestContextPromise = this.requestFactory.getAPITest(param.publicId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getAPITest(responseContext);
            });
        });
    }
    /**
     * Get the last 50 test results summaries for a given Synthetics API test.
     * @param param The request object
     */
    getAPITestLatestResults(param, options) {
        const requestContextPromise = this.requestFactory.getAPITestLatestResults(param.publicId, param.fromTs, param.toTs, param.probeDc, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getAPITestLatestResults(responseContext);
            });
        });
    }
    /**
     * Get a specific full result from a given (API) Synthetic test.
     * @param param The request object
     */
    getAPITestResult(param, options) {
        const requestContextPromise = this.requestFactory.getAPITestResult(param.publicId, param.resultId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getAPITestResult(responseContext);
            });
        });
    }
    /**
     * Get the detailed configuration (including steps) associated with
     * a Synthetic browser test.
     * @param param The request object
     */
    getBrowserTest(param, options) {
        const requestContextPromise = this.requestFactory.getBrowserTest(param.publicId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getBrowserTest(responseContext);
            });
        });
    }
    /**
     * Get the last 50 test results summaries for a given Synthetics Browser test.
     * @param param The request object
     */
    getBrowserTestLatestResults(param, options) {
        const requestContextPromise = this.requestFactory.getBrowserTestLatestResults(param.publicId, param.fromTs, param.toTs, param.probeDc, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getBrowserTestLatestResults(responseContext);
            });
        });
    }
    /**
     * Get a specific full result from a given (browser) Synthetic test.
     * @param param The request object
     */
    getBrowserTestResult(param, options) {
        const requestContextPromise = this.requestFactory.getBrowserTestResult(param.publicId, param.resultId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getBrowserTestResult(responseContext);
            });
        });
    }
    /**
     * Get the detailed configuration of a global variable.
     * @param param The request object
     */
    getGlobalVariable(param, options) {
        const requestContextPromise = this.requestFactory.getGlobalVariable(param.variableId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getGlobalVariable(responseContext);
            });
        });
    }
    /**
     * Get a Synthetics private location.
     * @param param The request object
     */
    getPrivateLocation(param, options) {
        const requestContextPromise = this.requestFactory.getPrivateLocation(param.locationId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getPrivateLocation(responseContext);
            });
        });
    }
    /**
     * Get a batch's updated details.
     * @param param The request object
     */
    getSyntheticsCIBatch(param, options) {
        const requestContextPromise = this.requestFactory.getSyntheticsCIBatch(param.batchId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getSyntheticsCIBatch(responseContext);
            });
        });
    }
    /**
     * Get the detailed configuration associated with a Synthetics test.
     * @param param The request object
     */
    getTest(param, options) {
        const requestContextPromise = this.requestFactory.getTest(param.publicId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getTest(responseContext);
            });
        });
    }
    /**
     * Get the list of all Synthetics global variables.
     * @param param The request object
     */
    listGlobalVariables(options) {
        const requestContextPromise = this.requestFactory.listGlobalVariables(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listGlobalVariables(responseContext);
            });
        });
    }
    /**
     * Get the list of public and private locations available for Synthetic
     * tests. No arguments required.
     * @param param The request object
     */
    listLocations(options) {
        const requestContextPromise = this.requestFactory.listLocations(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listLocations(responseContext);
            });
        });
    }
    /**
     * Get the list of all Synthetic tests.
     * @param param The request object
     */
    listTests(param = {}, options) {
        const requestContextPromise = this.requestFactory.listTests(param.pageSize, param.pageNumber, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listTests(responseContext);
            });
        });
    }
    /**
     * Trigger a set of Synthetics tests for continuous integration.
     * @param param The request object
     */
    triggerCITests(param, options) {
        const requestContextPromise = this.requestFactory.triggerCITests(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.triggerCITests(responseContext);
            });
        });
    }
    /**
     * Trigger a set of Synthetics tests.
     * @param param The request object
     */
    triggerTests(param, options) {
        const requestContextPromise = this.requestFactory.triggerTests(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.triggerTests(responseContext);
            });
        });
    }
    /**
     * Edit the configuration of a Synthetic API test.
     * @param param The request object
     */
    updateAPITest(param, options) {
        const requestContextPromise = this.requestFactory.updateAPITest(param.publicId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateAPITest(responseContext);
            });
        });
    }
    /**
     * Edit the configuration of a Synthetic browser test.
     * @param param The request object
     */
    updateBrowserTest(param, options) {
        const requestContextPromise = this.requestFactory.updateBrowserTest(param.publicId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateBrowserTest(responseContext);
            });
        });
    }
    /**
     * Edit a Synthetics private location.
     * @param param The request object
     */
    updatePrivateLocation(param, options) {
        const requestContextPromise = this.requestFactory.updatePrivateLocation(param.locationId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updatePrivateLocation(responseContext);
            });
        });
    }
    /**
     * Pause or start a Synthetics test by changing the status.
     * @param param The request object
     */
    updateTestPauseStatus(param, options) {
        const requestContextPromise = this.requestFactory.updateTestPauseStatus(param.publicId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateTestPauseStatus(responseContext);
            });
        });
    }
}
exports.SyntheticsApi = SyntheticsApi;
//# sourceMappingURL=SyntheticsApi.js.map

/***/ }),

/***/ 71569:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TagsApi = exports.TagsApiResponseProcessor = exports.TagsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class TagsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createHostTags(hostName, body, source, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'hostName' is not null or undefined
            if (hostName === null || hostName === undefined) {
                throw new baseapi_1.RequiredError("hostName", "createHostTags");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createHostTags");
            }
            // Path Params
            const localVarPath = "/api/v1/tags/hosts/{host_name}".replace("{host_name}", encodeURIComponent(String(hostName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.TagsApi.createHostTags").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (source !== undefined) {
                requestContext.setQueryParam("source", ObjectSerializer_1.ObjectSerializer.serialize(source, "string", ""));
            }
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "HostTags", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteHostTags(hostName, source, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'hostName' is not null or undefined
            if (hostName === null || hostName === undefined) {
                throw new baseapi_1.RequiredError("hostName", "deleteHostTags");
            }
            // Path Params
            const localVarPath = "/api/v1/tags/hosts/{host_name}".replace("{host_name}", encodeURIComponent(String(hostName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.TagsApi.deleteHostTags").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (source !== undefined) {
                requestContext.setQueryParam("source", ObjectSerializer_1.ObjectSerializer.serialize(source, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getHostTags(hostName, source, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'hostName' is not null or undefined
            if (hostName === null || hostName === undefined) {
                throw new baseapi_1.RequiredError("hostName", "getHostTags");
            }
            // Path Params
            const localVarPath = "/api/v1/tags/hosts/{host_name}".replace("{host_name}", encodeURIComponent(String(hostName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.TagsApi.getHostTags").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (source !== undefined) {
                requestContext.setQueryParam("source", ObjectSerializer_1.ObjectSerializer.serialize(source, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listHostTags(source, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/tags/hosts";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.TagsApi.listHostTags").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (source !== undefined) {
                requestContext.setQueryParam("source", ObjectSerializer_1.ObjectSerializer.serialize(source, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateHostTags(hostName, body, source, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'hostName' is not null or undefined
            if (hostName === null || hostName === undefined) {
                throw new baseapi_1.RequiredError("hostName", "updateHostTags");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateHostTags");
            }
            // Path Params
            const localVarPath = "/api/v1/tags/hosts/{host_name}".replace("{host_name}", encodeURIComponent(String(hostName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.TagsApi.updateHostTags").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (source !== undefined) {
                requestContext.setQueryParam("source", ObjectSerializer_1.ObjectSerializer.serialize(source, "string", ""));
            }
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "HostTags", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.TagsApiRequestFactory = TagsApiRequestFactory;
class TagsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createHostTags
     * @throws ApiException if the response code was not in [200, 299]
     */
    createHostTags(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "HostTags");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "HostTags", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteHostTags
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteHostTags(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getHostTags
     * @throws ApiException if the response code was not in [200, 299]
     */
    getHostTags(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "HostTags");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "HostTags", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listHostTags
     * @throws ApiException if the response code was not in [200, 299]
     */
    listHostTags(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "TagToHosts");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "TagToHosts", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateHostTags
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateHostTags(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "HostTags");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "HostTags", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.TagsApiResponseProcessor = TagsApiResponseProcessor;
class TagsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new TagsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new TagsApiResponseProcessor();
    }
    /**
     * This endpoint allows you to add new tags to a host,
     * optionally specifying where these tags come from.
     * @param param The request object
     */
    createHostTags(param, options) {
        const requestContextPromise = this.requestFactory.createHostTags(param.hostName, param.body, param.source, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createHostTags(responseContext);
            });
        });
    }
    /**
     * This endpoint allows you to remove all user-assigned tags
     * for a single host.
     * @param param The request object
     */
    deleteHostTags(param, options) {
        const requestContextPromise = this.requestFactory.deleteHostTags(param.hostName, param.source, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteHostTags(responseContext);
            });
        });
    }
    /**
     * Return the list of tags that apply to a given host.
     * @param param The request object
     */
    getHostTags(param, options) {
        const requestContextPromise = this.requestFactory.getHostTags(param.hostName, param.source, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getHostTags(responseContext);
            });
        });
    }
    /**
     * Return a mapping of tags to hosts for your whole infrastructure.
     * @param param The request object
     */
    listHostTags(param = {}, options) {
        const requestContextPromise = this.requestFactory.listHostTags(param.source, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listHostTags(responseContext);
            });
        });
    }
    /**
     * This endpoint allows you to update/replace all tags in
     * an integration source with those supplied in the request.
     * @param param The request object
     */
    updateHostTags(param, options) {
        const requestContextPromise = this.requestFactory.updateHostTags(param.hostName, param.body, param.source, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateHostTags(responseContext);
            });
        });
    }
}
exports.TagsApi = TagsApi;
//# sourceMappingURL=TagsApi.js.map

/***/ }),

/***/ 69255:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageMeteringApi = exports.UsageMeteringApiResponseProcessor = exports.UsageMeteringApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class UsageMeteringApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    getDailyCustomReports(pageSize, pageNumber, sortDir, sort, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/daily_custom_reports";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getDailyCustomReports").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page[size]", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "number", "int64"));
            }
            if (pageNumber !== undefined) {
                requestContext.setQueryParam("page[number]", ObjectSerializer_1.ObjectSerializer.serialize(pageNumber, "number", "int64"));
            }
            if (sortDir !== undefined) {
                requestContext.setQueryParam("sort_dir", ObjectSerializer_1.ObjectSerializer.serialize(sortDir, "UsageSortDirection", ""));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "UsageSort", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getHourlyUsageAttribution(startHr, usageType, endHr, nextRecordId, tagBreakdownKeys, includeDescendants, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getHourlyUsageAttribution");
            }
            // verify required parameter 'usageType' is not null or undefined
            if (usageType === null || usageType === undefined) {
                throw new baseapi_1.RequiredError("usageType", "getHourlyUsageAttribution");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/hourly-attribution";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getHourlyUsageAttribution").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            if (usageType !== undefined) {
                requestContext.setQueryParam("usage_type", ObjectSerializer_1.ObjectSerializer.serialize(usageType, "HourlyUsageAttributionUsageType", ""));
            }
            if (nextRecordId !== undefined) {
                requestContext.setQueryParam("next_record_id", ObjectSerializer_1.ObjectSerializer.serialize(nextRecordId, "string", ""));
            }
            if (tagBreakdownKeys !== undefined) {
                requestContext.setQueryParam("tag_breakdown_keys", ObjectSerializer_1.ObjectSerializer.serialize(tagBreakdownKeys, "string", ""));
            }
            if (includeDescendants !== undefined) {
                requestContext.setQueryParam("include_descendants", ObjectSerializer_1.ObjectSerializer.serialize(includeDescendants, "boolean", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getIncidentManagement(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getIncidentManagement");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/incident-management";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getIncidentManagement").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getIngestedSpans(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getIngestedSpans");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/ingested-spans";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getIngestedSpans").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getMonthlyCustomReports(pageSize, pageNumber, sortDir, sort, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/monthly_custom_reports";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getMonthlyCustomReports").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page[size]", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "number", "int64"));
            }
            if (pageNumber !== undefined) {
                requestContext.setQueryParam("page[number]", ObjectSerializer_1.ObjectSerializer.serialize(pageNumber, "number", "int64"));
            }
            if (sortDir !== undefined) {
                requestContext.setQueryParam("sort_dir", ObjectSerializer_1.ObjectSerializer.serialize(sortDir, "UsageSortDirection", ""));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "UsageSort", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getMonthlyUsageAttribution(startMonth, fields, endMonth, sortDirection, sortName, tagBreakdownKeys, nextRecordId, includeDescendants, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startMonth' is not null or undefined
            if (startMonth === null || startMonth === undefined) {
                throw new baseapi_1.RequiredError("startMonth", "getMonthlyUsageAttribution");
            }
            // verify required parameter 'fields' is not null or undefined
            if (fields === null || fields === undefined) {
                throw new baseapi_1.RequiredError("fields", "getMonthlyUsageAttribution");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/monthly-attribution";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getMonthlyUsageAttribution").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startMonth !== undefined) {
                requestContext.setQueryParam("start_month", ObjectSerializer_1.ObjectSerializer.serialize(startMonth, "Date", "date-time"));
            }
            if (endMonth !== undefined) {
                requestContext.setQueryParam("end_month", ObjectSerializer_1.ObjectSerializer.serialize(endMonth, "Date", "date-time"));
            }
            if (fields !== undefined) {
                requestContext.setQueryParam("fields", ObjectSerializer_1.ObjectSerializer.serialize(fields, "MonthlyUsageAttributionSupportedMetrics", ""));
            }
            if (sortDirection !== undefined) {
                requestContext.setQueryParam("sort_direction", ObjectSerializer_1.ObjectSerializer.serialize(sortDirection, "UsageSortDirection", ""));
            }
            if (sortName !== undefined) {
                requestContext.setQueryParam("sort_name", ObjectSerializer_1.ObjectSerializer.serialize(sortName, "MonthlyUsageAttributionSupportedMetrics", ""));
            }
            if (tagBreakdownKeys !== undefined) {
                requestContext.setQueryParam("tag_breakdown_keys", ObjectSerializer_1.ObjectSerializer.serialize(tagBreakdownKeys, "string", ""));
            }
            if (nextRecordId !== undefined) {
                requestContext.setQueryParam("next_record_id", ObjectSerializer_1.ObjectSerializer.serialize(nextRecordId, "string", ""));
            }
            if (includeDescendants !== undefined) {
                requestContext.setQueryParam("include_descendants", ObjectSerializer_1.ObjectSerializer.serialize(includeDescendants, "boolean", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getSpecifiedDailyCustomReports(reportId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'reportId' is not null or undefined
            if (reportId === null || reportId === undefined) {
                throw new baseapi_1.RequiredError("reportId", "getSpecifiedDailyCustomReports");
            }
            // Path Params
            const localVarPath = "/api/v1/daily_custom_reports/{report_id}".replace("{report_id}", encodeURIComponent(String(reportId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getSpecifiedDailyCustomReports").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getSpecifiedMonthlyCustomReports(reportId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'reportId' is not null or undefined
            if (reportId === null || reportId === undefined) {
                throw new baseapi_1.RequiredError("reportId", "getSpecifiedMonthlyCustomReports");
            }
            // Path Params
            const localVarPath = "/api/v1/monthly_custom_reports/{report_id}".replace("{report_id}", encodeURIComponent(String(reportId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getSpecifiedMonthlyCustomReports").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageAnalyzedLogs(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageAnalyzedLogs");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/analyzed_logs";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageAnalyzedLogs").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageAttribution(startMonth, fields, endMonth, sortDirection, sortName, includeDescendants, offset, limit, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startMonth' is not null or undefined
            if (startMonth === null || startMonth === undefined) {
                throw new baseapi_1.RequiredError("startMonth", "getUsageAttribution");
            }
            // verify required parameter 'fields' is not null or undefined
            if (fields === null || fields === undefined) {
                throw new baseapi_1.RequiredError("fields", "getUsageAttribution");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/attribution";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageAttribution").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startMonth !== undefined) {
                requestContext.setQueryParam("start_month", ObjectSerializer_1.ObjectSerializer.serialize(startMonth, "Date", "date-time"));
            }
            if (fields !== undefined) {
                requestContext.setQueryParam("fields", ObjectSerializer_1.ObjectSerializer.serialize(fields, "UsageAttributionSupportedMetrics", ""));
            }
            if (endMonth !== undefined) {
                requestContext.setQueryParam("end_month", ObjectSerializer_1.ObjectSerializer.serialize(endMonth, "Date", "date-time"));
            }
            if (sortDirection !== undefined) {
                requestContext.setQueryParam("sort_direction", ObjectSerializer_1.ObjectSerializer.serialize(sortDirection, "UsageSortDirection", ""));
            }
            if (sortName !== undefined) {
                requestContext.setQueryParam("sort_name", ObjectSerializer_1.ObjectSerializer.serialize(sortName, "UsageAttributionSort", ""));
            }
            if (includeDescendants !== undefined) {
                requestContext.setQueryParam("include_descendants", ObjectSerializer_1.ObjectSerializer.serialize(includeDescendants, "boolean", ""));
            }
            if (offset !== undefined) {
                requestContext.setQueryParam("offset", ObjectSerializer_1.ObjectSerializer.serialize(offset, "number", "int64"));
            }
            if (limit !== undefined) {
                requestContext.setQueryParam("limit", ObjectSerializer_1.ObjectSerializer.serialize(limit, "number", "int64"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageAuditLogs(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageAuditLogs");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/audit_logs";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageAuditLogs").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageBillableSummary(month, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/usage/billable-summary";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageBillableSummary").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (month !== undefined) {
                requestContext.setQueryParam("month", ObjectSerializer_1.ObjectSerializer.serialize(month, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageCIApp(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageCIApp");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/ci-app";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageCIApp").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageCloudSecurityPostureManagement(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageCloudSecurityPostureManagement");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/cspm";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageCloudSecurityPostureManagement").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageCWS(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageCWS");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/cws";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageCWS").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageDBM(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageDBM");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/dbm";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageDBM").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageFargate(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageFargate");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/fargate";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageFargate").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageHosts(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageHosts");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/hosts";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageHosts").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageIndexedSpans(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageIndexedSpans");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/indexed-spans";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageIndexedSpans").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageInternetOfThings(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageInternetOfThings");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/iot";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageInternetOfThings").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageLambda(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageLambda");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/aws_lambda";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageLambda").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageLogs(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageLogs");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/logs";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageLogs").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageLogsByIndex(startHr, endHr, indexName, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageLogsByIndex");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/logs_by_index";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageLogsByIndex").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            if (indexName !== undefined) {
                requestContext.setQueryParam("index_name", ObjectSerializer_1.ObjectSerializer.serialize(indexName, "Array<string>", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageLogsByRetention(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageLogsByRetention");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/logs-by-retention";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageLogsByRetention").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageNetworkFlows(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageNetworkFlows");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/network_flows";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageNetworkFlows").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageNetworkHosts(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageNetworkHosts");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/network_hosts";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageNetworkHosts").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageOnlineArchive(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageOnlineArchive");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/online-archive";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageOnlineArchive").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageProfiling(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageProfiling");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/profiling";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageProfiling").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageRumSessions(startHr, endHr, type, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageRumSessions");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/rum_sessions";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageRumSessions").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            if (type !== undefined) {
                requestContext.setQueryParam("type", ObjectSerializer_1.ObjectSerializer.serialize(type, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageRumUnits(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageRumUnits");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/rum";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageRumUnits").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageSDS(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageSDS");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/sds";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageSDS").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageSNMP(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageSNMP");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/snmp";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageSNMP").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageSummary(startMonth, endMonth, includeOrgDetails, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startMonth' is not null or undefined
            if (startMonth === null || startMonth === undefined) {
                throw new baseapi_1.RequiredError("startMonth", "getUsageSummary");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/summary";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageSummary").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startMonth !== undefined) {
                requestContext.setQueryParam("start_month", ObjectSerializer_1.ObjectSerializer.serialize(startMonth, "Date", "date-time"));
            }
            if (endMonth !== undefined) {
                requestContext.setQueryParam("end_month", ObjectSerializer_1.ObjectSerializer.serialize(endMonth, "Date", "date-time"));
            }
            if (includeOrgDetails !== undefined) {
                requestContext.setQueryParam("include_org_details", ObjectSerializer_1.ObjectSerializer.serialize(includeOrgDetails, "boolean", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageSynthetics(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageSynthetics");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/synthetics";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageSynthetics").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageSyntheticsAPI(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageSyntheticsAPI");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/synthetics_api";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageSyntheticsAPI").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageSyntheticsBrowser(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageSyntheticsBrowser");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/synthetics_browser";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageSyntheticsBrowser").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageTimeseries(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageTimeseries");
            }
            // Path Params
            const localVarPath = "/api/v1/usage/timeseries";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageTimeseries").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageTopAvgMetrics(month, day, names, limit, nextRecordId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/usage/top_avg_metrics";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsageMeteringApi.getUsageTopAvgMetrics").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (month !== undefined) {
                requestContext.setQueryParam("month", ObjectSerializer_1.ObjectSerializer.serialize(month, "Date", "date-time"));
            }
            if (day !== undefined) {
                requestContext.setQueryParam("day", ObjectSerializer_1.ObjectSerializer.serialize(day, "Date", "date-time"));
            }
            if (names !== undefined) {
                requestContext.setQueryParam("names", ObjectSerializer_1.ObjectSerializer.serialize(names, "Array<string>", ""));
            }
            if (limit !== undefined) {
                requestContext.setQueryParam("limit", ObjectSerializer_1.ObjectSerializer.serialize(limit, "number", "int32"));
            }
            if (nextRecordId !== undefined) {
                requestContext.setQueryParam("next_record_id", ObjectSerializer_1.ObjectSerializer.serialize(nextRecordId, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.UsageMeteringApiRequestFactory = UsageMeteringApiRequestFactory;
class UsageMeteringApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getDailyCustomReports
     * @throws ApiException if the response code was not in [200, 299]
     */
    getDailyCustomReports(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageCustomReportsResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageCustomReportsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getHourlyUsageAttribution
     * @throws ApiException if the response code was not in [200, 299]
     */
    getHourlyUsageAttribution(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "HourlyUsageAttributionResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "HourlyUsageAttributionResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getIncidentManagement
     * @throws ApiException if the response code was not in [200, 299]
     */
    getIncidentManagement(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageIncidentManagementResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageIncidentManagementResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getIngestedSpans
     * @throws ApiException if the response code was not in [200, 299]
     */
    getIngestedSpans(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageIngestedSpansResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageIngestedSpansResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getMonthlyCustomReports
     * @throws ApiException if the response code was not in [200, 299]
     */
    getMonthlyCustomReports(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageCustomReportsResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageCustomReportsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getMonthlyUsageAttribution
     * @throws ApiException if the response code was not in [200, 299]
     */
    getMonthlyUsageAttribution(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MonthlyUsageAttributionResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MonthlyUsageAttributionResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getSpecifiedDailyCustomReports
     * @throws ApiException if the response code was not in [200, 299]
     */
    getSpecifiedDailyCustomReports(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageSpecifiedCustomReportsResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageSpecifiedCustomReportsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getSpecifiedMonthlyCustomReports
     * @throws ApiException if the response code was not in [200, 299]
     */
    getSpecifiedMonthlyCustomReports(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageSpecifiedCustomReportsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageSpecifiedCustomReportsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageAnalyzedLogs
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageAnalyzedLogs(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageAnalyzedLogsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageAnalyzedLogsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageAttribution
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageAttribution(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageAttributionResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageAttributionResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageAuditLogs
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageAuditLogs(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageAuditLogsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageAuditLogsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageBillableSummary
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageBillableSummary(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageBillableSummaryResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageBillableSummaryResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageCIApp
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageCIApp(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageCIVisibilityResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageCIVisibilityResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageCloudSecurityPostureManagement
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageCloudSecurityPostureManagement(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageCloudSecurityPostureManagementResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageCloudSecurityPostureManagementResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageCWS
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageCWS(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageCWSResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageCWSResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageDBM
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageDBM(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageDBMResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageDBMResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageFargate
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageFargate(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageFargateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageFargateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageHosts
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageHosts(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageHostsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageHostsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageIndexedSpans
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageIndexedSpans(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageIndexedSpansResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageIndexedSpansResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageInternetOfThings
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageInternetOfThings(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageIoTResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageIoTResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageLambda
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageLambda(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageLambdaResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageLambdaResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageLogs
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageLogs(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageLogsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageLogsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageLogsByIndex
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageLogsByIndex(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageLogsByIndexResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageLogsByIndexResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageLogsByRetention
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageLogsByRetention(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageLogsByRetentionResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageLogsByRetentionResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageNetworkFlows
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageNetworkFlows(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageNetworkFlowsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageNetworkFlowsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageNetworkHosts
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageNetworkHosts(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageNetworkHostsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageNetworkHostsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageOnlineArchive
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageOnlineArchive(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageOnlineArchiveResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageOnlineArchiveResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageProfiling
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageProfiling(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageProfilingResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageProfilingResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageRumSessions
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageRumSessions(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageRumSessionsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageRumSessionsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageRumUnits
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageRumUnits(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageRumUnitsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageRumUnitsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageSDS
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageSDS(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageSDSResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageSDSResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageSNMP
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageSNMP(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageSNMPResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageSNMPResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageSummary
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageSummary(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageSummaryResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageSummaryResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageSynthetics
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageSynthetics(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageSyntheticsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageSyntheticsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageSyntheticsAPI
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageSyntheticsAPI(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageSyntheticsAPIResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageSyntheticsAPIResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageSyntheticsBrowser
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageSyntheticsBrowser(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageSyntheticsBrowserResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageSyntheticsBrowserResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageTimeseries
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageTimeseries(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageTimeseriesResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageTimeseriesResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageTopAvgMetrics
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageTopAvgMetrics(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageTopAvgMetricsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageTopAvgMetricsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.UsageMeteringApiResponseProcessor = UsageMeteringApiResponseProcessor;
class UsageMeteringApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new UsageMeteringApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new UsageMeteringApiResponseProcessor();
    }
    /**
     * Get daily custom reports.
     * **Note:** This endpoint will be fully deprecated on December 1, 2022.
     * Refer to [Migrating from v1 to v2 of the Usage Attribution API](https://docs.datadoghq.com/account_management/guide/usage-attribution-migration/) for the associated migration guide.
     * @param param The request object
     */
    getDailyCustomReports(param = {}, options) {
        const requestContextPromise = this.requestFactory.getDailyCustomReports(param.pageSize, param.pageNumber, param.sortDir, param.sort, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getDailyCustomReports(responseContext);
            });
        });
    }
    /**
     * Get hourly usage attribution.
     *
     * This API endpoint is paginated. To make sure you receive all records, check if the value of `next_record_id` is
     * set in the response. If it is, make another request and pass `next_record_id` as a parameter.
     * Pseudo code example:
     *
     * ```
     * response := GetHourlyUsageAttribution(start_month)
     * cursor := response.metadata.pagination.next_record_id
     * WHILE cursor != null BEGIN
     *   sleep(5 seconds)  # Avoid running into rate limit
     *   response := GetHourlyUsageAttribution(start_month, next_record_id=cursor)
     *   cursor := response.metadata.pagination.next_record_id
     * END
     * ```
     * @param param The request object
     */
    getHourlyUsageAttribution(param, options) {
        const requestContextPromise = this.requestFactory.getHourlyUsageAttribution(param.startHr, param.usageType, param.endHr, param.nextRecordId, param.tagBreakdownKeys, param.includeDescendants, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getHourlyUsageAttribution(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for incident management.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getIncidentManagement(param, options) {
        const requestContextPromise = this.requestFactory.getIncidentManagement(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getIncidentManagement(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for ingested spans.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getIngestedSpans(param, options) {
        const requestContextPromise = this.requestFactory.getIngestedSpans(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getIngestedSpans(responseContext);
            });
        });
    }
    /**
     * Get monthly custom reports.
     * **Note:** This endpoint will be fully deprecated on December 1, 2022.
     * Refer to [Migrating from v1 to v2 of the Usage Attribution API](https://docs.datadoghq.com/account_management/guide/usage-attribution-migration/) for the associated migration guide.
     * @param param The request object
     */
    getMonthlyCustomReports(param = {}, options) {
        const requestContextPromise = this.requestFactory.getMonthlyCustomReports(param.pageSize, param.pageNumber, param.sortDir, param.sort, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getMonthlyCustomReports(responseContext);
            });
        });
    }
    /**
     * Get monthly usage attribution.
     *
     * This API endpoint is paginated. To make sure you receive all records, check if the value of `next_record_id` is
     * set in the response. If it is, make another request and pass `next_record_id` as a parameter.
     * Pseudo code example:
     *
     * ```
     * response := GetMonthlyUsageAttribution(start_month)
     * cursor := response.metadata.pagination.next_record_id
     * WHILE cursor != null BEGIN
     *   sleep(5 seconds)  # Avoid running into rate limit
     *   response := GetMonthlyUsageAttribution(start_month, next_record_id=cursor)
     *   cursor := response.metadata.pagination.next_record_id
     * END
     * ```
     * @param param The request object
     */
    getMonthlyUsageAttribution(param, options) {
        const requestContextPromise = this.requestFactory.getMonthlyUsageAttribution(param.startMonth, param.fields, param.endMonth, param.sortDirection, param.sortName, param.tagBreakdownKeys, param.nextRecordId, param.includeDescendants, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getMonthlyUsageAttribution(responseContext);
            });
        });
    }
    /**
     * Get specified daily custom reports.
     * **Note:** This endpoint will be fully deprecated on December 1, 2022.
     * Refer to [Migrating from v1 to v2 of the Usage Attribution API](https://docs.datadoghq.com/account_management/guide/usage-attribution-migration/) for the associated migration guide.
     * @param param The request object
     */
    getSpecifiedDailyCustomReports(param, options) {
        const requestContextPromise = this.requestFactory.getSpecifiedDailyCustomReports(param.reportId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getSpecifiedDailyCustomReports(responseContext);
            });
        });
    }
    /**
     * Get specified monthly custom reports.
     * **Note:** This endpoint will be fully deprecated on December 1, 2022.
     * Refer to [Migrating from v1 to v2 of the Usage Attribution API](https://docs.datadoghq.com/account_management/guide/usage-attribution-migration/) for the associated migration guide.
     * @param param The request object
     */
    getSpecifiedMonthlyCustomReports(param, options) {
        const requestContextPromise = this.requestFactory.getSpecifiedMonthlyCustomReports(param.reportId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getSpecifiedMonthlyCustomReports(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for analyzed logs (Security Monitoring).
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageAnalyzedLogs(param, options) {
        const requestContextPromise = this.requestFactory.getUsageAnalyzedLogs(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageAnalyzedLogs(responseContext);
            });
        });
    }
    /**
     * Get usage attribution.
     * **Note:** This endpoint will be fully deprecated on December 1, 2022.
     * Refer to [Migrating from v1 to v2 of the Usage Attribution API](https://docs.datadoghq.com/account_management/guide/usage-attribution-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageAttribution(param, options) {
        const requestContextPromise = this.requestFactory.getUsageAttribution(param.startMonth, param.fields, param.endMonth, param.sortDirection, param.sortName, param.includeDescendants, param.offset, param.limit, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageAttribution(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for audit logs.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageAuditLogs(param, options) {
        const requestContextPromise = this.requestFactory.getUsageAuditLogs(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageAuditLogs(responseContext);
            });
        });
    }
    /**
     * Get billable usage across your account.
     * @param param The request object
     */
    getUsageBillableSummary(param = {}, options) {
        const requestContextPromise = this.requestFactory.getUsageBillableSummary(param.month, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageBillableSummary(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for CI visibility (tests, pipeline, and spans).
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageCIApp(param, options) {
        const requestContextPromise = this.requestFactory.getUsageCIApp(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageCIApp(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for cloud security posture management (CSPM).
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageCloudSecurityPostureManagement(param, options) {
        const requestContextPromise = this.requestFactory.getUsageCloudSecurityPostureManagement(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageCloudSecurityPostureManagement(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for cloud workload security.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageCWS(param, options) {
        const requestContextPromise = this.requestFactory.getUsageCWS(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageCWS(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for database monitoring
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageDBM(param, options) {
        const requestContextPromise = this.requestFactory.getUsageDBM(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageDBM(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for [Fargate](https://docs.datadoghq.com/integrations/ecs_fargate/).
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageFargate(param, options) {
        const requestContextPromise = this.requestFactory.getUsageFargate(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageFargate(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for hosts and containers.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageHosts(param, options) {
        const requestContextPromise = this.requestFactory.getUsageHosts(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageHosts(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for indexed spans.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageIndexedSpans(param, options) {
        const requestContextPromise = this.requestFactory.getUsageIndexedSpans(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageIndexedSpans(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for IoT.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageInternetOfThings(param, options) {
        const requestContextPromise = this.requestFactory.getUsageInternetOfThings(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageInternetOfThings(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for lambda.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageLambda(param, options) {
        const requestContextPromise = this.requestFactory.getUsageLambda(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageLambda(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for logs.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageLogs(param, options) {
        const requestContextPromise = this.requestFactory.getUsageLogs(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageLogs(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for logs by index.
     * @param param The request object
     */
    getUsageLogsByIndex(param, options) {
        const requestContextPromise = this.requestFactory.getUsageLogsByIndex(param.startHr, param.endHr, param.indexName, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageLogsByIndex(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for indexed logs by retention period.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageLogsByRetention(param, options) {
        const requestContextPromise = this.requestFactory.getUsageLogsByRetention(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageLogsByRetention(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for network flows.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageNetworkFlows(param, options) {
        const requestContextPromise = this.requestFactory.getUsageNetworkFlows(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageNetworkFlows(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for network hosts.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageNetworkHosts(param, options) {
        const requestContextPromise = this.requestFactory.getUsageNetworkHosts(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageNetworkHosts(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for online archive.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageOnlineArchive(param, options) {
        const requestContextPromise = this.requestFactory.getUsageOnlineArchive(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageOnlineArchive(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for profiled hosts.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageProfiling(param, options) {
        const requestContextPromise = this.requestFactory.getUsageProfiling(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageProfiling(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for [RUM](https://docs.datadoghq.com/real_user_monitoring/) Sessions.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageRumSessions(param, options) {
        const requestContextPromise = this.requestFactory.getUsageRumSessions(param.startHr, param.endHr, param.type, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageRumSessions(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for [RUM](https://docs.datadoghq.com/real_user_monitoring/) Units.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageRumUnits(param, options) {
        const requestContextPromise = this.requestFactory.getUsageRumUnits(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageRumUnits(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for sensitive data scanner.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageSDS(param, options) {
        const requestContextPromise = this.requestFactory.getUsageSDS(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageSDS(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for SNMP devices.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageSNMP(param, options) {
        const requestContextPromise = this.requestFactory.getUsageSNMP(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageSNMP(responseContext);
            });
        });
    }
    /**
     * Get all usage across your account.
     * @param param The request object
     */
    getUsageSummary(param, options) {
        const requestContextPromise = this.requestFactory.getUsageSummary(param.startMonth, param.endMonth, param.includeOrgDetails, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageSummary(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for [synthetics checks](https://docs.datadoghq.com/synthetics/).
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageSynthetics(param, options) {
        const requestContextPromise = this.requestFactory.getUsageSynthetics(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageSynthetics(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for [synthetics API checks](https://docs.datadoghq.com/synthetics/).
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageSyntheticsAPI(param, options) {
        const requestContextPromise = this.requestFactory.getUsageSyntheticsAPI(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageSyntheticsAPI(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for synthetics browser checks.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageSyntheticsBrowser(param, options) {
        const requestContextPromise = this.requestFactory.getUsageSyntheticsBrowser(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageSyntheticsBrowser(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for [custom metrics](https://docs.datadoghq.com/developers/metrics/custom_metrics/).
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family). Refer to [Migrating from the V1 Hourly Usage APIs to V2](https://docs.datadoghq.com/account_management/guide/hourly-usage-migration/) for the associated migration guide.
     * @param param The request object
     */
    getUsageTimeseries(param, options) {
        const requestContextPromise = this.requestFactory.getUsageTimeseries(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageTimeseries(responseContext);
            });
        });
    }
    /**
     * Get all [custom metrics](https://docs.datadoghq.com/developers/metrics/custom_metrics/) by hourly average. Use the month parameter to get a month-to-date data resolution or use the day parameter to get a daily resolution. One of the two is required, and only one of the two is allowed.
     * @param param The request object
     */
    getUsageTopAvgMetrics(param = {}, options) {
        const requestContextPromise = this.requestFactory.getUsageTopAvgMetrics(param.month, param.day, param.names, param.limit, param.nextRecordId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageTopAvgMetrics(responseContext);
            });
        });
    }
}
exports.UsageMeteringApi = UsageMeteringApi;
//# sourceMappingURL=UsageMeteringApi.js.map

/***/ }),

/***/ 56537:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersApi = exports.UsersApiResponseProcessor = exports.UsersApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class UsersApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createUser(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createUser");
            }
            // Path Params
            const localVarPath = "/api/v1/user";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsersApi.createUser").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "User", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    disableUser(userHandle, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'userHandle' is not null or undefined
            if (userHandle === null || userHandle === undefined) {
                throw new baseapi_1.RequiredError("userHandle", "disableUser");
            }
            // Path Params
            const localVarPath = "/api/v1/user/{user_handle}".replace("{user_handle}", encodeURIComponent(String(userHandle)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsersApi.disableUser").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUser(userHandle, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'userHandle' is not null or undefined
            if (userHandle === null || userHandle === undefined) {
                throw new baseapi_1.RequiredError("userHandle", "getUser");
            }
            // Path Params
            const localVarPath = "/api/v1/user/{user_handle}".replace("{user_handle}", encodeURIComponent(String(userHandle)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsersApi.getUser").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listUsers(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v1/user";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsersApi.listUsers").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateUser(userHandle, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'userHandle' is not null or undefined
            if (userHandle === null || userHandle === undefined) {
                throw new baseapi_1.RequiredError("userHandle", "updateUser");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateUser");
            }
            // Path Params
            const localVarPath = "/api/v1/user/{user_handle}".replace("{user_handle}", encodeURIComponent(String(userHandle)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.UsersApi.updateUser").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "User", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.UsersApiRequestFactory = UsersApiRequestFactory;
class UsersApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createUser
     * @throws ApiException if the response code was not in [200, 299]
     */
    createUser(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 409 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to disableUser
     * @throws ApiException if the response code was not in [200, 299]
     */
    disableUser(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserDisableResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserDisableResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUser
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUser(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listUsers
     * @throws ApiException if the response code was not in [200, 299]
     */
    listUsers(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserListResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateUser
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateUser(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.UsersApiResponseProcessor = UsersApiResponseProcessor;
class UsersApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new UsersApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new UsersApiResponseProcessor();
    }
    /**
     * Create a user for your organization.
     *
     * **Note**: Users can only be created with the admin access role
     * if application keys belong to administrators.
     * @param param The request object
     */
    createUser(param, options) {
        const requestContextPromise = this.requestFactory.createUser(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createUser(responseContext);
            });
        });
    }
    /**
     * Delete a user from an organization.
     *
     * **Note**: This endpoint can only be used with application keys belonging to
     * administrators.
     * @param param The request object
     */
    disableUser(param, options) {
        const requestContextPromise = this.requestFactory.disableUser(param.userHandle, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.disableUser(responseContext);
            });
        });
    }
    /**
     * Get a user's details.
     * @param param The request object
     */
    getUser(param, options) {
        const requestContextPromise = this.requestFactory.getUser(param.userHandle, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUser(responseContext);
            });
        });
    }
    /**
     * List all users for your organization.
     * @param param The request object
     */
    listUsers(options) {
        const requestContextPromise = this.requestFactory.listUsers(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listUsers(responseContext);
            });
        });
    }
    /**
     * Update a user information.
     *
     * **Note**: It can only be used with application keys belonging to administrators.
     * @param param The request object
     */
    updateUser(param, options) {
        const requestContextPromise = this.requestFactory.updateUser(param.userHandle, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateUser(responseContext);
            });
        });
    }
}
exports.UsersApi = UsersApi;
//# sourceMappingURL=UsersApi.js.map

/***/ }),

/***/ 80646:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebhooksIntegrationApi = exports.WebhooksIntegrationApiResponseProcessor = exports.WebhooksIntegrationApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(52674);
const exception_1 = __webpack_require__(41001);
class WebhooksIntegrationApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createWebhooksIntegration(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createWebhooksIntegration");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/webhooks/configuration/webhooks";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.WebhooksIntegrationApi.createWebhooksIntegration").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "WebhooksIntegration", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createWebhooksIntegrationCustomVariable(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createWebhooksIntegrationCustomVariable");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/webhooks/configuration/custom-variables";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.WebhooksIntegrationApi.createWebhooksIntegrationCustomVariable").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "WebhooksIntegrationCustomVariable", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteWebhooksIntegration(webhookName, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'webhookName' is not null or undefined
            if (webhookName === null || webhookName === undefined) {
                throw new baseapi_1.RequiredError("webhookName", "deleteWebhooksIntegration");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/webhooks/configuration/webhooks/{webhook_name}".replace("{webhook_name}", encodeURIComponent(String(webhookName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.WebhooksIntegrationApi.deleteWebhooksIntegration").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteWebhooksIntegrationCustomVariable(customVariableName, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'customVariableName' is not null or undefined
            if (customVariableName === null || customVariableName === undefined) {
                throw new baseapi_1.RequiredError("customVariableName", "deleteWebhooksIntegrationCustomVariable");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/webhooks/configuration/custom-variables/{custom_variable_name}".replace("{custom_variable_name}", encodeURIComponent(String(customVariableName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.WebhooksIntegrationApi.deleteWebhooksIntegrationCustomVariable").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getWebhooksIntegration(webhookName, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'webhookName' is not null or undefined
            if (webhookName === null || webhookName === undefined) {
                throw new baseapi_1.RequiredError("webhookName", "getWebhooksIntegration");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/webhooks/configuration/webhooks/{webhook_name}".replace("{webhook_name}", encodeURIComponent(String(webhookName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.WebhooksIntegrationApi.getWebhooksIntegration").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getWebhooksIntegrationCustomVariable(customVariableName, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'customVariableName' is not null or undefined
            if (customVariableName === null || customVariableName === undefined) {
                throw new baseapi_1.RequiredError("customVariableName", "getWebhooksIntegrationCustomVariable");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/webhooks/configuration/custom-variables/{custom_variable_name}".replace("{custom_variable_name}", encodeURIComponent(String(customVariableName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.WebhooksIntegrationApi.getWebhooksIntegrationCustomVariable").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateWebhooksIntegration(webhookName, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'webhookName' is not null or undefined
            if (webhookName === null || webhookName === undefined) {
                throw new baseapi_1.RequiredError("webhookName", "updateWebhooksIntegration");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateWebhooksIntegration");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/webhooks/configuration/webhooks/{webhook_name}".replace("{webhook_name}", encodeURIComponent(String(webhookName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.WebhooksIntegrationApi.updateWebhooksIntegration").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "WebhooksIntegrationUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateWebhooksIntegrationCustomVariable(customVariableName, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'customVariableName' is not null or undefined
            if (customVariableName === null || customVariableName === undefined) {
                throw new baseapi_1.RequiredError("customVariableName", "updateWebhooksIntegrationCustomVariable");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateWebhooksIntegrationCustomVariable");
            }
            // Path Params
            const localVarPath = "/api/v1/integration/webhooks/configuration/custom-variables/{custom_variable_name}".replace("{custom_variable_name}", encodeURIComponent(String(customVariableName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v1.WebhooksIntegrationApi.updateWebhooksIntegrationCustomVariable").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "WebhooksIntegrationCustomVariableUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.WebhooksIntegrationApiRequestFactory = WebhooksIntegrationApiRequestFactory;
class WebhooksIntegrationApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createWebhooksIntegration
     * @throws ApiException if the response code was not in [200, 299]
     */
    createWebhooksIntegration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "WebhooksIntegration");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "WebhooksIntegration", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createWebhooksIntegrationCustomVariable
     * @throws ApiException if the response code was not in [200, 299]
     */
    createWebhooksIntegrationCustomVariable(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "WebhooksIntegrationCustomVariableResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "WebhooksIntegrationCustomVariableResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteWebhooksIntegration
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteWebhooksIntegration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                return;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteWebhooksIntegrationCustomVariable
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteWebhooksIntegrationCustomVariable(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                return;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getWebhooksIntegration
     * @throws ApiException if the response code was not in [200, 299]
     */
    getWebhooksIntegration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "WebhooksIntegration");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "WebhooksIntegration", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getWebhooksIntegrationCustomVariable
     * @throws ApiException if the response code was not in [200, 299]
     */
    getWebhooksIntegrationCustomVariable(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "WebhooksIntegrationCustomVariableResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "WebhooksIntegrationCustomVariableResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateWebhooksIntegration
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateWebhooksIntegration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "WebhooksIntegration");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "WebhooksIntegration", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateWebhooksIntegrationCustomVariable
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateWebhooksIntegrationCustomVariable(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "WebhooksIntegrationCustomVariableResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "WebhooksIntegrationCustomVariableResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.WebhooksIntegrationApiResponseProcessor = WebhooksIntegrationApiResponseProcessor;
class WebhooksIntegrationApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new WebhooksIntegrationApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new WebhooksIntegrationApiResponseProcessor();
    }
    /**
     * Creates an endpoint with the name `<WEBHOOK_NAME>`.
     * @param param The request object
     */
    createWebhooksIntegration(param, options) {
        const requestContextPromise = this.requestFactory.createWebhooksIntegration(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createWebhooksIntegration(responseContext);
            });
        });
    }
    /**
     * Creates an endpoint with the name `<CUSTOM_VARIABLE_NAME>`.
     * @param param The request object
     */
    createWebhooksIntegrationCustomVariable(param, options) {
        const requestContextPromise = this.requestFactory.createWebhooksIntegrationCustomVariable(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createWebhooksIntegrationCustomVariable(responseContext);
            });
        });
    }
    /**
     * Deletes the endpoint with the name `<WEBHOOK NAME>`.
     * @param param The request object
     */
    deleteWebhooksIntegration(param, options) {
        const requestContextPromise = this.requestFactory.deleteWebhooksIntegration(param.webhookName, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteWebhooksIntegration(responseContext);
            });
        });
    }
    /**
     * Deletes the endpoint with the name `<CUSTOM_VARIABLE_NAME>`.
     * @param param The request object
     */
    deleteWebhooksIntegrationCustomVariable(param, options) {
        const requestContextPromise = this.requestFactory.deleteWebhooksIntegrationCustomVariable(param.customVariableName, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteWebhooksIntegrationCustomVariable(responseContext);
            });
        });
    }
    /**
     * Gets the content of the webhook with the name `<WEBHOOK_NAME>`.
     * @param param The request object
     */
    getWebhooksIntegration(param, options) {
        const requestContextPromise = this.requestFactory.getWebhooksIntegration(param.webhookName, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getWebhooksIntegration(responseContext);
            });
        });
    }
    /**
     * Shows the content of the custom variable with the name `<CUSTOM_VARIABLE_NAME>`.
     *
     * If the custom variable is secret, the value does not return in the
     * response payload.
     * @param param The request object
     */
    getWebhooksIntegrationCustomVariable(param, options) {
        const requestContextPromise = this.requestFactory.getWebhooksIntegrationCustomVariable(param.customVariableName, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getWebhooksIntegrationCustomVariable(responseContext);
            });
        });
    }
    /**
     * Updates the endpoint with the name `<WEBHOOK_NAME>`.
     * @param param The request object
     */
    updateWebhooksIntegration(param, options) {
        const requestContextPromise = this.requestFactory.updateWebhooksIntegration(param.webhookName, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateWebhooksIntegration(responseContext);
            });
        });
    }
    /**
     * Updates the endpoint with the name `<CUSTOM_VARIABLE_NAME>`.
     * @param param The request object
     */
    updateWebhooksIntegrationCustomVariable(param, options) {
        const requestContextPromise = this.requestFactory.updateWebhooksIntegrationCustomVariable(param.customVariableName, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateWebhooksIntegrationCustomVariable(responseContext);
            });
        });
    }
}
exports.WebhooksIntegrationApi = WebhooksIntegrationApi;
//# sourceMappingURL=WebhooksIntegrationApi.js.map

/***/ }),

/***/ 46649:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AWSLogsAsyncError = exports.AWSAccountListResponse = exports.AWSAccountDeleteRequest = exports.AWSAccountCreateResponse = exports.AWSAccountAndLambdaRequest = exports.AWSAccount = exports.AuthenticationValidationResponse = exports.ApplicationKeyResponse = exports.ApplicationKeyListResponse = exports.ApplicationKey = exports.ApmStatsQueryDefinition = exports.ApmStatsQueryColumnType = exports.ApiKeyResponse = exports.ApiKeyListResponse = exports.ApiKey = exports.APIErrorResponse = exports.AlertValueWidgetDefinition = exports.AlertGraphWidgetDefinition = exports.AddSignalToIncidentRequest = exports.WebhooksIntegrationApi = exports.UsersApi = exports.UsageMeteringApi = exports.TagsApi = exports.SyntheticsApi = exports.SnapshotsApi = exports.SlackIntegrationApi = exports.ServiceLevelObjectivesApi = exports.ServiceLevelObjectiveCorrectionsApi = exports.ServiceChecksApi = exports.SecurityMonitoringApi = exports.PagerDutyIntegrationApi = exports.OrganizationsApi = exports.NotebooksApi = exports.MonitorsApi = exports.MetricsApi = exports.LogsPipelinesApi = exports.LogsIndexesApi = exports.LogsApi = exports.KeyManagementApi = exports.IPRangesApi = exports.HostsApi = exports.GCPIntegrationApi = exports.EventsApi = exports.DowntimesApi = exports.DashboardsApi = exports.DashboardListsApi = exports.AzureIntegrationApi = exports.AuthenticationApi = exports.AWSLogsIntegrationApi = exports.AWSIntegrationApi = void 0;
exports.EventStreamWidgetDefinition = exports.EventResponse = exports.EventQueryDefinition = exports.EventListResponse = exports.EventCreateResponse = exports.EventCreateRequest = exports.Event = exports.DowntimeRecurrence = exports.DowntimeChild = exports.Downtime = exports.DistributionWidgetYAxis = exports.DistributionWidgetXAxis = exports.DistributionWidgetRequest = exports.DistributionWidgetDefinition = exports.DistributionPointsSeries = exports.DistributionPointsPayload = exports.DeletedMonitor = exports.DashboardTemplateVariablePresetValue = exports.DashboardTemplateVariablePreset = exports.DashboardTemplateVariable = exports.DashboardSummaryDefinition = exports.DashboardSummary = exports.DashboardRestoreRequest = exports.DashboardListListResponse = exports.DashboardListDeleteResponse = exports.DashboardList = exports.DashboardDeleteResponse = exports.DashboardBulkDeleteRequest = exports.DashboardBulkActionData = exports.Dashboard = exports.Creator = exports.CheckStatusWidgetDefinition = exports.CheckCanDeleteSLOResponseData = exports.CheckCanDeleteSLOResponse = exports.CheckCanDeleteMonitorResponseData = exports.CheckCanDeleteMonitorResponse = exports.ChangeWidgetRequest = exports.ChangeWidgetDefinition = exports.CanceledDowntimesIds = exports.CancelDowntimesByScopeRequest = exports.AzureAccount = exports.AWSTagFilterListResponse = exports.AWSTagFilterDeleteRequest = exports.AWSTagFilterCreateRequest = exports.AWSTagFilter = exports.AWSLogsServicesRequest = exports.AWSLogsListServicesResponse = exports.AWSLogsListResponse = exports.AWSLogsLambda = exports.AWSLogsAsyncResponse = void 0;
exports.IPPrefixesAPI = exports.IPPrefixesAgents = exports.IntakePayloadAccepted = exports.ImageWidgetDefinition = exports.IFrameWidgetDefinition = exports.IdpResponse = exports.IdpFormData = exports.HTTPLogItem = exports.HTTPLogError = exports.HourlyUsageAttributionResponse = exports.HourlyUsageAttributionPagination = exports.HourlyUsageAttributionMetadata = exports.HourlyUsageAttributionBody = exports.HostTotals = exports.HostTags = exports.HostMuteSettings = exports.HostMuteResponse = exports.HostMetrics = exports.HostMetaInstallMethod = exports.HostMeta = exports.HostMapWidgetDefinitionStyle = exports.HostMapWidgetDefinitionRequests = exports.HostMapWidgetDefinition = exports.HostMapRequest = exports.HostListResponse = exports.Host = exports.HeatMapWidgetRequest = exports.HeatMapWidgetDefinition = exports.GroupWidgetDefinition = exports.GraphSnapshot = exports.GeomapWidgetRequest = exports.GeomapWidgetDefinitionView = exports.GeomapWidgetDefinitionStyle = exports.GeomapWidgetDefinition = exports.GCPAccount = exports.FunnelWidgetRequest = exports.FunnelWidgetDefinition = exports.FunnelStep = exports.FunnelQuery = exports.FreeTextWidgetDefinition = exports.FormulaAndFunctionProcessQueryDefinition = exports.FormulaAndFunctionMetricQueryDefinition = exports.FormulaAndFunctionEventQueryGroupBySort = exports.FormulaAndFunctionEventQueryGroupBy = exports.FormulaAndFunctionEventQueryDefinitionSearch = exports.FormulaAndFunctionEventQueryDefinitionCompute = exports.FormulaAndFunctionEventQueryDefinition = exports.FormulaAndFunctionApmResourceStatsQueryDefinition = exports.FormulaAndFunctionApmDependencyStatsQueryDefinition = exports.EventTimelineWidgetDefinition = void 0;
exports.LogsRetentionAggSumUsage = exports.LogsQueryCompute = exports.LogsPipelinesOrder = exports.LogsPipelineProcessor = exports.LogsPipeline = exports.LogsMessageRemapper = exports.LogsLookupProcessor = exports.LogsListResponse = exports.LogsListRequestTime = exports.LogsListRequest = exports.LogsIndexUpdateRequest = exports.LogsIndexListResponse = exports.LogsIndexesOrder = exports.LogsIndex = exports.LogsGrokParserRules = exports.LogsGrokParser = exports.LogsGeoIPParser = exports.LogsFilter = exports.LogsExclusionFilter = exports.LogsExclusion = exports.LogsDateRemapper = exports.LogsCategoryProcessorCategory = exports.LogsCategoryProcessor = exports.LogsByRetentionOrgUsage = exports.LogsByRetentionOrgs = exports.LogsByRetentionMonthlyUsage = exports.LogsByRetention = exports.LogsAttributeRemapper = exports.LogsArithmeticProcessor = exports.LogsAPIErrorResponse = exports.LogsAPIError = exports.LogQueryDefinitionSearch = exports.LogQueryDefinitionGroupBySort = exports.LogQueryDefinitionGroupBy = exports.LogQueryDefinition = exports.LogContent = exports.Log = exports.ListStreamWidgetRequest = exports.ListStreamWidgetDefinition = exports.ListStreamQuery = exports.ListStreamGroupByItems = exports.ListStreamComputeItems = exports.ListStreamColumn = exports.IPRanges = exports.IPPrefixesWebhooks = exports.IPPrefixesSyntheticsPrivateLocations = exports.IPPrefixesSynthetics = exports.IPPrefixesProcess = exports.IPPrefixesLogs = exports.IPPrefixesAPM = void 0;
exports.NotebookCellResponse = exports.NotebookCellCreateRequest = exports.NotebookAuthor = exports.NotebookAbsoluteTime = exports.MonthlyUsageAttributionValues = exports.MonthlyUsageAttributionResponse = exports.MonthlyUsageAttributionPagination = exports.MonthlyUsageAttributionMetadata = exports.MonthlyUsageAttributionBody = exports.MonitorUpdateRequest = exports.MonitorThresholdWindowOptions = exports.MonitorThresholds = exports.MonitorSummaryWidgetDefinition = exports.MonitorStateGroup = exports.MonitorState = exports.MonitorSearchResultNotification = exports.MonitorSearchResult = exports.MonitorSearchResponseMetadata = exports.MonitorSearchResponseCounts = exports.MonitorSearchResponse = exports.MonitorSearchCountItem = exports.MonitorOptionsSchedulingOptionsEvaluationWindow = exports.MonitorOptionsSchedulingOptions = exports.MonitorOptionsAggregation = exports.MonitorOptions = exports.MonitorGroupSearchResult = exports.MonitorGroupSearchResponseCounts = exports.MonitorGroupSearchResponse = exports.MonitorFormulaAndFunctionEventQueryGroupBySort = exports.MonitorFormulaAndFunctionEventQueryGroupBy = exports.MonitorFormulaAndFunctionEventQueryDefinitionSearch = exports.MonitorFormulaAndFunctionEventQueryDefinitionCompute = exports.MonitorFormulaAndFunctionEventQueryDefinition = exports.Monitor = exports.MetricsQueryUnit = exports.MetricsQueryResponse = exports.MetricsQueryMetadata = exports.MetricsPayload = exports.MetricsListResponse = exports.MetricSearchResponseResults = exports.MetricSearchResponse = exports.MetricMetadata = exports.LogsUserAgentParser = exports.LogsURLParser = exports.LogStreamWidgetDefinition = exports.LogsTraceRemapper = exports.LogsStringBuilderProcessor = exports.LogsStatusRemapper = exports.LogsServiceRemapper = exports.LogsRetentionSumUsage = void 0;
exports.RunWorkflowWidgetInput = exports.RunWorkflowWidgetDefinition = exports.ResponseMetaAttributes = exports.ReferenceTableLogsLookupProcessor = exports.QueryValueWidgetRequest = exports.QueryValueWidgetDefinition = exports.ProcessQueryDefinition = exports.Pagination = exports.PagerDutyServiceName = exports.PagerDutyServiceKey = exports.PagerDutyService = exports.OrgDowngradedResponse = exports.OrganizationSubscription = exports.OrganizationSettingsSamlStrictMode = exports.OrganizationSettingsSamlIdpInitiatedLogin = exports.OrganizationSettingsSamlAutocreateUsersDomains = exports.OrganizationSettingsSaml = exports.OrganizationSettings = exports.OrganizationResponse = exports.OrganizationListResponse = exports.OrganizationCreateResponse = exports.OrganizationCreateBody = exports.OrganizationBilling = exports.Organization = exports.NoteWidgetDefinition = exports.NotebookUpdateRequest = exports.NotebookUpdateDataAttributes = exports.NotebookUpdateData = exports.NotebookToplistCellAttributes = exports.NotebookTimeseriesCellAttributes = exports.NotebooksResponsePage = exports.NotebooksResponseMeta = exports.NotebooksResponseDataAttributes = exports.NotebooksResponseData = exports.NotebooksResponse = exports.NotebookSplitBy = exports.NotebookResponseDataAttributes = exports.NotebookResponseData = exports.NotebookResponse = exports.NotebookRelativeTime = exports.NotebookMetadata = exports.NotebookMarkdownCellDefinition = exports.NotebookMarkdownCellAttributes = exports.NotebookLogStreamCellAttributes = exports.NotebookHeatMapCellAttributes = exports.NotebookDistributionCellAttributes = exports.NotebookCreateRequest = exports.NotebookCreateDataAttributes = exports.NotebookCreateData = exports.NotebookCellUpdateRequest = void 0;
exports.SLOHistoryMetricsSeriesMetadataUnit = exports.SLOHistoryMetricsSeriesMetadata = exports.SLOHistoryMetricsSeries = exports.SLOHistoryMetrics = exports.SLODeleteResponse = exports.SLOCreator = exports.SLOCorrectionUpdateRequestAttributes = exports.SLOCorrectionUpdateRequest = exports.SLOCorrectionUpdateData = exports.SLOCorrectionResponseAttributesModifier = exports.SLOCorrectionResponseAttributes = exports.SLOCorrectionResponse = exports.SLOCorrectionListResponse = exports.SLOCorrectionCreateRequestAttributes = exports.SLOCorrectionCreateRequest = exports.SLOCorrectionCreateData = exports.SLOCorrection = exports.SLOBulkDeleteResponseData = exports.SLOBulkDeleteResponse = exports.SLOBulkDeleteError = exports.SlackIntegrationChannelDisplay = exports.SlackIntegrationChannel = exports.SignalStateUpdateRequest = exports.SignalAssigneeUpdateRequest = exports.ServiceSummaryWidgetDefinition = exports.ServiceMapWidgetDefinition = exports.ServiceLevelObjectiveRequest = exports.ServiceLevelObjectiveQuery = exports.ServiceLevelObjective = exports.ServiceCheck = exports.Series = exports.SearchSLOThreshold = exports.SearchSLOResponseMetaPage = exports.SearchSLOResponseMeta = exports.SearchSLOResponseLinks = exports.SearchSLOResponseDataAttributesFacetsObjectString = exports.SearchSLOResponseDataAttributesFacetsObjectInt = exports.SearchSLOResponseDataAttributesFacets = exports.SearchSLOResponseDataAttributes = exports.SearchSLOResponseData = exports.SearchSLOResponse = exports.SearchSLOQuery = exports.SearchServiceLevelObjectiveData = exports.SearchServiceLevelObjectiveAttributes = exports.SearchServiceLevelObjective = exports.ScatterplotWidgetFormula = exports.ScatterPlotWidgetDefinitionRequests = exports.ScatterPlotWidgetDefinition = exports.ScatterplotTableRequest = exports.ScatterPlotRequest = void 0;
exports.SyntheticsBrowserTestResultData = exports.SyntheticsBrowserTestConfig = exports.SyntheticsBrowserTest = exports.SyntheticsBrowserError = exports.SyntheticsBatchResult = exports.SyntheticsBatchDetailsData = exports.SyntheticsBatchDetails = exports.SyntheticsBasicAuthWeb = exports.SyntheticsBasicAuthSigv4 = exports.SyntheticsBasicAuthOauthROP = exports.SyntheticsBasicAuthOauthClient = exports.SyntheticsBasicAuthNTLM = exports.SyntheticsBasicAuthDigest = exports.SyntheticsAssertionXPathTargetTarget = exports.SyntheticsAssertionXPathTarget = exports.SyntheticsAssertionTarget = exports.SyntheticsAssertionJSONPathTargetTarget = exports.SyntheticsAssertionJSONPathTarget = exports.SyntheticsAPITestResultShortResult = exports.SyntheticsAPITestResultShort = exports.SyntheticsAPITestResultFullCheck = exports.SyntheticsAPITestResultFull = exports.SyntheticsApiTestResultFailure = exports.SyntheticsAPITestResultData = exports.SyntheticsAPITestConfig = exports.SyntheticsAPITest = exports.SyntheticsAPIStep = exports.SunburstWidgetRequest = exports.SunburstWidgetLegendTable = exports.SunburstWidgetLegendInlineAutomatic = exports.SunburstWidgetDefinition = exports.SuccessfulSignalUpdateResponse = exports.SLOWidgetDefinition = exports.SLOThreshold = exports.SLOResponseData = exports.SLOResponse = exports.SLORawErrorBudgetRemaining = exports.SLOOverallStatuses = exports.SLOListWidgetRequest = exports.SLOListWidgetQuery = exports.SLOListWidgetDefinition = exports.SLOListResponseMetadataPage = exports.SLOListResponseMetadata = exports.SLOListResponse = exports.SLOHistorySLIData = exports.SLOHistoryResponseErrorWithType = exports.SLOHistoryResponseError = exports.SLOHistoryResponseData = exports.SLOHistoryResponse = exports.SLOHistoryMonitor = void 0;
exports.SyntheticsTestOptions = exports.SyntheticsTestDetails = exports.SyntheticsTestConfig = exports.SyntheticsTestCiOptions = exports.SyntheticsStepDetailWarning = exports.SyntheticsStepDetail = exports.SyntheticsStep = exports.SyntheticsSSLCertificateSubject = exports.SyntheticsSSLCertificateIssuer = exports.SyntheticsSSLCertificate = exports.SyntheticsPrivateLocationSecretsConfigDecryption = exports.SyntheticsPrivateLocationSecretsAuthentication = exports.SyntheticsPrivateLocationSecrets = exports.SyntheticsPrivateLocationMetadata = exports.SyntheticsPrivateLocationCreationResponseResultEncryption = exports.SyntheticsPrivateLocationCreationResponse = exports.SyntheticsPrivateLocation = exports.SyntheticsParsingOptions = exports.SyntheticsLocations = exports.SyntheticsLocation = exports.SyntheticsListTestsResponse = exports.SyntheticsListGlobalVariablesResponse = exports.SyntheticsGlobalVariableValue = exports.SyntheticsGlobalVariableTOTPParameters = exports.SyntheticsGlobalVariableParseTestOptions = exports.SyntheticsGlobalVariableOptions = exports.SyntheticsGlobalVariableAttributes = exports.SyntheticsGlobalVariable = exports.SyntheticsGetBrowserTestLatestResultsResponse = exports.SyntheticsGetAPITestLatestResultsResponse = exports.SyntheticsDevice = exports.SyntheticsDeleteTestsResponse = exports.SyntheticsDeleteTestsPayload = exports.SyntheticsDeletedTest = exports.SyntheticsCoreWebVitals = exports.SyntheticsConfigVariable = exports.SyntheticsCITestBody = exports.SyntheticsCITest = exports.SyntheticsCIBatchMetadataProvider = exports.SyntheticsCIBatchMetadataPipeline = exports.SyntheticsCIBatchMetadataGit = exports.SyntheticsCIBatchMetadataCI = exports.SyntheticsCIBatchMetadata = exports.SyntheticsBrowserVariable = exports.SyntheticsBrowserTestRumSettings = exports.SyntheticsBrowserTestResultShortResult = exports.SyntheticsBrowserTestResultShort = exports.SyntheticsBrowserTestResultFullCheck = exports.SyntheticsBrowserTestResultFull = exports.SyntheticsBrowserTestResultFailure = void 0;
exports.UsageCustomReportsData = exports.UsageCustomReportsAttributes = exports.UsageCloudSecurityPostureManagementResponse = exports.UsageCloudSecurityPostureManagementHour = exports.UsageCIVisibilityResponse = exports.UsageCIVisibilityHour = exports.UsageBillableSummaryResponse = exports.UsageBillableSummaryKeys = exports.UsageBillableSummaryHour = exports.UsageBillableSummaryBody = exports.UsageAuditLogsResponse = exports.UsageAuditLogsHour = exports.UsageAttributionValues = exports.UsageAttributionResponse = exports.UsageAttributionPagination = exports.UsageAttributionMetadata = exports.UsageAttributionBody = exports.UsageAttributionAggregatesBody = exports.UsageAnalyzedLogsResponse = exports.UsageAnalyzedLogsHour = exports.TreeMapWidgetRequest = exports.TreeMapWidgetDefinition = exports.TopologyRequest = exports.TopologyQuery = exports.TopologyMapWidgetDefinition = exports.ToplistWidgetRequest = exports.ToplistWidgetDefinition = exports.TimeseriesWidgetRequest = exports.TimeseriesWidgetExpressionAlias = exports.TimeseriesWidgetDefinition = exports.TimeseriesBackground = exports.TagToHosts = exports.TableWidgetRequest = exports.TableWidgetDefinition = exports.SyntheticsVariableParser = exports.SyntheticsUpdateTestPauseStatusPayload = exports.SyntheticsTriggerTest = exports.SyntheticsTriggerCITestsResponse = exports.SyntheticsTriggerCITestRunResult = exports.SyntheticsTriggerCITestLocation = exports.SyntheticsTriggerBody = exports.SyntheticsTiming = exports.SyntheticsTestRequestProxy = exports.SyntheticsTestRequestCertificateItem = exports.SyntheticsTestRequestCertificate = exports.SyntheticsTestRequest = exports.SyntheticsTestOptionsSchedulingTimeframe = exports.SyntheticsTestOptionsScheduling = exports.SyntheticsTestOptionsRetry = exports.SyntheticsTestOptionsMonitorOptions = void 0;
exports.UsageSummaryDateOrg = exports.UsageSummaryDate = exports.UsageSpecifiedCustomReportsResponse = exports.UsageSpecifiedCustomReportsPage = exports.UsageSpecifiedCustomReportsMeta = exports.UsageSpecifiedCustomReportsData = exports.UsageSpecifiedCustomReportsAttributes = exports.UsageSNMPResponse = exports.UsageSNMPHour = exports.UsageSDSResponse = exports.UsageSDSHour = exports.UsageRumUnitsResponse = exports.UsageRumUnitsHour = exports.UsageRumSessionsResponse = exports.UsageRumSessionsHour = exports.UsageProfilingResponse = exports.UsageProfilingHour = exports.UsageOnlineArchiveResponse = exports.UsageOnlineArchiveHour = exports.UsageNetworkHostsResponse = exports.UsageNetworkHostsHour = exports.UsageNetworkFlowsResponse = exports.UsageNetworkFlowsHour = exports.UsageLogsResponse = exports.UsageLogsHour = exports.UsageLogsByRetentionResponse = exports.UsageLogsByRetentionHour = exports.UsageLogsByIndexResponse = exports.UsageLogsByIndexHour = exports.UsageLambdaResponse = exports.UsageLambdaHour = exports.UsageIoTResponse = exports.UsageIoTHour = exports.UsageIngestedSpansResponse = exports.UsageIngestedSpansHour = exports.UsageIndexedSpansResponse = exports.UsageIndexedSpansHour = exports.UsageIncidentManagementResponse = exports.UsageIncidentManagementHour = exports.UsageHostsResponse = exports.UsageHostHour = exports.UsageFargateResponse = exports.UsageFargateHour = exports.UsageDBMResponse = exports.UsageDBMHour = exports.UsageCWSResponse = exports.UsageCWSHour = exports.UsageCustomReportsResponse = exports.UsageCustomReportsPage = exports.UsageCustomReportsMeta = void 0;
exports.ObjectSerializer = exports.WidgetTime = exports.WidgetStyle = exports.WidgetRequestStyle = exports.WidgetMarker = exports.WidgetLayout = exports.WidgetFormulaStyle = exports.WidgetFormulaLimit = exports.WidgetFormula = exports.WidgetFieldSort = exports.WidgetEvent = exports.WidgetCustomLink = exports.WidgetConditionalFormat = exports.WidgetAxis = exports.Widget = exports.WebhooksIntegrationUpdateRequest = exports.WebhooksIntegrationCustomVariableUpdateRequest = exports.WebhooksIntegrationCustomVariableResponse = exports.WebhooksIntegrationCustomVariable = exports.WebhooksIntegration = exports.UserResponse = exports.UserListResponse = exports.UserDisableResponse = exports.User = exports.UsageTopAvgMetricsResponse = exports.UsageTopAvgMetricsPagination = exports.UsageTopAvgMetricsMetadata = exports.UsageTopAvgMetricsHour = exports.UsageTimeseriesResponse = exports.UsageTimeseriesHour = exports.UsageSyntheticsResponse = exports.UsageSyntheticsHour = exports.UsageSyntheticsBrowserResponse = exports.UsageSyntheticsBrowserHour = exports.UsageSyntheticsAPIResponse = exports.UsageSyntheticsAPIHour = exports.UsageSummaryResponse = void 0;
var AWSIntegrationApi_1 = __webpack_require__(50502);
Object.defineProperty(exports, "AWSIntegrationApi", ({ enumerable: true, get: function () { return AWSIntegrationApi_1.AWSIntegrationApi; } }));
var AWSLogsIntegrationApi_1 = __webpack_require__(60149);
Object.defineProperty(exports, "AWSLogsIntegrationApi", ({ enumerable: true, get: function () { return AWSLogsIntegrationApi_1.AWSLogsIntegrationApi; } }));
var AuthenticationApi_1 = __webpack_require__(34507);
Object.defineProperty(exports, "AuthenticationApi", ({ enumerable: true, get: function () { return AuthenticationApi_1.AuthenticationApi; } }));
var AzureIntegrationApi_1 = __webpack_require__(89924);
Object.defineProperty(exports, "AzureIntegrationApi", ({ enumerable: true, get: function () { return AzureIntegrationApi_1.AzureIntegrationApi; } }));
var DashboardListsApi_1 = __webpack_require__(6094);
Object.defineProperty(exports, "DashboardListsApi", ({ enumerable: true, get: function () { return DashboardListsApi_1.DashboardListsApi; } }));
var DashboardsApi_1 = __webpack_require__(24177);
Object.defineProperty(exports, "DashboardsApi", ({ enumerable: true, get: function () { return DashboardsApi_1.DashboardsApi; } }));
var DowntimesApi_1 = __webpack_require__(6602);
Object.defineProperty(exports, "DowntimesApi", ({ enumerable: true, get: function () { return DowntimesApi_1.DowntimesApi; } }));
var EventsApi_1 = __webpack_require__(58715);
Object.defineProperty(exports, "EventsApi", ({ enumerable: true, get: function () { return EventsApi_1.EventsApi; } }));
var GCPIntegrationApi_1 = __webpack_require__(4665);
Object.defineProperty(exports, "GCPIntegrationApi", ({ enumerable: true, get: function () { return GCPIntegrationApi_1.GCPIntegrationApi; } }));
var HostsApi_1 = __webpack_require__(89523);
Object.defineProperty(exports, "HostsApi", ({ enumerable: true, get: function () { return HostsApi_1.HostsApi; } }));
var IPRangesApi_1 = __webpack_require__(53075);
Object.defineProperty(exports, "IPRangesApi", ({ enumerable: true, get: function () { return IPRangesApi_1.IPRangesApi; } }));
var KeyManagementApi_1 = __webpack_require__(40263);
Object.defineProperty(exports, "KeyManagementApi", ({ enumerable: true, get: function () { return KeyManagementApi_1.KeyManagementApi; } }));
var LogsApi_1 = __webpack_require__(19068);
Object.defineProperty(exports, "LogsApi", ({ enumerable: true, get: function () { return LogsApi_1.LogsApi; } }));
var LogsIndexesApi_1 = __webpack_require__(19669);
Object.defineProperty(exports, "LogsIndexesApi", ({ enumerable: true, get: function () { return LogsIndexesApi_1.LogsIndexesApi; } }));
var LogsPipelinesApi_1 = __webpack_require__(94917);
Object.defineProperty(exports, "LogsPipelinesApi", ({ enumerable: true, get: function () { return LogsPipelinesApi_1.LogsPipelinesApi; } }));
var MetricsApi_1 = __webpack_require__(74433);
Object.defineProperty(exports, "MetricsApi", ({ enumerable: true, get: function () { return MetricsApi_1.MetricsApi; } }));
var MonitorsApi_1 = __webpack_require__(80638);
Object.defineProperty(exports, "MonitorsApi", ({ enumerable: true, get: function () { return MonitorsApi_1.MonitorsApi; } }));
var NotebooksApi_1 = __webpack_require__(61958);
Object.defineProperty(exports, "NotebooksApi", ({ enumerable: true, get: function () { return NotebooksApi_1.NotebooksApi; } }));
var OrganizationsApi_1 = __webpack_require__(83497);
Object.defineProperty(exports, "OrganizationsApi", ({ enumerable: true, get: function () { return OrganizationsApi_1.OrganizationsApi; } }));
var PagerDutyIntegrationApi_1 = __webpack_require__(35724);
Object.defineProperty(exports, "PagerDutyIntegrationApi", ({ enumerable: true, get: function () { return PagerDutyIntegrationApi_1.PagerDutyIntegrationApi; } }));
var SecurityMonitoringApi_1 = __webpack_require__(75362);
Object.defineProperty(exports, "SecurityMonitoringApi", ({ enumerable: true, get: function () { return SecurityMonitoringApi_1.SecurityMonitoringApi; } }));
var ServiceChecksApi_1 = __webpack_require__(72017);
Object.defineProperty(exports, "ServiceChecksApi", ({ enumerable: true, get: function () { return ServiceChecksApi_1.ServiceChecksApi; } }));
var ServiceLevelObjectiveCorrectionsApi_1 = __webpack_require__(80224);
Object.defineProperty(exports, "ServiceLevelObjectiveCorrectionsApi", ({ enumerable: true, get: function () { return ServiceLevelObjectiveCorrectionsApi_1.ServiceLevelObjectiveCorrectionsApi; } }));
var ServiceLevelObjectivesApi_1 = __webpack_require__(19863);
Object.defineProperty(exports, "ServiceLevelObjectivesApi", ({ enumerable: true, get: function () { return ServiceLevelObjectivesApi_1.ServiceLevelObjectivesApi; } }));
var SlackIntegrationApi_1 = __webpack_require__(52597);
Object.defineProperty(exports, "SlackIntegrationApi", ({ enumerable: true, get: function () { return SlackIntegrationApi_1.SlackIntegrationApi; } }));
var SnapshotsApi_1 = __webpack_require__(38840);
Object.defineProperty(exports, "SnapshotsApi", ({ enumerable: true, get: function () { return SnapshotsApi_1.SnapshotsApi; } }));
var SyntheticsApi_1 = __webpack_require__(99457);
Object.defineProperty(exports, "SyntheticsApi", ({ enumerable: true, get: function () { return SyntheticsApi_1.SyntheticsApi; } }));
var TagsApi_1 = __webpack_require__(71569);
Object.defineProperty(exports, "TagsApi", ({ enumerable: true, get: function () { return TagsApi_1.TagsApi; } }));
var UsageMeteringApi_1 = __webpack_require__(69255);
Object.defineProperty(exports, "UsageMeteringApi", ({ enumerable: true, get: function () { return UsageMeteringApi_1.UsageMeteringApi; } }));
var UsersApi_1 = __webpack_require__(56537);
Object.defineProperty(exports, "UsersApi", ({ enumerable: true, get: function () { return UsersApi_1.UsersApi; } }));
var WebhooksIntegrationApi_1 = __webpack_require__(80646);
Object.defineProperty(exports, "WebhooksIntegrationApi", ({ enumerable: true, get: function () { return WebhooksIntegrationApi_1.WebhooksIntegrationApi; } }));
var AddSignalToIncidentRequest_1 = __webpack_require__(53778);
Object.defineProperty(exports, "AddSignalToIncidentRequest", ({ enumerable: true, get: function () { return AddSignalToIncidentRequest_1.AddSignalToIncidentRequest; } }));
var AlertGraphWidgetDefinition_1 = __webpack_require__(30928);
Object.defineProperty(exports, "AlertGraphWidgetDefinition", ({ enumerable: true, get: function () { return AlertGraphWidgetDefinition_1.AlertGraphWidgetDefinition; } }));
var AlertValueWidgetDefinition_1 = __webpack_require__(35622);
Object.defineProperty(exports, "AlertValueWidgetDefinition", ({ enumerable: true, get: function () { return AlertValueWidgetDefinition_1.AlertValueWidgetDefinition; } }));
var APIErrorResponse_1 = __webpack_require__(94187);
Object.defineProperty(exports, "APIErrorResponse", ({ enumerable: true, get: function () { return APIErrorResponse_1.APIErrorResponse; } }));
var ApiKey_1 = __webpack_require__(4583);
Object.defineProperty(exports, "ApiKey", ({ enumerable: true, get: function () { return ApiKey_1.ApiKey; } }));
var ApiKeyListResponse_1 = __webpack_require__(7164);
Object.defineProperty(exports, "ApiKeyListResponse", ({ enumerable: true, get: function () { return ApiKeyListResponse_1.ApiKeyListResponse; } }));
var ApiKeyResponse_1 = __webpack_require__(82196);
Object.defineProperty(exports, "ApiKeyResponse", ({ enumerable: true, get: function () { return ApiKeyResponse_1.ApiKeyResponse; } }));
var ApmStatsQueryColumnType_1 = __webpack_require__(17056);
Object.defineProperty(exports, "ApmStatsQueryColumnType", ({ enumerable: true, get: function () { return ApmStatsQueryColumnType_1.ApmStatsQueryColumnType; } }));
var ApmStatsQueryDefinition_1 = __webpack_require__(61753);
Object.defineProperty(exports, "ApmStatsQueryDefinition", ({ enumerable: true, get: function () { return ApmStatsQueryDefinition_1.ApmStatsQueryDefinition; } }));
var ApplicationKey_1 = __webpack_require__(12260);
Object.defineProperty(exports, "ApplicationKey", ({ enumerable: true, get: function () { return ApplicationKey_1.ApplicationKey; } }));
var ApplicationKeyListResponse_1 = __webpack_require__(524);
Object.defineProperty(exports, "ApplicationKeyListResponse", ({ enumerable: true, get: function () { return ApplicationKeyListResponse_1.ApplicationKeyListResponse; } }));
var ApplicationKeyResponse_1 = __webpack_require__(53730);
Object.defineProperty(exports, "ApplicationKeyResponse", ({ enumerable: true, get: function () { return ApplicationKeyResponse_1.ApplicationKeyResponse; } }));
var AuthenticationValidationResponse_1 = __webpack_require__(11965);
Object.defineProperty(exports, "AuthenticationValidationResponse", ({ enumerable: true, get: function () { return AuthenticationValidationResponse_1.AuthenticationValidationResponse; } }));
var AWSAccount_1 = __webpack_require__(75107);
Object.defineProperty(exports, "AWSAccount", ({ enumerable: true, get: function () { return AWSAccount_1.AWSAccount; } }));
var AWSAccountAndLambdaRequest_1 = __webpack_require__(79616);
Object.defineProperty(exports, "AWSAccountAndLambdaRequest", ({ enumerable: true, get: function () { return AWSAccountAndLambdaRequest_1.AWSAccountAndLambdaRequest; } }));
var AWSAccountCreateResponse_1 = __webpack_require__(205);
Object.defineProperty(exports, "AWSAccountCreateResponse", ({ enumerable: true, get: function () { return AWSAccountCreateResponse_1.AWSAccountCreateResponse; } }));
var AWSAccountDeleteRequest_1 = __webpack_require__(11338);
Object.defineProperty(exports, "AWSAccountDeleteRequest", ({ enumerable: true, get: function () { return AWSAccountDeleteRequest_1.AWSAccountDeleteRequest; } }));
var AWSAccountListResponse_1 = __webpack_require__(51224);
Object.defineProperty(exports, "AWSAccountListResponse", ({ enumerable: true, get: function () { return AWSAccountListResponse_1.AWSAccountListResponse; } }));
var AWSLogsAsyncError_1 = __webpack_require__(62953);
Object.defineProperty(exports, "AWSLogsAsyncError", ({ enumerable: true, get: function () { return AWSLogsAsyncError_1.AWSLogsAsyncError; } }));
var AWSLogsAsyncResponse_1 = __webpack_require__(87558);
Object.defineProperty(exports, "AWSLogsAsyncResponse", ({ enumerable: true, get: function () { return AWSLogsAsyncResponse_1.AWSLogsAsyncResponse; } }));
var AWSLogsLambda_1 = __webpack_require__(99754);
Object.defineProperty(exports, "AWSLogsLambda", ({ enumerable: true, get: function () { return AWSLogsLambda_1.AWSLogsLambda; } }));
var AWSLogsListResponse_1 = __webpack_require__(9120);
Object.defineProperty(exports, "AWSLogsListResponse", ({ enumerable: true, get: function () { return AWSLogsListResponse_1.AWSLogsListResponse; } }));
var AWSLogsListServicesResponse_1 = __webpack_require__(77474);
Object.defineProperty(exports, "AWSLogsListServicesResponse", ({ enumerable: true, get: function () { return AWSLogsListServicesResponse_1.AWSLogsListServicesResponse; } }));
var AWSLogsServicesRequest_1 = __webpack_require__(57943);
Object.defineProperty(exports, "AWSLogsServicesRequest", ({ enumerable: true, get: function () { return AWSLogsServicesRequest_1.AWSLogsServicesRequest; } }));
var AWSTagFilter_1 = __webpack_require__(26166);
Object.defineProperty(exports, "AWSTagFilter", ({ enumerable: true, get: function () { return AWSTagFilter_1.AWSTagFilter; } }));
var AWSTagFilterCreateRequest_1 = __webpack_require__(8647);
Object.defineProperty(exports, "AWSTagFilterCreateRequest", ({ enumerable: true, get: function () { return AWSTagFilterCreateRequest_1.AWSTagFilterCreateRequest; } }));
var AWSTagFilterDeleteRequest_1 = __webpack_require__(81212);
Object.defineProperty(exports, "AWSTagFilterDeleteRequest", ({ enumerable: true, get: function () { return AWSTagFilterDeleteRequest_1.AWSTagFilterDeleteRequest; } }));
var AWSTagFilterListResponse_1 = __webpack_require__(28788);
Object.defineProperty(exports, "AWSTagFilterListResponse", ({ enumerable: true, get: function () { return AWSTagFilterListResponse_1.AWSTagFilterListResponse; } }));
var AzureAccount_1 = __webpack_require__(99096);
Object.defineProperty(exports, "AzureAccount", ({ enumerable: true, get: function () { return AzureAccount_1.AzureAccount; } }));
var CancelDowntimesByScopeRequest_1 = __webpack_require__(30337);
Object.defineProperty(exports, "CancelDowntimesByScopeRequest", ({ enumerable: true, get: function () { return CancelDowntimesByScopeRequest_1.CancelDowntimesByScopeRequest; } }));
var CanceledDowntimesIds_1 = __webpack_require__(49157);
Object.defineProperty(exports, "CanceledDowntimesIds", ({ enumerable: true, get: function () { return CanceledDowntimesIds_1.CanceledDowntimesIds; } }));
var ChangeWidgetDefinition_1 = __webpack_require__(59016);
Object.defineProperty(exports, "ChangeWidgetDefinition", ({ enumerable: true, get: function () { return ChangeWidgetDefinition_1.ChangeWidgetDefinition; } }));
var ChangeWidgetRequest_1 = __webpack_require__(71103);
Object.defineProperty(exports, "ChangeWidgetRequest", ({ enumerable: true, get: function () { return ChangeWidgetRequest_1.ChangeWidgetRequest; } }));
var CheckCanDeleteMonitorResponse_1 = __webpack_require__(55696);
Object.defineProperty(exports, "CheckCanDeleteMonitorResponse", ({ enumerable: true, get: function () { return CheckCanDeleteMonitorResponse_1.CheckCanDeleteMonitorResponse; } }));
var CheckCanDeleteMonitorResponseData_1 = __webpack_require__(8779);
Object.defineProperty(exports, "CheckCanDeleteMonitorResponseData", ({ enumerable: true, get: function () { return CheckCanDeleteMonitorResponseData_1.CheckCanDeleteMonitorResponseData; } }));
var CheckCanDeleteSLOResponse_1 = __webpack_require__(37497);
Object.defineProperty(exports, "CheckCanDeleteSLOResponse", ({ enumerable: true, get: function () { return CheckCanDeleteSLOResponse_1.CheckCanDeleteSLOResponse; } }));
var CheckCanDeleteSLOResponseData_1 = __webpack_require__(45281);
Object.defineProperty(exports, "CheckCanDeleteSLOResponseData", ({ enumerable: true, get: function () { return CheckCanDeleteSLOResponseData_1.CheckCanDeleteSLOResponseData; } }));
var CheckStatusWidgetDefinition_1 = __webpack_require__(92980);
Object.defineProperty(exports, "CheckStatusWidgetDefinition", ({ enumerable: true, get: function () { return CheckStatusWidgetDefinition_1.CheckStatusWidgetDefinition; } }));
var Creator_1 = __webpack_require__(84519);
Object.defineProperty(exports, "Creator", ({ enumerable: true, get: function () { return Creator_1.Creator; } }));
var Dashboard_1 = __webpack_require__(63114);
Object.defineProperty(exports, "Dashboard", ({ enumerable: true, get: function () { return Dashboard_1.Dashboard; } }));
var DashboardBulkActionData_1 = __webpack_require__(66634);
Object.defineProperty(exports, "DashboardBulkActionData", ({ enumerable: true, get: function () { return DashboardBulkActionData_1.DashboardBulkActionData; } }));
var DashboardBulkDeleteRequest_1 = __webpack_require__(14689);
Object.defineProperty(exports, "DashboardBulkDeleteRequest", ({ enumerable: true, get: function () { return DashboardBulkDeleteRequest_1.DashboardBulkDeleteRequest; } }));
var DashboardDeleteResponse_1 = __webpack_require__(22899);
Object.defineProperty(exports, "DashboardDeleteResponse", ({ enumerable: true, get: function () { return DashboardDeleteResponse_1.DashboardDeleteResponse; } }));
var DashboardList_1 = __webpack_require__(37165);
Object.defineProperty(exports, "DashboardList", ({ enumerable: true, get: function () { return DashboardList_1.DashboardList; } }));
var DashboardListDeleteResponse_1 = __webpack_require__(40167);
Object.defineProperty(exports, "DashboardListDeleteResponse", ({ enumerable: true, get: function () { return DashboardListDeleteResponse_1.DashboardListDeleteResponse; } }));
var DashboardListListResponse_1 = __webpack_require__(18934);
Object.defineProperty(exports, "DashboardListListResponse", ({ enumerable: true, get: function () { return DashboardListListResponse_1.DashboardListListResponse; } }));
var DashboardRestoreRequest_1 = __webpack_require__(15827);
Object.defineProperty(exports, "DashboardRestoreRequest", ({ enumerable: true, get: function () { return DashboardRestoreRequest_1.DashboardRestoreRequest; } }));
var DashboardSummary_1 = __webpack_require__(71472);
Object.defineProperty(exports, "DashboardSummary", ({ enumerable: true, get: function () { return DashboardSummary_1.DashboardSummary; } }));
var DashboardSummaryDefinition_1 = __webpack_require__(45087);
Object.defineProperty(exports, "DashboardSummaryDefinition", ({ enumerable: true, get: function () { return DashboardSummaryDefinition_1.DashboardSummaryDefinition; } }));
var DashboardTemplateVariable_1 = __webpack_require__(99326);
Object.defineProperty(exports, "DashboardTemplateVariable", ({ enumerable: true, get: function () { return DashboardTemplateVariable_1.DashboardTemplateVariable; } }));
var DashboardTemplateVariablePreset_1 = __webpack_require__(37874);
Object.defineProperty(exports, "DashboardTemplateVariablePreset", ({ enumerable: true, get: function () { return DashboardTemplateVariablePreset_1.DashboardTemplateVariablePreset; } }));
var DashboardTemplateVariablePresetValue_1 = __webpack_require__(7037);
Object.defineProperty(exports, "DashboardTemplateVariablePresetValue", ({ enumerable: true, get: function () { return DashboardTemplateVariablePresetValue_1.DashboardTemplateVariablePresetValue; } }));
var DeletedMonitor_1 = __webpack_require__(4711);
Object.defineProperty(exports, "DeletedMonitor", ({ enumerable: true, get: function () { return DeletedMonitor_1.DeletedMonitor; } }));
var DistributionPointsPayload_1 = __webpack_require__(5990);
Object.defineProperty(exports, "DistributionPointsPayload", ({ enumerable: true, get: function () { return DistributionPointsPayload_1.DistributionPointsPayload; } }));
var DistributionPointsSeries_1 = __webpack_require__(2963);
Object.defineProperty(exports, "DistributionPointsSeries", ({ enumerable: true, get: function () { return DistributionPointsSeries_1.DistributionPointsSeries; } }));
var DistributionWidgetDefinition_1 = __webpack_require__(88954);
Object.defineProperty(exports, "DistributionWidgetDefinition", ({ enumerable: true, get: function () { return DistributionWidgetDefinition_1.DistributionWidgetDefinition; } }));
var DistributionWidgetRequest_1 = __webpack_require__(54139);
Object.defineProperty(exports, "DistributionWidgetRequest", ({ enumerable: true, get: function () { return DistributionWidgetRequest_1.DistributionWidgetRequest; } }));
var DistributionWidgetXAxis_1 = __webpack_require__(59792);
Object.defineProperty(exports, "DistributionWidgetXAxis", ({ enumerable: true, get: function () { return DistributionWidgetXAxis_1.DistributionWidgetXAxis; } }));
var DistributionWidgetYAxis_1 = __webpack_require__(53869);
Object.defineProperty(exports, "DistributionWidgetYAxis", ({ enumerable: true, get: function () { return DistributionWidgetYAxis_1.DistributionWidgetYAxis; } }));
var Downtime_1 = __webpack_require__(66345);
Object.defineProperty(exports, "Downtime", ({ enumerable: true, get: function () { return Downtime_1.Downtime; } }));
var DowntimeChild_1 = __webpack_require__(36940);
Object.defineProperty(exports, "DowntimeChild", ({ enumerable: true, get: function () { return DowntimeChild_1.DowntimeChild; } }));
var DowntimeRecurrence_1 = __webpack_require__(10878);
Object.defineProperty(exports, "DowntimeRecurrence", ({ enumerable: true, get: function () { return DowntimeRecurrence_1.DowntimeRecurrence; } }));
var Event_1 = __webpack_require__(68426);
Object.defineProperty(exports, "Event", ({ enumerable: true, get: function () { return Event_1.Event; } }));
var EventCreateRequest_1 = __webpack_require__(98964);
Object.defineProperty(exports, "EventCreateRequest", ({ enumerable: true, get: function () { return EventCreateRequest_1.EventCreateRequest; } }));
var EventCreateResponse_1 = __webpack_require__(15571);
Object.defineProperty(exports, "EventCreateResponse", ({ enumerable: true, get: function () { return EventCreateResponse_1.EventCreateResponse; } }));
var EventListResponse_1 = __webpack_require__(64758);
Object.defineProperty(exports, "EventListResponse", ({ enumerable: true, get: function () { return EventListResponse_1.EventListResponse; } }));
var EventQueryDefinition_1 = __webpack_require__(86630);
Object.defineProperty(exports, "EventQueryDefinition", ({ enumerable: true, get: function () { return EventQueryDefinition_1.EventQueryDefinition; } }));
var EventResponse_1 = __webpack_require__(57097);
Object.defineProperty(exports, "EventResponse", ({ enumerable: true, get: function () { return EventResponse_1.EventResponse; } }));
var EventStreamWidgetDefinition_1 = __webpack_require__(41446);
Object.defineProperty(exports, "EventStreamWidgetDefinition", ({ enumerable: true, get: function () { return EventStreamWidgetDefinition_1.EventStreamWidgetDefinition; } }));
var EventTimelineWidgetDefinition_1 = __webpack_require__(5387);
Object.defineProperty(exports, "EventTimelineWidgetDefinition", ({ enumerable: true, get: function () { return EventTimelineWidgetDefinition_1.EventTimelineWidgetDefinition; } }));
var FormulaAndFunctionApmDependencyStatsQueryDefinition_1 = __webpack_require__(86280);
Object.defineProperty(exports, "FormulaAndFunctionApmDependencyStatsQueryDefinition", ({ enumerable: true, get: function () { return FormulaAndFunctionApmDependencyStatsQueryDefinition_1.FormulaAndFunctionApmDependencyStatsQueryDefinition; } }));
var FormulaAndFunctionApmResourceStatsQueryDefinition_1 = __webpack_require__(38483);
Object.defineProperty(exports, "FormulaAndFunctionApmResourceStatsQueryDefinition", ({ enumerable: true, get: function () { return FormulaAndFunctionApmResourceStatsQueryDefinition_1.FormulaAndFunctionApmResourceStatsQueryDefinition; } }));
var FormulaAndFunctionEventQueryDefinition_1 = __webpack_require__(922);
Object.defineProperty(exports, "FormulaAndFunctionEventQueryDefinition", ({ enumerable: true, get: function () { return FormulaAndFunctionEventQueryDefinition_1.FormulaAndFunctionEventQueryDefinition; } }));
var FormulaAndFunctionEventQueryDefinitionCompute_1 = __webpack_require__(23526);
Object.defineProperty(exports, "FormulaAndFunctionEventQueryDefinitionCompute", ({ enumerable: true, get: function () { return FormulaAndFunctionEventQueryDefinitionCompute_1.FormulaAndFunctionEventQueryDefinitionCompute; } }));
var FormulaAndFunctionEventQueryDefinitionSearch_1 = __webpack_require__(35781);
Object.defineProperty(exports, "FormulaAndFunctionEventQueryDefinitionSearch", ({ enumerable: true, get: function () { return FormulaAndFunctionEventQueryDefinitionSearch_1.FormulaAndFunctionEventQueryDefinitionSearch; } }));
var FormulaAndFunctionEventQueryGroupBy_1 = __webpack_require__(40218);
Object.defineProperty(exports, "FormulaAndFunctionEventQueryGroupBy", ({ enumerable: true, get: function () { return FormulaAndFunctionEventQueryGroupBy_1.FormulaAndFunctionEventQueryGroupBy; } }));
var FormulaAndFunctionEventQueryGroupBySort_1 = __webpack_require__(66766);
Object.defineProperty(exports, "FormulaAndFunctionEventQueryGroupBySort", ({ enumerable: true, get: function () { return FormulaAndFunctionEventQueryGroupBySort_1.FormulaAndFunctionEventQueryGroupBySort; } }));
var FormulaAndFunctionMetricQueryDefinition_1 = __webpack_require__(61311);
Object.defineProperty(exports, "FormulaAndFunctionMetricQueryDefinition", ({ enumerable: true, get: function () { return FormulaAndFunctionMetricQueryDefinition_1.FormulaAndFunctionMetricQueryDefinition; } }));
var FormulaAndFunctionProcessQueryDefinition_1 = __webpack_require__(57572);
Object.defineProperty(exports, "FormulaAndFunctionProcessQueryDefinition", ({ enumerable: true, get: function () { return FormulaAndFunctionProcessQueryDefinition_1.FormulaAndFunctionProcessQueryDefinition; } }));
var FreeTextWidgetDefinition_1 = __webpack_require__(3026);
Object.defineProperty(exports, "FreeTextWidgetDefinition", ({ enumerable: true, get: function () { return FreeTextWidgetDefinition_1.FreeTextWidgetDefinition; } }));
var FunnelQuery_1 = __webpack_require__(87832);
Object.defineProperty(exports, "FunnelQuery", ({ enumerable: true, get: function () { return FunnelQuery_1.FunnelQuery; } }));
var FunnelStep_1 = __webpack_require__(15073);
Object.defineProperty(exports, "FunnelStep", ({ enumerable: true, get: function () { return FunnelStep_1.FunnelStep; } }));
var FunnelWidgetDefinition_1 = __webpack_require__(20000);
Object.defineProperty(exports, "FunnelWidgetDefinition", ({ enumerable: true, get: function () { return FunnelWidgetDefinition_1.FunnelWidgetDefinition; } }));
var FunnelWidgetRequest_1 = __webpack_require__(75402);
Object.defineProperty(exports, "FunnelWidgetRequest", ({ enumerable: true, get: function () { return FunnelWidgetRequest_1.FunnelWidgetRequest; } }));
var GCPAccount_1 = __webpack_require__(78369);
Object.defineProperty(exports, "GCPAccount", ({ enumerable: true, get: function () { return GCPAccount_1.GCPAccount; } }));
var GeomapWidgetDefinition_1 = __webpack_require__(919);
Object.defineProperty(exports, "GeomapWidgetDefinition", ({ enumerable: true, get: function () { return GeomapWidgetDefinition_1.GeomapWidgetDefinition; } }));
var GeomapWidgetDefinitionStyle_1 = __webpack_require__(42280);
Object.defineProperty(exports, "GeomapWidgetDefinitionStyle", ({ enumerable: true, get: function () { return GeomapWidgetDefinitionStyle_1.GeomapWidgetDefinitionStyle; } }));
var GeomapWidgetDefinitionView_1 = __webpack_require__(92237);
Object.defineProperty(exports, "GeomapWidgetDefinitionView", ({ enumerable: true, get: function () { return GeomapWidgetDefinitionView_1.GeomapWidgetDefinitionView; } }));
var GeomapWidgetRequest_1 = __webpack_require__(47862);
Object.defineProperty(exports, "GeomapWidgetRequest", ({ enumerable: true, get: function () { return GeomapWidgetRequest_1.GeomapWidgetRequest; } }));
var GraphSnapshot_1 = __webpack_require__(13325);
Object.defineProperty(exports, "GraphSnapshot", ({ enumerable: true, get: function () { return GraphSnapshot_1.GraphSnapshot; } }));
var GroupWidgetDefinition_1 = __webpack_require__(82330);
Object.defineProperty(exports, "GroupWidgetDefinition", ({ enumerable: true, get: function () { return GroupWidgetDefinition_1.GroupWidgetDefinition; } }));
var HeatMapWidgetDefinition_1 = __webpack_require__(84622);
Object.defineProperty(exports, "HeatMapWidgetDefinition", ({ enumerable: true, get: function () { return HeatMapWidgetDefinition_1.HeatMapWidgetDefinition; } }));
var HeatMapWidgetRequest_1 = __webpack_require__(82293);
Object.defineProperty(exports, "HeatMapWidgetRequest", ({ enumerable: true, get: function () { return HeatMapWidgetRequest_1.HeatMapWidgetRequest; } }));
var Host_1 = __webpack_require__(49556);
Object.defineProperty(exports, "Host", ({ enumerable: true, get: function () { return Host_1.Host; } }));
var HostListResponse_1 = __webpack_require__(16915);
Object.defineProperty(exports, "HostListResponse", ({ enumerable: true, get: function () { return HostListResponse_1.HostListResponse; } }));
var HostMapRequest_1 = __webpack_require__(25910);
Object.defineProperty(exports, "HostMapRequest", ({ enumerable: true, get: function () { return HostMapRequest_1.HostMapRequest; } }));
var HostMapWidgetDefinition_1 = __webpack_require__(59477);
Object.defineProperty(exports, "HostMapWidgetDefinition", ({ enumerable: true, get: function () { return HostMapWidgetDefinition_1.HostMapWidgetDefinition; } }));
var HostMapWidgetDefinitionRequests_1 = __webpack_require__(80831);
Object.defineProperty(exports, "HostMapWidgetDefinitionRequests", ({ enumerable: true, get: function () { return HostMapWidgetDefinitionRequests_1.HostMapWidgetDefinitionRequests; } }));
var HostMapWidgetDefinitionStyle_1 = __webpack_require__(42370);
Object.defineProperty(exports, "HostMapWidgetDefinitionStyle", ({ enumerable: true, get: function () { return HostMapWidgetDefinitionStyle_1.HostMapWidgetDefinitionStyle; } }));
var HostMeta_1 = __webpack_require__(48137);
Object.defineProperty(exports, "HostMeta", ({ enumerable: true, get: function () { return HostMeta_1.HostMeta; } }));
var HostMetaInstallMethod_1 = __webpack_require__(33508);
Object.defineProperty(exports, "HostMetaInstallMethod", ({ enumerable: true, get: function () { return HostMetaInstallMethod_1.HostMetaInstallMethod; } }));
var HostMetrics_1 = __webpack_require__(70176);
Object.defineProperty(exports, "HostMetrics", ({ enumerable: true, get: function () { return HostMetrics_1.HostMetrics; } }));
var HostMuteResponse_1 = __webpack_require__(43814);
Object.defineProperty(exports, "HostMuteResponse", ({ enumerable: true, get: function () { return HostMuteResponse_1.HostMuteResponse; } }));
var HostMuteSettings_1 = __webpack_require__(52003);
Object.defineProperty(exports, "HostMuteSettings", ({ enumerable: true, get: function () { return HostMuteSettings_1.HostMuteSettings; } }));
var HostTags_1 = __webpack_require__(14891);
Object.defineProperty(exports, "HostTags", ({ enumerable: true, get: function () { return HostTags_1.HostTags; } }));
var HostTotals_1 = __webpack_require__(78002);
Object.defineProperty(exports, "HostTotals", ({ enumerable: true, get: function () { return HostTotals_1.HostTotals; } }));
var HourlyUsageAttributionBody_1 = __webpack_require__(60079);
Object.defineProperty(exports, "HourlyUsageAttributionBody", ({ enumerable: true, get: function () { return HourlyUsageAttributionBody_1.HourlyUsageAttributionBody; } }));
var HourlyUsageAttributionMetadata_1 = __webpack_require__(46590);
Object.defineProperty(exports, "HourlyUsageAttributionMetadata", ({ enumerable: true, get: function () { return HourlyUsageAttributionMetadata_1.HourlyUsageAttributionMetadata; } }));
var HourlyUsageAttributionPagination_1 = __webpack_require__(73798);
Object.defineProperty(exports, "HourlyUsageAttributionPagination", ({ enumerable: true, get: function () { return HourlyUsageAttributionPagination_1.HourlyUsageAttributionPagination; } }));
var HourlyUsageAttributionResponse_1 = __webpack_require__(81641);
Object.defineProperty(exports, "HourlyUsageAttributionResponse", ({ enumerable: true, get: function () { return HourlyUsageAttributionResponse_1.HourlyUsageAttributionResponse; } }));
var HTTPLogError_1 = __webpack_require__(81263);
Object.defineProperty(exports, "HTTPLogError", ({ enumerable: true, get: function () { return HTTPLogError_1.HTTPLogError; } }));
var HTTPLogItem_1 = __webpack_require__(19674);
Object.defineProperty(exports, "HTTPLogItem", ({ enumerable: true, get: function () { return HTTPLogItem_1.HTTPLogItem; } }));
var IdpFormData_1 = __webpack_require__(43719);
Object.defineProperty(exports, "IdpFormData", ({ enumerable: true, get: function () { return IdpFormData_1.IdpFormData; } }));
var IdpResponse_1 = __webpack_require__(91992);
Object.defineProperty(exports, "IdpResponse", ({ enumerable: true, get: function () { return IdpResponse_1.IdpResponse; } }));
var IFrameWidgetDefinition_1 = __webpack_require__(26242);
Object.defineProperty(exports, "IFrameWidgetDefinition", ({ enumerable: true, get: function () { return IFrameWidgetDefinition_1.IFrameWidgetDefinition; } }));
var ImageWidgetDefinition_1 = __webpack_require__(86051);
Object.defineProperty(exports, "ImageWidgetDefinition", ({ enumerable: true, get: function () { return ImageWidgetDefinition_1.ImageWidgetDefinition; } }));
var IntakePayloadAccepted_1 = __webpack_require__(71328);
Object.defineProperty(exports, "IntakePayloadAccepted", ({ enumerable: true, get: function () { return IntakePayloadAccepted_1.IntakePayloadAccepted; } }));
var IPPrefixesAgents_1 = __webpack_require__(15536);
Object.defineProperty(exports, "IPPrefixesAgents", ({ enumerable: true, get: function () { return IPPrefixesAgents_1.IPPrefixesAgents; } }));
var IPPrefixesAPI_1 = __webpack_require__(9737);
Object.defineProperty(exports, "IPPrefixesAPI", ({ enumerable: true, get: function () { return IPPrefixesAPI_1.IPPrefixesAPI; } }));
var IPPrefixesAPM_1 = __webpack_require__(51806);
Object.defineProperty(exports, "IPPrefixesAPM", ({ enumerable: true, get: function () { return IPPrefixesAPM_1.IPPrefixesAPM; } }));
var IPPrefixesLogs_1 = __webpack_require__(50334);
Object.defineProperty(exports, "IPPrefixesLogs", ({ enumerable: true, get: function () { return IPPrefixesLogs_1.IPPrefixesLogs; } }));
var IPPrefixesProcess_1 = __webpack_require__(16605);
Object.defineProperty(exports, "IPPrefixesProcess", ({ enumerable: true, get: function () { return IPPrefixesProcess_1.IPPrefixesProcess; } }));
var IPPrefixesSynthetics_1 = __webpack_require__(31933);
Object.defineProperty(exports, "IPPrefixesSynthetics", ({ enumerable: true, get: function () { return IPPrefixesSynthetics_1.IPPrefixesSynthetics; } }));
var IPPrefixesSyntheticsPrivateLocations_1 = __webpack_require__(29817);
Object.defineProperty(exports, "IPPrefixesSyntheticsPrivateLocations", ({ enumerable: true, get: function () { return IPPrefixesSyntheticsPrivateLocations_1.IPPrefixesSyntheticsPrivateLocations; } }));
var IPPrefixesWebhooks_1 = __webpack_require__(61031);
Object.defineProperty(exports, "IPPrefixesWebhooks", ({ enumerable: true, get: function () { return IPPrefixesWebhooks_1.IPPrefixesWebhooks; } }));
var IPRanges_1 = __webpack_require__(28956);
Object.defineProperty(exports, "IPRanges", ({ enumerable: true, get: function () { return IPRanges_1.IPRanges; } }));
var ListStreamColumn_1 = __webpack_require__(91106);
Object.defineProperty(exports, "ListStreamColumn", ({ enumerable: true, get: function () { return ListStreamColumn_1.ListStreamColumn; } }));
var ListStreamComputeItems_1 = __webpack_require__(63069);
Object.defineProperty(exports, "ListStreamComputeItems", ({ enumerable: true, get: function () { return ListStreamComputeItems_1.ListStreamComputeItems; } }));
var ListStreamGroupByItems_1 = __webpack_require__(6326);
Object.defineProperty(exports, "ListStreamGroupByItems", ({ enumerable: true, get: function () { return ListStreamGroupByItems_1.ListStreamGroupByItems; } }));
var ListStreamQuery_1 = __webpack_require__(44439);
Object.defineProperty(exports, "ListStreamQuery", ({ enumerable: true, get: function () { return ListStreamQuery_1.ListStreamQuery; } }));
var ListStreamWidgetDefinition_1 = __webpack_require__(49497);
Object.defineProperty(exports, "ListStreamWidgetDefinition", ({ enumerable: true, get: function () { return ListStreamWidgetDefinition_1.ListStreamWidgetDefinition; } }));
var ListStreamWidgetRequest_1 = __webpack_require__(80951);
Object.defineProperty(exports, "ListStreamWidgetRequest", ({ enumerable: true, get: function () { return ListStreamWidgetRequest_1.ListStreamWidgetRequest; } }));
var Log_1 = __webpack_require__(83438);
Object.defineProperty(exports, "Log", ({ enumerable: true, get: function () { return Log_1.Log; } }));
var LogContent_1 = __webpack_require__(67704);
Object.defineProperty(exports, "LogContent", ({ enumerable: true, get: function () { return LogContent_1.LogContent; } }));
var LogQueryDefinition_1 = __webpack_require__(12197);
Object.defineProperty(exports, "LogQueryDefinition", ({ enumerable: true, get: function () { return LogQueryDefinition_1.LogQueryDefinition; } }));
var LogQueryDefinitionGroupBy_1 = __webpack_require__(54246);
Object.defineProperty(exports, "LogQueryDefinitionGroupBy", ({ enumerable: true, get: function () { return LogQueryDefinitionGroupBy_1.LogQueryDefinitionGroupBy; } }));
var LogQueryDefinitionGroupBySort_1 = __webpack_require__(37827);
Object.defineProperty(exports, "LogQueryDefinitionGroupBySort", ({ enumerable: true, get: function () { return LogQueryDefinitionGroupBySort_1.LogQueryDefinitionGroupBySort; } }));
var LogQueryDefinitionSearch_1 = __webpack_require__(20235);
Object.defineProperty(exports, "LogQueryDefinitionSearch", ({ enumerable: true, get: function () { return LogQueryDefinitionSearch_1.LogQueryDefinitionSearch; } }));
var LogsAPIError_1 = __webpack_require__(27806);
Object.defineProperty(exports, "LogsAPIError", ({ enumerable: true, get: function () { return LogsAPIError_1.LogsAPIError; } }));
var LogsAPIErrorResponse_1 = __webpack_require__(25074);
Object.defineProperty(exports, "LogsAPIErrorResponse", ({ enumerable: true, get: function () { return LogsAPIErrorResponse_1.LogsAPIErrorResponse; } }));
var LogsArithmeticProcessor_1 = __webpack_require__(15426);
Object.defineProperty(exports, "LogsArithmeticProcessor", ({ enumerable: true, get: function () { return LogsArithmeticProcessor_1.LogsArithmeticProcessor; } }));
var LogsAttributeRemapper_1 = __webpack_require__(70365);
Object.defineProperty(exports, "LogsAttributeRemapper", ({ enumerable: true, get: function () { return LogsAttributeRemapper_1.LogsAttributeRemapper; } }));
var LogsByRetention_1 = __webpack_require__(97769);
Object.defineProperty(exports, "LogsByRetention", ({ enumerable: true, get: function () { return LogsByRetention_1.LogsByRetention; } }));
var LogsByRetentionMonthlyUsage_1 = __webpack_require__(96594);
Object.defineProperty(exports, "LogsByRetentionMonthlyUsage", ({ enumerable: true, get: function () { return LogsByRetentionMonthlyUsage_1.LogsByRetentionMonthlyUsage; } }));
var LogsByRetentionOrgs_1 = __webpack_require__(45185);
Object.defineProperty(exports, "LogsByRetentionOrgs", ({ enumerable: true, get: function () { return LogsByRetentionOrgs_1.LogsByRetentionOrgs; } }));
var LogsByRetentionOrgUsage_1 = __webpack_require__(79667);
Object.defineProperty(exports, "LogsByRetentionOrgUsage", ({ enumerable: true, get: function () { return LogsByRetentionOrgUsage_1.LogsByRetentionOrgUsage; } }));
var LogsCategoryProcessor_1 = __webpack_require__(40573);
Object.defineProperty(exports, "LogsCategoryProcessor", ({ enumerable: true, get: function () { return LogsCategoryProcessor_1.LogsCategoryProcessor; } }));
var LogsCategoryProcessorCategory_1 = __webpack_require__(10242);
Object.defineProperty(exports, "LogsCategoryProcessorCategory", ({ enumerable: true, get: function () { return LogsCategoryProcessorCategory_1.LogsCategoryProcessorCategory; } }));
var LogsDateRemapper_1 = __webpack_require__(34468);
Object.defineProperty(exports, "LogsDateRemapper", ({ enumerable: true, get: function () { return LogsDateRemapper_1.LogsDateRemapper; } }));
var LogsExclusion_1 = __webpack_require__(78203);
Object.defineProperty(exports, "LogsExclusion", ({ enumerable: true, get: function () { return LogsExclusion_1.LogsExclusion; } }));
var LogsExclusionFilter_1 = __webpack_require__(73573);
Object.defineProperty(exports, "LogsExclusionFilter", ({ enumerable: true, get: function () { return LogsExclusionFilter_1.LogsExclusionFilter; } }));
var LogsFilter_1 = __webpack_require__(96533);
Object.defineProperty(exports, "LogsFilter", ({ enumerable: true, get: function () { return LogsFilter_1.LogsFilter; } }));
var LogsGeoIPParser_1 = __webpack_require__(30810);
Object.defineProperty(exports, "LogsGeoIPParser", ({ enumerable: true, get: function () { return LogsGeoIPParser_1.LogsGeoIPParser; } }));
var LogsGrokParser_1 = __webpack_require__(86255);
Object.defineProperty(exports, "LogsGrokParser", ({ enumerable: true, get: function () { return LogsGrokParser_1.LogsGrokParser; } }));
var LogsGrokParserRules_1 = __webpack_require__(17200);
Object.defineProperty(exports, "LogsGrokParserRules", ({ enumerable: true, get: function () { return LogsGrokParserRules_1.LogsGrokParserRules; } }));
var LogsIndex_1 = __webpack_require__(67826);
Object.defineProperty(exports, "LogsIndex", ({ enumerable: true, get: function () { return LogsIndex_1.LogsIndex; } }));
var LogsIndexesOrder_1 = __webpack_require__(10785);
Object.defineProperty(exports, "LogsIndexesOrder", ({ enumerable: true, get: function () { return LogsIndexesOrder_1.LogsIndexesOrder; } }));
var LogsIndexListResponse_1 = __webpack_require__(32099);
Object.defineProperty(exports, "LogsIndexListResponse", ({ enumerable: true, get: function () { return LogsIndexListResponse_1.LogsIndexListResponse; } }));
var LogsIndexUpdateRequest_1 = __webpack_require__(60006);
Object.defineProperty(exports, "LogsIndexUpdateRequest", ({ enumerable: true, get: function () { return LogsIndexUpdateRequest_1.LogsIndexUpdateRequest; } }));
var LogsListRequest_1 = __webpack_require__(98514);
Object.defineProperty(exports, "LogsListRequest", ({ enumerable: true, get: function () { return LogsListRequest_1.LogsListRequest; } }));
var LogsListRequestTime_1 = __webpack_require__(21905);
Object.defineProperty(exports, "LogsListRequestTime", ({ enumerable: true, get: function () { return LogsListRequestTime_1.LogsListRequestTime; } }));
var LogsListResponse_1 = __webpack_require__(49469);
Object.defineProperty(exports, "LogsListResponse", ({ enumerable: true, get: function () { return LogsListResponse_1.LogsListResponse; } }));
var LogsLookupProcessor_1 = __webpack_require__(36335);
Object.defineProperty(exports, "LogsLookupProcessor", ({ enumerable: true, get: function () { return LogsLookupProcessor_1.LogsLookupProcessor; } }));
var LogsMessageRemapper_1 = __webpack_require__(1148);
Object.defineProperty(exports, "LogsMessageRemapper", ({ enumerable: true, get: function () { return LogsMessageRemapper_1.LogsMessageRemapper; } }));
var LogsPipeline_1 = __webpack_require__(62446);
Object.defineProperty(exports, "LogsPipeline", ({ enumerable: true, get: function () { return LogsPipeline_1.LogsPipeline; } }));
var LogsPipelineProcessor_1 = __webpack_require__(93445);
Object.defineProperty(exports, "LogsPipelineProcessor", ({ enumerable: true, get: function () { return LogsPipelineProcessor_1.LogsPipelineProcessor; } }));
var LogsPipelinesOrder_1 = __webpack_require__(53880);
Object.defineProperty(exports, "LogsPipelinesOrder", ({ enumerable: true, get: function () { return LogsPipelinesOrder_1.LogsPipelinesOrder; } }));
var LogsQueryCompute_1 = __webpack_require__(6239);
Object.defineProperty(exports, "LogsQueryCompute", ({ enumerable: true, get: function () { return LogsQueryCompute_1.LogsQueryCompute; } }));
var LogsRetentionAggSumUsage_1 = __webpack_require__(59107);
Object.defineProperty(exports, "LogsRetentionAggSumUsage", ({ enumerable: true, get: function () { return LogsRetentionAggSumUsage_1.LogsRetentionAggSumUsage; } }));
var LogsRetentionSumUsage_1 = __webpack_require__(93863);
Object.defineProperty(exports, "LogsRetentionSumUsage", ({ enumerable: true, get: function () { return LogsRetentionSumUsage_1.LogsRetentionSumUsage; } }));
var LogsServiceRemapper_1 = __webpack_require__(73178);
Object.defineProperty(exports, "LogsServiceRemapper", ({ enumerable: true, get: function () { return LogsServiceRemapper_1.LogsServiceRemapper; } }));
var LogsStatusRemapper_1 = __webpack_require__(6206);
Object.defineProperty(exports, "LogsStatusRemapper", ({ enumerable: true, get: function () { return LogsStatusRemapper_1.LogsStatusRemapper; } }));
var LogsStringBuilderProcessor_1 = __webpack_require__(54184);
Object.defineProperty(exports, "LogsStringBuilderProcessor", ({ enumerable: true, get: function () { return LogsStringBuilderProcessor_1.LogsStringBuilderProcessor; } }));
var LogsTraceRemapper_1 = __webpack_require__(69922);
Object.defineProperty(exports, "LogsTraceRemapper", ({ enumerable: true, get: function () { return LogsTraceRemapper_1.LogsTraceRemapper; } }));
var LogStreamWidgetDefinition_1 = __webpack_require__(76959);
Object.defineProperty(exports, "LogStreamWidgetDefinition", ({ enumerable: true, get: function () { return LogStreamWidgetDefinition_1.LogStreamWidgetDefinition; } }));
var LogsURLParser_1 = __webpack_require__(16650);
Object.defineProperty(exports, "LogsURLParser", ({ enumerable: true, get: function () { return LogsURLParser_1.LogsURLParser; } }));
var LogsUserAgentParser_1 = __webpack_require__(62792);
Object.defineProperty(exports, "LogsUserAgentParser", ({ enumerable: true, get: function () { return LogsUserAgentParser_1.LogsUserAgentParser; } }));
var MetricMetadata_1 = __webpack_require__(91082);
Object.defineProperty(exports, "MetricMetadata", ({ enumerable: true, get: function () { return MetricMetadata_1.MetricMetadata; } }));
var MetricSearchResponse_1 = __webpack_require__(5629);
Object.defineProperty(exports, "MetricSearchResponse", ({ enumerable: true, get: function () { return MetricSearchResponse_1.MetricSearchResponse; } }));
var MetricSearchResponseResults_1 = __webpack_require__(32036);
Object.defineProperty(exports, "MetricSearchResponseResults", ({ enumerable: true, get: function () { return MetricSearchResponseResults_1.MetricSearchResponseResults; } }));
var MetricsListResponse_1 = __webpack_require__(36562);
Object.defineProperty(exports, "MetricsListResponse", ({ enumerable: true, get: function () { return MetricsListResponse_1.MetricsListResponse; } }));
var MetricsPayload_1 = __webpack_require__(18312);
Object.defineProperty(exports, "MetricsPayload", ({ enumerable: true, get: function () { return MetricsPayload_1.MetricsPayload; } }));
var MetricsQueryMetadata_1 = __webpack_require__(94266);
Object.defineProperty(exports, "MetricsQueryMetadata", ({ enumerable: true, get: function () { return MetricsQueryMetadata_1.MetricsQueryMetadata; } }));
var MetricsQueryResponse_1 = __webpack_require__(10574);
Object.defineProperty(exports, "MetricsQueryResponse", ({ enumerable: true, get: function () { return MetricsQueryResponse_1.MetricsQueryResponse; } }));
var MetricsQueryUnit_1 = __webpack_require__(54581);
Object.defineProperty(exports, "MetricsQueryUnit", ({ enumerable: true, get: function () { return MetricsQueryUnit_1.MetricsQueryUnit; } }));
var Monitor_1 = __webpack_require__(45685);
Object.defineProperty(exports, "Monitor", ({ enumerable: true, get: function () { return Monitor_1.Monitor; } }));
var MonitorFormulaAndFunctionEventQueryDefinition_1 = __webpack_require__(58983);
Object.defineProperty(exports, "MonitorFormulaAndFunctionEventQueryDefinition", ({ enumerable: true, get: function () { return MonitorFormulaAndFunctionEventQueryDefinition_1.MonitorFormulaAndFunctionEventQueryDefinition; } }));
var MonitorFormulaAndFunctionEventQueryDefinitionCompute_1 = __webpack_require__(18547);
Object.defineProperty(exports, "MonitorFormulaAndFunctionEventQueryDefinitionCompute", ({ enumerable: true, get: function () { return MonitorFormulaAndFunctionEventQueryDefinitionCompute_1.MonitorFormulaAndFunctionEventQueryDefinitionCompute; } }));
var MonitorFormulaAndFunctionEventQueryDefinitionSearch_1 = __webpack_require__(22864);
Object.defineProperty(exports, "MonitorFormulaAndFunctionEventQueryDefinitionSearch", ({ enumerable: true, get: function () { return MonitorFormulaAndFunctionEventQueryDefinitionSearch_1.MonitorFormulaAndFunctionEventQueryDefinitionSearch; } }));
var MonitorFormulaAndFunctionEventQueryGroupBy_1 = __webpack_require__(23168);
Object.defineProperty(exports, "MonitorFormulaAndFunctionEventQueryGroupBy", ({ enumerable: true, get: function () { return MonitorFormulaAndFunctionEventQueryGroupBy_1.MonitorFormulaAndFunctionEventQueryGroupBy; } }));
var MonitorFormulaAndFunctionEventQueryGroupBySort_1 = __webpack_require__(45798);
Object.defineProperty(exports, "MonitorFormulaAndFunctionEventQueryGroupBySort", ({ enumerable: true, get: function () { return MonitorFormulaAndFunctionEventQueryGroupBySort_1.MonitorFormulaAndFunctionEventQueryGroupBySort; } }));
var MonitorGroupSearchResponse_1 = __webpack_require__(25941);
Object.defineProperty(exports, "MonitorGroupSearchResponse", ({ enumerable: true, get: function () { return MonitorGroupSearchResponse_1.MonitorGroupSearchResponse; } }));
var MonitorGroupSearchResponseCounts_1 = __webpack_require__(6527);
Object.defineProperty(exports, "MonitorGroupSearchResponseCounts", ({ enumerable: true, get: function () { return MonitorGroupSearchResponseCounts_1.MonitorGroupSearchResponseCounts; } }));
var MonitorGroupSearchResult_1 = __webpack_require__(55041);
Object.defineProperty(exports, "MonitorGroupSearchResult", ({ enumerable: true, get: function () { return MonitorGroupSearchResult_1.MonitorGroupSearchResult; } }));
var MonitorOptions_1 = __webpack_require__(48231);
Object.defineProperty(exports, "MonitorOptions", ({ enumerable: true, get: function () { return MonitorOptions_1.MonitorOptions; } }));
var MonitorOptionsAggregation_1 = __webpack_require__(48316);
Object.defineProperty(exports, "MonitorOptionsAggregation", ({ enumerable: true, get: function () { return MonitorOptionsAggregation_1.MonitorOptionsAggregation; } }));
var MonitorOptionsSchedulingOptions_1 = __webpack_require__(55782);
Object.defineProperty(exports, "MonitorOptionsSchedulingOptions", ({ enumerable: true, get: function () { return MonitorOptionsSchedulingOptions_1.MonitorOptionsSchedulingOptions; } }));
var MonitorOptionsSchedulingOptionsEvaluationWindow_1 = __webpack_require__(1362);
Object.defineProperty(exports, "MonitorOptionsSchedulingOptionsEvaluationWindow", ({ enumerable: true, get: function () { return MonitorOptionsSchedulingOptionsEvaluationWindow_1.MonitorOptionsSchedulingOptionsEvaluationWindow; } }));
var MonitorSearchCountItem_1 = __webpack_require__(31944);
Object.defineProperty(exports, "MonitorSearchCountItem", ({ enumerable: true, get: function () { return MonitorSearchCountItem_1.MonitorSearchCountItem; } }));
var MonitorSearchResponse_1 = __webpack_require__(40893);
Object.defineProperty(exports, "MonitorSearchResponse", ({ enumerable: true, get: function () { return MonitorSearchResponse_1.MonitorSearchResponse; } }));
var MonitorSearchResponseCounts_1 = __webpack_require__(80198);
Object.defineProperty(exports, "MonitorSearchResponseCounts", ({ enumerable: true, get: function () { return MonitorSearchResponseCounts_1.MonitorSearchResponseCounts; } }));
var MonitorSearchResponseMetadata_1 = __webpack_require__(78696);
Object.defineProperty(exports, "MonitorSearchResponseMetadata", ({ enumerable: true, get: function () { return MonitorSearchResponseMetadata_1.MonitorSearchResponseMetadata; } }));
var MonitorSearchResult_1 = __webpack_require__(14120);
Object.defineProperty(exports, "MonitorSearchResult", ({ enumerable: true, get: function () { return MonitorSearchResult_1.MonitorSearchResult; } }));
var MonitorSearchResultNotification_1 = __webpack_require__(17402);
Object.defineProperty(exports, "MonitorSearchResultNotification", ({ enumerable: true, get: function () { return MonitorSearchResultNotification_1.MonitorSearchResultNotification; } }));
var MonitorState_1 = __webpack_require__(27789);
Object.defineProperty(exports, "MonitorState", ({ enumerable: true, get: function () { return MonitorState_1.MonitorState; } }));
var MonitorStateGroup_1 = __webpack_require__(68737);
Object.defineProperty(exports, "MonitorStateGroup", ({ enumerable: true, get: function () { return MonitorStateGroup_1.MonitorStateGroup; } }));
var MonitorSummaryWidgetDefinition_1 = __webpack_require__(22788);
Object.defineProperty(exports, "MonitorSummaryWidgetDefinition", ({ enumerable: true, get: function () { return MonitorSummaryWidgetDefinition_1.MonitorSummaryWidgetDefinition; } }));
var MonitorThresholds_1 = __webpack_require__(28522);
Object.defineProperty(exports, "MonitorThresholds", ({ enumerable: true, get: function () { return MonitorThresholds_1.MonitorThresholds; } }));
var MonitorThresholdWindowOptions_1 = __webpack_require__(12780);
Object.defineProperty(exports, "MonitorThresholdWindowOptions", ({ enumerable: true, get: function () { return MonitorThresholdWindowOptions_1.MonitorThresholdWindowOptions; } }));
var MonitorUpdateRequest_1 = __webpack_require__(77039);
Object.defineProperty(exports, "MonitorUpdateRequest", ({ enumerable: true, get: function () { return MonitorUpdateRequest_1.MonitorUpdateRequest; } }));
var MonthlyUsageAttributionBody_1 = __webpack_require__(22537);
Object.defineProperty(exports, "MonthlyUsageAttributionBody", ({ enumerable: true, get: function () { return MonthlyUsageAttributionBody_1.MonthlyUsageAttributionBody; } }));
var MonthlyUsageAttributionMetadata_1 = __webpack_require__(25116);
Object.defineProperty(exports, "MonthlyUsageAttributionMetadata", ({ enumerable: true, get: function () { return MonthlyUsageAttributionMetadata_1.MonthlyUsageAttributionMetadata; } }));
var MonthlyUsageAttributionPagination_1 = __webpack_require__(73712);
Object.defineProperty(exports, "MonthlyUsageAttributionPagination", ({ enumerable: true, get: function () { return MonthlyUsageAttributionPagination_1.MonthlyUsageAttributionPagination; } }));
var MonthlyUsageAttributionResponse_1 = __webpack_require__(95112);
Object.defineProperty(exports, "MonthlyUsageAttributionResponse", ({ enumerable: true, get: function () { return MonthlyUsageAttributionResponse_1.MonthlyUsageAttributionResponse; } }));
var MonthlyUsageAttributionValues_1 = __webpack_require__(80336);
Object.defineProperty(exports, "MonthlyUsageAttributionValues", ({ enumerable: true, get: function () { return MonthlyUsageAttributionValues_1.MonthlyUsageAttributionValues; } }));
var NotebookAbsoluteTime_1 = __webpack_require__(65962);
Object.defineProperty(exports, "NotebookAbsoluteTime", ({ enumerable: true, get: function () { return NotebookAbsoluteTime_1.NotebookAbsoluteTime; } }));
var NotebookAuthor_1 = __webpack_require__(90658);
Object.defineProperty(exports, "NotebookAuthor", ({ enumerable: true, get: function () { return NotebookAuthor_1.NotebookAuthor; } }));
var NotebookCellCreateRequest_1 = __webpack_require__(62235);
Object.defineProperty(exports, "NotebookCellCreateRequest", ({ enumerable: true, get: function () { return NotebookCellCreateRequest_1.NotebookCellCreateRequest; } }));
var NotebookCellResponse_1 = __webpack_require__(84386);
Object.defineProperty(exports, "NotebookCellResponse", ({ enumerable: true, get: function () { return NotebookCellResponse_1.NotebookCellResponse; } }));
var NotebookCellUpdateRequest_1 = __webpack_require__(99902);
Object.defineProperty(exports, "NotebookCellUpdateRequest", ({ enumerable: true, get: function () { return NotebookCellUpdateRequest_1.NotebookCellUpdateRequest; } }));
var NotebookCreateData_1 = __webpack_require__(42541);
Object.defineProperty(exports, "NotebookCreateData", ({ enumerable: true, get: function () { return NotebookCreateData_1.NotebookCreateData; } }));
var NotebookCreateDataAttributes_1 = __webpack_require__(52931);
Object.defineProperty(exports, "NotebookCreateDataAttributes", ({ enumerable: true, get: function () { return NotebookCreateDataAttributes_1.NotebookCreateDataAttributes; } }));
var NotebookCreateRequest_1 = __webpack_require__(82520);
Object.defineProperty(exports, "NotebookCreateRequest", ({ enumerable: true, get: function () { return NotebookCreateRequest_1.NotebookCreateRequest; } }));
var NotebookDistributionCellAttributes_1 = __webpack_require__(87594);
Object.defineProperty(exports, "NotebookDistributionCellAttributes", ({ enumerable: true, get: function () { return NotebookDistributionCellAttributes_1.NotebookDistributionCellAttributes; } }));
var NotebookHeatMapCellAttributes_1 = __webpack_require__(81974);
Object.defineProperty(exports, "NotebookHeatMapCellAttributes", ({ enumerable: true, get: function () { return NotebookHeatMapCellAttributes_1.NotebookHeatMapCellAttributes; } }));
var NotebookLogStreamCellAttributes_1 = __webpack_require__(60761);
Object.defineProperty(exports, "NotebookLogStreamCellAttributes", ({ enumerable: true, get: function () { return NotebookLogStreamCellAttributes_1.NotebookLogStreamCellAttributes; } }));
var NotebookMarkdownCellAttributes_1 = __webpack_require__(3567);
Object.defineProperty(exports, "NotebookMarkdownCellAttributes", ({ enumerable: true, get: function () { return NotebookMarkdownCellAttributes_1.NotebookMarkdownCellAttributes; } }));
var NotebookMarkdownCellDefinition_1 = __webpack_require__(12035);
Object.defineProperty(exports, "NotebookMarkdownCellDefinition", ({ enumerable: true, get: function () { return NotebookMarkdownCellDefinition_1.NotebookMarkdownCellDefinition; } }));
var NotebookMetadata_1 = __webpack_require__(34078);
Object.defineProperty(exports, "NotebookMetadata", ({ enumerable: true, get: function () { return NotebookMetadata_1.NotebookMetadata; } }));
var NotebookRelativeTime_1 = __webpack_require__(94586);
Object.defineProperty(exports, "NotebookRelativeTime", ({ enumerable: true, get: function () { return NotebookRelativeTime_1.NotebookRelativeTime; } }));
var NotebookResponse_1 = __webpack_require__(43296);
Object.defineProperty(exports, "NotebookResponse", ({ enumerable: true, get: function () { return NotebookResponse_1.NotebookResponse; } }));
var NotebookResponseData_1 = __webpack_require__(59227);
Object.defineProperty(exports, "NotebookResponseData", ({ enumerable: true, get: function () { return NotebookResponseData_1.NotebookResponseData; } }));
var NotebookResponseDataAttributes_1 = __webpack_require__(59433);
Object.defineProperty(exports, "NotebookResponseDataAttributes", ({ enumerable: true, get: function () { return NotebookResponseDataAttributes_1.NotebookResponseDataAttributes; } }));
var NotebookSplitBy_1 = __webpack_require__(17911);
Object.defineProperty(exports, "NotebookSplitBy", ({ enumerable: true, get: function () { return NotebookSplitBy_1.NotebookSplitBy; } }));
var NotebooksResponse_1 = __webpack_require__(34680);
Object.defineProperty(exports, "NotebooksResponse", ({ enumerable: true, get: function () { return NotebooksResponse_1.NotebooksResponse; } }));
var NotebooksResponseData_1 = __webpack_require__(92333);
Object.defineProperty(exports, "NotebooksResponseData", ({ enumerable: true, get: function () { return NotebooksResponseData_1.NotebooksResponseData; } }));
var NotebooksResponseDataAttributes_1 = __webpack_require__(67182);
Object.defineProperty(exports, "NotebooksResponseDataAttributes", ({ enumerable: true, get: function () { return NotebooksResponseDataAttributes_1.NotebooksResponseDataAttributes; } }));
var NotebooksResponseMeta_1 = __webpack_require__(91514);
Object.defineProperty(exports, "NotebooksResponseMeta", ({ enumerable: true, get: function () { return NotebooksResponseMeta_1.NotebooksResponseMeta; } }));
var NotebooksResponsePage_1 = __webpack_require__(29365);
Object.defineProperty(exports, "NotebooksResponsePage", ({ enumerable: true, get: function () { return NotebooksResponsePage_1.NotebooksResponsePage; } }));
var NotebookTimeseriesCellAttributes_1 = __webpack_require__(38581);
Object.defineProperty(exports, "NotebookTimeseriesCellAttributes", ({ enumerable: true, get: function () { return NotebookTimeseriesCellAttributes_1.NotebookTimeseriesCellAttributes; } }));
var NotebookToplistCellAttributes_1 = __webpack_require__(45652);
Object.defineProperty(exports, "NotebookToplistCellAttributes", ({ enumerable: true, get: function () { return NotebookToplistCellAttributes_1.NotebookToplistCellAttributes; } }));
var NotebookUpdateData_1 = __webpack_require__(31500);
Object.defineProperty(exports, "NotebookUpdateData", ({ enumerable: true, get: function () { return NotebookUpdateData_1.NotebookUpdateData; } }));
var NotebookUpdateDataAttributes_1 = __webpack_require__(39612);
Object.defineProperty(exports, "NotebookUpdateDataAttributes", ({ enumerable: true, get: function () { return NotebookUpdateDataAttributes_1.NotebookUpdateDataAttributes; } }));
var NotebookUpdateRequest_1 = __webpack_require__(57229);
Object.defineProperty(exports, "NotebookUpdateRequest", ({ enumerable: true, get: function () { return NotebookUpdateRequest_1.NotebookUpdateRequest; } }));
var NoteWidgetDefinition_1 = __webpack_require__(35355);
Object.defineProperty(exports, "NoteWidgetDefinition", ({ enumerable: true, get: function () { return NoteWidgetDefinition_1.NoteWidgetDefinition; } }));
var Organization_1 = __webpack_require__(5080);
Object.defineProperty(exports, "Organization", ({ enumerable: true, get: function () { return Organization_1.Organization; } }));
var OrganizationBilling_1 = __webpack_require__(89008);
Object.defineProperty(exports, "OrganizationBilling", ({ enumerable: true, get: function () { return OrganizationBilling_1.OrganizationBilling; } }));
var OrganizationCreateBody_1 = __webpack_require__(16132);
Object.defineProperty(exports, "OrganizationCreateBody", ({ enumerable: true, get: function () { return OrganizationCreateBody_1.OrganizationCreateBody; } }));
var OrganizationCreateResponse_1 = __webpack_require__(24007);
Object.defineProperty(exports, "OrganizationCreateResponse", ({ enumerable: true, get: function () { return OrganizationCreateResponse_1.OrganizationCreateResponse; } }));
var OrganizationListResponse_1 = __webpack_require__(67823);
Object.defineProperty(exports, "OrganizationListResponse", ({ enumerable: true, get: function () { return OrganizationListResponse_1.OrganizationListResponse; } }));
var OrganizationResponse_1 = __webpack_require__(58106);
Object.defineProperty(exports, "OrganizationResponse", ({ enumerable: true, get: function () { return OrganizationResponse_1.OrganizationResponse; } }));
var OrganizationSettings_1 = __webpack_require__(49434);
Object.defineProperty(exports, "OrganizationSettings", ({ enumerable: true, get: function () { return OrganizationSettings_1.OrganizationSettings; } }));
var OrganizationSettingsSaml_1 = __webpack_require__(23808);
Object.defineProperty(exports, "OrganizationSettingsSaml", ({ enumerable: true, get: function () { return OrganizationSettingsSaml_1.OrganizationSettingsSaml; } }));
var OrganizationSettingsSamlAutocreateUsersDomains_1 = __webpack_require__(83448);
Object.defineProperty(exports, "OrganizationSettingsSamlAutocreateUsersDomains", ({ enumerable: true, get: function () { return OrganizationSettingsSamlAutocreateUsersDomains_1.OrganizationSettingsSamlAutocreateUsersDomains; } }));
var OrganizationSettingsSamlIdpInitiatedLogin_1 = __webpack_require__(79957);
Object.defineProperty(exports, "OrganizationSettingsSamlIdpInitiatedLogin", ({ enumerable: true, get: function () { return OrganizationSettingsSamlIdpInitiatedLogin_1.OrganizationSettingsSamlIdpInitiatedLogin; } }));
var OrganizationSettingsSamlStrictMode_1 = __webpack_require__(21101);
Object.defineProperty(exports, "OrganizationSettingsSamlStrictMode", ({ enumerable: true, get: function () { return OrganizationSettingsSamlStrictMode_1.OrganizationSettingsSamlStrictMode; } }));
var OrganizationSubscription_1 = __webpack_require__(75122);
Object.defineProperty(exports, "OrganizationSubscription", ({ enumerable: true, get: function () { return OrganizationSubscription_1.OrganizationSubscription; } }));
var OrgDowngradedResponse_1 = __webpack_require__(15364);
Object.defineProperty(exports, "OrgDowngradedResponse", ({ enumerable: true, get: function () { return OrgDowngradedResponse_1.OrgDowngradedResponse; } }));
var PagerDutyService_1 = __webpack_require__(99433);
Object.defineProperty(exports, "PagerDutyService", ({ enumerable: true, get: function () { return PagerDutyService_1.PagerDutyService; } }));
var PagerDutyServiceKey_1 = __webpack_require__(32766);
Object.defineProperty(exports, "PagerDutyServiceKey", ({ enumerable: true, get: function () { return PagerDutyServiceKey_1.PagerDutyServiceKey; } }));
var PagerDutyServiceName_1 = __webpack_require__(44198);
Object.defineProperty(exports, "PagerDutyServiceName", ({ enumerable: true, get: function () { return PagerDutyServiceName_1.PagerDutyServiceName; } }));
var Pagination_1 = __webpack_require__(97834);
Object.defineProperty(exports, "Pagination", ({ enumerable: true, get: function () { return Pagination_1.Pagination; } }));
var ProcessQueryDefinition_1 = __webpack_require__(96386);
Object.defineProperty(exports, "ProcessQueryDefinition", ({ enumerable: true, get: function () { return ProcessQueryDefinition_1.ProcessQueryDefinition; } }));
var QueryValueWidgetDefinition_1 = __webpack_require__(78268);
Object.defineProperty(exports, "QueryValueWidgetDefinition", ({ enumerable: true, get: function () { return QueryValueWidgetDefinition_1.QueryValueWidgetDefinition; } }));
var QueryValueWidgetRequest_1 = __webpack_require__(10384);
Object.defineProperty(exports, "QueryValueWidgetRequest", ({ enumerable: true, get: function () { return QueryValueWidgetRequest_1.QueryValueWidgetRequest; } }));
var ReferenceTableLogsLookupProcessor_1 = __webpack_require__(31537);
Object.defineProperty(exports, "ReferenceTableLogsLookupProcessor", ({ enumerable: true, get: function () { return ReferenceTableLogsLookupProcessor_1.ReferenceTableLogsLookupProcessor; } }));
var ResponseMetaAttributes_1 = __webpack_require__(44993);
Object.defineProperty(exports, "ResponseMetaAttributes", ({ enumerable: true, get: function () { return ResponseMetaAttributes_1.ResponseMetaAttributes; } }));
var RunWorkflowWidgetDefinition_1 = __webpack_require__(66209);
Object.defineProperty(exports, "RunWorkflowWidgetDefinition", ({ enumerable: true, get: function () { return RunWorkflowWidgetDefinition_1.RunWorkflowWidgetDefinition; } }));
var RunWorkflowWidgetInput_1 = __webpack_require__(71677);
Object.defineProperty(exports, "RunWorkflowWidgetInput", ({ enumerable: true, get: function () { return RunWorkflowWidgetInput_1.RunWorkflowWidgetInput; } }));
var ScatterPlotRequest_1 = __webpack_require__(90691);
Object.defineProperty(exports, "ScatterPlotRequest", ({ enumerable: true, get: function () { return ScatterPlotRequest_1.ScatterPlotRequest; } }));
var ScatterplotTableRequest_1 = __webpack_require__(95803);
Object.defineProperty(exports, "ScatterplotTableRequest", ({ enumerable: true, get: function () { return ScatterplotTableRequest_1.ScatterplotTableRequest; } }));
var ScatterPlotWidgetDefinition_1 = __webpack_require__(85820);
Object.defineProperty(exports, "ScatterPlotWidgetDefinition", ({ enumerable: true, get: function () { return ScatterPlotWidgetDefinition_1.ScatterPlotWidgetDefinition; } }));
var ScatterPlotWidgetDefinitionRequests_1 = __webpack_require__(6095);
Object.defineProperty(exports, "ScatterPlotWidgetDefinitionRequests", ({ enumerable: true, get: function () { return ScatterPlotWidgetDefinitionRequests_1.ScatterPlotWidgetDefinitionRequests; } }));
var ScatterplotWidgetFormula_1 = __webpack_require__(36910);
Object.defineProperty(exports, "ScatterplotWidgetFormula", ({ enumerable: true, get: function () { return ScatterplotWidgetFormula_1.ScatterplotWidgetFormula; } }));
var SearchServiceLevelObjective_1 = __webpack_require__(76963);
Object.defineProperty(exports, "SearchServiceLevelObjective", ({ enumerable: true, get: function () { return SearchServiceLevelObjective_1.SearchServiceLevelObjective; } }));
var SearchServiceLevelObjectiveAttributes_1 = __webpack_require__(21615);
Object.defineProperty(exports, "SearchServiceLevelObjectiveAttributes", ({ enumerable: true, get: function () { return SearchServiceLevelObjectiveAttributes_1.SearchServiceLevelObjectiveAttributes; } }));
var SearchServiceLevelObjectiveData_1 = __webpack_require__(31007);
Object.defineProperty(exports, "SearchServiceLevelObjectiveData", ({ enumerable: true, get: function () { return SearchServiceLevelObjectiveData_1.SearchServiceLevelObjectiveData; } }));
var SearchSLOQuery_1 = __webpack_require__(16851);
Object.defineProperty(exports, "SearchSLOQuery", ({ enumerable: true, get: function () { return SearchSLOQuery_1.SearchSLOQuery; } }));
var SearchSLOResponse_1 = __webpack_require__(79978);
Object.defineProperty(exports, "SearchSLOResponse", ({ enumerable: true, get: function () { return SearchSLOResponse_1.SearchSLOResponse; } }));
var SearchSLOResponseData_1 = __webpack_require__(64161);
Object.defineProperty(exports, "SearchSLOResponseData", ({ enumerable: true, get: function () { return SearchSLOResponseData_1.SearchSLOResponseData; } }));
var SearchSLOResponseDataAttributes_1 = __webpack_require__(17459);
Object.defineProperty(exports, "SearchSLOResponseDataAttributes", ({ enumerable: true, get: function () { return SearchSLOResponseDataAttributes_1.SearchSLOResponseDataAttributes; } }));
var SearchSLOResponseDataAttributesFacets_1 = __webpack_require__(70209);
Object.defineProperty(exports, "SearchSLOResponseDataAttributesFacets", ({ enumerable: true, get: function () { return SearchSLOResponseDataAttributesFacets_1.SearchSLOResponseDataAttributesFacets; } }));
var SearchSLOResponseDataAttributesFacetsObjectInt_1 = __webpack_require__(58199);
Object.defineProperty(exports, "SearchSLOResponseDataAttributesFacetsObjectInt", ({ enumerable: true, get: function () { return SearchSLOResponseDataAttributesFacetsObjectInt_1.SearchSLOResponseDataAttributesFacetsObjectInt; } }));
var SearchSLOResponseDataAttributesFacetsObjectString_1 = __webpack_require__(67630);
Object.defineProperty(exports, "SearchSLOResponseDataAttributesFacetsObjectString", ({ enumerable: true, get: function () { return SearchSLOResponseDataAttributesFacetsObjectString_1.SearchSLOResponseDataAttributesFacetsObjectString; } }));
var SearchSLOResponseLinks_1 = __webpack_require__(21812);
Object.defineProperty(exports, "SearchSLOResponseLinks", ({ enumerable: true, get: function () { return SearchSLOResponseLinks_1.SearchSLOResponseLinks; } }));
var SearchSLOResponseMeta_1 = __webpack_require__(15832);
Object.defineProperty(exports, "SearchSLOResponseMeta", ({ enumerable: true, get: function () { return SearchSLOResponseMeta_1.SearchSLOResponseMeta; } }));
var SearchSLOResponseMetaPage_1 = __webpack_require__(98664);
Object.defineProperty(exports, "SearchSLOResponseMetaPage", ({ enumerable: true, get: function () { return SearchSLOResponseMetaPage_1.SearchSLOResponseMetaPage; } }));
var SearchSLOThreshold_1 = __webpack_require__(23463);
Object.defineProperty(exports, "SearchSLOThreshold", ({ enumerable: true, get: function () { return SearchSLOThreshold_1.SearchSLOThreshold; } }));
var Series_1 = __webpack_require__(47757);
Object.defineProperty(exports, "Series", ({ enumerable: true, get: function () { return Series_1.Series; } }));
var ServiceCheck_1 = __webpack_require__(87544);
Object.defineProperty(exports, "ServiceCheck", ({ enumerable: true, get: function () { return ServiceCheck_1.ServiceCheck; } }));
var ServiceLevelObjective_1 = __webpack_require__(43228);
Object.defineProperty(exports, "ServiceLevelObjective", ({ enumerable: true, get: function () { return ServiceLevelObjective_1.ServiceLevelObjective; } }));
var ServiceLevelObjectiveQuery_1 = __webpack_require__(72178);
Object.defineProperty(exports, "ServiceLevelObjectiveQuery", ({ enumerable: true, get: function () { return ServiceLevelObjectiveQuery_1.ServiceLevelObjectiveQuery; } }));
var ServiceLevelObjectiveRequest_1 = __webpack_require__(20112);
Object.defineProperty(exports, "ServiceLevelObjectiveRequest", ({ enumerable: true, get: function () { return ServiceLevelObjectiveRequest_1.ServiceLevelObjectiveRequest; } }));
var ServiceMapWidgetDefinition_1 = __webpack_require__(96744);
Object.defineProperty(exports, "ServiceMapWidgetDefinition", ({ enumerable: true, get: function () { return ServiceMapWidgetDefinition_1.ServiceMapWidgetDefinition; } }));
var ServiceSummaryWidgetDefinition_1 = __webpack_require__(15351);
Object.defineProperty(exports, "ServiceSummaryWidgetDefinition", ({ enumerable: true, get: function () { return ServiceSummaryWidgetDefinition_1.ServiceSummaryWidgetDefinition; } }));
var SignalAssigneeUpdateRequest_1 = __webpack_require__(5609);
Object.defineProperty(exports, "SignalAssigneeUpdateRequest", ({ enumerable: true, get: function () { return SignalAssigneeUpdateRequest_1.SignalAssigneeUpdateRequest; } }));
var SignalStateUpdateRequest_1 = __webpack_require__(6223);
Object.defineProperty(exports, "SignalStateUpdateRequest", ({ enumerable: true, get: function () { return SignalStateUpdateRequest_1.SignalStateUpdateRequest; } }));
var SlackIntegrationChannel_1 = __webpack_require__(96032);
Object.defineProperty(exports, "SlackIntegrationChannel", ({ enumerable: true, get: function () { return SlackIntegrationChannel_1.SlackIntegrationChannel; } }));
var SlackIntegrationChannelDisplay_1 = __webpack_require__(7456);
Object.defineProperty(exports, "SlackIntegrationChannelDisplay", ({ enumerable: true, get: function () { return SlackIntegrationChannelDisplay_1.SlackIntegrationChannelDisplay; } }));
var SLOBulkDeleteError_1 = __webpack_require__(6307);
Object.defineProperty(exports, "SLOBulkDeleteError", ({ enumerable: true, get: function () { return SLOBulkDeleteError_1.SLOBulkDeleteError; } }));
var SLOBulkDeleteResponse_1 = __webpack_require__(53119);
Object.defineProperty(exports, "SLOBulkDeleteResponse", ({ enumerable: true, get: function () { return SLOBulkDeleteResponse_1.SLOBulkDeleteResponse; } }));
var SLOBulkDeleteResponseData_1 = __webpack_require__(28093);
Object.defineProperty(exports, "SLOBulkDeleteResponseData", ({ enumerable: true, get: function () { return SLOBulkDeleteResponseData_1.SLOBulkDeleteResponseData; } }));
var SLOCorrection_1 = __webpack_require__(2852);
Object.defineProperty(exports, "SLOCorrection", ({ enumerable: true, get: function () { return SLOCorrection_1.SLOCorrection; } }));
var SLOCorrectionCreateData_1 = __webpack_require__(43215);
Object.defineProperty(exports, "SLOCorrectionCreateData", ({ enumerable: true, get: function () { return SLOCorrectionCreateData_1.SLOCorrectionCreateData; } }));
var SLOCorrectionCreateRequest_1 = __webpack_require__(87152);
Object.defineProperty(exports, "SLOCorrectionCreateRequest", ({ enumerable: true, get: function () { return SLOCorrectionCreateRequest_1.SLOCorrectionCreateRequest; } }));
var SLOCorrectionCreateRequestAttributes_1 = __webpack_require__(26204);
Object.defineProperty(exports, "SLOCorrectionCreateRequestAttributes", ({ enumerable: true, get: function () { return SLOCorrectionCreateRequestAttributes_1.SLOCorrectionCreateRequestAttributes; } }));
var SLOCorrectionListResponse_1 = __webpack_require__(12062);
Object.defineProperty(exports, "SLOCorrectionListResponse", ({ enumerable: true, get: function () { return SLOCorrectionListResponse_1.SLOCorrectionListResponse; } }));
var SLOCorrectionResponse_1 = __webpack_require__(26986);
Object.defineProperty(exports, "SLOCorrectionResponse", ({ enumerable: true, get: function () { return SLOCorrectionResponse_1.SLOCorrectionResponse; } }));
var SLOCorrectionResponseAttributes_1 = __webpack_require__(35052);
Object.defineProperty(exports, "SLOCorrectionResponseAttributes", ({ enumerable: true, get: function () { return SLOCorrectionResponseAttributes_1.SLOCorrectionResponseAttributes; } }));
var SLOCorrectionResponseAttributesModifier_1 = __webpack_require__(88857);
Object.defineProperty(exports, "SLOCorrectionResponseAttributesModifier", ({ enumerable: true, get: function () { return SLOCorrectionResponseAttributesModifier_1.SLOCorrectionResponseAttributesModifier; } }));
var SLOCorrectionUpdateData_1 = __webpack_require__(99745);
Object.defineProperty(exports, "SLOCorrectionUpdateData", ({ enumerable: true, get: function () { return SLOCorrectionUpdateData_1.SLOCorrectionUpdateData; } }));
var SLOCorrectionUpdateRequest_1 = __webpack_require__(77273);
Object.defineProperty(exports, "SLOCorrectionUpdateRequest", ({ enumerable: true, get: function () { return SLOCorrectionUpdateRequest_1.SLOCorrectionUpdateRequest; } }));
var SLOCorrectionUpdateRequestAttributes_1 = __webpack_require__(75164);
Object.defineProperty(exports, "SLOCorrectionUpdateRequestAttributes", ({ enumerable: true, get: function () { return SLOCorrectionUpdateRequestAttributes_1.SLOCorrectionUpdateRequestAttributes; } }));
var SLOCreator_1 = __webpack_require__(52294);
Object.defineProperty(exports, "SLOCreator", ({ enumerable: true, get: function () { return SLOCreator_1.SLOCreator; } }));
var SLODeleteResponse_1 = __webpack_require__(47941);
Object.defineProperty(exports, "SLODeleteResponse", ({ enumerable: true, get: function () { return SLODeleteResponse_1.SLODeleteResponse; } }));
var SLOHistoryMetrics_1 = __webpack_require__(55029);
Object.defineProperty(exports, "SLOHistoryMetrics", ({ enumerable: true, get: function () { return SLOHistoryMetrics_1.SLOHistoryMetrics; } }));
var SLOHistoryMetricsSeries_1 = __webpack_require__(96132);
Object.defineProperty(exports, "SLOHistoryMetricsSeries", ({ enumerable: true, get: function () { return SLOHistoryMetricsSeries_1.SLOHistoryMetricsSeries; } }));
var SLOHistoryMetricsSeriesMetadata_1 = __webpack_require__(83288);
Object.defineProperty(exports, "SLOHistoryMetricsSeriesMetadata", ({ enumerable: true, get: function () { return SLOHistoryMetricsSeriesMetadata_1.SLOHistoryMetricsSeriesMetadata; } }));
var SLOHistoryMetricsSeriesMetadataUnit_1 = __webpack_require__(67323);
Object.defineProperty(exports, "SLOHistoryMetricsSeriesMetadataUnit", ({ enumerable: true, get: function () { return SLOHistoryMetricsSeriesMetadataUnit_1.SLOHistoryMetricsSeriesMetadataUnit; } }));
var SLOHistoryMonitor_1 = __webpack_require__(62797);
Object.defineProperty(exports, "SLOHistoryMonitor", ({ enumerable: true, get: function () { return SLOHistoryMonitor_1.SLOHistoryMonitor; } }));
var SLOHistoryResponse_1 = __webpack_require__(27297);
Object.defineProperty(exports, "SLOHistoryResponse", ({ enumerable: true, get: function () { return SLOHistoryResponse_1.SLOHistoryResponse; } }));
var SLOHistoryResponseData_1 = __webpack_require__(81357);
Object.defineProperty(exports, "SLOHistoryResponseData", ({ enumerable: true, get: function () { return SLOHistoryResponseData_1.SLOHistoryResponseData; } }));
var SLOHistoryResponseError_1 = __webpack_require__(30144);
Object.defineProperty(exports, "SLOHistoryResponseError", ({ enumerable: true, get: function () { return SLOHistoryResponseError_1.SLOHistoryResponseError; } }));
var SLOHistoryResponseErrorWithType_1 = __webpack_require__(58524);
Object.defineProperty(exports, "SLOHistoryResponseErrorWithType", ({ enumerable: true, get: function () { return SLOHistoryResponseErrorWithType_1.SLOHistoryResponseErrorWithType; } }));
var SLOHistorySLIData_1 = __webpack_require__(6636);
Object.defineProperty(exports, "SLOHistorySLIData", ({ enumerable: true, get: function () { return SLOHistorySLIData_1.SLOHistorySLIData; } }));
var SLOListResponse_1 = __webpack_require__(19477);
Object.defineProperty(exports, "SLOListResponse", ({ enumerable: true, get: function () { return SLOListResponse_1.SLOListResponse; } }));
var SLOListResponseMetadata_1 = __webpack_require__(95727);
Object.defineProperty(exports, "SLOListResponseMetadata", ({ enumerable: true, get: function () { return SLOListResponseMetadata_1.SLOListResponseMetadata; } }));
var SLOListResponseMetadataPage_1 = __webpack_require__(559);
Object.defineProperty(exports, "SLOListResponseMetadataPage", ({ enumerable: true, get: function () { return SLOListResponseMetadataPage_1.SLOListResponseMetadataPage; } }));
var SLOListWidgetDefinition_1 = __webpack_require__(87733);
Object.defineProperty(exports, "SLOListWidgetDefinition", ({ enumerable: true, get: function () { return SLOListWidgetDefinition_1.SLOListWidgetDefinition; } }));
var SLOListWidgetQuery_1 = __webpack_require__(77106);
Object.defineProperty(exports, "SLOListWidgetQuery", ({ enumerable: true, get: function () { return SLOListWidgetQuery_1.SLOListWidgetQuery; } }));
var SLOListWidgetRequest_1 = __webpack_require__(74176);
Object.defineProperty(exports, "SLOListWidgetRequest", ({ enumerable: true, get: function () { return SLOListWidgetRequest_1.SLOListWidgetRequest; } }));
var SLOOverallStatuses_1 = __webpack_require__(4058);
Object.defineProperty(exports, "SLOOverallStatuses", ({ enumerable: true, get: function () { return SLOOverallStatuses_1.SLOOverallStatuses; } }));
var SLORawErrorBudgetRemaining_1 = __webpack_require__(22565);
Object.defineProperty(exports, "SLORawErrorBudgetRemaining", ({ enumerable: true, get: function () { return SLORawErrorBudgetRemaining_1.SLORawErrorBudgetRemaining; } }));
var SLOResponse_1 = __webpack_require__(58530);
Object.defineProperty(exports, "SLOResponse", ({ enumerable: true, get: function () { return SLOResponse_1.SLOResponse; } }));
var SLOResponseData_1 = __webpack_require__(98608);
Object.defineProperty(exports, "SLOResponseData", ({ enumerable: true, get: function () { return SLOResponseData_1.SLOResponseData; } }));
var SLOThreshold_1 = __webpack_require__(96548);
Object.defineProperty(exports, "SLOThreshold", ({ enumerable: true, get: function () { return SLOThreshold_1.SLOThreshold; } }));
var SLOWidgetDefinition_1 = __webpack_require__(32026);
Object.defineProperty(exports, "SLOWidgetDefinition", ({ enumerable: true, get: function () { return SLOWidgetDefinition_1.SLOWidgetDefinition; } }));
var SuccessfulSignalUpdateResponse_1 = __webpack_require__(80928);
Object.defineProperty(exports, "SuccessfulSignalUpdateResponse", ({ enumerable: true, get: function () { return SuccessfulSignalUpdateResponse_1.SuccessfulSignalUpdateResponse; } }));
var SunburstWidgetDefinition_1 = __webpack_require__(20775);
Object.defineProperty(exports, "SunburstWidgetDefinition", ({ enumerable: true, get: function () { return SunburstWidgetDefinition_1.SunburstWidgetDefinition; } }));
var SunburstWidgetLegendInlineAutomatic_1 = __webpack_require__(1527);
Object.defineProperty(exports, "SunburstWidgetLegendInlineAutomatic", ({ enumerable: true, get: function () { return SunburstWidgetLegendInlineAutomatic_1.SunburstWidgetLegendInlineAutomatic; } }));
var SunburstWidgetLegendTable_1 = __webpack_require__(42284);
Object.defineProperty(exports, "SunburstWidgetLegendTable", ({ enumerable: true, get: function () { return SunburstWidgetLegendTable_1.SunburstWidgetLegendTable; } }));
var SunburstWidgetRequest_1 = __webpack_require__(60511);
Object.defineProperty(exports, "SunburstWidgetRequest", ({ enumerable: true, get: function () { return SunburstWidgetRequest_1.SunburstWidgetRequest; } }));
var SyntheticsAPIStep_1 = __webpack_require__(4175);
Object.defineProperty(exports, "SyntheticsAPIStep", ({ enumerable: true, get: function () { return SyntheticsAPIStep_1.SyntheticsAPIStep; } }));
var SyntheticsAPITest_1 = __webpack_require__(3433);
Object.defineProperty(exports, "SyntheticsAPITest", ({ enumerable: true, get: function () { return SyntheticsAPITest_1.SyntheticsAPITest; } }));
var SyntheticsAPITestConfig_1 = __webpack_require__(60634);
Object.defineProperty(exports, "SyntheticsAPITestConfig", ({ enumerable: true, get: function () { return SyntheticsAPITestConfig_1.SyntheticsAPITestConfig; } }));
var SyntheticsAPITestResultData_1 = __webpack_require__(21132);
Object.defineProperty(exports, "SyntheticsAPITestResultData", ({ enumerable: true, get: function () { return SyntheticsAPITestResultData_1.SyntheticsAPITestResultData; } }));
var SyntheticsApiTestResultFailure_1 = __webpack_require__(42098);
Object.defineProperty(exports, "SyntheticsApiTestResultFailure", ({ enumerable: true, get: function () { return SyntheticsApiTestResultFailure_1.SyntheticsApiTestResultFailure; } }));
var SyntheticsAPITestResultFull_1 = __webpack_require__(92111);
Object.defineProperty(exports, "SyntheticsAPITestResultFull", ({ enumerable: true, get: function () { return SyntheticsAPITestResultFull_1.SyntheticsAPITestResultFull; } }));
var SyntheticsAPITestResultFullCheck_1 = __webpack_require__(81032);
Object.defineProperty(exports, "SyntheticsAPITestResultFullCheck", ({ enumerable: true, get: function () { return SyntheticsAPITestResultFullCheck_1.SyntheticsAPITestResultFullCheck; } }));
var SyntheticsAPITestResultShort_1 = __webpack_require__(2048);
Object.defineProperty(exports, "SyntheticsAPITestResultShort", ({ enumerable: true, get: function () { return SyntheticsAPITestResultShort_1.SyntheticsAPITestResultShort; } }));
var SyntheticsAPITestResultShortResult_1 = __webpack_require__(85380);
Object.defineProperty(exports, "SyntheticsAPITestResultShortResult", ({ enumerable: true, get: function () { return SyntheticsAPITestResultShortResult_1.SyntheticsAPITestResultShortResult; } }));
var SyntheticsAssertionJSONPathTarget_1 = __webpack_require__(14493);
Object.defineProperty(exports, "SyntheticsAssertionJSONPathTarget", ({ enumerable: true, get: function () { return SyntheticsAssertionJSONPathTarget_1.SyntheticsAssertionJSONPathTarget; } }));
var SyntheticsAssertionJSONPathTargetTarget_1 = __webpack_require__(46885);
Object.defineProperty(exports, "SyntheticsAssertionJSONPathTargetTarget", ({ enumerable: true, get: function () { return SyntheticsAssertionJSONPathTargetTarget_1.SyntheticsAssertionJSONPathTargetTarget; } }));
var SyntheticsAssertionTarget_1 = __webpack_require__(11801);
Object.defineProperty(exports, "SyntheticsAssertionTarget", ({ enumerable: true, get: function () { return SyntheticsAssertionTarget_1.SyntheticsAssertionTarget; } }));
var SyntheticsAssertionXPathTarget_1 = __webpack_require__(77700);
Object.defineProperty(exports, "SyntheticsAssertionXPathTarget", ({ enumerable: true, get: function () { return SyntheticsAssertionXPathTarget_1.SyntheticsAssertionXPathTarget; } }));
var SyntheticsAssertionXPathTargetTarget_1 = __webpack_require__(55117);
Object.defineProperty(exports, "SyntheticsAssertionXPathTargetTarget", ({ enumerable: true, get: function () { return SyntheticsAssertionXPathTargetTarget_1.SyntheticsAssertionXPathTargetTarget; } }));
var SyntheticsBasicAuthDigest_1 = __webpack_require__(18046);
Object.defineProperty(exports, "SyntheticsBasicAuthDigest", ({ enumerable: true, get: function () { return SyntheticsBasicAuthDigest_1.SyntheticsBasicAuthDigest; } }));
var SyntheticsBasicAuthNTLM_1 = __webpack_require__(82481);
Object.defineProperty(exports, "SyntheticsBasicAuthNTLM", ({ enumerable: true, get: function () { return SyntheticsBasicAuthNTLM_1.SyntheticsBasicAuthNTLM; } }));
var SyntheticsBasicAuthOauthClient_1 = __webpack_require__(15718);
Object.defineProperty(exports, "SyntheticsBasicAuthOauthClient", ({ enumerable: true, get: function () { return SyntheticsBasicAuthOauthClient_1.SyntheticsBasicAuthOauthClient; } }));
var SyntheticsBasicAuthOauthROP_1 = __webpack_require__(3887);
Object.defineProperty(exports, "SyntheticsBasicAuthOauthROP", ({ enumerable: true, get: function () { return SyntheticsBasicAuthOauthROP_1.SyntheticsBasicAuthOauthROP; } }));
var SyntheticsBasicAuthSigv4_1 = __webpack_require__(30084);
Object.defineProperty(exports, "SyntheticsBasicAuthSigv4", ({ enumerable: true, get: function () { return SyntheticsBasicAuthSigv4_1.SyntheticsBasicAuthSigv4; } }));
var SyntheticsBasicAuthWeb_1 = __webpack_require__(82117);
Object.defineProperty(exports, "SyntheticsBasicAuthWeb", ({ enumerable: true, get: function () { return SyntheticsBasicAuthWeb_1.SyntheticsBasicAuthWeb; } }));
var SyntheticsBatchDetails_1 = __webpack_require__(82598);
Object.defineProperty(exports, "SyntheticsBatchDetails", ({ enumerable: true, get: function () { return SyntheticsBatchDetails_1.SyntheticsBatchDetails; } }));
var SyntheticsBatchDetailsData_1 = __webpack_require__(47215);
Object.defineProperty(exports, "SyntheticsBatchDetailsData", ({ enumerable: true, get: function () { return SyntheticsBatchDetailsData_1.SyntheticsBatchDetailsData; } }));
var SyntheticsBatchResult_1 = __webpack_require__(8974);
Object.defineProperty(exports, "SyntheticsBatchResult", ({ enumerable: true, get: function () { return SyntheticsBatchResult_1.SyntheticsBatchResult; } }));
var SyntheticsBrowserError_1 = __webpack_require__(7593);
Object.defineProperty(exports, "SyntheticsBrowserError", ({ enumerable: true, get: function () { return SyntheticsBrowserError_1.SyntheticsBrowserError; } }));
var SyntheticsBrowserTest_1 = __webpack_require__(44771);
Object.defineProperty(exports, "SyntheticsBrowserTest", ({ enumerable: true, get: function () { return SyntheticsBrowserTest_1.SyntheticsBrowserTest; } }));
var SyntheticsBrowserTestConfig_1 = __webpack_require__(73455);
Object.defineProperty(exports, "SyntheticsBrowserTestConfig", ({ enumerable: true, get: function () { return SyntheticsBrowserTestConfig_1.SyntheticsBrowserTestConfig; } }));
var SyntheticsBrowserTestResultData_1 = __webpack_require__(9337);
Object.defineProperty(exports, "SyntheticsBrowserTestResultData", ({ enumerable: true, get: function () { return SyntheticsBrowserTestResultData_1.SyntheticsBrowserTestResultData; } }));
var SyntheticsBrowserTestResultFailure_1 = __webpack_require__(80686);
Object.defineProperty(exports, "SyntheticsBrowserTestResultFailure", ({ enumerable: true, get: function () { return SyntheticsBrowserTestResultFailure_1.SyntheticsBrowserTestResultFailure; } }));
var SyntheticsBrowserTestResultFull_1 = __webpack_require__(88630);
Object.defineProperty(exports, "SyntheticsBrowserTestResultFull", ({ enumerable: true, get: function () { return SyntheticsBrowserTestResultFull_1.SyntheticsBrowserTestResultFull; } }));
var SyntheticsBrowserTestResultFullCheck_1 = __webpack_require__(32340);
Object.defineProperty(exports, "SyntheticsBrowserTestResultFullCheck", ({ enumerable: true, get: function () { return SyntheticsBrowserTestResultFullCheck_1.SyntheticsBrowserTestResultFullCheck; } }));
var SyntheticsBrowserTestResultShort_1 = __webpack_require__(2904);
Object.defineProperty(exports, "SyntheticsBrowserTestResultShort", ({ enumerable: true, get: function () { return SyntheticsBrowserTestResultShort_1.SyntheticsBrowserTestResultShort; } }));
var SyntheticsBrowserTestResultShortResult_1 = __webpack_require__(58505);
Object.defineProperty(exports, "SyntheticsBrowserTestResultShortResult", ({ enumerable: true, get: function () { return SyntheticsBrowserTestResultShortResult_1.SyntheticsBrowserTestResultShortResult; } }));
var SyntheticsBrowserTestRumSettings_1 = __webpack_require__(42556);
Object.defineProperty(exports, "SyntheticsBrowserTestRumSettings", ({ enumerable: true, get: function () { return SyntheticsBrowserTestRumSettings_1.SyntheticsBrowserTestRumSettings; } }));
var SyntheticsBrowserVariable_1 = __webpack_require__(35642);
Object.defineProperty(exports, "SyntheticsBrowserVariable", ({ enumerable: true, get: function () { return SyntheticsBrowserVariable_1.SyntheticsBrowserVariable; } }));
var SyntheticsCIBatchMetadata_1 = __webpack_require__(12212);
Object.defineProperty(exports, "SyntheticsCIBatchMetadata", ({ enumerable: true, get: function () { return SyntheticsCIBatchMetadata_1.SyntheticsCIBatchMetadata; } }));
var SyntheticsCIBatchMetadataCI_1 = __webpack_require__(20102);
Object.defineProperty(exports, "SyntheticsCIBatchMetadataCI", ({ enumerable: true, get: function () { return SyntheticsCIBatchMetadataCI_1.SyntheticsCIBatchMetadataCI; } }));
var SyntheticsCIBatchMetadataGit_1 = __webpack_require__(72392);
Object.defineProperty(exports, "SyntheticsCIBatchMetadataGit", ({ enumerable: true, get: function () { return SyntheticsCIBatchMetadataGit_1.SyntheticsCIBatchMetadataGit; } }));
var SyntheticsCIBatchMetadataPipeline_1 = __webpack_require__(31619);
Object.defineProperty(exports, "SyntheticsCIBatchMetadataPipeline", ({ enumerable: true, get: function () { return SyntheticsCIBatchMetadataPipeline_1.SyntheticsCIBatchMetadataPipeline; } }));
var SyntheticsCIBatchMetadataProvider_1 = __webpack_require__(75363);
Object.defineProperty(exports, "SyntheticsCIBatchMetadataProvider", ({ enumerable: true, get: function () { return SyntheticsCIBatchMetadataProvider_1.SyntheticsCIBatchMetadataProvider; } }));
var SyntheticsCITest_1 = __webpack_require__(56409);
Object.defineProperty(exports, "SyntheticsCITest", ({ enumerable: true, get: function () { return SyntheticsCITest_1.SyntheticsCITest; } }));
var SyntheticsCITestBody_1 = __webpack_require__(32615);
Object.defineProperty(exports, "SyntheticsCITestBody", ({ enumerable: true, get: function () { return SyntheticsCITestBody_1.SyntheticsCITestBody; } }));
var SyntheticsConfigVariable_1 = __webpack_require__(24023);
Object.defineProperty(exports, "SyntheticsConfigVariable", ({ enumerable: true, get: function () { return SyntheticsConfigVariable_1.SyntheticsConfigVariable; } }));
var SyntheticsCoreWebVitals_1 = __webpack_require__(67701);
Object.defineProperty(exports, "SyntheticsCoreWebVitals", ({ enumerable: true, get: function () { return SyntheticsCoreWebVitals_1.SyntheticsCoreWebVitals; } }));
var SyntheticsDeletedTest_1 = __webpack_require__(7885);
Object.defineProperty(exports, "SyntheticsDeletedTest", ({ enumerable: true, get: function () { return SyntheticsDeletedTest_1.SyntheticsDeletedTest; } }));
var SyntheticsDeleteTestsPayload_1 = __webpack_require__(60972);
Object.defineProperty(exports, "SyntheticsDeleteTestsPayload", ({ enumerable: true, get: function () { return SyntheticsDeleteTestsPayload_1.SyntheticsDeleteTestsPayload; } }));
var SyntheticsDeleteTestsResponse_1 = __webpack_require__(80634);
Object.defineProperty(exports, "SyntheticsDeleteTestsResponse", ({ enumerable: true, get: function () { return SyntheticsDeleteTestsResponse_1.SyntheticsDeleteTestsResponse; } }));
var SyntheticsDevice_1 = __webpack_require__(6906);
Object.defineProperty(exports, "SyntheticsDevice", ({ enumerable: true, get: function () { return SyntheticsDevice_1.SyntheticsDevice; } }));
var SyntheticsGetAPITestLatestResultsResponse_1 = __webpack_require__(42609);
Object.defineProperty(exports, "SyntheticsGetAPITestLatestResultsResponse", ({ enumerable: true, get: function () { return SyntheticsGetAPITestLatestResultsResponse_1.SyntheticsGetAPITestLatestResultsResponse; } }));
var SyntheticsGetBrowserTestLatestResultsResponse_1 = __webpack_require__(73873);
Object.defineProperty(exports, "SyntheticsGetBrowserTestLatestResultsResponse", ({ enumerable: true, get: function () { return SyntheticsGetBrowserTestLatestResultsResponse_1.SyntheticsGetBrowserTestLatestResultsResponse; } }));
var SyntheticsGlobalVariable_1 = __webpack_require__(10404);
Object.defineProperty(exports, "SyntheticsGlobalVariable", ({ enumerable: true, get: function () { return SyntheticsGlobalVariable_1.SyntheticsGlobalVariable; } }));
var SyntheticsGlobalVariableAttributes_1 = __webpack_require__(2156);
Object.defineProperty(exports, "SyntheticsGlobalVariableAttributes", ({ enumerable: true, get: function () { return SyntheticsGlobalVariableAttributes_1.SyntheticsGlobalVariableAttributes; } }));
var SyntheticsGlobalVariableOptions_1 = __webpack_require__(41521);
Object.defineProperty(exports, "SyntheticsGlobalVariableOptions", ({ enumerable: true, get: function () { return SyntheticsGlobalVariableOptions_1.SyntheticsGlobalVariableOptions; } }));
var SyntheticsGlobalVariableParseTestOptions_1 = __webpack_require__(60172);
Object.defineProperty(exports, "SyntheticsGlobalVariableParseTestOptions", ({ enumerable: true, get: function () { return SyntheticsGlobalVariableParseTestOptions_1.SyntheticsGlobalVariableParseTestOptions; } }));
var SyntheticsGlobalVariableTOTPParameters_1 = __webpack_require__(6429);
Object.defineProperty(exports, "SyntheticsGlobalVariableTOTPParameters", ({ enumerable: true, get: function () { return SyntheticsGlobalVariableTOTPParameters_1.SyntheticsGlobalVariableTOTPParameters; } }));
var SyntheticsGlobalVariableValue_1 = __webpack_require__(50263);
Object.defineProperty(exports, "SyntheticsGlobalVariableValue", ({ enumerable: true, get: function () { return SyntheticsGlobalVariableValue_1.SyntheticsGlobalVariableValue; } }));
var SyntheticsListGlobalVariablesResponse_1 = __webpack_require__(51341);
Object.defineProperty(exports, "SyntheticsListGlobalVariablesResponse", ({ enumerable: true, get: function () { return SyntheticsListGlobalVariablesResponse_1.SyntheticsListGlobalVariablesResponse; } }));
var SyntheticsListTestsResponse_1 = __webpack_require__(46280);
Object.defineProperty(exports, "SyntheticsListTestsResponse", ({ enumerable: true, get: function () { return SyntheticsListTestsResponse_1.SyntheticsListTestsResponse; } }));
var SyntheticsLocation_1 = __webpack_require__(36515);
Object.defineProperty(exports, "SyntheticsLocation", ({ enumerable: true, get: function () { return SyntheticsLocation_1.SyntheticsLocation; } }));
var SyntheticsLocations_1 = __webpack_require__(9091);
Object.defineProperty(exports, "SyntheticsLocations", ({ enumerable: true, get: function () { return SyntheticsLocations_1.SyntheticsLocations; } }));
var SyntheticsParsingOptions_1 = __webpack_require__(5015);
Object.defineProperty(exports, "SyntheticsParsingOptions", ({ enumerable: true, get: function () { return SyntheticsParsingOptions_1.SyntheticsParsingOptions; } }));
var SyntheticsPrivateLocation_1 = __webpack_require__(6991);
Object.defineProperty(exports, "SyntheticsPrivateLocation", ({ enumerable: true, get: function () { return SyntheticsPrivateLocation_1.SyntheticsPrivateLocation; } }));
var SyntheticsPrivateLocationCreationResponse_1 = __webpack_require__(31386);
Object.defineProperty(exports, "SyntheticsPrivateLocationCreationResponse", ({ enumerable: true, get: function () { return SyntheticsPrivateLocationCreationResponse_1.SyntheticsPrivateLocationCreationResponse; } }));
var SyntheticsPrivateLocationCreationResponseResultEncryption_1 = __webpack_require__(16331);
Object.defineProperty(exports, "SyntheticsPrivateLocationCreationResponseResultEncryption", ({ enumerable: true, get: function () { return SyntheticsPrivateLocationCreationResponseResultEncryption_1.SyntheticsPrivateLocationCreationResponseResultEncryption; } }));
var SyntheticsPrivateLocationMetadata_1 = __webpack_require__(89160);
Object.defineProperty(exports, "SyntheticsPrivateLocationMetadata", ({ enumerable: true, get: function () { return SyntheticsPrivateLocationMetadata_1.SyntheticsPrivateLocationMetadata; } }));
var SyntheticsPrivateLocationSecrets_1 = __webpack_require__(91325);
Object.defineProperty(exports, "SyntheticsPrivateLocationSecrets", ({ enumerable: true, get: function () { return SyntheticsPrivateLocationSecrets_1.SyntheticsPrivateLocationSecrets; } }));
var SyntheticsPrivateLocationSecretsAuthentication_1 = __webpack_require__(26886);
Object.defineProperty(exports, "SyntheticsPrivateLocationSecretsAuthentication", ({ enumerable: true, get: function () { return SyntheticsPrivateLocationSecretsAuthentication_1.SyntheticsPrivateLocationSecretsAuthentication; } }));
var SyntheticsPrivateLocationSecretsConfigDecryption_1 = __webpack_require__(24829);
Object.defineProperty(exports, "SyntheticsPrivateLocationSecretsConfigDecryption", ({ enumerable: true, get: function () { return SyntheticsPrivateLocationSecretsConfigDecryption_1.SyntheticsPrivateLocationSecretsConfigDecryption; } }));
var SyntheticsSSLCertificate_1 = __webpack_require__(24211);
Object.defineProperty(exports, "SyntheticsSSLCertificate", ({ enumerable: true, get: function () { return SyntheticsSSLCertificate_1.SyntheticsSSLCertificate; } }));
var SyntheticsSSLCertificateIssuer_1 = __webpack_require__(70007);
Object.defineProperty(exports, "SyntheticsSSLCertificateIssuer", ({ enumerable: true, get: function () { return SyntheticsSSLCertificateIssuer_1.SyntheticsSSLCertificateIssuer; } }));
var SyntheticsSSLCertificateSubject_1 = __webpack_require__(75798);
Object.defineProperty(exports, "SyntheticsSSLCertificateSubject", ({ enumerable: true, get: function () { return SyntheticsSSLCertificateSubject_1.SyntheticsSSLCertificateSubject; } }));
var SyntheticsStep_1 = __webpack_require__(96180);
Object.defineProperty(exports, "SyntheticsStep", ({ enumerable: true, get: function () { return SyntheticsStep_1.SyntheticsStep; } }));
var SyntheticsStepDetail_1 = __webpack_require__(86493);
Object.defineProperty(exports, "SyntheticsStepDetail", ({ enumerable: true, get: function () { return SyntheticsStepDetail_1.SyntheticsStepDetail; } }));
var SyntheticsStepDetailWarning_1 = __webpack_require__(86754);
Object.defineProperty(exports, "SyntheticsStepDetailWarning", ({ enumerable: true, get: function () { return SyntheticsStepDetailWarning_1.SyntheticsStepDetailWarning; } }));
var SyntheticsTestCiOptions_1 = __webpack_require__(38758);
Object.defineProperty(exports, "SyntheticsTestCiOptions", ({ enumerable: true, get: function () { return SyntheticsTestCiOptions_1.SyntheticsTestCiOptions; } }));
var SyntheticsTestConfig_1 = __webpack_require__(91535);
Object.defineProperty(exports, "SyntheticsTestConfig", ({ enumerable: true, get: function () { return SyntheticsTestConfig_1.SyntheticsTestConfig; } }));
var SyntheticsTestDetails_1 = __webpack_require__(22701);
Object.defineProperty(exports, "SyntheticsTestDetails", ({ enumerable: true, get: function () { return SyntheticsTestDetails_1.SyntheticsTestDetails; } }));
var SyntheticsTestOptions_1 = __webpack_require__(55515);
Object.defineProperty(exports, "SyntheticsTestOptions", ({ enumerable: true, get: function () { return SyntheticsTestOptions_1.SyntheticsTestOptions; } }));
var SyntheticsTestOptionsMonitorOptions_1 = __webpack_require__(37717);
Object.defineProperty(exports, "SyntheticsTestOptionsMonitorOptions", ({ enumerable: true, get: function () { return SyntheticsTestOptionsMonitorOptions_1.SyntheticsTestOptionsMonitorOptions; } }));
var SyntheticsTestOptionsRetry_1 = __webpack_require__(76723);
Object.defineProperty(exports, "SyntheticsTestOptionsRetry", ({ enumerable: true, get: function () { return SyntheticsTestOptionsRetry_1.SyntheticsTestOptionsRetry; } }));
var SyntheticsTestOptionsScheduling_1 = __webpack_require__(24636);
Object.defineProperty(exports, "SyntheticsTestOptionsScheduling", ({ enumerable: true, get: function () { return SyntheticsTestOptionsScheduling_1.SyntheticsTestOptionsScheduling; } }));
var SyntheticsTestOptionsSchedulingTimeframe_1 = __webpack_require__(15344);
Object.defineProperty(exports, "SyntheticsTestOptionsSchedulingTimeframe", ({ enumerable: true, get: function () { return SyntheticsTestOptionsSchedulingTimeframe_1.SyntheticsTestOptionsSchedulingTimeframe; } }));
var SyntheticsTestRequest_1 = __webpack_require__(7105);
Object.defineProperty(exports, "SyntheticsTestRequest", ({ enumerable: true, get: function () { return SyntheticsTestRequest_1.SyntheticsTestRequest; } }));
var SyntheticsTestRequestCertificate_1 = __webpack_require__(86420);
Object.defineProperty(exports, "SyntheticsTestRequestCertificate", ({ enumerable: true, get: function () { return SyntheticsTestRequestCertificate_1.SyntheticsTestRequestCertificate; } }));
var SyntheticsTestRequestCertificateItem_1 = __webpack_require__(77558);
Object.defineProperty(exports, "SyntheticsTestRequestCertificateItem", ({ enumerable: true, get: function () { return SyntheticsTestRequestCertificateItem_1.SyntheticsTestRequestCertificateItem; } }));
var SyntheticsTestRequestProxy_1 = __webpack_require__(57736);
Object.defineProperty(exports, "SyntheticsTestRequestProxy", ({ enumerable: true, get: function () { return SyntheticsTestRequestProxy_1.SyntheticsTestRequestProxy; } }));
var SyntheticsTiming_1 = __webpack_require__(30782);
Object.defineProperty(exports, "SyntheticsTiming", ({ enumerable: true, get: function () { return SyntheticsTiming_1.SyntheticsTiming; } }));
var SyntheticsTriggerBody_1 = __webpack_require__(20524);
Object.defineProperty(exports, "SyntheticsTriggerBody", ({ enumerable: true, get: function () { return SyntheticsTriggerBody_1.SyntheticsTriggerBody; } }));
var SyntheticsTriggerCITestLocation_1 = __webpack_require__(88420);
Object.defineProperty(exports, "SyntheticsTriggerCITestLocation", ({ enumerable: true, get: function () { return SyntheticsTriggerCITestLocation_1.SyntheticsTriggerCITestLocation; } }));
var SyntheticsTriggerCITestRunResult_1 = __webpack_require__(63605);
Object.defineProperty(exports, "SyntheticsTriggerCITestRunResult", ({ enumerable: true, get: function () { return SyntheticsTriggerCITestRunResult_1.SyntheticsTriggerCITestRunResult; } }));
var SyntheticsTriggerCITestsResponse_1 = __webpack_require__(35779);
Object.defineProperty(exports, "SyntheticsTriggerCITestsResponse", ({ enumerable: true, get: function () { return SyntheticsTriggerCITestsResponse_1.SyntheticsTriggerCITestsResponse; } }));
var SyntheticsTriggerTest_1 = __webpack_require__(24099);
Object.defineProperty(exports, "SyntheticsTriggerTest", ({ enumerable: true, get: function () { return SyntheticsTriggerTest_1.SyntheticsTriggerTest; } }));
var SyntheticsUpdateTestPauseStatusPayload_1 = __webpack_require__(41655);
Object.defineProperty(exports, "SyntheticsUpdateTestPauseStatusPayload", ({ enumerable: true, get: function () { return SyntheticsUpdateTestPauseStatusPayload_1.SyntheticsUpdateTestPauseStatusPayload; } }));
var SyntheticsVariableParser_1 = __webpack_require__(74500);
Object.defineProperty(exports, "SyntheticsVariableParser", ({ enumerable: true, get: function () { return SyntheticsVariableParser_1.SyntheticsVariableParser; } }));
var TableWidgetDefinition_1 = __webpack_require__(17750);
Object.defineProperty(exports, "TableWidgetDefinition", ({ enumerable: true, get: function () { return TableWidgetDefinition_1.TableWidgetDefinition; } }));
var TableWidgetRequest_1 = __webpack_require__(24403);
Object.defineProperty(exports, "TableWidgetRequest", ({ enumerable: true, get: function () { return TableWidgetRequest_1.TableWidgetRequest; } }));
var TagToHosts_1 = __webpack_require__(94643);
Object.defineProperty(exports, "TagToHosts", ({ enumerable: true, get: function () { return TagToHosts_1.TagToHosts; } }));
var TimeseriesBackground_1 = __webpack_require__(87235);
Object.defineProperty(exports, "TimeseriesBackground", ({ enumerable: true, get: function () { return TimeseriesBackground_1.TimeseriesBackground; } }));
var TimeseriesWidgetDefinition_1 = __webpack_require__(50074);
Object.defineProperty(exports, "TimeseriesWidgetDefinition", ({ enumerable: true, get: function () { return TimeseriesWidgetDefinition_1.TimeseriesWidgetDefinition; } }));
var TimeseriesWidgetExpressionAlias_1 = __webpack_require__(91672);
Object.defineProperty(exports, "TimeseriesWidgetExpressionAlias", ({ enumerable: true, get: function () { return TimeseriesWidgetExpressionAlias_1.TimeseriesWidgetExpressionAlias; } }));
var TimeseriesWidgetRequest_1 = __webpack_require__(10800);
Object.defineProperty(exports, "TimeseriesWidgetRequest", ({ enumerable: true, get: function () { return TimeseriesWidgetRequest_1.TimeseriesWidgetRequest; } }));
var ToplistWidgetDefinition_1 = __webpack_require__(61970);
Object.defineProperty(exports, "ToplistWidgetDefinition", ({ enumerable: true, get: function () { return ToplistWidgetDefinition_1.ToplistWidgetDefinition; } }));
var ToplistWidgetRequest_1 = __webpack_require__(89181);
Object.defineProperty(exports, "ToplistWidgetRequest", ({ enumerable: true, get: function () { return ToplistWidgetRequest_1.ToplistWidgetRequest; } }));
var TopologyMapWidgetDefinition_1 = __webpack_require__(3185);
Object.defineProperty(exports, "TopologyMapWidgetDefinition", ({ enumerable: true, get: function () { return TopologyMapWidgetDefinition_1.TopologyMapWidgetDefinition; } }));
var TopologyQuery_1 = __webpack_require__(8641);
Object.defineProperty(exports, "TopologyQuery", ({ enumerable: true, get: function () { return TopologyQuery_1.TopologyQuery; } }));
var TopologyRequest_1 = __webpack_require__(71327);
Object.defineProperty(exports, "TopologyRequest", ({ enumerable: true, get: function () { return TopologyRequest_1.TopologyRequest; } }));
var TreeMapWidgetDefinition_1 = __webpack_require__(84230);
Object.defineProperty(exports, "TreeMapWidgetDefinition", ({ enumerable: true, get: function () { return TreeMapWidgetDefinition_1.TreeMapWidgetDefinition; } }));
var TreeMapWidgetRequest_1 = __webpack_require__(32930);
Object.defineProperty(exports, "TreeMapWidgetRequest", ({ enumerable: true, get: function () { return TreeMapWidgetRequest_1.TreeMapWidgetRequest; } }));
var UsageAnalyzedLogsHour_1 = __webpack_require__(46989);
Object.defineProperty(exports, "UsageAnalyzedLogsHour", ({ enumerable: true, get: function () { return UsageAnalyzedLogsHour_1.UsageAnalyzedLogsHour; } }));
var UsageAnalyzedLogsResponse_1 = __webpack_require__(18830);
Object.defineProperty(exports, "UsageAnalyzedLogsResponse", ({ enumerable: true, get: function () { return UsageAnalyzedLogsResponse_1.UsageAnalyzedLogsResponse; } }));
var UsageAttributionAggregatesBody_1 = __webpack_require__(17881);
Object.defineProperty(exports, "UsageAttributionAggregatesBody", ({ enumerable: true, get: function () { return UsageAttributionAggregatesBody_1.UsageAttributionAggregatesBody; } }));
var UsageAttributionBody_1 = __webpack_require__(15656);
Object.defineProperty(exports, "UsageAttributionBody", ({ enumerable: true, get: function () { return UsageAttributionBody_1.UsageAttributionBody; } }));
var UsageAttributionMetadata_1 = __webpack_require__(93350);
Object.defineProperty(exports, "UsageAttributionMetadata", ({ enumerable: true, get: function () { return UsageAttributionMetadata_1.UsageAttributionMetadata; } }));
var UsageAttributionPagination_1 = __webpack_require__(72584);
Object.defineProperty(exports, "UsageAttributionPagination", ({ enumerable: true, get: function () { return UsageAttributionPagination_1.UsageAttributionPagination; } }));
var UsageAttributionResponse_1 = __webpack_require__(45011);
Object.defineProperty(exports, "UsageAttributionResponse", ({ enumerable: true, get: function () { return UsageAttributionResponse_1.UsageAttributionResponse; } }));
var UsageAttributionValues_1 = __webpack_require__(61746);
Object.defineProperty(exports, "UsageAttributionValues", ({ enumerable: true, get: function () { return UsageAttributionValues_1.UsageAttributionValues; } }));
var UsageAuditLogsHour_1 = __webpack_require__(59268);
Object.defineProperty(exports, "UsageAuditLogsHour", ({ enumerable: true, get: function () { return UsageAuditLogsHour_1.UsageAuditLogsHour; } }));
var UsageAuditLogsResponse_1 = __webpack_require__(89238);
Object.defineProperty(exports, "UsageAuditLogsResponse", ({ enumerable: true, get: function () { return UsageAuditLogsResponse_1.UsageAuditLogsResponse; } }));
var UsageBillableSummaryBody_1 = __webpack_require__(17329);
Object.defineProperty(exports, "UsageBillableSummaryBody", ({ enumerable: true, get: function () { return UsageBillableSummaryBody_1.UsageBillableSummaryBody; } }));
var UsageBillableSummaryHour_1 = __webpack_require__(52813);
Object.defineProperty(exports, "UsageBillableSummaryHour", ({ enumerable: true, get: function () { return UsageBillableSummaryHour_1.UsageBillableSummaryHour; } }));
var UsageBillableSummaryKeys_1 = __webpack_require__(35118);
Object.defineProperty(exports, "UsageBillableSummaryKeys", ({ enumerable: true, get: function () { return UsageBillableSummaryKeys_1.UsageBillableSummaryKeys; } }));
var UsageBillableSummaryResponse_1 = __webpack_require__(84619);
Object.defineProperty(exports, "UsageBillableSummaryResponse", ({ enumerable: true, get: function () { return UsageBillableSummaryResponse_1.UsageBillableSummaryResponse; } }));
var UsageCIVisibilityHour_1 = __webpack_require__(41653);
Object.defineProperty(exports, "UsageCIVisibilityHour", ({ enumerable: true, get: function () { return UsageCIVisibilityHour_1.UsageCIVisibilityHour; } }));
var UsageCIVisibilityResponse_1 = __webpack_require__(55005);
Object.defineProperty(exports, "UsageCIVisibilityResponse", ({ enumerable: true, get: function () { return UsageCIVisibilityResponse_1.UsageCIVisibilityResponse; } }));
var UsageCloudSecurityPostureManagementHour_1 = __webpack_require__(75358);
Object.defineProperty(exports, "UsageCloudSecurityPostureManagementHour", ({ enumerable: true, get: function () { return UsageCloudSecurityPostureManagementHour_1.UsageCloudSecurityPostureManagementHour; } }));
var UsageCloudSecurityPostureManagementResponse_1 = __webpack_require__(87374);
Object.defineProperty(exports, "UsageCloudSecurityPostureManagementResponse", ({ enumerable: true, get: function () { return UsageCloudSecurityPostureManagementResponse_1.UsageCloudSecurityPostureManagementResponse; } }));
var UsageCustomReportsAttributes_1 = __webpack_require__(47558);
Object.defineProperty(exports, "UsageCustomReportsAttributes", ({ enumerable: true, get: function () { return UsageCustomReportsAttributes_1.UsageCustomReportsAttributes; } }));
var UsageCustomReportsData_1 = __webpack_require__(88385);
Object.defineProperty(exports, "UsageCustomReportsData", ({ enumerable: true, get: function () { return UsageCustomReportsData_1.UsageCustomReportsData; } }));
var UsageCustomReportsMeta_1 = __webpack_require__(63185);
Object.defineProperty(exports, "UsageCustomReportsMeta", ({ enumerable: true, get: function () { return UsageCustomReportsMeta_1.UsageCustomReportsMeta; } }));
var UsageCustomReportsPage_1 = __webpack_require__(54974);
Object.defineProperty(exports, "UsageCustomReportsPage", ({ enumerable: true, get: function () { return UsageCustomReportsPage_1.UsageCustomReportsPage; } }));
var UsageCustomReportsResponse_1 = __webpack_require__(55902);
Object.defineProperty(exports, "UsageCustomReportsResponse", ({ enumerable: true, get: function () { return UsageCustomReportsResponse_1.UsageCustomReportsResponse; } }));
var UsageCWSHour_1 = __webpack_require__(18482);
Object.defineProperty(exports, "UsageCWSHour", ({ enumerable: true, get: function () { return UsageCWSHour_1.UsageCWSHour; } }));
var UsageCWSResponse_1 = __webpack_require__(22674);
Object.defineProperty(exports, "UsageCWSResponse", ({ enumerable: true, get: function () { return UsageCWSResponse_1.UsageCWSResponse; } }));
var UsageDBMHour_1 = __webpack_require__(68808);
Object.defineProperty(exports, "UsageDBMHour", ({ enumerable: true, get: function () { return UsageDBMHour_1.UsageDBMHour; } }));
var UsageDBMResponse_1 = __webpack_require__(2026);
Object.defineProperty(exports, "UsageDBMResponse", ({ enumerable: true, get: function () { return UsageDBMResponse_1.UsageDBMResponse; } }));
var UsageFargateHour_1 = __webpack_require__(57386);
Object.defineProperty(exports, "UsageFargateHour", ({ enumerable: true, get: function () { return UsageFargateHour_1.UsageFargateHour; } }));
var UsageFargateResponse_1 = __webpack_require__(48053);
Object.defineProperty(exports, "UsageFargateResponse", ({ enumerable: true, get: function () { return UsageFargateResponse_1.UsageFargateResponse; } }));
var UsageHostHour_1 = __webpack_require__(22603);
Object.defineProperty(exports, "UsageHostHour", ({ enumerable: true, get: function () { return UsageHostHour_1.UsageHostHour; } }));
var UsageHostsResponse_1 = __webpack_require__(31325);
Object.defineProperty(exports, "UsageHostsResponse", ({ enumerable: true, get: function () { return UsageHostsResponse_1.UsageHostsResponse; } }));
var UsageIncidentManagementHour_1 = __webpack_require__(40048);
Object.defineProperty(exports, "UsageIncidentManagementHour", ({ enumerable: true, get: function () { return UsageIncidentManagementHour_1.UsageIncidentManagementHour; } }));
var UsageIncidentManagementResponse_1 = __webpack_require__(98434);
Object.defineProperty(exports, "UsageIncidentManagementResponse", ({ enumerable: true, get: function () { return UsageIncidentManagementResponse_1.UsageIncidentManagementResponse; } }));
var UsageIndexedSpansHour_1 = __webpack_require__(66099);
Object.defineProperty(exports, "UsageIndexedSpansHour", ({ enumerable: true, get: function () { return UsageIndexedSpansHour_1.UsageIndexedSpansHour; } }));
var UsageIndexedSpansResponse_1 = __webpack_require__(7275);
Object.defineProperty(exports, "UsageIndexedSpansResponse", ({ enumerable: true, get: function () { return UsageIndexedSpansResponse_1.UsageIndexedSpansResponse; } }));
var UsageIngestedSpansHour_1 = __webpack_require__(72078);
Object.defineProperty(exports, "UsageIngestedSpansHour", ({ enumerable: true, get: function () { return UsageIngestedSpansHour_1.UsageIngestedSpansHour; } }));
var UsageIngestedSpansResponse_1 = __webpack_require__(52819);
Object.defineProperty(exports, "UsageIngestedSpansResponse", ({ enumerable: true, get: function () { return UsageIngestedSpansResponse_1.UsageIngestedSpansResponse; } }));
var UsageIoTHour_1 = __webpack_require__(45137);
Object.defineProperty(exports, "UsageIoTHour", ({ enumerable: true, get: function () { return UsageIoTHour_1.UsageIoTHour; } }));
var UsageIoTResponse_1 = __webpack_require__(73096);
Object.defineProperty(exports, "UsageIoTResponse", ({ enumerable: true, get: function () { return UsageIoTResponse_1.UsageIoTResponse; } }));
var UsageLambdaHour_1 = __webpack_require__(97435);
Object.defineProperty(exports, "UsageLambdaHour", ({ enumerable: true, get: function () { return UsageLambdaHour_1.UsageLambdaHour; } }));
var UsageLambdaResponse_1 = __webpack_require__(95231);
Object.defineProperty(exports, "UsageLambdaResponse", ({ enumerable: true, get: function () { return UsageLambdaResponse_1.UsageLambdaResponse; } }));
var UsageLogsByIndexHour_1 = __webpack_require__(48710);
Object.defineProperty(exports, "UsageLogsByIndexHour", ({ enumerable: true, get: function () { return UsageLogsByIndexHour_1.UsageLogsByIndexHour; } }));
var UsageLogsByIndexResponse_1 = __webpack_require__(18950);
Object.defineProperty(exports, "UsageLogsByIndexResponse", ({ enumerable: true, get: function () { return UsageLogsByIndexResponse_1.UsageLogsByIndexResponse; } }));
var UsageLogsByRetentionHour_1 = __webpack_require__(51648);
Object.defineProperty(exports, "UsageLogsByRetentionHour", ({ enumerable: true, get: function () { return UsageLogsByRetentionHour_1.UsageLogsByRetentionHour; } }));
var UsageLogsByRetentionResponse_1 = __webpack_require__(62783);
Object.defineProperty(exports, "UsageLogsByRetentionResponse", ({ enumerable: true, get: function () { return UsageLogsByRetentionResponse_1.UsageLogsByRetentionResponse; } }));
var UsageLogsHour_1 = __webpack_require__(52600);
Object.defineProperty(exports, "UsageLogsHour", ({ enumerable: true, get: function () { return UsageLogsHour_1.UsageLogsHour; } }));
var UsageLogsResponse_1 = __webpack_require__(1375);
Object.defineProperty(exports, "UsageLogsResponse", ({ enumerable: true, get: function () { return UsageLogsResponse_1.UsageLogsResponse; } }));
var UsageNetworkFlowsHour_1 = __webpack_require__(97327);
Object.defineProperty(exports, "UsageNetworkFlowsHour", ({ enumerable: true, get: function () { return UsageNetworkFlowsHour_1.UsageNetworkFlowsHour; } }));
var UsageNetworkFlowsResponse_1 = __webpack_require__(66234);
Object.defineProperty(exports, "UsageNetworkFlowsResponse", ({ enumerable: true, get: function () { return UsageNetworkFlowsResponse_1.UsageNetworkFlowsResponse; } }));
var UsageNetworkHostsHour_1 = __webpack_require__(5620);
Object.defineProperty(exports, "UsageNetworkHostsHour", ({ enumerable: true, get: function () { return UsageNetworkHostsHour_1.UsageNetworkHostsHour; } }));
var UsageNetworkHostsResponse_1 = __webpack_require__(4994);
Object.defineProperty(exports, "UsageNetworkHostsResponse", ({ enumerable: true, get: function () { return UsageNetworkHostsResponse_1.UsageNetworkHostsResponse; } }));
var UsageOnlineArchiveHour_1 = __webpack_require__(22627);
Object.defineProperty(exports, "UsageOnlineArchiveHour", ({ enumerable: true, get: function () { return UsageOnlineArchiveHour_1.UsageOnlineArchiveHour; } }));
var UsageOnlineArchiveResponse_1 = __webpack_require__(17926);
Object.defineProperty(exports, "UsageOnlineArchiveResponse", ({ enumerable: true, get: function () { return UsageOnlineArchiveResponse_1.UsageOnlineArchiveResponse; } }));
var UsageProfilingHour_1 = __webpack_require__(66510);
Object.defineProperty(exports, "UsageProfilingHour", ({ enumerable: true, get: function () { return UsageProfilingHour_1.UsageProfilingHour; } }));
var UsageProfilingResponse_1 = __webpack_require__(82060);
Object.defineProperty(exports, "UsageProfilingResponse", ({ enumerable: true, get: function () { return UsageProfilingResponse_1.UsageProfilingResponse; } }));
var UsageRumSessionsHour_1 = __webpack_require__(105);
Object.defineProperty(exports, "UsageRumSessionsHour", ({ enumerable: true, get: function () { return UsageRumSessionsHour_1.UsageRumSessionsHour; } }));
var UsageRumSessionsResponse_1 = __webpack_require__(6633);
Object.defineProperty(exports, "UsageRumSessionsResponse", ({ enumerable: true, get: function () { return UsageRumSessionsResponse_1.UsageRumSessionsResponse; } }));
var UsageRumUnitsHour_1 = __webpack_require__(8936);
Object.defineProperty(exports, "UsageRumUnitsHour", ({ enumerable: true, get: function () { return UsageRumUnitsHour_1.UsageRumUnitsHour; } }));
var UsageRumUnitsResponse_1 = __webpack_require__(537);
Object.defineProperty(exports, "UsageRumUnitsResponse", ({ enumerable: true, get: function () { return UsageRumUnitsResponse_1.UsageRumUnitsResponse; } }));
var UsageSDSHour_1 = __webpack_require__(40876);
Object.defineProperty(exports, "UsageSDSHour", ({ enumerable: true, get: function () { return UsageSDSHour_1.UsageSDSHour; } }));
var UsageSDSResponse_1 = __webpack_require__(96687);
Object.defineProperty(exports, "UsageSDSResponse", ({ enumerable: true, get: function () { return UsageSDSResponse_1.UsageSDSResponse; } }));
var UsageSNMPHour_1 = __webpack_require__(39577);
Object.defineProperty(exports, "UsageSNMPHour", ({ enumerable: true, get: function () { return UsageSNMPHour_1.UsageSNMPHour; } }));
var UsageSNMPResponse_1 = __webpack_require__(82210);
Object.defineProperty(exports, "UsageSNMPResponse", ({ enumerable: true, get: function () { return UsageSNMPResponse_1.UsageSNMPResponse; } }));
var UsageSpecifiedCustomReportsAttributes_1 = __webpack_require__(38724);
Object.defineProperty(exports, "UsageSpecifiedCustomReportsAttributes", ({ enumerable: true, get: function () { return UsageSpecifiedCustomReportsAttributes_1.UsageSpecifiedCustomReportsAttributes; } }));
var UsageSpecifiedCustomReportsData_1 = __webpack_require__(47586);
Object.defineProperty(exports, "UsageSpecifiedCustomReportsData", ({ enumerable: true, get: function () { return UsageSpecifiedCustomReportsData_1.UsageSpecifiedCustomReportsData; } }));
var UsageSpecifiedCustomReportsMeta_1 = __webpack_require__(75435);
Object.defineProperty(exports, "UsageSpecifiedCustomReportsMeta", ({ enumerable: true, get: function () { return UsageSpecifiedCustomReportsMeta_1.UsageSpecifiedCustomReportsMeta; } }));
var UsageSpecifiedCustomReportsPage_1 = __webpack_require__(60544);
Object.defineProperty(exports, "UsageSpecifiedCustomReportsPage", ({ enumerable: true, get: function () { return UsageSpecifiedCustomReportsPage_1.UsageSpecifiedCustomReportsPage; } }));
var UsageSpecifiedCustomReportsResponse_1 = __webpack_require__(47226);
Object.defineProperty(exports, "UsageSpecifiedCustomReportsResponse", ({ enumerable: true, get: function () { return UsageSpecifiedCustomReportsResponse_1.UsageSpecifiedCustomReportsResponse; } }));
var UsageSummaryDate_1 = __webpack_require__(72971);
Object.defineProperty(exports, "UsageSummaryDate", ({ enumerable: true, get: function () { return UsageSummaryDate_1.UsageSummaryDate; } }));
var UsageSummaryDateOrg_1 = __webpack_require__(31308);
Object.defineProperty(exports, "UsageSummaryDateOrg", ({ enumerable: true, get: function () { return UsageSummaryDateOrg_1.UsageSummaryDateOrg; } }));
var UsageSummaryResponse_1 = __webpack_require__(61378);
Object.defineProperty(exports, "UsageSummaryResponse", ({ enumerable: true, get: function () { return UsageSummaryResponse_1.UsageSummaryResponse; } }));
var UsageSyntheticsAPIHour_1 = __webpack_require__(80931);
Object.defineProperty(exports, "UsageSyntheticsAPIHour", ({ enumerable: true, get: function () { return UsageSyntheticsAPIHour_1.UsageSyntheticsAPIHour; } }));
var UsageSyntheticsAPIResponse_1 = __webpack_require__(36143);
Object.defineProperty(exports, "UsageSyntheticsAPIResponse", ({ enumerable: true, get: function () { return UsageSyntheticsAPIResponse_1.UsageSyntheticsAPIResponse; } }));
var UsageSyntheticsBrowserHour_1 = __webpack_require__(68362);
Object.defineProperty(exports, "UsageSyntheticsBrowserHour", ({ enumerable: true, get: function () { return UsageSyntheticsBrowserHour_1.UsageSyntheticsBrowserHour; } }));
var UsageSyntheticsBrowserResponse_1 = __webpack_require__(95322);
Object.defineProperty(exports, "UsageSyntheticsBrowserResponse", ({ enumerable: true, get: function () { return UsageSyntheticsBrowserResponse_1.UsageSyntheticsBrowserResponse; } }));
var UsageSyntheticsHour_1 = __webpack_require__(60809);
Object.defineProperty(exports, "UsageSyntheticsHour", ({ enumerable: true, get: function () { return UsageSyntheticsHour_1.UsageSyntheticsHour; } }));
var UsageSyntheticsResponse_1 = __webpack_require__(46862);
Object.defineProperty(exports, "UsageSyntheticsResponse", ({ enumerable: true, get: function () { return UsageSyntheticsResponse_1.UsageSyntheticsResponse; } }));
var UsageTimeseriesHour_1 = __webpack_require__(4062);
Object.defineProperty(exports, "UsageTimeseriesHour", ({ enumerable: true, get: function () { return UsageTimeseriesHour_1.UsageTimeseriesHour; } }));
var UsageTimeseriesResponse_1 = __webpack_require__(2516);
Object.defineProperty(exports, "UsageTimeseriesResponse", ({ enumerable: true, get: function () { return UsageTimeseriesResponse_1.UsageTimeseriesResponse; } }));
var UsageTopAvgMetricsHour_1 = __webpack_require__(62000);
Object.defineProperty(exports, "UsageTopAvgMetricsHour", ({ enumerable: true, get: function () { return UsageTopAvgMetricsHour_1.UsageTopAvgMetricsHour; } }));
var UsageTopAvgMetricsMetadata_1 = __webpack_require__(57758);
Object.defineProperty(exports, "UsageTopAvgMetricsMetadata", ({ enumerable: true, get: function () { return UsageTopAvgMetricsMetadata_1.UsageTopAvgMetricsMetadata; } }));
var UsageTopAvgMetricsPagination_1 = __webpack_require__(69015);
Object.defineProperty(exports, "UsageTopAvgMetricsPagination", ({ enumerable: true, get: function () { return UsageTopAvgMetricsPagination_1.UsageTopAvgMetricsPagination; } }));
var UsageTopAvgMetricsResponse_1 = __webpack_require__(5587);
Object.defineProperty(exports, "UsageTopAvgMetricsResponse", ({ enumerable: true, get: function () { return UsageTopAvgMetricsResponse_1.UsageTopAvgMetricsResponse; } }));
var User_1 = __webpack_require__(65582);
Object.defineProperty(exports, "User", ({ enumerable: true, get: function () { return User_1.User; } }));
var UserDisableResponse_1 = __webpack_require__(97395);
Object.defineProperty(exports, "UserDisableResponse", ({ enumerable: true, get: function () { return UserDisableResponse_1.UserDisableResponse; } }));
var UserListResponse_1 = __webpack_require__(56284);
Object.defineProperty(exports, "UserListResponse", ({ enumerable: true, get: function () { return UserListResponse_1.UserListResponse; } }));
var UserResponse_1 = __webpack_require__(73865);
Object.defineProperty(exports, "UserResponse", ({ enumerable: true, get: function () { return UserResponse_1.UserResponse; } }));
var WebhooksIntegration_1 = __webpack_require__(54773);
Object.defineProperty(exports, "WebhooksIntegration", ({ enumerable: true, get: function () { return WebhooksIntegration_1.WebhooksIntegration; } }));
var WebhooksIntegrationCustomVariable_1 = __webpack_require__(67832);
Object.defineProperty(exports, "WebhooksIntegrationCustomVariable", ({ enumerable: true, get: function () { return WebhooksIntegrationCustomVariable_1.WebhooksIntegrationCustomVariable; } }));
var WebhooksIntegrationCustomVariableResponse_1 = __webpack_require__(25545);
Object.defineProperty(exports, "WebhooksIntegrationCustomVariableResponse", ({ enumerable: true, get: function () { return WebhooksIntegrationCustomVariableResponse_1.WebhooksIntegrationCustomVariableResponse; } }));
var WebhooksIntegrationCustomVariableUpdateRequest_1 = __webpack_require__(66363);
Object.defineProperty(exports, "WebhooksIntegrationCustomVariableUpdateRequest", ({ enumerable: true, get: function () { return WebhooksIntegrationCustomVariableUpdateRequest_1.WebhooksIntegrationCustomVariableUpdateRequest; } }));
var WebhooksIntegrationUpdateRequest_1 = __webpack_require__(86321);
Object.defineProperty(exports, "WebhooksIntegrationUpdateRequest", ({ enumerable: true, get: function () { return WebhooksIntegrationUpdateRequest_1.WebhooksIntegrationUpdateRequest; } }));
var Widget_1 = __webpack_require__(6000);
Object.defineProperty(exports, "Widget", ({ enumerable: true, get: function () { return Widget_1.Widget; } }));
var WidgetAxis_1 = __webpack_require__(36356);
Object.defineProperty(exports, "WidgetAxis", ({ enumerable: true, get: function () { return WidgetAxis_1.WidgetAxis; } }));
var WidgetConditionalFormat_1 = __webpack_require__(68824);
Object.defineProperty(exports, "WidgetConditionalFormat", ({ enumerable: true, get: function () { return WidgetConditionalFormat_1.WidgetConditionalFormat; } }));
var WidgetCustomLink_1 = __webpack_require__(83892);
Object.defineProperty(exports, "WidgetCustomLink", ({ enumerable: true, get: function () { return WidgetCustomLink_1.WidgetCustomLink; } }));
var WidgetEvent_1 = __webpack_require__(27093);
Object.defineProperty(exports, "WidgetEvent", ({ enumerable: true, get: function () { return WidgetEvent_1.WidgetEvent; } }));
var WidgetFieldSort_1 = __webpack_require__(95452);
Object.defineProperty(exports, "WidgetFieldSort", ({ enumerable: true, get: function () { return WidgetFieldSort_1.WidgetFieldSort; } }));
var WidgetFormula_1 = __webpack_require__(96398);
Object.defineProperty(exports, "WidgetFormula", ({ enumerable: true, get: function () { return WidgetFormula_1.WidgetFormula; } }));
var WidgetFormulaLimit_1 = __webpack_require__(16658);
Object.defineProperty(exports, "WidgetFormulaLimit", ({ enumerable: true, get: function () { return WidgetFormulaLimit_1.WidgetFormulaLimit; } }));
var WidgetFormulaStyle_1 = __webpack_require__(39089);
Object.defineProperty(exports, "WidgetFormulaStyle", ({ enumerable: true, get: function () { return WidgetFormulaStyle_1.WidgetFormulaStyle; } }));
var WidgetLayout_1 = __webpack_require__(29557);
Object.defineProperty(exports, "WidgetLayout", ({ enumerable: true, get: function () { return WidgetLayout_1.WidgetLayout; } }));
var WidgetMarker_1 = __webpack_require__(35484);
Object.defineProperty(exports, "WidgetMarker", ({ enumerable: true, get: function () { return WidgetMarker_1.WidgetMarker; } }));
var WidgetRequestStyle_1 = __webpack_require__(87457);
Object.defineProperty(exports, "WidgetRequestStyle", ({ enumerable: true, get: function () { return WidgetRequestStyle_1.WidgetRequestStyle; } }));
var WidgetStyle_1 = __webpack_require__(49795);
Object.defineProperty(exports, "WidgetStyle", ({ enumerable: true, get: function () { return WidgetStyle_1.WidgetStyle; } }));
var WidgetTime_1 = __webpack_require__(39079);
Object.defineProperty(exports, "WidgetTime", ({ enumerable: true, get: function () { return WidgetTime_1.WidgetTime; } }));
var ObjectSerializer_1 = __webpack_require__(52674);
Object.defineProperty(exports, "ObjectSerializer", ({ enumerable: true, get: function () { return ObjectSerializer_1.ObjectSerializer; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 94187:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.APIErrorResponse = void 0;
/**
 * Error response object.
 */
class APIErrorResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return APIErrorResponse.attributeTypeMap;
    }
}
exports.APIErrorResponse = APIErrorResponse;
/**
 * @ignore
 */
APIErrorResponse.attributeTypeMap = {
    errors: {
        baseName: "errors",
        type: "Array<string>",
        required: true,
    },
};
//# sourceMappingURL=APIErrorResponse.js.map

/***/ }),

/***/ 75107:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AWSAccount = void 0;
/**
 * Returns the AWS account associated with this integration.
 */
class AWSAccount {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AWSAccount.attributeTypeMap;
    }
}
exports.AWSAccount = AWSAccount;
/**
 * @ignore
 */
AWSAccount.attributeTypeMap = {
    accessKeyId: {
        baseName: "access_key_id",
        type: "string",
    },
    accountId: {
        baseName: "account_id",
        type: "string",
    },
    accountSpecificNamespaceRules: {
        baseName: "account_specific_namespace_rules",
        type: "{ [key: string]: boolean; }",
    },
    cspmResourceCollectionEnabled: {
        baseName: "cspm_resource_collection_enabled",
        type: "boolean",
    },
    excludedRegions: {
        baseName: "excluded_regions",
        type: "Array<string>",
    },
    filterTags: {
        baseName: "filter_tags",
        type: "Array<string>",
    },
    hostTags: {
        baseName: "host_tags",
        type: "Array<string>",
    },
    metricsCollectionEnabled: {
        baseName: "metrics_collection_enabled",
        type: "boolean",
    },
    resourceCollectionEnabled: {
        baseName: "resource_collection_enabled",
        type: "boolean",
    },
    roleName: {
        baseName: "role_name",
        type: "string",
    },
    secretAccessKey: {
        baseName: "secret_access_key",
        type: "string",
    },
};
//# sourceMappingURL=AWSAccount.js.map

/***/ }),

/***/ 79616:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AWSAccountAndLambdaRequest = void 0;
/**
 * AWS account ID and Lambda ARN.
 */
class AWSAccountAndLambdaRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AWSAccountAndLambdaRequest.attributeTypeMap;
    }
}
exports.AWSAccountAndLambdaRequest = AWSAccountAndLambdaRequest;
/**
 * @ignore
 */
AWSAccountAndLambdaRequest.attributeTypeMap = {
    accountId: {
        baseName: "account_id",
        type: "string",
        required: true,
    },
    lambdaArn: {
        baseName: "lambda_arn",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=AWSAccountAndLambdaRequest.js.map

/***/ }),

/***/ 205:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AWSAccountCreateResponse = void 0;
/**
 * The Response returned by the AWS Create Account call.
 */
class AWSAccountCreateResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AWSAccountCreateResponse.attributeTypeMap;
    }
}
exports.AWSAccountCreateResponse = AWSAccountCreateResponse;
/**
 * @ignore
 */
AWSAccountCreateResponse.attributeTypeMap = {
    externalId: {
        baseName: "external_id",
        type: "string",
    },
};
//# sourceMappingURL=AWSAccountCreateResponse.js.map

/***/ }),

/***/ 11338:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AWSAccountDeleteRequest = void 0;
/**
 * List of AWS accounts to delete.
 */
class AWSAccountDeleteRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AWSAccountDeleteRequest.attributeTypeMap;
    }
}
exports.AWSAccountDeleteRequest = AWSAccountDeleteRequest;
/**
 * @ignore
 */
AWSAccountDeleteRequest.attributeTypeMap = {
    accessKeyId: {
        baseName: "access_key_id",
        type: "string",
    },
    accountId: {
        baseName: "account_id",
        type: "string",
    },
    roleName: {
        baseName: "role_name",
        type: "string",
    },
};
//# sourceMappingURL=AWSAccountDeleteRequest.js.map

/***/ }),

/***/ 51224:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AWSAccountListResponse = void 0;
/**
 * List of enabled AWS accounts.
 */
class AWSAccountListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AWSAccountListResponse.attributeTypeMap;
    }
}
exports.AWSAccountListResponse = AWSAccountListResponse;
/**
 * @ignore
 */
AWSAccountListResponse.attributeTypeMap = {
    accounts: {
        baseName: "accounts",
        type: "Array<AWSAccount>",
    },
};
//# sourceMappingURL=AWSAccountListResponse.js.map

/***/ }),

/***/ 62953:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AWSLogsAsyncError = void 0;
/**
 * Description of errors.
 */
class AWSLogsAsyncError {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AWSLogsAsyncError.attributeTypeMap;
    }
}
exports.AWSLogsAsyncError = AWSLogsAsyncError;
/**
 * @ignore
 */
AWSLogsAsyncError.attributeTypeMap = {
    code: {
        baseName: "code",
        type: "string",
    },
    message: {
        baseName: "message",
        type: "string",
    },
};
//# sourceMappingURL=AWSLogsAsyncError.js.map

/***/ }),

/***/ 87558:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AWSLogsAsyncResponse = void 0;
/**
 * A list of all Datadog-AWS logs integrations available in your Datadog organization.
 */
class AWSLogsAsyncResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AWSLogsAsyncResponse.attributeTypeMap;
    }
}
exports.AWSLogsAsyncResponse = AWSLogsAsyncResponse;
/**
 * @ignore
 */
AWSLogsAsyncResponse.attributeTypeMap = {
    errors: {
        baseName: "errors",
        type: "Array<AWSLogsAsyncError>",
    },
    status: {
        baseName: "status",
        type: "string",
    },
};
//# sourceMappingURL=AWSLogsAsyncResponse.js.map

/***/ }),

/***/ 99754:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AWSLogsLambda = void 0;
/**
 * Description of the Lambdas.
 */
class AWSLogsLambda {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AWSLogsLambda.attributeTypeMap;
    }
}
exports.AWSLogsLambda = AWSLogsLambda;
/**
 * @ignore
 */
AWSLogsLambda.attributeTypeMap = {
    arn: {
        baseName: "arn",
        type: "string",
    },
};
//# sourceMappingURL=AWSLogsLambda.js.map

/***/ }),

/***/ 9120:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AWSLogsListResponse = void 0;
/**
 * A list of all Datadog-AWS logs integrations available in your Datadog organization.
 */
class AWSLogsListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AWSLogsListResponse.attributeTypeMap;
    }
}
exports.AWSLogsListResponse = AWSLogsListResponse;
/**
 * @ignore
 */
AWSLogsListResponse.attributeTypeMap = {
    accountId: {
        baseName: "account_id",
        type: "string",
    },
    lambdas: {
        baseName: "lambdas",
        type: "Array<AWSLogsLambda>",
    },
    services: {
        baseName: "services",
        type: "Array<string>",
    },
};
//# sourceMappingURL=AWSLogsListResponse.js.map

/***/ }),

/***/ 77474:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AWSLogsListServicesResponse = void 0;
/**
 * The list of current AWS services for which Datadog offers automatic log collection.
 */
class AWSLogsListServicesResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AWSLogsListServicesResponse.attributeTypeMap;
    }
}
exports.AWSLogsListServicesResponse = AWSLogsListServicesResponse;
/**
 * @ignore
 */
AWSLogsListServicesResponse.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
    },
    label: {
        baseName: "label",
        type: "string",
    },
};
//# sourceMappingURL=AWSLogsListServicesResponse.js.map

/***/ }),

/***/ 57943:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AWSLogsServicesRequest = void 0;
/**
 * A list of current AWS services for which Datadog offers automatic log collection.
 */
class AWSLogsServicesRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AWSLogsServicesRequest.attributeTypeMap;
    }
}
exports.AWSLogsServicesRequest = AWSLogsServicesRequest;
/**
 * @ignore
 */
AWSLogsServicesRequest.attributeTypeMap = {
    accountId: {
        baseName: "account_id",
        type: "string",
        required: true,
    },
    services: {
        baseName: "services",
        type: "Array<string>",
        required: true,
    },
};
//# sourceMappingURL=AWSLogsServicesRequest.js.map

/***/ }),

/***/ 26166:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AWSTagFilter = void 0;
/**
 * A tag filter.
 */
class AWSTagFilter {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AWSTagFilter.attributeTypeMap;
    }
}
exports.AWSTagFilter = AWSTagFilter;
/**
 * @ignore
 */
AWSTagFilter.attributeTypeMap = {
    namespace: {
        baseName: "namespace",
        type: "AWSNamespace",
    },
    tagFilterStr: {
        baseName: "tag_filter_str",
        type: "string",
    },
};
//# sourceMappingURL=AWSTagFilter.js.map

/***/ }),

/***/ 8647:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AWSTagFilterCreateRequest = void 0;
/**
 * The objects used to set an AWS tag filter.
 */
class AWSTagFilterCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AWSTagFilterCreateRequest.attributeTypeMap;
    }
}
exports.AWSTagFilterCreateRequest = AWSTagFilterCreateRequest;
/**
 * @ignore
 */
AWSTagFilterCreateRequest.attributeTypeMap = {
    accountId: {
        baseName: "account_id",
        type: "string",
    },
    namespace: {
        baseName: "namespace",
        type: "AWSNamespace",
    },
    tagFilterStr: {
        baseName: "tag_filter_str",
        type: "string",
    },
};
//# sourceMappingURL=AWSTagFilterCreateRequest.js.map

/***/ }),

/***/ 81212:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AWSTagFilterDeleteRequest = void 0;
/**
 * The objects used to delete an AWS tag filter entry.
 */
class AWSTagFilterDeleteRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AWSTagFilterDeleteRequest.attributeTypeMap;
    }
}
exports.AWSTagFilterDeleteRequest = AWSTagFilterDeleteRequest;
/**
 * @ignore
 */
AWSTagFilterDeleteRequest.attributeTypeMap = {
    accountId: {
        baseName: "account_id",
        type: "string",
    },
    namespace: {
        baseName: "namespace",
        type: "AWSNamespace",
    },
};
//# sourceMappingURL=AWSTagFilterDeleteRequest.js.map

/***/ }),

/***/ 28788:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AWSTagFilterListResponse = void 0;
/**
 * An array of tag filter rules by `namespace` and tag filter string.
 */
class AWSTagFilterListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AWSTagFilterListResponse.attributeTypeMap;
    }
}
exports.AWSTagFilterListResponse = AWSTagFilterListResponse;
/**
 * @ignore
 */
AWSTagFilterListResponse.attributeTypeMap = {
    filters: {
        baseName: "filters",
        type: "Array<AWSTagFilter>",
    },
};
//# sourceMappingURL=AWSTagFilterListResponse.js.map

/***/ }),

/***/ 53778:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddSignalToIncidentRequest = void 0;
/**
 * Attributes describing which incident to add the signal to.
 */
class AddSignalToIncidentRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AddSignalToIncidentRequest.attributeTypeMap;
    }
}
exports.AddSignalToIncidentRequest = AddSignalToIncidentRequest;
/**
 * @ignore
 */
AddSignalToIncidentRequest.attributeTypeMap = {
    addToSignalTimeline: {
        baseName: "add_to_signal_timeline",
        type: "boolean",
    },
    incidentId: {
        baseName: "incident_id",
        type: "number",
        required: true,
        format: "int64",
    },
    version: {
        baseName: "version",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=AddSignalToIncidentRequest.js.map

/***/ }),

/***/ 30928:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlertGraphWidgetDefinition = void 0;
/**
 * Alert graphs are timeseries graphs showing the current status of any monitor defined on your system.
 */
class AlertGraphWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AlertGraphWidgetDefinition.attributeTypeMap;
    }
}
exports.AlertGraphWidgetDefinition = AlertGraphWidgetDefinition;
/**
 * @ignore
 */
AlertGraphWidgetDefinition.attributeTypeMap = {
    alertId: {
        baseName: "alert_id",
        type: "string",
        required: true,
    },
    time: {
        baseName: "time",
        type: "WidgetTime",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "AlertGraphWidgetDefinitionType",
        required: true,
    },
    vizType: {
        baseName: "viz_type",
        type: "WidgetVizType",
        required: true,
    },
};
//# sourceMappingURL=AlertGraphWidgetDefinition.js.map

/***/ }),

/***/ 35622:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlertValueWidgetDefinition = void 0;
/**
 * Alert values are query values showing the current value of the metric in any monitor defined on your system.
 */
class AlertValueWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AlertValueWidgetDefinition.attributeTypeMap;
    }
}
exports.AlertValueWidgetDefinition = AlertValueWidgetDefinition;
/**
 * @ignore
 */
AlertValueWidgetDefinition.attributeTypeMap = {
    alertId: {
        baseName: "alert_id",
        type: "string",
        required: true,
    },
    precision: {
        baseName: "precision",
        type: "number",
        format: "int64",
    },
    textAlign: {
        baseName: "text_align",
        type: "WidgetTextAlign",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "AlertValueWidgetDefinitionType",
        required: true,
    },
    unit: {
        baseName: "unit",
        type: "string",
    },
};
//# sourceMappingURL=AlertValueWidgetDefinition.js.map

/***/ }),

/***/ 4583:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiKey = void 0;
/**
 * Datadog API key.
 */
class ApiKey {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ApiKey.attributeTypeMap;
    }
}
exports.ApiKey = ApiKey;
/**
 * @ignore
 */
ApiKey.attributeTypeMap = {
    created: {
        baseName: "created",
        type: "string",
    },
    createdBy: {
        baseName: "created_by",
        type: "string",
    },
    key: {
        baseName: "key",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=ApiKey.js.map

/***/ }),

/***/ 7164:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiKeyListResponse = void 0;
/**
 * List of API and application keys available for a given organization.
 */
class ApiKeyListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ApiKeyListResponse.attributeTypeMap;
    }
}
exports.ApiKeyListResponse = ApiKeyListResponse;
/**
 * @ignore
 */
ApiKeyListResponse.attributeTypeMap = {
    apiKeys: {
        baseName: "api_keys",
        type: "Array<ApiKey>",
    },
};
//# sourceMappingURL=ApiKeyListResponse.js.map

/***/ }),

/***/ 82196:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiKeyResponse = void 0;
/**
 * An API key with its associated metadata.
 */
class ApiKeyResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ApiKeyResponse.attributeTypeMap;
    }
}
exports.ApiKeyResponse = ApiKeyResponse;
/**
 * @ignore
 */
ApiKeyResponse.attributeTypeMap = {
    apiKey: {
        baseName: "api_key",
        type: "ApiKey",
    },
};
//# sourceMappingURL=ApiKeyResponse.js.map

/***/ }),

/***/ 17056:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApmStatsQueryColumnType = void 0;
/**
 * Column properties.
 */
class ApmStatsQueryColumnType {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ApmStatsQueryColumnType.attributeTypeMap;
    }
}
exports.ApmStatsQueryColumnType = ApmStatsQueryColumnType;
/**
 * @ignore
 */
ApmStatsQueryColumnType.attributeTypeMap = {
    alias: {
        baseName: "alias",
        type: "string",
    },
    cellDisplayMode: {
        baseName: "cell_display_mode",
        type: "TableWidgetCellDisplayMode",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    order: {
        baseName: "order",
        type: "WidgetSort",
    },
};
//# sourceMappingURL=ApmStatsQueryColumnType.js.map

/***/ }),

/***/ 61753:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApmStatsQueryDefinition = void 0;
/**
 * The APM stats query for table and distributions widgets.
 */
class ApmStatsQueryDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ApmStatsQueryDefinition.attributeTypeMap;
    }
}
exports.ApmStatsQueryDefinition = ApmStatsQueryDefinition;
/**
 * @ignore
 */
ApmStatsQueryDefinition.attributeTypeMap = {
    columns: {
        baseName: "columns",
        type: "Array<ApmStatsQueryColumnType>",
    },
    env: {
        baseName: "env",
        type: "string",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    primaryTag: {
        baseName: "primary_tag",
        type: "string",
        required: true,
    },
    resource: {
        baseName: "resource",
        type: "string",
    },
    rowType: {
        baseName: "row_type",
        type: "ApmStatsQueryRowType",
        required: true,
    },
    service: {
        baseName: "service",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=ApmStatsQueryDefinition.js.map

/***/ }),

/***/ 12260:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApplicationKey = void 0;
/**
 * An application key with its associated metadata.
 */
class ApplicationKey {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ApplicationKey.attributeTypeMap;
    }
}
exports.ApplicationKey = ApplicationKey;
/**
 * @ignore
 */
ApplicationKey.attributeTypeMap = {
    hash: {
        baseName: "hash",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    owner: {
        baseName: "owner",
        type: "string",
    },
};
//# sourceMappingURL=ApplicationKey.js.map

/***/ }),

/***/ 524:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApplicationKeyListResponse = void 0;
/**
 * An application key response.
 */
class ApplicationKeyListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ApplicationKeyListResponse.attributeTypeMap;
    }
}
exports.ApplicationKeyListResponse = ApplicationKeyListResponse;
/**
 * @ignore
 */
ApplicationKeyListResponse.attributeTypeMap = {
    applicationKeys: {
        baseName: "application_keys",
        type: "Array<ApplicationKey>",
    },
};
//# sourceMappingURL=ApplicationKeyListResponse.js.map

/***/ }),

/***/ 53730:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApplicationKeyResponse = void 0;
/**
 * An application key response.
 */
class ApplicationKeyResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ApplicationKeyResponse.attributeTypeMap;
    }
}
exports.ApplicationKeyResponse = ApplicationKeyResponse;
/**
 * @ignore
 */
ApplicationKeyResponse.attributeTypeMap = {
    applicationKey: {
        baseName: "application_key",
        type: "ApplicationKey",
    },
};
//# sourceMappingURL=ApplicationKeyResponse.js.map

/***/ }),

/***/ 11965:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthenticationValidationResponse = void 0;
/**
 * Represent validation endpoint responses.
 */
class AuthenticationValidationResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuthenticationValidationResponse.attributeTypeMap;
    }
}
exports.AuthenticationValidationResponse = AuthenticationValidationResponse;
/**
 * @ignore
 */
AuthenticationValidationResponse.attributeTypeMap = {
    valid: {
        baseName: "valid",
        type: "boolean",
    },
};
//# sourceMappingURL=AuthenticationValidationResponse.js.map

/***/ }),

/***/ 99096:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AzureAccount = void 0;
/**
 * Datadog-Azure integrations configured for your organization.
 */
class AzureAccount {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AzureAccount.attributeTypeMap;
    }
}
exports.AzureAccount = AzureAccount;
/**
 * @ignore
 */
AzureAccount.attributeTypeMap = {
    automute: {
        baseName: "automute",
        type: "boolean",
    },
    clientId: {
        baseName: "client_id",
        type: "string",
    },
    clientSecret: {
        baseName: "client_secret",
        type: "string",
    },
    errors: {
        baseName: "errors",
        type: "Array<string>",
    },
    hostFilters: {
        baseName: "host_filters",
        type: "string",
    },
    newClientId: {
        baseName: "new_client_id",
        type: "string",
    },
    newTenantName: {
        baseName: "new_tenant_name",
        type: "string",
    },
    tenantName: {
        baseName: "tenant_name",
        type: "string",
    },
};
//# sourceMappingURL=AzureAccount.js.map

/***/ }),

/***/ 30337:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancelDowntimesByScopeRequest = void 0;
/**
 * Cancel downtimes according to scope.
 */
class CancelDowntimesByScopeRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CancelDowntimesByScopeRequest.attributeTypeMap;
    }
}
exports.CancelDowntimesByScopeRequest = CancelDowntimesByScopeRequest;
/**
 * @ignore
 */
CancelDowntimesByScopeRequest.attributeTypeMap = {
    scope: {
        baseName: "scope",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=CancelDowntimesByScopeRequest.js.map

/***/ }),

/***/ 49157:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CanceledDowntimesIds = void 0;
/**
 * Object containing array of IDs of canceled downtimes.
 */
class CanceledDowntimesIds {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CanceledDowntimesIds.attributeTypeMap;
    }
}
exports.CanceledDowntimesIds = CanceledDowntimesIds;
/**
 * @ignore
 */
CanceledDowntimesIds.attributeTypeMap = {
    cancelledIds: {
        baseName: "cancelled_ids",
        type: "Array<number>",
        format: "int64",
    },
};
//# sourceMappingURL=CanceledDowntimesIds.js.map

/***/ }),

/***/ 59016:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChangeWidgetDefinition = void 0;
/**
 * The Change graph shows you the change in a value over the time period chosen.
 */
class ChangeWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ChangeWidgetDefinition.attributeTypeMap;
    }
}
exports.ChangeWidgetDefinition = ChangeWidgetDefinition;
/**
 * @ignore
 */
ChangeWidgetDefinition.attributeTypeMap = {
    customLinks: {
        baseName: "custom_links",
        type: "Array<WidgetCustomLink>",
    },
    requests: {
        baseName: "requests",
        type: "[ChangeWidgetRequest]",
        required: true,
    },
    time: {
        baseName: "time",
        type: "WidgetTime",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "ChangeWidgetDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=ChangeWidgetDefinition.js.map

/***/ }),

/***/ 71103:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChangeWidgetRequest = void 0;
/**
 * Updated change widget.
 */
class ChangeWidgetRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ChangeWidgetRequest.attributeTypeMap;
    }
}
exports.ChangeWidgetRequest = ChangeWidgetRequest;
/**
 * @ignore
 */
ChangeWidgetRequest.attributeTypeMap = {
    apmQuery: {
        baseName: "apm_query",
        type: "LogQueryDefinition",
    },
    changeType: {
        baseName: "change_type",
        type: "WidgetChangeType",
    },
    compareTo: {
        baseName: "compare_to",
        type: "WidgetCompareTo",
    },
    eventQuery: {
        baseName: "event_query",
        type: "LogQueryDefinition",
    },
    formulas: {
        baseName: "formulas",
        type: "Array<WidgetFormula>",
    },
    increaseGood: {
        baseName: "increase_good",
        type: "boolean",
    },
    logQuery: {
        baseName: "log_query",
        type: "LogQueryDefinition",
    },
    networkQuery: {
        baseName: "network_query",
        type: "LogQueryDefinition",
    },
    orderBy: {
        baseName: "order_by",
        type: "WidgetOrderBy",
    },
    orderDir: {
        baseName: "order_dir",
        type: "WidgetSort",
    },
    processQuery: {
        baseName: "process_query",
        type: "ProcessQueryDefinition",
    },
    profileMetricsQuery: {
        baseName: "profile_metrics_query",
        type: "LogQueryDefinition",
    },
    q: {
        baseName: "q",
        type: "string",
    },
    queries: {
        baseName: "queries",
        type: "Array<FormulaAndFunctionQueryDefinition>",
    },
    responseFormat: {
        baseName: "response_format",
        type: "FormulaAndFunctionResponseFormat",
    },
    rumQuery: {
        baseName: "rum_query",
        type: "LogQueryDefinition",
    },
    securityQuery: {
        baseName: "security_query",
        type: "LogQueryDefinition",
    },
    showPresent: {
        baseName: "show_present",
        type: "boolean",
    },
};
//# sourceMappingURL=ChangeWidgetRequest.js.map

/***/ }),

/***/ 55696:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckCanDeleteMonitorResponse = void 0;
/**
 * Response of monitor IDs that can or can't be safely deleted.
 */
class CheckCanDeleteMonitorResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CheckCanDeleteMonitorResponse.attributeTypeMap;
    }
}
exports.CheckCanDeleteMonitorResponse = CheckCanDeleteMonitorResponse;
/**
 * @ignore
 */
CheckCanDeleteMonitorResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "CheckCanDeleteMonitorResponseData",
        required: true,
    },
    errors: {
        baseName: "errors",
        type: "{ [key: string]: Array<string>; }",
    },
};
//# sourceMappingURL=CheckCanDeleteMonitorResponse.js.map

/***/ }),

/***/ 8779:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckCanDeleteMonitorResponseData = void 0;
/**
 * Wrapper object with the list of monitor IDs.
 */
class CheckCanDeleteMonitorResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CheckCanDeleteMonitorResponseData.attributeTypeMap;
    }
}
exports.CheckCanDeleteMonitorResponseData = CheckCanDeleteMonitorResponseData;
/**
 * @ignore
 */
CheckCanDeleteMonitorResponseData.attributeTypeMap = {
    ok: {
        baseName: "ok",
        type: "Array<number>",
        format: "int64",
    },
};
//# sourceMappingURL=CheckCanDeleteMonitorResponseData.js.map

/***/ }),

/***/ 37497:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckCanDeleteSLOResponse = void 0;
/**
 * A service level objective response containing the requested object.
 */
class CheckCanDeleteSLOResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CheckCanDeleteSLOResponse.attributeTypeMap;
    }
}
exports.CheckCanDeleteSLOResponse = CheckCanDeleteSLOResponse;
/**
 * @ignore
 */
CheckCanDeleteSLOResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "CheckCanDeleteSLOResponseData",
    },
    errors: {
        baseName: "errors",
        type: "{ [key: string]: string; }",
    },
};
//# sourceMappingURL=CheckCanDeleteSLOResponse.js.map

/***/ }),

/***/ 45281:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckCanDeleteSLOResponseData = void 0;
/**
 * An array of service level objective objects.
 */
class CheckCanDeleteSLOResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CheckCanDeleteSLOResponseData.attributeTypeMap;
    }
}
exports.CheckCanDeleteSLOResponseData = CheckCanDeleteSLOResponseData;
/**
 * @ignore
 */
CheckCanDeleteSLOResponseData.attributeTypeMap = {
    ok: {
        baseName: "ok",
        type: "Array<string>",
    },
};
//# sourceMappingURL=CheckCanDeleteSLOResponseData.js.map

/***/ }),

/***/ 92980:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckStatusWidgetDefinition = void 0;
/**
 * Check status shows the current status or number of results for any check performed.
 */
class CheckStatusWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CheckStatusWidgetDefinition.attributeTypeMap;
    }
}
exports.CheckStatusWidgetDefinition = CheckStatusWidgetDefinition;
/**
 * @ignore
 */
CheckStatusWidgetDefinition.attributeTypeMap = {
    check: {
        baseName: "check",
        type: "string",
        required: true,
    },
    group: {
        baseName: "group",
        type: "string",
    },
    groupBy: {
        baseName: "group_by",
        type: "Array<string>",
    },
    grouping: {
        baseName: "grouping",
        type: "WidgetGrouping",
        required: true,
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    time: {
        baseName: "time",
        type: "WidgetTime",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "CheckStatusWidgetDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=CheckStatusWidgetDefinition.js.map

/***/ }),

/***/ 84519:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Creator = void 0;
/**
 * Object describing the creator of the shared element.
 */
class Creator {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return Creator.attributeTypeMap;
    }
}
exports.Creator = Creator;
/**
 * @ignore
 */
Creator.attributeTypeMap = {
    email: {
        baseName: "email",
        type: "string",
    },
    handle: {
        baseName: "handle",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=Creator.js.map

/***/ }),

/***/ 63114:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Dashboard = void 0;
/**
 * A dashboard is Datadogs tool for visually tracking, analyzing, and displaying
 * key performance metrics, which enable you to monitor the health of your infrastructure.
 */
class Dashboard {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return Dashboard.attributeTypeMap;
    }
}
exports.Dashboard = Dashboard;
/**
 * @ignore
 */
Dashboard.attributeTypeMap = {
    authorHandle: {
        baseName: "author_handle",
        type: "string",
    },
    authorName: {
        baseName: "author_name",
        type: "string",
    },
    createdAt: {
        baseName: "created_at",
        type: "Date",
        format: "date-time",
    },
    description: {
        baseName: "description",
        type: "string",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    isReadOnly: {
        baseName: "is_read_only",
        type: "boolean",
    },
    layoutType: {
        baseName: "layout_type",
        type: "DashboardLayoutType",
        required: true,
    },
    modifiedAt: {
        baseName: "modified_at",
        type: "Date",
        format: "date-time",
    },
    notifyList: {
        baseName: "notify_list",
        type: "Array<string>",
    },
    reflowType: {
        baseName: "reflow_type",
        type: "DashboardReflowType",
    },
    restrictedRoles: {
        baseName: "restricted_roles",
        type: "Array<string>",
    },
    templateVariablePresets: {
        baseName: "template_variable_presets",
        type: "Array<DashboardTemplateVariablePreset>",
    },
    templateVariables: {
        baseName: "template_variables",
        type: "Array<DashboardTemplateVariable>",
    },
    title: {
        baseName: "title",
        type: "string",
        required: true,
    },
    url: {
        baseName: "url",
        type: "string",
    },
    widgets: {
        baseName: "widgets",
        type: "Array<Widget>",
        required: true,
    },
};
//# sourceMappingURL=Dashboard.js.map

/***/ }),

/***/ 66634:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardBulkActionData = void 0;
/**
 * Dashboard bulk action request data.
 */
class DashboardBulkActionData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardBulkActionData.attributeTypeMap;
    }
}
exports.DashboardBulkActionData = DashboardBulkActionData;
/**
 * @ignore
 */
DashboardBulkActionData.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "DashboardResourceType",
        required: true,
    },
};
//# sourceMappingURL=DashboardBulkActionData.js.map

/***/ }),

/***/ 14689:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardBulkDeleteRequest = void 0;
/**
 * Dashboard bulk delete request body.
 */
class DashboardBulkDeleteRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardBulkDeleteRequest.attributeTypeMap;
    }
}
exports.DashboardBulkDeleteRequest = DashboardBulkDeleteRequest;
/**
 * @ignore
 */
DashboardBulkDeleteRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<DashboardBulkActionData>",
        required: true,
    },
};
//# sourceMappingURL=DashboardBulkDeleteRequest.js.map

/***/ }),

/***/ 22899:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardDeleteResponse = void 0;
/**
 * Response from the delete dashboard call.
 */
class DashboardDeleteResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardDeleteResponse.attributeTypeMap;
    }
}
exports.DashboardDeleteResponse = DashboardDeleteResponse;
/**
 * @ignore
 */
DashboardDeleteResponse.attributeTypeMap = {
    deletedDashboardId: {
        baseName: "deleted_dashboard_id",
        type: "string",
    },
};
//# sourceMappingURL=DashboardDeleteResponse.js.map

/***/ }),

/***/ 37165:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardList = void 0;
/**
 * Your Datadog Dashboards.
 */
class DashboardList {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardList.attributeTypeMap;
    }
}
exports.DashboardList = DashboardList;
/**
 * @ignore
 */
DashboardList.attributeTypeMap = {
    author: {
        baseName: "author",
        type: "Creator",
    },
    created: {
        baseName: "created",
        type: "Date",
        format: "date-time",
    },
    dashboardCount: {
        baseName: "dashboard_count",
        type: "number",
        format: "int64",
    },
    id: {
        baseName: "id",
        type: "number",
        format: "int64",
    },
    isFavorite: {
        baseName: "is_favorite",
        type: "boolean",
    },
    modified: {
        baseName: "modified",
        type: "Date",
        format: "date-time",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "string",
    },
};
//# sourceMappingURL=DashboardList.js.map

/***/ }),

/***/ 40167:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardListDeleteResponse = void 0;
/**
 * Deleted dashboard details.
 */
class DashboardListDeleteResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardListDeleteResponse.attributeTypeMap;
    }
}
exports.DashboardListDeleteResponse = DashboardListDeleteResponse;
/**
 * @ignore
 */
DashboardListDeleteResponse.attributeTypeMap = {
    deletedDashboardListId: {
        baseName: "deleted_dashboard_list_id",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=DashboardListDeleteResponse.js.map

/***/ }),

/***/ 18934:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardListListResponse = void 0;
/**
 * Information on your dashboard lists.
 */
class DashboardListListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardListListResponse.attributeTypeMap;
    }
}
exports.DashboardListListResponse = DashboardListListResponse;
/**
 * @ignore
 */
DashboardListListResponse.attributeTypeMap = {
    dashboardLists: {
        baseName: "dashboard_lists",
        type: "Array<DashboardList>",
    },
};
//# sourceMappingURL=DashboardListListResponse.js.map

/***/ }),

/***/ 15827:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardRestoreRequest = void 0;
/**
 * Dashboard restore request body.
 */
class DashboardRestoreRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardRestoreRequest.attributeTypeMap;
    }
}
exports.DashboardRestoreRequest = DashboardRestoreRequest;
/**
 * @ignore
 */
DashboardRestoreRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<DashboardBulkActionData>",
        required: true,
    },
};
//# sourceMappingURL=DashboardRestoreRequest.js.map

/***/ }),

/***/ 71472:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardSummary = void 0;
/**
 * Dashboard summary response.
 */
class DashboardSummary {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardSummary.attributeTypeMap;
    }
}
exports.DashboardSummary = DashboardSummary;
/**
 * @ignore
 */
DashboardSummary.attributeTypeMap = {
    dashboards: {
        baseName: "dashboards",
        type: "Array<DashboardSummaryDefinition>",
    },
};
//# sourceMappingURL=DashboardSummary.js.map

/***/ }),

/***/ 45087:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardSummaryDefinition = void 0;
/**
 * Dashboard definition.
 */
class DashboardSummaryDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardSummaryDefinition.attributeTypeMap;
    }
}
exports.DashboardSummaryDefinition = DashboardSummaryDefinition;
/**
 * @ignore
 */
DashboardSummaryDefinition.attributeTypeMap = {
    authorHandle: {
        baseName: "author_handle",
        type: "string",
    },
    createdAt: {
        baseName: "created_at",
        type: "Date",
        format: "date-time",
    },
    description: {
        baseName: "description",
        type: "string",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    isReadOnly: {
        baseName: "is_read_only",
        type: "boolean",
    },
    layoutType: {
        baseName: "layout_type",
        type: "DashboardLayoutType",
    },
    modifiedAt: {
        baseName: "modified_at",
        type: "Date",
        format: "date-time",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    url: {
        baseName: "url",
        type: "string",
    },
};
//# sourceMappingURL=DashboardSummaryDefinition.js.map

/***/ }),

/***/ 99326:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardTemplateVariable = void 0;
/**
 * Template variable.
 */
class DashboardTemplateVariable {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardTemplateVariable.attributeTypeMap;
    }
}
exports.DashboardTemplateVariable = DashboardTemplateVariable;
/**
 * @ignore
 */
DashboardTemplateVariable.attributeTypeMap = {
    availableValues: {
        baseName: "available_values",
        type: "Array<string>",
    },
    _default: {
        baseName: "default",
        type: "string",
    },
    defaults: {
        baseName: "defaults",
        type: "Array<string>",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    prefix: {
        baseName: "prefix",
        type: "string",
    },
};
//# sourceMappingURL=DashboardTemplateVariable.js.map

/***/ }),

/***/ 37874:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardTemplateVariablePreset = void 0;
/**
 * Template variables saved views.
 */
class DashboardTemplateVariablePreset {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardTemplateVariablePreset.attributeTypeMap;
    }
}
exports.DashboardTemplateVariablePreset = DashboardTemplateVariablePreset;
/**
 * @ignore
 */
DashboardTemplateVariablePreset.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
    },
    templateVariables: {
        baseName: "template_variables",
        type: "Array<DashboardTemplateVariablePresetValue>",
    },
};
//# sourceMappingURL=DashboardTemplateVariablePreset.js.map

/***/ }),

/***/ 7037:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardTemplateVariablePresetValue = void 0;
/**
 * Template variables saved views.
 */
class DashboardTemplateVariablePresetValue {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardTemplateVariablePresetValue.attributeTypeMap;
    }
}
exports.DashboardTemplateVariablePresetValue = DashboardTemplateVariablePresetValue;
/**
 * @ignore
 */
DashboardTemplateVariablePresetValue.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
    },
    value: {
        baseName: "value",
        type: "string",
    },
    values: {
        baseName: "values",
        type: "Array<string>",
    },
};
//# sourceMappingURL=DashboardTemplateVariablePresetValue.js.map

/***/ }),

/***/ 4711:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeletedMonitor = void 0;
/**
 * Response from the delete monitor call.
 */
class DeletedMonitor {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DeletedMonitor.attributeTypeMap;
    }
}
exports.DeletedMonitor = DeletedMonitor;
/**
 * @ignore
 */
DeletedMonitor.attributeTypeMap = {
    deletedMonitorId: {
        baseName: "deleted_monitor_id",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=DeletedMonitor.js.map

/***/ }),

/***/ 5990:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DistributionPointsPayload = void 0;
/**
 * The distribution points payload.
 */
class DistributionPointsPayload {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DistributionPointsPayload.attributeTypeMap;
    }
}
exports.DistributionPointsPayload = DistributionPointsPayload;
/**
 * @ignore
 */
DistributionPointsPayload.attributeTypeMap = {
    series: {
        baseName: "series",
        type: "Array<DistributionPointsSeries>",
        required: true,
    },
};
//# sourceMappingURL=DistributionPointsPayload.js.map

/***/ }),

/***/ 2963:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DistributionPointsSeries = void 0;
/**
 * A distribution points metric to submit to Datadog.
 */
class DistributionPointsSeries {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DistributionPointsSeries.attributeTypeMap;
    }
}
exports.DistributionPointsSeries = DistributionPointsSeries;
/**
 * @ignore
 */
DistributionPointsSeries.attributeTypeMap = {
    host: {
        baseName: "host",
        type: "string",
    },
    metric: {
        baseName: "metric",
        type: "string",
        required: true,
    },
    points: {
        baseName: "points",
        type: "Array<[DistributionPointItem, DistributionPointItem]>",
        required: true,
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    type: {
        baseName: "type",
        type: "DistributionPointsType",
    },
};
//# sourceMappingURL=DistributionPointsSeries.js.map

/***/ }),

/***/ 88954:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DistributionWidgetDefinition = void 0;
/**
 * The Distribution visualization is another way of showing metrics
 * aggregated across one or several tags, such as hosts.
 * Unlike the heat map, a distribution graphs x-axis is quantity rather than time.
 */
class DistributionWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DistributionWidgetDefinition.attributeTypeMap;
    }
}
exports.DistributionWidgetDefinition = DistributionWidgetDefinition;
/**
 * @ignore
 */
DistributionWidgetDefinition.attributeTypeMap = {
    legendSize: {
        baseName: "legend_size",
        type: "string",
    },
    markers: {
        baseName: "markers",
        type: "Array<WidgetMarker>",
    },
    requests: {
        baseName: "requests",
        type: "[DistributionWidgetRequest]",
        required: true,
    },
    showLegend: {
        baseName: "show_legend",
        type: "boolean",
    },
    time: {
        baseName: "time",
        type: "WidgetTime",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "DistributionWidgetDefinitionType",
        required: true,
    },
    xaxis: {
        baseName: "xaxis",
        type: "DistributionWidgetXAxis",
    },
    yaxis: {
        baseName: "yaxis",
        type: "DistributionWidgetYAxis",
    },
};
//# sourceMappingURL=DistributionWidgetDefinition.js.map

/***/ }),

/***/ 54139:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DistributionWidgetRequest = void 0;
/**
 * Updated distribution widget.
 */
class DistributionWidgetRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DistributionWidgetRequest.attributeTypeMap;
    }
}
exports.DistributionWidgetRequest = DistributionWidgetRequest;
/**
 * @ignore
 */
DistributionWidgetRequest.attributeTypeMap = {
    apmQuery: {
        baseName: "apm_query",
        type: "LogQueryDefinition",
    },
    apmStatsQuery: {
        baseName: "apm_stats_query",
        type: "ApmStatsQueryDefinition",
    },
    eventQuery: {
        baseName: "event_query",
        type: "LogQueryDefinition",
    },
    logQuery: {
        baseName: "log_query",
        type: "LogQueryDefinition",
    },
    networkQuery: {
        baseName: "network_query",
        type: "LogQueryDefinition",
    },
    processQuery: {
        baseName: "process_query",
        type: "ProcessQueryDefinition",
    },
    profileMetricsQuery: {
        baseName: "profile_metrics_query",
        type: "LogQueryDefinition",
    },
    q: {
        baseName: "q",
        type: "string",
    },
    query: {
        baseName: "query",
        type: "DistributionWidgetHistogramRequestQuery",
    },
    requestType: {
        baseName: "request_type",
        type: "DistributionWidgetHistogramRequestType",
    },
    rumQuery: {
        baseName: "rum_query",
        type: "LogQueryDefinition",
    },
    securityQuery: {
        baseName: "security_query",
        type: "LogQueryDefinition",
    },
    style: {
        baseName: "style",
        type: "WidgetStyle",
    },
};
//# sourceMappingURL=DistributionWidgetRequest.js.map

/***/ }),

/***/ 59792:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DistributionWidgetXAxis = void 0;
/**
 * X Axis controls for the distribution widget.
 */
class DistributionWidgetXAxis {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DistributionWidgetXAxis.attributeTypeMap;
    }
}
exports.DistributionWidgetXAxis = DistributionWidgetXAxis;
/**
 * @ignore
 */
DistributionWidgetXAxis.attributeTypeMap = {
    includeZero: {
        baseName: "include_zero",
        type: "boolean",
    },
    max: {
        baseName: "max",
        type: "string",
    },
    min: {
        baseName: "min",
        type: "string",
    },
    scale: {
        baseName: "scale",
        type: "string",
    },
};
//# sourceMappingURL=DistributionWidgetXAxis.js.map

/***/ }),

/***/ 53869:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DistributionWidgetYAxis = void 0;
/**
 * Y Axis controls for the distribution widget.
 */
class DistributionWidgetYAxis {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DistributionWidgetYAxis.attributeTypeMap;
    }
}
exports.DistributionWidgetYAxis = DistributionWidgetYAxis;
/**
 * @ignore
 */
DistributionWidgetYAxis.attributeTypeMap = {
    includeZero: {
        baseName: "include_zero",
        type: "boolean",
    },
    label: {
        baseName: "label",
        type: "string",
    },
    max: {
        baseName: "max",
        type: "string",
    },
    min: {
        baseName: "min",
        type: "string",
    },
    scale: {
        baseName: "scale",
        type: "string",
    },
};
//# sourceMappingURL=DistributionWidgetYAxis.js.map

/***/ }),

/***/ 66345:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Downtime = void 0;
/**
 * Downtiming gives you greater control over monitor notifications by
 * allowing you to globally exclude scopes from alerting.
 * Downtime settings, which can be scheduled with start and end times,
 * prevent all alerting related to specified Datadog tags.
 */
class Downtime {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return Downtime.attributeTypeMap;
    }
}
exports.Downtime = Downtime;
/**
 * @ignore
 */
Downtime.attributeTypeMap = {
    active: {
        baseName: "active",
        type: "boolean",
    },
    activeChild: {
        baseName: "active_child",
        type: "DowntimeChild",
    },
    canceled: {
        baseName: "canceled",
        type: "number",
        format: "int64",
    },
    creatorId: {
        baseName: "creator_id",
        type: "number",
        format: "int32",
    },
    disabled: {
        baseName: "disabled",
        type: "boolean",
    },
    downtimeType: {
        baseName: "downtime_type",
        type: "number",
        format: "int32",
    },
    end: {
        baseName: "end",
        type: "number",
        format: "int64",
    },
    id: {
        baseName: "id",
        type: "number",
        format: "int64",
    },
    message: {
        baseName: "message",
        type: "string",
    },
    monitorId: {
        baseName: "monitor_id",
        type: "number",
        format: "int64",
    },
    monitorTags: {
        baseName: "monitor_tags",
        type: "Array<string>",
    },
    muteFirstRecoveryNotification: {
        baseName: "mute_first_recovery_notification",
        type: "boolean",
    },
    parentId: {
        baseName: "parent_id",
        type: "number",
        format: "int64",
    },
    recurrence: {
        baseName: "recurrence",
        type: "DowntimeRecurrence",
    },
    scope: {
        baseName: "scope",
        type: "Array<string>",
    },
    start: {
        baseName: "start",
        type: "number",
        format: "int64",
    },
    timezone: {
        baseName: "timezone",
        type: "string",
    },
    updaterId: {
        baseName: "updater_id",
        type: "number",
        format: "int32",
    },
};
//# sourceMappingURL=Downtime.js.map

/***/ }),

/***/ 36940:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DowntimeChild = void 0;
/**
 * The downtime object definition of the active child for the original parent recurring downtime. This
 * field will only exist on recurring downtimes.
 */
class DowntimeChild {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DowntimeChild.attributeTypeMap;
    }
}
exports.DowntimeChild = DowntimeChild;
/**
 * @ignore
 */
DowntimeChild.attributeTypeMap = {
    active: {
        baseName: "active",
        type: "boolean",
    },
    canceled: {
        baseName: "canceled",
        type: "number",
        format: "int64",
    },
    creatorId: {
        baseName: "creator_id",
        type: "number",
        format: "int32",
    },
    disabled: {
        baseName: "disabled",
        type: "boolean",
    },
    downtimeType: {
        baseName: "downtime_type",
        type: "number",
        format: "int32",
    },
    end: {
        baseName: "end",
        type: "number",
        format: "int64",
    },
    id: {
        baseName: "id",
        type: "number",
        format: "int64",
    },
    message: {
        baseName: "message",
        type: "string",
    },
    monitorId: {
        baseName: "monitor_id",
        type: "number",
        format: "int64",
    },
    monitorTags: {
        baseName: "monitor_tags",
        type: "Array<string>",
    },
    muteFirstRecoveryNotification: {
        baseName: "mute_first_recovery_notification",
        type: "boolean",
    },
    parentId: {
        baseName: "parent_id",
        type: "number",
        format: "int64",
    },
    recurrence: {
        baseName: "recurrence",
        type: "DowntimeRecurrence",
    },
    scope: {
        baseName: "scope",
        type: "Array<string>",
    },
    start: {
        baseName: "start",
        type: "number",
        format: "int64",
    },
    timezone: {
        baseName: "timezone",
        type: "string",
    },
    updaterId: {
        baseName: "updater_id",
        type: "number",
        format: "int32",
    },
};
//# sourceMappingURL=DowntimeChild.js.map

/***/ }),

/***/ 10878:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DowntimeRecurrence = void 0;
/**
 * An object defining the recurrence of the downtime.
 */
class DowntimeRecurrence {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DowntimeRecurrence.attributeTypeMap;
    }
}
exports.DowntimeRecurrence = DowntimeRecurrence;
/**
 * @ignore
 */
DowntimeRecurrence.attributeTypeMap = {
    period: {
        baseName: "period",
        type: "number",
        format: "int32",
    },
    rrule: {
        baseName: "rrule",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "string",
    },
    untilDate: {
        baseName: "until_date",
        type: "number",
        format: "int64",
    },
    untilOccurrences: {
        baseName: "until_occurrences",
        type: "number",
        format: "int32",
    },
    weekDays: {
        baseName: "week_days",
        type: "Array<string>",
    },
};
//# sourceMappingURL=DowntimeRecurrence.js.map

/***/ }),

/***/ 68426:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Event = void 0;
/**
 * Object representing an event.
 */
class Event {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return Event.attributeTypeMap;
    }
}
exports.Event = Event;
/**
 * @ignore
 */
Event.attributeTypeMap = {
    alertType: {
        baseName: "alert_type",
        type: "EventAlertType",
    },
    dateHappened: {
        baseName: "date_happened",
        type: "number",
        format: "int64",
    },
    deviceName: {
        baseName: "device_name",
        type: "string",
    },
    host: {
        baseName: "host",
        type: "string",
    },
    id: {
        baseName: "id",
        type: "number",
        format: "int64",
    },
    idStr: {
        baseName: "id_str",
        type: "string",
    },
    payload: {
        baseName: "payload",
        type: "string",
    },
    priority: {
        baseName: "priority",
        type: "EventPriority",
    },
    sourceTypeName: {
        baseName: "source_type_name",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    text: {
        baseName: "text",
        type: "string",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    url: {
        baseName: "url",
        type: "string",
    },
};
//# sourceMappingURL=Event.js.map

/***/ }),

/***/ 98964:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventCreateRequest = void 0;
/**
 * Object representing an event.
 */
class EventCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventCreateRequest.attributeTypeMap;
    }
}
exports.EventCreateRequest = EventCreateRequest;
/**
 * @ignore
 */
EventCreateRequest.attributeTypeMap = {
    aggregationKey: {
        baseName: "aggregation_key",
        type: "string",
    },
    alertType: {
        baseName: "alert_type",
        type: "EventAlertType",
    },
    dateHappened: {
        baseName: "date_happened",
        type: "number",
        format: "int64",
    },
    deviceName: {
        baseName: "device_name",
        type: "string",
    },
    host: {
        baseName: "host",
        type: "string",
    },
    priority: {
        baseName: "priority",
        type: "EventPriority",
    },
    relatedEventId: {
        baseName: "related_event_id",
        type: "number",
        format: "int64",
    },
    sourceTypeName: {
        baseName: "source_type_name",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    text: {
        baseName: "text",
        type: "string",
        required: true,
    },
    title: {
        baseName: "title",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=EventCreateRequest.js.map

/***/ }),

/***/ 15571:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventCreateResponse = void 0;
/**
 * Object containing an event response.
 */
class EventCreateResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventCreateResponse.attributeTypeMap;
    }
}
exports.EventCreateResponse = EventCreateResponse;
/**
 * @ignore
 */
EventCreateResponse.attributeTypeMap = {
    event: {
        baseName: "event",
        type: "Event",
    },
    status: {
        baseName: "status",
        type: "string",
    },
};
//# sourceMappingURL=EventCreateResponse.js.map

/***/ }),

/***/ 64758:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventListResponse = void 0;
/**
 * An event list response.
 */
class EventListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventListResponse.attributeTypeMap;
    }
}
exports.EventListResponse = EventListResponse;
/**
 * @ignore
 */
EventListResponse.attributeTypeMap = {
    events: {
        baseName: "events",
        type: "Array<Event>",
    },
    status: {
        baseName: "status",
        type: "string",
    },
};
//# sourceMappingURL=EventListResponse.js.map

/***/ }),

/***/ 86630:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventQueryDefinition = void 0;
/**
 * The event query.
 */
class EventQueryDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventQueryDefinition.attributeTypeMap;
    }
}
exports.EventQueryDefinition = EventQueryDefinition;
/**
 * @ignore
 */
EventQueryDefinition.attributeTypeMap = {
    search: {
        baseName: "search",
        type: "string",
        required: true,
    },
    tagsExecution: {
        baseName: "tags_execution",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=EventQueryDefinition.js.map

/***/ }),

/***/ 57097:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventResponse = void 0;
/**
 * Object containing an event response.
 */
class EventResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventResponse.attributeTypeMap;
    }
}
exports.EventResponse = EventResponse;
/**
 * @ignore
 */
EventResponse.attributeTypeMap = {
    event: {
        baseName: "event",
        type: "Event",
    },
    status: {
        baseName: "status",
        type: "string",
    },
};
//# sourceMappingURL=EventResponse.js.map

/***/ }),

/***/ 41446:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventStreamWidgetDefinition = void 0;
/**
 * The event stream is a widget version of the stream of events
 * on the Event Stream view. Only available on FREE layout dashboards.
 */
class EventStreamWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventStreamWidgetDefinition.attributeTypeMap;
    }
}
exports.EventStreamWidgetDefinition = EventStreamWidgetDefinition;
/**
 * @ignore
 */
EventStreamWidgetDefinition.attributeTypeMap = {
    eventSize: {
        baseName: "event_size",
        type: "WidgetEventSize",
    },
    query: {
        baseName: "query",
        type: "string",
        required: true,
    },
    tagsExecution: {
        baseName: "tags_execution",
        type: "string",
    },
    time: {
        baseName: "time",
        type: "WidgetTime",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "EventStreamWidgetDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=EventStreamWidgetDefinition.js.map

/***/ }),

/***/ 5387:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventTimelineWidgetDefinition = void 0;
/**
 * The event timeline is a widget version of the timeline that appears at the top of the Event Stream view. Only available on FREE layout dashboards.
 */
class EventTimelineWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventTimelineWidgetDefinition.attributeTypeMap;
    }
}
exports.EventTimelineWidgetDefinition = EventTimelineWidgetDefinition;
/**
 * @ignore
 */
EventTimelineWidgetDefinition.attributeTypeMap = {
    query: {
        baseName: "query",
        type: "string",
        required: true,
    },
    tagsExecution: {
        baseName: "tags_execution",
        type: "string",
    },
    time: {
        baseName: "time",
        type: "WidgetTime",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "EventTimelineWidgetDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=EventTimelineWidgetDefinition.js.map

/***/ }),

/***/ 86280:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormulaAndFunctionApmDependencyStatsQueryDefinition = void 0;
/**
 * A formula and functions APM dependency stats query.
 */
class FormulaAndFunctionApmDependencyStatsQueryDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FormulaAndFunctionApmDependencyStatsQueryDefinition.attributeTypeMap;
    }
}
exports.FormulaAndFunctionApmDependencyStatsQueryDefinition = FormulaAndFunctionApmDependencyStatsQueryDefinition;
/**
 * @ignore
 */
FormulaAndFunctionApmDependencyStatsQueryDefinition.attributeTypeMap = {
    dataSource: {
        baseName: "data_source",
        type: "FormulaAndFunctionApmDependencyStatsDataSource",
        required: true,
    },
    env: {
        baseName: "env",
        type: "string",
        required: true,
    },
    isUpstream: {
        baseName: "is_upstream",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    operationName: {
        baseName: "operation_name",
        type: "string",
        required: true,
    },
    primaryTagName: {
        baseName: "primary_tag_name",
        type: "string",
    },
    primaryTagValue: {
        baseName: "primary_tag_value",
        type: "string",
    },
    resourceName: {
        baseName: "resource_name",
        type: "string",
        required: true,
    },
    service: {
        baseName: "service",
        type: "string",
        required: true,
    },
    stat: {
        baseName: "stat",
        type: "FormulaAndFunctionApmDependencyStatName",
        required: true,
    },
};
//# sourceMappingURL=FormulaAndFunctionApmDependencyStatsQueryDefinition.js.map

/***/ }),

/***/ 38483:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormulaAndFunctionApmResourceStatsQueryDefinition = void 0;
/**
 * APM resource stats query using formulas and functions.
 */
class FormulaAndFunctionApmResourceStatsQueryDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FormulaAndFunctionApmResourceStatsQueryDefinition.attributeTypeMap;
    }
}
exports.FormulaAndFunctionApmResourceStatsQueryDefinition = FormulaAndFunctionApmResourceStatsQueryDefinition;
/**
 * @ignore
 */
FormulaAndFunctionApmResourceStatsQueryDefinition.attributeTypeMap = {
    dataSource: {
        baseName: "data_source",
        type: "FormulaAndFunctionApmResourceStatsDataSource",
        required: true,
    },
    env: {
        baseName: "env",
        type: "string",
        required: true,
    },
    groupBy: {
        baseName: "group_by",
        type: "Array<string>",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    operationName: {
        baseName: "operation_name",
        type: "string",
    },
    primaryTagName: {
        baseName: "primary_tag_name",
        type: "string",
    },
    primaryTagValue: {
        baseName: "primary_tag_value",
        type: "string",
    },
    resourceName: {
        baseName: "resource_name",
        type: "string",
    },
    service: {
        baseName: "service",
        type: "string",
        required: true,
    },
    stat: {
        baseName: "stat",
        type: "FormulaAndFunctionApmResourceStatName",
        required: true,
    },
};
//# sourceMappingURL=FormulaAndFunctionApmResourceStatsQueryDefinition.js.map

/***/ }),

/***/ 922:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormulaAndFunctionEventQueryDefinition = void 0;
/**
 * A formula and functions events query.
 */
class FormulaAndFunctionEventQueryDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FormulaAndFunctionEventQueryDefinition.attributeTypeMap;
    }
}
exports.FormulaAndFunctionEventQueryDefinition = FormulaAndFunctionEventQueryDefinition;
/**
 * @ignore
 */
FormulaAndFunctionEventQueryDefinition.attributeTypeMap = {
    compute: {
        baseName: "compute",
        type: "FormulaAndFunctionEventQueryDefinitionCompute",
        required: true,
    },
    dataSource: {
        baseName: "data_source",
        type: "FormulaAndFunctionEventsDataSource",
        required: true,
    },
    groupBy: {
        baseName: "group_by",
        type: "Array<FormulaAndFunctionEventQueryGroupBy>",
    },
    indexes: {
        baseName: "indexes",
        type: "Array<string>",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    search: {
        baseName: "search",
        type: "FormulaAndFunctionEventQueryDefinitionSearch",
    },
    storage: {
        baseName: "storage",
        type: "string",
    },
};
//# sourceMappingURL=FormulaAndFunctionEventQueryDefinition.js.map

/***/ }),

/***/ 23526:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormulaAndFunctionEventQueryDefinitionCompute = void 0;
/**
 * Compute options.
 */
class FormulaAndFunctionEventQueryDefinitionCompute {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FormulaAndFunctionEventQueryDefinitionCompute.attributeTypeMap;
    }
}
exports.FormulaAndFunctionEventQueryDefinitionCompute = FormulaAndFunctionEventQueryDefinitionCompute;
/**
 * @ignore
 */
FormulaAndFunctionEventQueryDefinitionCompute.attributeTypeMap = {
    aggregation: {
        baseName: "aggregation",
        type: "FormulaAndFunctionEventAggregation",
        required: true,
    },
    interval: {
        baseName: "interval",
        type: "number",
        format: "int64",
    },
    metric: {
        baseName: "metric",
        type: "string",
    },
};
//# sourceMappingURL=FormulaAndFunctionEventQueryDefinitionCompute.js.map

/***/ }),

/***/ 35781:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormulaAndFunctionEventQueryDefinitionSearch = void 0;
/**
 * Search options.
 */
class FormulaAndFunctionEventQueryDefinitionSearch {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FormulaAndFunctionEventQueryDefinitionSearch.attributeTypeMap;
    }
}
exports.FormulaAndFunctionEventQueryDefinitionSearch = FormulaAndFunctionEventQueryDefinitionSearch;
/**
 * @ignore
 */
FormulaAndFunctionEventQueryDefinitionSearch.attributeTypeMap = {
    query: {
        baseName: "query",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=FormulaAndFunctionEventQueryDefinitionSearch.js.map

/***/ }),

/***/ 40218:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormulaAndFunctionEventQueryGroupBy = void 0;
/**
 * List of objects used to group by.
 */
class FormulaAndFunctionEventQueryGroupBy {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FormulaAndFunctionEventQueryGroupBy.attributeTypeMap;
    }
}
exports.FormulaAndFunctionEventQueryGroupBy = FormulaAndFunctionEventQueryGroupBy;
/**
 * @ignore
 */
FormulaAndFunctionEventQueryGroupBy.attributeTypeMap = {
    facet: {
        baseName: "facet",
        type: "string",
        required: true,
    },
    limit: {
        baseName: "limit",
        type: "number",
        format: "int64",
    },
    sort: {
        baseName: "sort",
        type: "FormulaAndFunctionEventQueryGroupBySort",
    },
};
//# sourceMappingURL=FormulaAndFunctionEventQueryGroupBy.js.map

/***/ }),

/***/ 66766:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormulaAndFunctionEventQueryGroupBySort = void 0;
/**
 * Options for sorting group by results.
 */
class FormulaAndFunctionEventQueryGroupBySort {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FormulaAndFunctionEventQueryGroupBySort.attributeTypeMap;
    }
}
exports.FormulaAndFunctionEventQueryGroupBySort = FormulaAndFunctionEventQueryGroupBySort;
/**
 * @ignore
 */
FormulaAndFunctionEventQueryGroupBySort.attributeTypeMap = {
    aggregation: {
        baseName: "aggregation",
        type: "FormulaAndFunctionEventAggregation",
        required: true,
    },
    metric: {
        baseName: "metric",
        type: "string",
    },
    order: {
        baseName: "order",
        type: "QuerySortOrder",
    },
};
//# sourceMappingURL=FormulaAndFunctionEventQueryGroupBySort.js.map

/***/ }),

/***/ 61311:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormulaAndFunctionMetricQueryDefinition = void 0;
/**
 * A formula and functions metrics query.
 */
class FormulaAndFunctionMetricQueryDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FormulaAndFunctionMetricQueryDefinition.attributeTypeMap;
    }
}
exports.FormulaAndFunctionMetricQueryDefinition = FormulaAndFunctionMetricQueryDefinition;
/**
 * @ignore
 */
FormulaAndFunctionMetricQueryDefinition.attributeTypeMap = {
    aggregator: {
        baseName: "aggregator",
        type: "FormulaAndFunctionMetricAggregation",
    },
    dataSource: {
        baseName: "data_source",
        type: "FormulaAndFunctionMetricDataSource",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    query: {
        baseName: "query",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=FormulaAndFunctionMetricQueryDefinition.js.map

/***/ }),

/***/ 57572:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormulaAndFunctionProcessQueryDefinition = void 0;
/**
 * Process query using formulas and functions.
 */
class FormulaAndFunctionProcessQueryDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FormulaAndFunctionProcessQueryDefinition.attributeTypeMap;
    }
}
exports.FormulaAndFunctionProcessQueryDefinition = FormulaAndFunctionProcessQueryDefinition;
/**
 * @ignore
 */
FormulaAndFunctionProcessQueryDefinition.attributeTypeMap = {
    aggregator: {
        baseName: "aggregator",
        type: "FormulaAndFunctionMetricAggregation",
    },
    dataSource: {
        baseName: "data_source",
        type: "FormulaAndFunctionProcessQueryDataSource",
        required: true,
    },
    isNormalizedCpu: {
        baseName: "is_normalized_cpu",
        type: "boolean",
    },
    limit: {
        baseName: "limit",
        type: "number",
        format: "int64",
    },
    metric: {
        baseName: "metric",
        type: "string",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    sort: {
        baseName: "sort",
        type: "QuerySortOrder",
    },
    tagFilters: {
        baseName: "tag_filters",
        type: "Array<string>",
    },
    textFilter: {
        baseName: "text_filter",
        type: "string",
    },
};
//# sourceMappingURL=FormulaAndFunctionProcessQueryDefinition.js.map

/***/ }),

/***/ 3026:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FreeTextWidgetDefinition = void 0;
/**
 * Free text is a widget that allows you to add headings to your screenboard. Commonly used to state the overall purpose of the dashboard. Only available on FREE layout dashboards.
 */
class FreeTextWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FreeTextWidgetDefinition.attributeTypeMap;
    }
}
exports.FreeTextWidgetDefinition = FreeTextWidgetDefinition;
/**
 * @ignore
 */
FreeTextWidgetDefinition.attributeTypeMap = {
    color: {
        baseName: "color",
        type: "string",
    },
    fontSize: {
        baseName: "font_size",
        type: "string",
    },
    text: {
        baseName: "text",
        type: "string",
        required: true,
    },
    textAlign: {
        baseName: "text_align",
        type: "WidgetTextAlign",
    },
    type: {
        baseName: "type",
        type: "FreeTextWidgetDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=FreeTextWidgetDefinition.js.map

/***/ }),

/***/ 87832:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunnelQuery = void 0;
/**
 * Updated funnel widget.
 */
class FunnelQuery {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FunnelQuery.attributeTypeMap;
    }
}
exports.FunnelQuery = FunnelQuery;
/**
 * @ignore
 */
FunnelQuery.attributeTypeMap = {
    dataSource: {
        baseName: "data_source",
        type: "FunnelSource",
        required: true,
    },
    queryString: {
        baseName: "query_string",
        type: "string",
        required: true,
    },
    steps: {
        baseName: "steps",
        type: "Array<FunnelStep>",
        required: true,
    },
};
//# sourceMappingURL=FunnelQuery.js.map

/***/ }),

/***/ 15073:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunnelStep = void 0;
/**
 * The funnel step.
 */
class FunnelStep {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FunnelStep.attributeTypeMap;
    }
}
exports.FunnelStep = FunnelStep;
/**
 * @ignore
 */
FunnelStep.attributeTypeMap = {
    facet: {
        baseName: "facet",
        type: "string",
        required: true,
    },
    value: {
        baseName: "value",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=FunnelStep.js.map

/***/ }),

/***/ 20000:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunnelWidgetDefinition = void 0;
/**
 * The funnel visualization displays a funnel of user sessions that maps a sequence of view navigation and user interaction in your application.
 */
class FunnelWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FunnelWidgetDefinition.attributeTypeMap;
    }
}
exports.FunnelWidgetDefinition = FunnelWidgetDefinition;
/**
 * @ignore
 */
FunnelWidgetDefinition.attributeTypeMap = {
    requests: {
        baseName: "requests",
        type: "[FunnelWidgetRequest]",
        required: true,
    },
    time: {
        baseName: "time",
        type: "WidgetTime",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "FunnelWidgetDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=FunnelWidgetDefinition.js.map

/***/ }),

/***/ 75402:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunnelWidgetRequest = void 0;
/**
 * Updated funnel widget.
 */
class FunnelWidgetRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FunnelWidgetRequest.attributeTypeMap;
    }
}
exports.FunnelWidgetRequest = FunnelWidgetRequest;
/**
 * @ignore
 */
FunnelWidgetRequest.attributeTypeMap = {
    query: {
        baseName: "query",
        type: "FunnelQuery",
        required: true,
    },
    requestType: {
        baseName: "request_type",
        type: "FunnelRequestType",
        required: true,
    },
};
//# sourceMappingURL=FunnelWidgetRequest.js.map

/***/ }),

/***/ 78369:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GCPAccount = void 0;
/**
 * Your Google Cloud Platform Account.
 */
class GCPAccount {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return GCPAccount.attributeTypeMap;
    }
}
exports.GCPAccount = GCPAccount;
/**
 * @ignore
 */
GCPAccount.attributeTypeMap = {
    authProviderX509CertUrl: {
        baseName: "auth_provider_x509_cert_url",
        type: "string",
    },
    authUri: {
        baseName: "auth_uri",
        type: "string",
    },
    automute: {
        baseName: "automute",
        type: "boolean",
    },
    clientEmail: {
        baseName: "client_email",
        type: "string",
    },
    clientId: {
        baseName: "client_id",
        type: "string",
    },
    clientX509CertUrl: {
        baseName: "client_x509_cert_url",
        type: "string",
    },
    errors: {
        baseName: "errors",
        type: "Array<string>",
    },
    hostFilters: {
        baseName: "host_filters",
        type: "string",
    },
    isCspmEnabled: {
        baseName: "is_cspm_enabled",
        type: "boolean",
    },
    privateKey: {
        baseName: "private_key",
        type: "string",
    },
    privateKeyId: {
        baseName: "private_key_id",
        type: "string",
    },
    projectId: {
        baseName: "project_id",
        type: "string",
    },
    tokenUri: {
        baseName: "token_uri",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "string",
    },
};
//# sourceMappingURL=GCPAccount.js.map

/***/ }),

/***/ 919:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GeomapWidgetDefinition = void 0;
/**
 * This visualization displays a series of values by country on a world map.
 */
class GeomapWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return GeomapWidgetDefinition.attributeTypeMap;
    }
}
exports.GeomapWidgetDefinition = GeomapWidgetDefinition;
/**
 * @ignore
 */
GeomapWidgetDefinition.attributeTypeMap = {
    customLinks: {
        baseName: "custom_links",
        type: "Array<WidgetCustomLink>",
    },
    requests: {
        baseName: "requests",
        type: "[GeomapWidgetRequest]",
        required: true,
    },
    style: {
        baseName: "style",
        type: "GeomapWidgetDefinitionStyle",
        required: true,
    },
    time: {
        baseName: "time",
        type: "WidgetTime",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "GeomapWidgetDefinitionType",
        required: true,
    },
    view: {
        baseName: "view",
        type: "GeomapWidgetDefinitionView",
        required: true,
    },
};
//# sourceMappingURL=GeomapWidgetDefinition.js.map

/***/ }),

/***/ 42280:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GeomapWidgetDefinitionStyle = void 0;
/**
 * The style to apply to the widget.
 */
class GeomapWidgetDefinitionStyle {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return GeomapWidgetDefinitionStyle.attributeTypeMap;
    }
}
exports.GeomapWidgetDefinitionStyle = GeomapWidgetDefinitionStyle;
/**
 * @ignore
 */
GeomapWidgetDefinitionStyle.attributeTypeMap = {
    palette: {
        baseName: "palette",
        type: "string",
        required: true,
    },
    paletteFlip: {
        baseName: "palette_flip",
        type: "boolean",
        required: true,
    },
};
//# sourceMappingURL=GeomapWidgetDefinitionStyle.js.map

/***/ }),

/***/ 92237:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GeomapWidgetDefinitionView = void 0;
/**
 * The view of the world that the map should render.
 */
class GeomapWidgetDefinitionView {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return GeomapWidgetDefinitionView.attributeTypeMap;
    }
}
exports.GeomapWidgetDefinitionView = GeomapWidgetDefinitionView;
/**
 * @ignore
 */
GeomapWidgetDefinitionView.attributeTypeMap = {
    focus: {
        baseName: "focus",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=GeomapWidgetDefinitionView.js.map

/***/ }),

/***/ 47862:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GeomapWidgetRequest = void 0;
/**
 * An updated geomap widget.
 */
class GeomapWidgetRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return GeomapWidgetRequest.attributeTypeMap;
    }
}
exports.GeomapWidgetRequest = GeomapWidgetRequest;
/**
 * @ignore
 */
GeomapWidgetRequest.attributeTypeMap = {
    formulas: {
        baseName: "formulas",
        type: "Array<WidgetFormula>",
    },
    logQuery: {
        baseName: "log_query",
        type: "LogQueryDefinition",
    },
    q: {
        baseName: "q",
        type: "string",
    },
    queries: {
        baseName: "queries",
        type: "Array<FormulaAndFunctionQueryDefinition>",
    },
    responseFormat: {
        baseName: "response_format",
        type: "FormulaAndFunctionResponseFormat",
    },
    rumQuery: {
        baseName: "rum_query",
        type: "LogQueryDefinition",
    },
    securityQuery: {
        baseName: "security_query",
        type: "LogQueryDefinition",
    },
};
//# sourceMappingURL=GeomapWidgetRequest.js.map

/***/ }),

/***/ 13325:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GraphSnapshot = void 0;
/**
 * Object representing a graph snapshot.
 */
class GraphSnapshot {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return GraphSnapshot.attributeTypeMap;
    }
}
exports.GraphSnapshot = GraphSnapshot;
/**
 * @ignore
 */
GraphSnapshot.attributeTypeMap = {
    graphDef: {
        baseName: "graph_def",
        type: "string",
    },
    metricQuery: {
        baseName: "metric_query",
        type: "string",
    },
    snapshotUrl: {
        baseName: "snapshot_url",
        type: "string",
    },
};
//# sourceMappingURL=GraphSnapshot.js.map

/***/ }),

/***/ 82330:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupWidgetDefinition = void 0;
/**
 * The groups widget allows you to keep similar graphs together on your timeboard. Each group has a custom header, can hold one to many graphs, and is collapsible.
 */
class GroupWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return GroupWidgetDefinition.attributeTypeMap;
    }
}
exports.GroupWidgetDefinition = GroupWidgetDefinition;
/**
 * @ignore
 */
GroupWidgetDefinition.attributeTypeMap = {
    backgroundColor: {
        baseName: "background_color",
        type: "string",
    },
    bannerImg: {
        baseName: "banner_img",
        type: "string",
    },
    layoutType: {
        baseName: "layout_type",
        type: "WidgetLayoutType",
        required: true,
    },
    showTitle: {
        baseName: "show_title",
        type: "boolean",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    type: {
        baseName: "type",
        type: "GroupWidgetDefinitionType",
        required: true,
    },
    widgets: {
        baseName: "widgets",
        type: "Array<Widget>",
        required: true,
    },
};
//# sourceMappingURL=GroupWidgetDefinition.js.map

/***/ }),

/***/ 81263:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HTTPLogError = void 0;
/**
 * Invalid query performed.
 */
class HTTPLogError {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HTTPLogError.attributeTypeMap;
    }
}
exports.HTTPLogError = HTTPLogError;
/**
 * @ignore
 */
HTTPLogError.attributeTypeMap = {
    code: {
        baseName: "code",
        type: "number",
        required: true,
        format: "int32",
    },
    message: {
        baseName: "message",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=HTTPLogError.js.map

/***/ }),

/***/ 19674:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HTTPLogItem = void 0;
/**
 * Logs that are sent over HTTP.
 */
class HTTPLogItem {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HTTPLogItem.attributeTypeMap;
    }
}
exports.HTTPLogItem = HTTPLogItem;
/**
 * @ignore
 */
HTTPLogItem.attributeTypeMap = {
    ddsource: {
        baseName: "ddsource",
        type: "string",
    },
    ddtags: {
        baseName: "ddtags",
        type: "string",
    },
    hostname: {
        baseName: "hostname",
        type: "string",
    },
    message: {
        baseName: "message",
        type: "string",
        required: true,
    },
    service: {
        baseName: "service",
        type: "string",
    },
    additionalProperties: {
        baseName: "additionalProperties",
        type: "string",
    },
};
//# sourceMappingURL=HTTPLogItem.js.map

/***/ }),

/***/ 84622:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeatMapWidgetDefinition = void 0;
/**
 * The heat map visualization shows metrics aggregated across many tags, such as hosts. The more hosts that have a particular value, the darker that square is.
 */
class HeatMapWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HeatMapWidgetDefinition.attributeTypeMap;
    }
}
exports.HeatMapWidgetDefinition = HeatMapWidgetDefinition;
/**
 * @ignore
 */
HeatMapWidgetDefinition.attributeTypeMap = {
    customLinks: {
        baseName: "custom_links",
        type: "Array<WidgetCustomLink>",
    },
    events: {
        baseName: "events",
        type: "Array<WidgetEvent>",
    },
    legendSize: {
        baseName: "legend_size",
        type: "string",
    },
    requests: {
        baseName: "requests",
        type: "[HeatMapWidgetRequest]",
        required: true,
    },
    showLegend: {
        baseName: "show_legend",
        type: "boolean",
    },
    time: {
        baseName: "time",
        type: "WidgetTime",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "HeatMapWidgetDefinitionType",
        required: true,
    },
    yaxis: {
        baseName: "yaxis",
        type: "WidgetAxis",
    },
};
//# sourceMappingURL=HeatMapWidgetDefinition.js.map

/***/ }),

/***/ 82293:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeatMapWidgetRequest = void 0;
/**
 * Updated heat map widget.
 */
class HeatMapWidgetRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HeatMapWidgetRequest.attributeTypeMap;
    }
}
exports.HeatMapWidgetRequest = HeatMapWidgetRequest;
/**
 * @ignore
 */
HeatMapWidgetRequest.attributeTypeMap = {
    apmQuery: {
        baseName: "apm_query",
        type: "LogQueryDefinition",
    },
    eventQuery: {
        baseName: "event_query",
        type: "EventQueryDefinition",
    },
    logQuery: {
        baseName: "log_query",
        type: "LogQueryDefinition",
    },
    networkQuery: {
        baseName: "network_query",
        type: "LogQueryDefinition",
    },
    processQuery: {
        baseName: "process_query",
        type: "ProcessQueryDefinition",
    },
    profileMetricsQuery: {
        baseName: "profile_metrics_query",
        type: "LogQueryDefinition",
    },
    q: {
        baseName: "q",
        type: "string",
    },
    rumQuery: {
        baseName: "rum_query",
        type: "LogQueryDefinition",
    },
    securityQuery: {
        baseName: "security_query",
        type: "LogQueryDefinition",
    },
    style: {
        baseName: "style",
        type: "WidgetStyle",
    },
};
//# sourceMappingURL=HeatMapWidgetRequest.js.map

/***/ }),

/***/ 49556:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Host = void 0;
/**
 * Object representing a host.
 */
class Host {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return Host.attributeTypeMap;
    }
}
exports.Host = Host;
/**
 * @ignore
 */
Host.attributeTypeMap = {
    aliases: {
        baseName: "aliases",
        type: "Array<string>",
    },
    apps: {
        baseName: "apps",
        type: "Array<string>",
    },
    awsName: {
        baseName: "aws_name",
        type: "string",
    },
    hostName: {
        baseName: "host_name",
        type: "string",
    },
    id: {
        baseName: "id",
        type: "number",
        format: "int64",
    },
    isMuted: {
        baseName: "is_muted",
        type: "boolean",
    },
    lastReportedTime: {
        baseName: "last_reported_time",
        type: "number",
        format: "int64",
    },
    meta: {
        baseName: "meta",
        type: "HostMeta",
    },
    metrics: {
        baseName: "metrics",
        type: "HostMetrics",
    },
    muteTimeout: {
        baseName: "mute_timeout",
        type: "number",
        format: "int64",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    sources: {
        baseName: "sources",
        type: "Array<string>",
    },
    tagsBySource: {
        baseName: "tags_by_source",
        type: "{ [key: string]: Array<string>; }",
    },
    up: {
        baseName: "up",
        type: "boolean",
    },
};
//# sourceMappingURL=Host.js.map

/***/ }),

/***/ 16915:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HostListResponse = void 0;
/**
 * Response with Host information from Datadog.
 */
class HostListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HostListResponse.attributeTypeMap;
    }
}
exports.HostListResponse = HostListResponse;
/**
 * @ignore
 */
HostListResponse.attributeTypeMap = {
    hostList: {
        baseName: "host_list",
        type: "Array<Host>",
    },
    totalMatching: {
        baseName: "total_matching",
        type: "number",
        format: "int64",
    },
    totalReturned: {
        baseName: "total_returned",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=HostListResponse.js.map

/***/ }),

/***/ 25910:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HostMapRequest = void 0;
/**
 * Updated host map.
 */
class HostMapRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HostMapRequest.attributeTypeMap;
    }
}
exports.HostMapRequest = HostMapRequest;
/**
 * @ignore
 */
HostMapRequest.attributeTypeMap = {
    apmQuery: {
        baseName: "apm_query",
        type: "LogQueryDefinition",
    },
    eventQuery: {
        baseName: "event_query",
        type: "LogQueryDefinition",
    },
    logQuery: {
        baseName: "log_query",
        type: "LogQueryDefinition",
    },
    networkQuery: {
        baseName: "network_query",
        type: "LogQueryDefinition",
    },
    processQuery: {
        baseName: "process_query",
        type: "ProcessQueryDefinition",
    },
    profileMetricsQuery: {
        baseName: "profile_metrics_query",
        type: "LogQueryDefinition",
    },
    q: {
        baseName: "q",
        type: "string",
    },
    rumQuery: {
        baseName: "rum_query",
        type: "LogQueryDefinition",
    },
    securityQuery: {
        baseName: "security_query",
        type: "LogQueryDefinition",
    },
};
//# sourceMappingURL=HostMapRequest.js.map

/***/ }),

/***/ 59477:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HostMapWidgetDefinition = void 0;
/**
 * The host map widget graphs any metric across your hosts using the same visualization available from the main Host Map page.
 */
class HostMapWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HostMapWidgetDefinition.attributeTypeMap;
    }
}
exports.HostMapWidgetDefinition = HostMapWidgetDefinition;
/**
 * @ignore
 */
HostMapWidgetDefinition.attributeTypeMap = {
    customLinks: {
        baseName: "custom_links",
        type: "Array<WidgetCustomLink>",
    },
    group: {
        baseName: "group",
        type: "Array<string>",
    },
    noGroupHosts: {
        baseName: "no_group_hosts",
        type: "boolean",
    },
    noMetricHosts: {
        baseName: "no_metric_hosts",
        type: "boolean",
    },
    nodeType: {
        baseName: "node_type",
        type: "WidgetNodeType",
    },
    notes: {
        baseName: "notes",
        type: "string",
    },
    requests: {
        baseName: "requests",
        type: "HostMapWidgetDefinitionRequests",
        required: true,
    },
    scope: {
        baseName: "scope",
        type: "Array<string>",
    },
    style: {
        baseName: "style",
        type: "HostMapWidgetDefinitionStyle",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "HostMapWidgetDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=HostMapWidgetDefinition.js.map

/***/ }),

/***/ 80831:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HostMapWidgetDefinitionRequests = void 0;
/**
 * List of definitions.
 */
class HostMapWidgetDefinitionRequests {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HostMapWidgetDefinitionRequests.attributeTypeMap;
    }
}
exports.HostMapWidgetDefinitionRequests = HostMapWidgetDefinitionRequests;
/**
 * @ignore
 */
HostMapWidgetDefinitionRequests.attributeTypeMap = {
    fill: {
        baseName: "fill",
        type: "HostMapRequest",
    },
    size: {
        baseName: "size",
        type: "HostMapRequest",
    },
};
//# sourceMappingURL=HostMapWidgetDefinitionRequests.js.map

/***/ }),

/***/ 42370:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HostMapWidgetDefinitionStyle = void 0;
/**
 * The style to apply to the widget.
 */
class HostMapWidgetDefinitionStyle {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HostMapWidgetDefinitionStyle.attributeTypeMap;
    }
}
exports.HostMapWidgetDefinitionStyle = HostMapWidgetDefinitionStyle;
/**
 * @ignore
 */
HostMapWidgetDefinitionStyle.attributeTypeMap = {
    fillMax: {
        baseName: "fill_max",
        type: "string",
    },
    fillMin: {
        baseName: "fill_min",
        type: "string",
    },
    palette: {
        baseName: "palette",
        type: "string",
    },
    paletteFlip: {
        baseName: "palette_flip",
        type: "boolean",
    },
};
//# sourceMappingURL=HostMapWidgetDefinitionStyle.js.map

/***/ }),

/***/ 48137:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HostMeta = void 0;
/**
 * Metadata associated with your host.
 */
class HostMeta {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HostMeta.attributeTypeMap;
    }
}
exports.HostMeta = HostMeta;
/**
 * @ignore
 */
HostMeta.attributeTypeMap = {
    agentChecks: {
        baseName: "agent_checks",
        type: "Array<Array<any>>",
    },
    agentVersion: {
        baseName: "agent_version",
        type: "string",
    },
    cpuCores: {
        baseName: "cpuCores",
        type: "number",
        format: "int64",
    },
    fbsdV: {
        baseName: "fbsdV",
        type: "Array<string>",
    },
    gohai: {
        baseName: "gohai",
        type: "string",
    },
    installMethod: {
        baseName: "install_method",
        type: "HostMetaInstallMethod",
    },
    macV: {
        baseName: "macV",
        type: "Array<any>",
    },
    machine: {
        baseName: "machine",
        type: "string",
    },
    nixV: {
        baseName: "nixV",
        type: "Array<string>",
    },
    platform: {
        baseName: "platform",
        type: "string",
    },
    processor: {
        baseName: "processor",
        type: "string",
    },
    pythonV: {
        baseName: "pythonV",
        type: "string",
    },
    socketFqdn: {
        baseName: "socket-fqdn",
        type: "string",
    },
    socketHostname: {
        baseName: "socket-hostname",
        type: "string",
    },
    winV: {
        baseName: "winV",
        type: "Array<string>",
    },
};
//# sourceMappingURL=HostMeta.js.map

/***/ }),

/***/ 33508:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HostMetaInstallMethod = void 0;
/**
 * Agent install method.
 */
class HostMetaInstallMethod {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HostMetaInstallMethod.attributeTypeMap;
    }
}
exports.HostMetaInstallMethod = HostMetaInstallMethod;
/**
 * @ignore
 */
HostMetaInstallMethod.attributeTypeMap = {
    installerVersion: {
        baseName: "installer_version",
        type: "string",
    },
    tool: {
        baseName: "tool",
        type: "string",
    },
    toolVersion: {
        baseName: "tool_version",
        type: "string",
    },
};
//# sourceMappingURL=HostMetaInstallMethod.js.map

/***/ }),

/***/ 70176:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HostMetrics = void 0;
/**
 * Host Metrics collected.
 */
class HostMetrics {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HostMetrics.attributeTypeMap;
    }
}
exports.HostMetrics = HostMetrics;
/**
 * @ignore
 */
HostMetrics.attributeTypeMap = {
    cpu: {
        baseName: "cpu",
        type: "number",
        format: "double",
    },
    iowait: {
        baseName: "iowait",
        type: "number",
        format: "double",
    },
    load: {
        baseName: "load",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=HostMetrics.js.map

/***/ }),

/***/ 43814:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HostMuteResponse = void 0;
/**
 * Response with the list of muted host for your organization.
 */
class HostMuteResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HostMuteResponse.attributeTypeMap;
    }
}
exports.HostMuteResponse = HostMuteResponse;
/**
 * @ignore
 */
HostMuteResponse.attributeTypeMap = {
    action: {
        baseName: "action",
        type: "string",
    },
    end: {
        baseName: "end",
        type: "number",
        format: "int64",
    },
    hostname: {
        baseName: "hostname",
        type: "string",
    },
    message: {
        baseName: "message",
        type: "string",
    },
};
//# sourceMappingURL=HostMuteResponse.js.map

/***/ }),

/***/ 52003:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HostMuteSettings = void 0;
/**
 * Combination of settings to mute a host.
 */
class HostMuteSettings {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HostMuteSettings.attributeTypeMap;
    }
}
exports.HostMuteSettings = HostMuteSettings;
/**
 * @ignore
 */
HostMuteSettings.attributeTypeMap = {
    end: {
        baseName: "end",
        type: "number",
        format: "int64",
    },
    message: {
        baseName: "message",
        type: "string",
    },
    override: {
        baseName: "override",
        type: "boolean",
    },
};
//# sourceMappingURL=HostMuteSettings.js.map

/***/ }),

/***/ 14891:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HostTags = void 0;
/**
 * Set of tags to associate with your host.
 */
class HostTags {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HostTags.attributeTypeMap;
    }
}
exports.HostTags = HostTags;
/**
 * @ignore
 */
HostTags.attributeTypeMap = {
    host: {
        baseName: "host",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
};
//# sourceMappingURL=HostTags.js.map

/***/ }),

/***/ 78002:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HostTotals = void 0;
/**
 * Total number of host currently monitored by Datadog.
 */
class HostTotals {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HostTotals.attributeTypeMap;
    }
}
exports.HostTotals = HostTotals;
/**
 * @ignore
 */
HostTotals.attributeTypeMap = {
    totalActive: {
        baseName: "total_active",
        type: "number",
        format: "int64",
    },
    totalUp: {
        baseName: "total_up",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=HostTotals.js.map

/***/ }),

/***/ 60079:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HourlyUsageAttributionBody = void 0;
/**
 * The usage for one set of tags for one hour.
 */
class HourlyUsageAttributionBody {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HourlyUsageAttributionBody.attributeTypeMap;
    }
}
exports.HourlyUsageAttributionBody = HourlyUsageAttributionBody;
/**
 * @ignore
 */
HourlyUsageAttributionBody.attributeTypeMap = {
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    tagConfigSource: {
        baseName: "tag_config_source",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "{ [key: string]: Array<string>; }",
    },
    totalUsageSum: {
        baseName: "total_usage_sum",
        type: "number",
        format: "double",
    },
    updatedAt: {
        baseName: "updated_at",
        type: "string",
    },
    usageType: {
        baseName: "usage_type",
        type: "HourlyUsageAttributionUsageType",
    },
};
//# sourceMappingURL=HourlyUsageAttributionBody.js.map

/***/ }),

/***/ 46590:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HourlyUsageAttributionMetadata = void 0;
/**
 * The object containing document metadata.
 */
class HourlyUsageAttributionMetadata {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HourlyUsageAttributionMetadata.attributeTypeMap;
    }
}
exports.HourlyUsageAttributionMetadata = HourlyUsageAttributionMetadata;
/**
 * @ignore
 */
HourlyUsageAttributionMetadata.attributeTypeMap = {
    pagination: {
        baseName: "pagination",
        type: "HourlyUsageAttributionPagination",
    },
};
//# sourceMappingURL=HourlyUsageAttributionMetadata.js.map

/***/ }),

/***/ 73798:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HourlyUsageAttributionPagination = void 0;
/**
 * The metadata for the current pagination.
 */
class HourlyUsageAttributionPagination {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HourlyUsageAttributionPagination.attributeTypeMap;
    }
}
exports.HourlyUsageAttributionPagination = HourlyUsageAttributionPagination;
/**
 * @ignore
 */
HourlyUsageAttributionPagination.attributeTypeMap = {
    nextRecordId: {
        baseName: "next_record_id",
        type: "string",
    },
};
//# sourceMappingURL=HourlyUsageAttributionPagination.js.map

/***/ }),

/***/ 81641:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HourlyUsageAttributionResponse = void 0;
/**
 * Response containing the hourly usage attribution by tag(s).
 */
class HourlyUsageAttributionResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HourlyUsageAttributionResponse.attributeTypeMap;
    }
}
exports.HourlyUsageAttributionResponse = HourlyUsageAttributionResponse;
/**
 * @ignore
 */
HourlyUsageAttributionResponse.attributeTypeMap = {
    metadata: {
        baseName: "metadata",
        type: "HourlyUsageAttributionMetadata",
    },
    usage: {
        baseName: "usage",
        type: "Array<HourlyUsageAttributionBody>",
    },
};
//# sourceMappingURL=HourlyUsageAttributionResponse.js.map

/***/ }),

/***/ 26242:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IFrameWidgetDefinition = void 0;
/**
 * The iframe widget allows you to embed a portion of any other web page on your dashboard. Only available on FREE layout dashboards.
 */
class IFrameWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IFrameWidgetDefinition.attributeTypeMap;
    }
}
exports.IFrameWidgetDefinition = IFrameWidgetDefinition;
/**
 * @ignore
 */
IFrameWidgetDefinition.attributeTypeMap = {
    type: {
        baseName: "type",
        type: "IFrameWidgetDefinitionType",
        required: true,
    },
    url: {
        baseName: "url",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=IFrameWidgetDefinition.js.map

/***/ }),

/***/ 9737:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IPPrefixesAPI = void 0;
/**
 * Available prefix information for the API endpoints.
 */
class IPPrefixesAPI {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IPPrefixesAPI.attributeTypeMap;
    }
}
exports.IPPrefixesAPI = IPPrefixesAPI;
/**
 * @ignore
 */
IPPrefixesAPI.attributeTypeMap = {
    prefixesIpv4: {
        baseName: "prefixes_ipv4",
        type: "Array<string>",
    },
    prefixesIpv6: {
        baseName: "prefixes_ipv6",
        type: "Array<string>",
    },
};
//# sourceMappingURL=IPPrefixesAPI.js.map

/***/ }),

/***/ 51806:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IPPrefixesAPM = void 0;
/**
 * Available prefix information for the APM endpoints.
 */
class IPPrefixesAPM {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IPPrefixesAPM.attributeTypeMap;
    }
}
exports.IPPrefixesAPM = IPPrefixesAPM;
/**
 * @ignore
 */
IPPrefixesAPM.attributeTypeMap = {
    prefixesIpv4: {
        baseName: "prefixes_ipv4",
        type: "Array<string>",
    },
    prefixesIpv6: {
        baseName: "prefixes_ipv6",
        type: "Array<string>",
    },
};
//# sourceMappingURL=IPPrefixesAPM.js.map

/***/ }),

/***/ 15536:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IPPrefixesAgents = void 0;
/**
 * Available prefix information for the Agent endpoints.
 */
class IPPrefixesAgents {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IPPrefixesAgents.attributeTypeMap;
    }
}
exports.IPPrefixesAgents = IPPrefixesAgents;
/**
 * @ignore
 */
IPPrefixesAgents.attributeTypeMap = {
    prefixesIpv4: {
        baseName: "prefixes_ipv4",
        type: "Array<string>",
    },
    prefixesIpv6: {
        baseName: "prefixes_ipv6",
        type: "Array<string>",
    },
};
//# sourceMappingURL=IPPrefixesAgents.js.map

/***/ }),

/***/ 50334:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IPPrefixesLogs = void 0;
/**
 * Available prefix information for the Logs endpoints.
 */
class IPPrefixesLogs {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IPPrefixesLogs.attributeTypeMap;
    }
}
exports.IPPrefixesLogs = IPPrefixesLogs;
/**
 * @ignore
 */
IPPrefixesLogs.attributeTypeMap = {
    prefixesIpv4: {
        baseName: "prefixes_ipv4",
        type: "Array<string>",
    },
    prefixesIpv6: {
        baseName: "prefixes_ipv6",
        type: "Array<string>",
    },
};
//# sourceMappingURL=IPPrefixesLogs.js.map

/***/ }),

/***/ 16605:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IPPrefixesProcess = void 0;
/**
 * Available prefix information for the Process endpoints.
 */
class IPPrefixesProcess {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IPPrefixesProcess.attributeTypeMap;
    }
}
exports.IPPrefixesProcess = IPPrefixesProcess;
/**
 * @ignore
 */
IPPrefixesProcess.attributeTypeMap = {
    prefixesIpv4: {
        baseName: "prefixes_ipv4",
        type: "Array<string>",
    },
    prefixesIpv6: {
        baseName: "prefixes_ipv6",
        type: "Array<string>",
    },
};
//# sourceMappingURL=IPPrefixesProcess.js.map

/***/ }),

/***/ 31933:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IPPrefixesSynthetics = void 0;
/**
 * Available prefix information for the Synthetics endpoints.
 */
class IPPrefixesSynthetics {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IPPrefixesSynthetics.attributeTypeMap;
    }
}
exports.IPPrefixesSynthetics = IPPrefixesSynthetics;
/**
 * @ignore
 */
IPPrefixesSynthetics.attributeTypeMap = {
    prefixesIpv4: {
        baseName: "prefixes_ipv4",
        type: "Array<string>",
    },
    prefixesIpv4ByLocation: {
        baseName: "prefixes_ipv4_by_location",
        type: "{ [key: string]: Array<string>; }",
    },
    prefixesIpv6: {
        baseName: "prefixes_ipv6",
        type: "Array<string>",
    },
    prefixesIpv6ByLocation: {
        baseName: "prefixes_ipv6_by_location",
        type: "{ [key: string]: Array<string>; }",
    },
};
//# sourceMappingURL=IPPrefixesSynthetics.js.map

/***/ }),

/***/ 29817:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IPPrefixesSyntheticsPrivateLocations = void 0;
/**
 * Available prefix information for the Synthetics Private Locations endpoints.
 */
class IPPrefixesSyntheticsPrivateLocations {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IPPrefixesSyntheticsPrivateLocations.attributeTypeMap;
    }
}
exports.IPPrefixesSyntheticsPrivateLocations = IPPrefixesSyntheticsPrivateLocations;
/**
 * @ignore
 */
IPPrefixesSyntheticsPrivateLocations.attributeTypeMap = {
    prefixesIpv4: {
        baseName: "prefixes_ipv4",
        type: "Array<string>",
    },
    prefixesIpv6: {
        baseName: "prefixes_ipv6",
        type: "Array<string>",
    },
};
//# sourceMappingURL=IPPrefixesSyntheticsPrivateLocations.js.map

/***/ }),

/***/ 61031:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IPPrefixesWebhooks = void 0;
/**
 * Available prefix information for the Webhook endpoints.
 */
class IPPrefixesWebhooks {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IPPrefixesWebhooks.attributeTypeMap;
    }
}
exports.IPPrefixesWebhooks = IPPrefixesWebhooks;
/**
 * @ignore
 */
IPPrefixesWebhooks.attributeTypeMap = {
    prefixesIpv4: {
        baseName: "prefixes_ipv4",
        type: "Array<string>",
    },
    prefixesIpv6: {
        baseName: "prefixes_ipv6",
        type: "Array<string>",
    },
};
//# sourceMappingURL=IPPrefixesWebhooks.js.map

/***/ }),

/***/ 28956:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IPRanges = void 0;
/**
 * IP ranges.
 */
class IPRanges {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IPRanges.attributeTypeMap;
    }
}
exports.IPRanges = IPRanges;
/**
 * @ignore
 */
IPRanges.attributeTypeMap = {
    agents: {
        baseName: "agents",
        type: "IPPrefixesAgents",
    },
    api: {
        baseName: "api",
        type: "IPPrefixesAPI",
    },
    apm: {
        baseName: "apm",
        type: "IPPrefixesAPM",
    },
    logs: {
        baseName: "logs",
        type: "IPPrefixesLogs",
    },
    modified: {
        baseName: "modified",
        type: "string",
    },
    process: {
        baseName: "process",
        type: "IPPrefixesProcess",
    },
    synthetics: {
        baseName: "synthetics",
        type: "IPPrefixesSynthetics",
    },
    syntheticsPrivateLocations: {
        baseName: "synthetics-private-locations",
        type: "IPPrefixesSyntheticsPrivateLocations",
    },
    version: {
        baseName: "version",
        type: "number",
        format: "int64",
    },
    webhooks: {
        baseName: "webhooks",
        type: "IPPrefixesWebhooks",
    },
};
//# sourceMappingURL=IPRanges.js.map

/***/ }),

/***/ 43719:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IdpFormData = void 0;
/**
 * Object describing the IdP configuration.
 */
class IdpFormData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IdpFormData.attributeTypeMap;
    }
}
exports.IdpFormData = IdpFormData;
/**
 * @ignore
 */
IdpFormData.attributeTypeMap = {
    idpFile: {
        baseName: "idp_file",
        type: "HttpFile",
        required: true,
        format: "binary",
    },
};
//# sourceMappingURL=IdpFormData.js.map

/***/ }),

/***/ 91992:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IdpResponse = void 0;
/**
 * The IdP response object.
 */
class IdpResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IdpResponse.attributeTypeMap;
    }
}
exports.IdpResponse = IdpResponse;
/**
 * @ignore
 */
IdpResponse.attributeTypeMap = {
    message: {
        baseName: "message",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=IdpResponse.js.map

/***/ }),

/***/ 86051:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImageWidgetDefinition = void 0;
/**
 * The image widget allows you to embed an image on your dashboard. An image can be a PNG, JPG, or animated GIF. Only available on FREE layout dashboards.
 */
class ImageWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ImageWidgetDefinition.attributeTypeMap;
    }
}
exports.ImageWidgetDefinition = ImageWidgetDefinition;
/**
 * @ignore
 */
ImageWidgetDefinition.attributeTypeMap = {
    hasBackground: {
        baseName: "has_background",
        type: "boolean",
    },
    hasBorder: {
        baseName: "has_border",
        type: "boolean",
    },
    horizontalAlign: {
        baseName: "horizontal_align",
        type: "WidgetHorizontalAlign",
    },
    margin: {
        baseName: "margin",
        type: "WidgetMargin",
    },
    sizing: {
        baseName: "sizing",
        type: "WidgetImageSizing",
    },
    type: {
        baseName: "type",
        type: "ImageWidgetDefinitionType",
        required: true,
    },
    url: {
        baseName: "url",
        type: "string",
        required: true,
    },
    urlDarkTheme: {
        baseName: "url_dark_theme",
        type: "string",
    },
    verticalAlign: {
        baseName: "vertical_align",
        type: "WidgetVerticalAlign",
    },
};
//# sourceMappingURL=ImageWidgetDefinition.js.map

/***/ }),

/***/ 71328:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IntakePayloadAccepted = void 0;
/**
 * The payload accepted for intake.
 */
class IntakePayloadAccepted {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IntakePayloadAccepted.attributeTypeMap;
    }
}
exports.IntakePayloadAccepted = IntakePayloadAccepted;
/**
 * @ignore
 */
IntakePayloadAccepted.attributeTypeMap = {
    status: {
        baseName: "status",
        type: "string",
    },
};
//# sourceMappingURL=IntakePayloadAccepted.js.map

/***/ }),

/***/ 91106:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListStreamColumn = void 0;
/**
 * Widget column.
 */
class ListStreamColumn {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ListStreamColumn.attributeTypeMap;
    }
}
exports.ListStreamColumn = ListStreamColumn;
/**
 * @ignore
 */
ListStreamColumn.attributeTypeMap = {
    field: {
        baseName: "field",
        type: "string",
        required: true,
    },
    width: {
        baseName: "width",
        type: "ListStreamColumnWidth",
        required: true,
    },
};
//# sourceMappingURL=ListStreamColumn.js.map

/***/ }),

/***/ 63069:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListStreamComputeItems = void 0;
/**
 * List of facets and aggregations which to compute.
 */
class ListStreamComputeItems {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ListStreamComputeItems.attributeTypeMap;
    }
}
exports.ListStreamComputeItems = ListStreamComputeItems;
/**
 * @ignore
 */
ListStreamComputeItems.attributeTypeMap = {
    aggregation: {
        baseName: "aggregation",
        type: "ListStreamComputeAggregation",
        required: true,
    },
    facet: {
        baseName: "facet",
        type: "string",
    },
};
//# sourceMappingURL=ListStreamComputeItems.js.map

/***/ }),

/***/ 6326:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListStreamGroupByItems = void 0;
/**
 * List of facets on which to group.
 */
class ListStreamGroupByItems {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ListStreamGroupByItems.attributeTypeMap;
    }
}
exports.ListStreamGroupByItems = ListStreamGroupByItems;
/**
 * @ignore
 */
ListStreamGroupByItems.attributeTypeMap = {
    facet: {
        baseName: "facet",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=ListStreamGroupByItems.js.map

/***/ }),

/***/ 44439:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListStreamQuery = void 0;
/**
 * Updated list stream widget.
 */
class ListStreamQuery {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ListStreamQuery.attributeTypeMap;
    }
}
exports.ListStreamQuery = ListStreamQuery;
/**
 * @ignore
 */
ListStreamQuery.attributeTypeMap = {
    compute: {
        baseName: "compute",
        type: "Array<ListStreamComputeItems>",
    },
    dataSource: {
        baseName: "data_source",
        type: "ListStreamSource",
        required: true,
    },
    eventSize: {
        baseName: "event_size",
        type: "WidgetEventSize",
    },
    groupBy: {
        baseName: "group_by",
        type: "Array<ListStreamGroupByItems>",
    },
    indexes: {
        baseName: "indexes",
        type: "Array<string>",
    },
    queryString: {
        baseName: "query_string",
        type: "string",
        required: true,
    },
    storage: {
        baseName: "storage",
        type: "string",
    },
};
//# sourceMappingURL=ListStreamQuery.js.map

/***/ }),

/***/ 49497:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListStreamWidgetDefinition = void 0;
/**
 * The list stream visualization displays a table of recent events in your application that
 * match a search criteria using user-defined columns.
 */
class ListStreamWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ListStreamWidgetDefinition.attributeTypeMap;
    }
}
exports.ListStreamWidgetDefinition = ListStreamWidgetDefinition;
/**
 * @ignore
 */
ListStreamWidgetDefinition.attributeTypeMap = {
    legendSize: {
        baseName: "legend_size",
        type: "string",
    },
    requests: {
        baseName: "requests",
        type: "[ListStreamWidgetRequest]",
        required: true,
    },
    showLegend: {
        baseName: "show_legend",
        type: "boolean",
    },
    time: {
        baseName: "time",
        type: "WidgetTime",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "ListStreamWidgetDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=ListStreamWidgetDefinition.js.map

/***/ }),

/***/ 80951:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListStreamWidgetRequest = void 0;
/**
 * Updated list stream widget.
 */
class ListStreamWidgetRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ListStreamWidgetRequest.attributeTypeMap;
    }
}
exports.ListStreamWidgetRequest = ListStreamWidgetRequest;
/**
 * @ignore
 */
ListStreamWidgetRequest.attributeTypeMap = {
    columns: {
        baseName: "columns",
        type: "Array<ListStreamColumn>",
        required: true,
    },
    query: {
        baseName: "query",
        type: "ListStreamQuery",
        required: true,
    },
    responseFormat: {
        baseName: "response_format",
        type: "ListStreamResponseFormat",
        required: true,
    },
};
//# sourceMappingURL=ListStreamWidgetRequest.js.map

/***/ }),

/***/ 83438:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Log = void 0;
/**
 * Object describing a log after being processed and stored by Datadog.
 */
class Log {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return Log.attributeTypeMap;
    }
}
exports.Log = Log;
/**
 * @ignore
 */
Log.attributeTypeMap = {
    content: {
        baseName: "content",
        type: "LogContent",
    },
    id: {
        baseName: "id",
        type: "string",
    },
};
//# sourceMappingURL=Log.js.map

/***/ }),

/***/ 67704:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogContent = void 0;
/**
 * JSON object containing all log attributes and their associated values.
 */
class LogContent {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogContent.attributeTypeMap;
    }
}
exports.LogContent = LogContent;
/**
 * @ignore
 */
LogContent.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "{ [key: string]: any; }",
    },
    host: {
        baseName: "host",
        type: "string",
    },
    message: {
        baseName: "message",
        type: "string",
    },
    service: {
        baseName: "service",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    timestamp: {
        baseName: "timestamp",
        type: "Date",
        format: "date-time",
    },
};
//# sourceMappingURL=LogContent.js.map

/***/ }),

/***/ 12197:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogQueryDefinition = void 0;
/**
 * The log query.
 */
class LogQueryDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogQueryDefinition.attributeTypeMap;
    }
}
exports.LogQueryDefinition = LogQueryDefinition;
/**
 * @ignore
 */
LogQueryDefinition.attributeTypeMap = {
    compute: {
        baseName: "compute",
        type: "LogsQueryCompute",
    },
    groupBy: {
        baseName: "group_by",
        type: "Array<LogQueryDefinitionGroupBy>",
    },
    index: {
        baseName: "index",
        type: "string",
    },
    multiCompute: {
        baseName: "multi_compute",
        type: "Array<LogsQueryCompute>",
    },
    search: {
        baseName: "search",
        type: "LogQueryDefinitionSearch",
    },
};
//# sourceMappingURL=LogQueryDefinition.js.map

/***/ }),

/***/ 54246:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogQueryDefinitionGroupBy = void 0;
/**
 * Defined items in the group.
 */
class LogQueryDefinitionGroupBy {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogQueryDefinitionGroupBy.attributeTypeMap;
    }
}
exports.LogQueryDefinitionGroupBy = LogQueryDefinitionGroupBy;
/**
 * @ignore
 */
LogQueryDefinitionGroupBy.attributeTypeMap = {
    facet: {
        baseName: "facet",
        type: "string",
        required: true,
    },
    limit: {
        baseName: "limit",
        type: "number",
        format: "int64",
    },
    sort: {
        baseName: "sort",
        type: "LogQueryDefinitionGroupBySort",
    },
};
//# sourceMappingURL=LogQueryDefinitionGroupBy.js.map

/***/ }),

/***/ 37827:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogQueryDefinitionGroupBySort = void 0;
/**
 * Define a sorting method.
 */
class LogQueryDefinitionGroupBySort {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogQueryDefinitionGroupBySort.attributeTypeMap;
    }
}
exports.LogQueryDefinitionGroupBySort = LogQueryDefinitionGroupBySort;
/**
 * @ignore
 */
LogQueryDefinitionGroupBySort.attributeTypeMap = {
    aggregation: {
        baseName: "aggregation",
        type: "string",
        required: true,
    },
    facet: {
        baseName: "facet",
        type: "string",
    },
    order: {
        baseName: "order",
        type: "WidgetSort",
        required: true,
    },
};
//# sourceMappingURL=LogQueryDefinitionGroupBySort.js.map

/***/ }),

/***/ 20235:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogQueryDefinitionSearch = void 0;
/**
 * The query being made on the logs.
 */
class LogQueryDefinitionSearch {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogQueryDefinitionSearch.attributeTypeMap;
    }
}
exports.LogQueryDefinitionSearch = LogQueryDefinitionSearch;
/**
 * @ignore
 */
LogQueryDefinitionSearch.attributeTypeMap = {
    query: {
        baseName: "query",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=LogQueryDefinitionSearch.js.map

/***/ }),

/***/ 76959:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogStreamWidgetDefinition = void 0;
/**
 * The Log Stream displays a log flow matching the defined query. Only available on FREE layout dashboards.
 */
class LogStreamWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogStreamWidgetDefinition.attributeTypeMap;
    }
}
exports.LogStreamWidgetDefinition = LogStreamWidgetDefinition;
/**
 * @ignore
 */
LogStreamWidgetDefinition.attributeTypeMap = {
    columns: {
        baseName: "columns",
        type: "Array<string>",
    },
    indexes: {
        baseName: "indexes",
        type: "Array<string>",
    },
    logset: {
        baseName: "logset",
        type: "string",
    },
    messageDisplay: {
        baseName: "message_display",
        type: "WidgetMessageDisplay",
    },
    query: {
        baseName: "query",
        type: "string",
    },
    showDateColumn: {
        baseName: "show_date_column",
        type: "boolean",
    },
    showMessageColumn: {
        baseName: "show_message_column",
        type: "boolean",
    },
    sort: {
        baseName: "sort",
        type: "WidgetFieldSort",
    },
    time: {
        baseName: "time",
        type: "WidgetTime",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "LogStreamWidgetDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=LogStreamWidgetDefinition.js.map

/***/ }),

/***/ 27806:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsAPIError = void 0;
/**
 * Error returned by the Logs API
 */
class LogsAPIError {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsAPIError.attributeTypeMap;
    }
}
exports.LogsAPIError = LogsAPIError;
/**
 * @ignore
 */
LogsAPIError.attributeTypeMap = {
    code: {
        baseName: "code",
        type: "string",
    },
    details: {
        baseName: "details",
        type: "Array<LogsAPIError>",
    },
    message: {
        baseName: "message",
        type: "string",
    },
};
//# sourceMappingURL=LogsAPIError.js.map

/***/ }),

/***/ 25074:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsAPIErrorResponse = void 0;
/**
 * Response returned by the Logs API when errors occur.
 */
class LogsAPIErrorResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsAPIErrorResponse.attributeTypeMap;
    }
}
exports.LogsAPIErrorResponse = LogsAPIErrorResponse;
/**
 * @ignore
 */
LogsAPIErrorResponse.attributeTypeMap = {
    error: {
        baseName: "error",
        type: "LogsAPIError",
    },
};
//# sourceMappingURL=LogsAPIErrorResponse.js.map

/***/ }),

/***/ 15426:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsArithmeticProcessor = void 0;
/**
 * Use the Arithmetic Processor to add a new attribute (without spaces or special characters
 * in the new attribute name) to a log with the result of the provided formula.
 * This enables you to remap different time attributes with different units into a single attribute,
 * or to compute operations on attributes within the same log.
 *
 * The formula can use parentheses and the basic arithmetic operators `-`, `+`, `*`, `/`.
 *
 * By default, the calculation is skipped if an attribute is missing.
 * Select Replace missing attribute by 0 to automatically populate
 * missing attribute values with 0 to ensure that the calculation is done.
 * An attribute is missing if it is not found in the log attributes,
 * or if it cannot be converted to a number.
 *
 * *Notes*:
 *
 * - The operator `-` needs to be space split in the formula as it can also be contained in attribute names.
 * - If the target attribute already exists, it is overwritten by the result of the formula.
 * - Results are rounded up to the 9th decimal. For example, if the result of the formula is `0.1234567891`,
 *   the actual value stored for the attribute is `0.123456789`.
 * - If you need to scale a unit of measure,
 *   see [Scale Filter](https://docs.datadoghq.com/logs/log_configuration/parsing/?tab=filter#matcher-and-filter).
 */
class LogsArithmeticProcessor {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsArithmeticProcessor.attributeTypeMap;
    }
}
exports.LogsArithmeticProcessor = LogsArithmeticProcessor;
/**
 * @ignore
 */
LogsArithmeticProcessor.attributeTypeMap = {
    expression: {
        baseName: "expression",
        type: "string",
        required: true,
    },
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    isReplaceMissing: {
        baseName: "is_replace_missing",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    target: {
        baseName: "target",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "LogsArithmeticProcessorType",
        required: true,
    },
};
//# sourceMappingURL=LogsArithmeticProcessor.js.map

/***/ }),

/***/ 70365:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsAttributeRemapper = void 0;
/**
 * The remapper processor remaps any source attribute(s) or tag to another target attribute or tag.
 * Constraints on the tag/attribute name are explained in the [Tag Best Practice documentation](https://docs.datadoghq.com/logs/guide/log-parsing-best-practice).
 * Some additional constraints are applied as `:` or `,` are not allowed in the target tag/attribute name.
 */
class LogsAttributeRemapper {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsAttributeRemapper.attributeTypeMap;
    }
}
exports.LogsAttributeRemapper = LogsAttributeRemapper;
/**
 * @ignore
 */
LogsAttributeRemapper.attributeTypeMap = {
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    overrideOnConflict: {
        baseName: "override_on_conflict",
        type: "boolean",
    },
    preserveSource: {
        baseName: "preserve_source",
        type: "boolean",
    },
    sourceType: {
        baseName: "source_type",
        type: "string",
    },
    sources: {
        baseName: "sources",
        type: "Array<string>",
        required: true,
    },
    target: {
        baseName: "target",
        type: "string",
        required: true,
    },
    targetFormat: {
        baseName: "target_format",
        type: "TargetFormatType",
    },
    targetType: {
        baseName: "target_type",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "LogsAttributeRemapperType",
        required: true,
    },
};
//# sourceMappingURL=LogsAttributeRemapper.js.map

/***/ }),

/***/ 97769:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsByRetention = void 0;
/**
 * Object containing logs usage data broken down by retention period.
 */
class LogsByRetention {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsByRetention.attributeTypeMap;
    }
}
exports.LogsByRetention = LogsByRetention;
/**
 * @ignore
 */
LogsByRetention.attributeTypeMap = {
    orgs: {
        baseName: "orgs",
        type: "LogsByRetentionOrgs",
    },
    usage: {
        baseName: "usage",
        type: "Array<LogsRetentionAggSumUsage>",
    },
    usageByMonth: {
        baseName: "usage_by_month",
        type: "LogsByRetentionMonthlyUsage",
    },
};
//# sourceMappingURL=LogsByRetention.js.map

/***/ }),

/***/ 96594:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsByRetentionMonthlyUsage = void 0;
/**
 * Object containing a summary of indexed logs usage by retention period for a single month.
 */
class LogsByRetentionMonthlyUsage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsByRetentionMonthlyUsage.attributeTypeMap;
    }
}
exports.LogsByRetentionMonthlyUsage = LogsByRetentionMonthlyUsage;
/**
 * @ignore
 */
LogsByRetentionMonthlyUsage.attributeTypeMap = {
    date: {
        baseName: "date",
        type: "Date",
        format: "date-time",
    },
    usage: {
        baseName: "usage",
        type: "Array<LogsRetentionSumUsage>",
    },
};
//# sourceMappingURL=LogsByRetentionMonthlyUsage.js.map

/***/ }),

/***/ 79667:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsByRetentionOrgUsage = void 0;
/**
 * Indexed logs usage by retention for a single organization.
 */
class LogsByRetentionOrgUsage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsByRetentionOrgUsage.attributeTypeMap;
    }
}
exports.LogsByRetentionOrgUsage = LogsByRetentionOrgUsage;
/**
 * @ignore
 */
LogsByRetentionOrgUsage.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<LogsRetentionSumUsage>",
    },
};
//# sourceMappingURL=LogsByRetentionOrgUsage.js.map

/***/ }),

/***/ 45185:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsByRetentionOrgs = void 0;
/**
 * Indexed logs usage summary for each organization for each retention period with usage.
 */
class LogsByRetentionOrgs {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsByRetentionOrgs.attributeTypeMap;
    }
}
exports.LogsByRetentionOrgs = LogsByRetentionOrgs;
/**
 * @ignore
 */
LogsByRetentionOrgs.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<LogsByRetentionOrgUsage>",
    },
};
//# sourceMappingURL=LogsByRetentionOrgs.js.map

/***/ }),

/***/ 40573:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsCategoryProcessor = void 0;
/**
 * Use the Category Processor to add a new attribute (without spaces or special characters in the new attribute name)
 * to a log matching a provided search query. Use categories to create groups for an analytical view.
 * For example, URL groups, machine groups, environments, and response time buckets.
 *
 * **Notes**:
 *
 * - The syntax of the query is the one of Logs Explorer search bar.
 *   The query can be done on any log attribute or tag, whether it is a facet or not.
 *   Wildcards can also be used inside your query.
 * - Once the log has matched one of the Processor queries, it stops.
 *   Make sure they are properly ordered in case a log could match several queries.
 * - The names of the categories must be unique.
 * - Once defined in the Category Processor, you can map categories to log status using the Log Status Remapper.
 */
class LogsCategoryProcessor {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsCategoryProcessor.attributeTypeMap;
    }
}
exports.LogsCategoryProcessor = LogsCategoryProcessor;
/**
 * @ignore
 */
LogsCategoryProcessor.attributeTypeMap = {
    categories: {
        baseName: "categories",
        type: "Array<LogsCategoryProcessorCategory>",
        required: true,
    },
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    target: {
        baseName: "target",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "LogsCategoryProcessorType",
        required: true,
    },
};
//# sourceMappingURL=LogsCategoryProcessor.js.map

/***/ }),

/***/ 10242:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsCategoryProcessorCategory = void 0;
/**
 * Object describing the logs filter.
 */
class LogsCategoryProcessorCategory {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsCategoryProcessorCategory.attributeTypeMap;
    }
}
exports.LogsCategoryProcessorCategory = LogsCategoryProcessorCategory;
/**
 * @ignore
 */
LogsCategoryProcessorCategory.attributeTypeMap = {
    filter: {
        baseName: "filter",
        type: "LogsFilter",
    },
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=LogsCategoryProcessorCategory.js.map

/***/ }),

/***/ 34468:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsDateRemapper = void 0;
/**
 * As Datadog receives logs, it timestamps them using the value(s) from any of these default attributes.
 *
 *   - `timestamp`
 *   - `date`
 *   - `_timestamp`
 *   - `Timestamp`
 *   - `eventTime`
 *   - `published_date`
 *
 *   If your logs put their dates in an attribute not in this list,
 *   use the log date Remapper Processor to define their date attribute as the official log timestamp.
 *   The recognized date formats are ISO8601, UNIX (the milliseconds EPOCH format), and RFC3164.
 *
 *   **Note:** If your logs dont contain any of the default attributes
 *   and you havent defined your own date attribute, Datadog timestamps
 *   the logs with the date it received them.
 *
 *   If multiple log date remapper processors can be applied to a given log,
 *   only the first one (according to the pipelines order) is taken into account.
 */
class LogsDateRemapper {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsDateRemapper.attributeTypeMap;
    }
}
exports.LogsDateRemapper = LogsDateRemapper;
/**
 * @ignore
 */
LogsDateRemapper.attributeTypeMap = {
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    sources: {
        baseName: "sources",
        type: "Array<string>",
        required: true,
    },
    type: {
        baseName: "type",
        type: "LogsDateRemapperType",
        required: true,
    },
};
//# sourceMappingURL=LogsDateRemapper.js.map

/***/ }),

/***/ 78203:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsExclusion = void 0;
/**
 * Represents the index exclusion filter object from configuration API.
 */
class LogsExclusion {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsExclusion.attributeTypeMap;
    }
}
exports.LogsExclusion = LogsExclusion;
/**
 * @ignore
 */
LogsExclusion.attributeTypeMap = {
    filter: {
        baseName: "filter",
        type: "LogsExclusionFilter",
    },
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=LogsExclusion.js.map

/***/ }),

/***/ 73573:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsExclusionFilter = void 0;
/**
 * Exclusion filter is defined by a query, a sampling rule, and a active/inactive toggle.
 */
class LogsExclusionFilter {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsExclusionFilter.attributeTypeMap;
    }
}
exports.LogsExclusionFilter = LogsExclusionFilter;
/**
 * @ignore
 */
LogsExclusionFilter.attributeTypeMap = {
    query: {
        baseName: "query",
        type: "string",
    },
    sampleRate: {
        baseName: "sample_rate",
        type: "number",
        required: true,
        format: "double",
    },
};
//# sourceMappingURL=LogsExclusionFilter.js.map

/***/ }),

/***/ 96533:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsFilter = void 0;
/**
 * Filter for logs.
 */
class LogsFilter {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsFilter.attributeTypeMap;
    }
}
exports.LogsFilter = LogsFilter;
/**
 * @ignore
 */
LogsFilter.attributeTypeMap = {
    query: {
        baseName: "query",
        type: "string",
    },
};
//# sourceMappingURL=LogsFilter.js.map

/***/ }),

/***/ 30810:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsGeoIPParser = void 0;
/**
 * The GeoIP parser takes an IP address attribute and extracts if available
 * the Continent, Country, Subdivision, and City information in the target attribute path.
 */
class LogsGeoIPParser {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsGeoIPParser.attributeTypeMap;
    }
}
exports.LogsGeoIPParser = LogsGeoIPParser;
/**
 * @ignore
 */
LogsGeoIPParser.attributeTypeMap = {
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    sources: {
        baseName: "sources",
        type: "Array<string>",
        required: true,
    },
    target: {
        baseName: "target",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "LogsGeoIPParserType",
        required: true,
    },
};
//# sourceMappingURL=LogsGeoIPParser.js.map

/***/ }),

/***/ 86255:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsGrokParser = void 0;
/**
 * Create custom grok rules to parse the full message or [a specific attribute of your raw event](https://docs.datadoghq.com/logs/log_configuration/parsing/#advanced-settings).
 * For more information, see the [parsing section](https://docs.datadoghq.com/logs/log_configuration/parsing).
 */
class LogsGrokParser {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsGrokParser.attributeTypeMap;
    }
}
exports.LogsGrokParser = LogsGrokParser;
/**
 * @ignore
 */
LogsGrokParser.attributeTypeMap = {
    grok: {
        baseName: "grok",
        type: "LogsGrokParserRules",
        required: true,
    },
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    samples: {
        baseName: "samples",
        type: "Array<string>",
    },
    source: {
        baseName: "source",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "LogsGrokParserType",
        required: true,
    },
};
//# sourceMappingURL=LogsGrokParser.js.map

/***/ }),

/***/ 17200:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsGrokParserRules = void 0;
/**
 * Set of rules for the grok parser.
 */
class LogsGrokParserRules {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsGrokParserRules.attributeTypeMap;
    }
}
exports.LogsGrokParserRules = LogsGrokParserRules;
/**
 * @ignore
 */
LogsGrokParserRules.attributeTypeMap = {
    matchRules: {
        baseName: "match_rules",
        type: "string",
        required: true,
    },
    supportRules: {
        baseName: "support_rules",
        type: "string",
    },
};
//# sourceMappingURL=LogsGrokParserRules.js.map

/***/ }),

/***/ 67826:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsIndex = void 0;
/**
 * Object describing a Datadog Log index.
 */
class LogsIndex {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsIndex.attributeTypeMap;
    }
}
exports.LogsIndex = LogsIndex;
/**
 * @ignore
 */
LogsIndex.attributeTypeMap = {
    dailyLimit: {
        baseName: "daily_limit",
        type: "number",
        format: "int64",
    },
    exclusionFilters: {
        baseName: "exclusion_filters",
        type: "Array<LogsExclusion>",
    },
    filter: {
        baseName: "filter",
        type: "LogsFilter",
        required: true,
    },
    isRateLimited: {
        baseName: "is_rate_limited",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    numRetentionDays: {
        baseName: "num_retention_days",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=LogsIndex.js.map

/***/ }),

/***/ 32099:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsIndexListResponse = void 0;
/**
 * Object with all Index configurations for a given organization.
 */
class LogsIndexListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsIndexListResponse.attributeTypeMap;
    }
}
exports.LogsIndexListResponse = LogsIndexListResponse;
/**
 * @ignore
 */
LogsIndexListResponse.attributeTypeMap = {
    indexes: {
        baseName: "indexes",
        type: "Array<LogsIndex>",
    },
};
//# sourceMappingURL=LogsIndexListResponse.js.map

/***/ }),

/***/ 60006:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsIndexUpdateRequest = void 0;
/**
 * Object for updating a Datadog Log index.
 */
class LogsIndexUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsIndexUpdateRequest.attributeTypeMap;
    }
}
exports.LogsIndexUpdateRequest = LogsIndexUpdateRequest;
/**
 * @ignore
 */
LogsIndexUpdateRequest.attributeTypeMap = {
    dailyLimit: {
        baseName: "daily_limit",
        type: "number",
        format: "int64",
    },
    disableDailyLimit: {
        baseName: "disable_daily_limit",
        type: "boolean",
    },
    exclusionFilters: {
        baseName: "exclusion_filters",
        type: "Array<LogsExclusion>",
    },
    filter: {
        baseName: "filter",
        type: "LogsFilter",
        required: true,
    },
    numRetentionDays: {
        baseName: "num_retention_days",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=LogsIndexUpdateRequest.js.map

/***/ }),

/***/ 10785:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsIndexesOrder = void 0;
/**
 * Object containing the ordered list of log index names.
 */
class LogsIndexesOrder {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsIndexesOrder.attributeTypeMap;
    }
}
exports.LogsIndexesOrder = LogsIndexesOrder;
/**
 * @ignore
 */
LogsIndexesOrder.attributeTypeMap = {
    indexNames: {
        baseName: "index_names",
        type: "Array<string>",
        required: true,
    },
};
//# sourceMappingURL=LogsIndexesOrder.js.map

/***/ }),

/***/ 98514:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsListRequest = void 0;
/**
 * Object to send with the request to retrieve a list of logs from your Organization.
 */
class LogsListRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsListRequest.attributeTypeMap;
    }
}
exports.LogsListRequest = LogsListRequest;
/**
 * @ignore
 */
LogsListRequest.attributeTypeMap = {
    index: {
        baseName: "index",
        type: "string",
    },
    limit: {
        baseName: "limit",
        type: "number",
        format: "int32",
    },
    query: {
        baseName: "query",
        type: "string",
    },
    sort: {
        baseName: "sort",
        type: "LogsSort",
    },
    startAt: {
        baseName: "startAt",
        type: "string",
    },
    time: {
        baseName: "time",
        type: "LogsListRequestTime",
        required: true,
    },
};
//# sourceMappingURL=LogsListRequest.js.map

/***/ }),

/***/ 21905:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsListRequestTime = void 0;
/**
 * Timeframe to retrieve the log from.
 */
class LogsListRequestTime {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsListRequestTime.attributeTypeMap;
    }
}
exports.LogsListRequestTime = LogsListRequestTime;
/**
 * @ignore
 */
LogsListRequestTime.attributeTypeMap = {
    from: {
        baseName: "from",
        type: "Date",
        required: true,
        format: "date-time",
    },
    timezone: {
        baseName: "timezone",
        type: "string",
    },
    to: {
        baseName: "to",
        type: "Date",
        required: true,
        format: "date-time",
    },
};
//# sourceMappingURL=LogsListRequestTime.js.map

/***/ }),

/***/ 49469:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsListResponse = void 0;
/**
 * Response object with all logs matching the request and pagination information.
 */
class LogsListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsListResponse.attributeTypeMap;
    }
}
exports.LogsListResponse = LogsListResponse;
/**
 * @ignore
 */
LogsListResponse.attributeTypeMap = {
    logs: {
        baseName: "logs",
        type: "Array<Log>",
    },
    nextLogId: {
        baseName: "nextLogId",
        type: "string",
    },
    status: {
        baseName: "status",
        type: "string",
    },
};
//# sourceMappingURL=LogsListResponse.js.map

/***/ }),

/***/ 36335:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsLookupProcessor = void 0;
/**
 * Use the Lookup Processor to define a mapping between a log attribute
 * and a human readable value saved in the processors mapping table.
 * For example, you can use the Lookup Processor to map an internal service ID
 * into a human readable service name. Alternatively, you could also use it to check
 * if the MAC address that just attempted to connect to the production
 * environment belongs to your list of stolen machines.
 */
class LogsLookupProcessor {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsLookupProcessor.attributeTypeMap;
    }
}
exports.LogsLookupProcessor = LogsLookupProcessor;
/**
 * @ignore
 */
LogsLookupProcessor.attributeTypeMap = {
    defaultLookup: {
        baseName: "default_lookup",
        type: "string",
    },
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    lookupTable: {
        baseName: "lookup_table",
        type: "Array<string>",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
    },
    source: {
        baseName: "source",
        type: "string",
        required: true,
    },
    target: {
        baseName: "target",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "LogsLookupProcessorType",
        required: true,
    },
};
//# sourceMappingURL=LogsLookupProcessor.js.map

/***/ }),

/***/ 1148:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsMessageRemapper = void 0;
/**
 * The message is a key attribute in Datadog.
 * It is displayed in the message column of the Log Explorer and you can do full string search on it.
 * Use this Processor to define one or more attributes as the official log message.
 *
 * **Note:** If multiple log message remapper processors can be applied to a given log,
 * only the first one (according to the pipeline order) is taken into account.
 */
class LogsMessageRemapper {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsMessageRemapper.attributeTypeMap;
    }
}
exports.LogsMessageRemapper = LogsMessageRemapper;
/**
 * @ignore
 */
LogsMessageRemapper.attributeTypeMap = {
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    sources: {
        baseName: "sources",
        type: "Array<string>",
        required: true,
    },
    type: {
        baseName: "type",
        type: "LogsMessageRemapperType",
        required: true,
    },
};
//# sourceMappingURL=LogsMessageRemapper.js.map

/***/ }),

/***/ 62446:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsPipeline = void 0;
/**
 * Pipelines and processors operate on incoming logs,
 * parsing and transforming them into structured attributes for easier querying.
 *
 * **Note**: These endpoints are only available for admin users.
 * Make sure to use an application key created by an admin.
 */
class LogsPipeline {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsPipeline.attributeTypeMap;
    }
}
exports.LogsPipeline = LogsPipeline;
/**
 * @ignore
 */
LogsPipeline.attributeTypeMap = {
    filter: {
        baseName: "filter",
        type: "LogsFilter",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    isReadOnly: {
        baseName: "is_read_only",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    processors: {
        baseName: "processors",
        type: "Array<LogsProcessor>",
    },
    type: {
        baseName: "type",
        type: "string",
    },
};
//# sourceMappingURL=LogsPipeline.js.map

/***/ }),

/***/ 93445:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsPipelineProcessor = void 0;
/**
 * Nested Pipelines are pipelines within a pipeline. Use Nested Pipelines to split the processing into two steps.
 * For example, first use a high-level filtering such as team and then a second level of filtering based on the
 * integration, service, or any other tag or attribute.
 *
 * A pipeline can contain Nested Pipelines and Processors whereas a Nested Pipeline can only contain Processors.
 */
class LogsPipelineProcessor {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsPipelineProcessor.attributeTypeMap;
    }
}
exports.LogsPipelineProcessor = LogsPipelineProcessor;
/**
 * @ignore
 */
LogsPipelineProcessor.attributeTypeMap = {
    filter: {
        baseName: "filter",
        type: "LogsFilter",
    },
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    processors: {
        baseName: "processors",
        type: "Array<LogsProcessor>",
    },
    type: {
        baseName: "type",
        type: "LogsPipelineProcessorType",
        required: true,
    },
};
//# sourceMappingURL=LogsPipelineProcessor.js.map

/***/ }),

/***/ 53880:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsPipelinesOrder = void 0;
/**
 * Object containing the ordered list of pipeline IDs.
 */
class LogsPipelinesOrder {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsPipelinesOrder.attributeTypeMap;
    }
}
exports.LogsPipelinesOrder = LogsPipelinesOrder;
/**
 * @ignore
 */
LogsPipelinesOrder.attributeTypeMap = {
    pipelineIds: {
        baseName: "pipeline_ids",
        type: "Array<string>",
        required: true,
    },
};
//# sourceMappingURL=LogsPipelinesOrder.js.map

/***/ }),

/***/ 6239:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsQueryCompute = void 0;
/**
 * Define computation for a log query.
 */
class LogsQueryCompute {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsQueryCompute.attributeTypeMap;
    }
}
exports.LogsQueryCompute = LogsQueryCompute;
/**
 * @ignore
 */
LogsQueryCompute.attributeTypeMap = {
    aggregation: {
        baseName: "aggregation",
        type: "string",
        required: true,
    },
    facet: {
        baseName: "facet",
        type: "string",
    },
    interval: {
        baseName: "interval",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=LogsQueryCompute.js.map

/***/ }),

/***/ 59107:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsRetentionAggSumUsage = void 0;
/**
 * Object containing indexed logs usage aggregated across organizations and months for a retention period.
 */
class LogsRetentionAggSumUsage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsRetentionAggSumUsage.attributeTypeMap;
    }
}
exports.LogsRetentionAggSumUsage = LogsRetentionAggSumUsage;
/**
 * @ignore
 */
LogsRetentionAggSumUsage.attributeTypeMap = {
    logsIndexedLogsUsageAggSum: {
        baseName: "logs_indexed_logs_usage_agg_sum",
        type: "number",
        format: "int64",
    },
    logsLiveIndexedLogsUsageAggSum: {
        baseName: "logs_live_indexed_logs_usage_agg_sum",
        type: "number",
        format: "int64",
    },
    logsRehydratedIndexedLogsUsageAggSum: {
        baseName: "logs_rehydrated_indexed_logs_usage_agg_sum",
        type: "number",
        format: "int64",
    },
    retention: {
        baseName: "retention",
        type: "string",
    },
};
//# sourceMappingURL=LogsRetentionAggSumUsage.js.map

/***/ }),

/***/ 93863:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsRetentionSumUsage = void 0;
/**
 * Object containing indexed logs usage grouped by retention period and summed.
 */
class LogsRetentionSumUsage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsRetentionSumUsage.attributeTypeMap;
    }
}
exports.LogsRetentionSumUsage = LogsRetentionSumUsage;
/**
 * @ignore
 */
LogsRetentionSumUsage.attributeTypeMap = {
    logsIndexedLogsUsageSum: {
        baseName: "logs_indexed_logs_usage_sum",
        type: "number",
        format: "int64",
    },
    logsLiveIndexedLogsUsageSum: {
        baseName: "logs_live_indexed_logs_usage_sum",
        type: "number",
        format: "int64",
    },
    logsRehydratedIndexedLogsUsageSum: {
        baseName: "logs_rehydrated_indexed_logs_usage_sum",
        type: "number",
        format: "int64",
    },
    retention: {
        baseName: "retention",
        type: "string",
    },
};
//# sourceMappingURL=LogsRetentionSumUsage.js.map

/***/ }),

/***/ 73178:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsServiceRemapper = void 0;
/**
 * Use this processor if you want to assign one or more attributes as the official service.
 *
 * **Note:** If multiple service remapper processors can be applied to a given log,
 * only the first one (according to the pipeline order) is taken into account.
 */
class LogsServiceRemapper {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsServiceRemapper.attributeTypeMap;
    }
}
exports.LogsServiceRemapper = LogsServiceRemapper;
/**
 * @ignore
 */
LogsServiceRemapper.attributeTypeMap = {
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    sources: {
        baseName: "sources",
        type: "Array<string>",
        required: true,
    },
    type: {
        baseName: "type",
        type: "LogsServiceRemapperType",
        required: true,
    },
};
//# sourceMappingURL=LogsServiceRemapper.js.map

/***/ }),

/***/ 6206:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsStatusRemapper = void 0;
/**
 * Use this Processor if you want to assign some attributes as the official status.
 *
 * Each incoming status value is mapped as follows.
 *
 *   - Integers from 0 to 7 map to the Syslog severity standards
 *   - Strings beginning with `emerg` or f (case-insensitive) map to `emerg` (0)
 *   - Strings beginning with `a` (case-insensitive) map to `alert` (1)
 *   - Strings beginning with `c` (case-insensitive) map to `critical` (2)
 *   - Strings beginning with `err` (case-insensitive) map to `error` (3)
 *   - Strings beginning with `w` (case-insensitive) map to `warning` (4)
 *   - Strings beginning with `n` (case-insensitive) map to `notice` (5)
 *   - Strings beginning with `i` (case-insensitive) map to `info` (6)
 *   - Strings beginning with `d`, `trace` or `verbose` (case-insensitive) map to `debug` (7)
 *   - Strings beginning with `o` or matching `OK` or `Success` (case-insensitive) map to OK
 *   - All others map to `info` (6)
 *
 *   **Note:** If multiple log status remapper processors can be applied to a given log,
 *   only the first one (according to the pipelines order) is taken into account.
 */
class LogsStatusRemapper {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsStatusRemapper.attributeTypeMap;
    }
}
exports.LogsStatusRemapper = LogsStatusRemapper;
/**
 * @ignore
 */
LogsStatusRemapper.attributeTypeMap = {
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    sources: {
        baseName: "sources",
        type: "Array<string>",
        required: true,
    },
    type: {
        baseName: "type",
        type: "LogsStatusRemapperType",
        required: true,
    },
};
//# sourceMappingURL=LogsStatusRemapper.js.map

/***/ }),

/***/ 54184:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsStringBuilderProcessor = void 0;
/**
 * Use the string builder processor to add a new attribute (without spaces or special characters)
 * to a log with the result of the provided template.
 * This enables aggregation of different attributes or raw strings into a single attribute.
 *
 * The template is defined by both raw text and blocks with the syntax `%{attribute_path}`.
 *
 * **Notes**:
 *
 * - The processor only accepts attributes with values or an array of values in the blocks.
 * - If an attribute cannot be used (object or array of object),
 *   it is replaced by an empty string or the entire operation is skipped depending on your selection.
 * - If the target attribute already exists, it is overwritten by the result of the template.
 * - Results of the template cannot exceed 256 characters.
 */
class LogsStringBuilderProcessor {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsStringBuilderProcessor.attributeTypeMap;
    }
}
exports.LogsStringBuilderProcessor = LogsStringBuilderProcessor;
/**
 * @ignore
 */
LogsStringBuilderProcessor.attributeTypeMap = {
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    isReplaceMissing: {
        baseName: "is_replace_missing",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    target: {
        baseName: "target",
        type: "string",
        required: true,
    },
    template: {
        baseName: "template",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "LogsStringBuilderProcessorType",
        required: true,
    },
};
//# sourceMappingURL=LogsStringBuilderProcessor.js.map

/***/ }),

/***/ 69922:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsTraceRemapper = void 0;
/**
 * There are two ways to improve correlation between application traces and logs.
 *
 *   1. Follow the documentation on [how to inject a trace ID in the application logs](https://docs.datadoghq.com/tracing/connect_logs_and_traces)
 *   and by default log integrations take care of all the rest of the setup.
 *
 *   2. Use the Trace remapper processor to define a log attribute as its associated trace ID.
 */
class LogsTraceRemapper {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsTraceRemapper.attributeTypeMap;
    }
}
exports.LogsTraceRemapper = LogsTraceRemapper;
/**
 * @ignore
 */
LogsTraceRemapper.attributeTypeMap = {
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    sources: {
        baseName: "sources",
        type: "Array<string>",
    },
    type: {
        baseName: "type",
        type: "LogsTraceRemapperType",
        required: true,
    },
};
//# sourceMappingURL=LogsTraceRemapper.js.map

/***/ }),

/***/ 16650:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsURLParser = void 0;
/**
 * This processor extracts query parameters and other important parameters from a URL.
 */
class LogsURLParser {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsURLParser.attributeTypeMap;
    }
}
exports.LogsURLParser = LogsURLParser;
/**
 * @ignore
 */
LogsURLParser.attributeTypeMap = {
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    normalizeEndingSlashes: {
        baseName: "normalize_ending_slashes",
        type: "boolean",
    },
    sources: {
        baseName: "sources",
        type: "Array<string>",
        required: true,
    },
    target: {
        baseName: "target",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "LogsURLParserType",
        required: true,
    },
};
//# sourceMappingURL=LogsURLParser.js.map

/***/ }),

/***/ 62792:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsUserAgentParser = void 0;
/**
 * The User-Agent parser takes a User-Agent attribute and extracts the OS, browser, device, and other user data.
 * It recognizes major bots like the Google Bot, Yahoo Slurp, and Bing.
 */
class LogsUserAgentParser {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsUserAgentParser.attributeTypeMap;
    }
}
exports.LogsUserAgentParser = LogsUserAgentParser;
/**
 * @ignore
 */
LogsUserAgentParser.attributeTypeMap = {
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    isEncoded: {
        baseName: "is_encoded",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    sources: {
        baseName: "sources",
        type: "Array<string>",
        required: true,
    },
    target: {
        baseName: "target",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "LogsUserAgentParserType",
        required: true,
    },
};
//# sourceMappingURL=LogsUserAgentParser.js.map

/***/ }),

/***/ 91082:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricMetadata = void 0;
/**
 * Object with all metric related metadata.
 */
class MetricMetadata {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricMetadata.attributeTypeMap;
    }
}
exports.MetricMetadata = MetricMetadata;
/**
 * @ignore
 */
MetricMetadata.attributeTypeMap = {
    description: {
        baseName: "description",
        type: "string",
    },
    integration: {
        baseName: "integration",
        type: "string",
    },
    perUnit: {
        baseName: "per_unit",
        type: "string",
    },
    shortName: {
        baseName: "short_name",
        type: "string",
    },
    statsdInterval: {
        baseName: "statsd_interval",
        type: "number",
        format: "int64",
    },
    type: {
        baseName: "type",
        type: "string",
    },
    unit: {
        baseName: "unit",
        type: "string",
    },
};
//# sourceMappingURL=MetricMetadata.js.map

/***/ }),

/***/ 5629:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricSearchResponse = void 0;
/**
 * Object containing the list of metrics matching the search query.
 */
class MetricSearchResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricSearchResponse.attributeTypeMap;
    }
}
exports.MetricSearchResponse = MetricSearchResponse;
/**
 * @ignore
 */
MetricSearchResponse.attributeTypeMap = {
    results: {
        baseName: "results",
        type: "MetricSearchResponseResults",
    },
};
//# sourceMappingURL=MetricSearchResponse.js.map

/***/ }),

/***/ 32036:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricSearchResponseResults = void 0;
/**
 * Search result.
 */
class MetricSearchResponseResults {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricSearchResponseResults.attributeTypeMap;
    }
}
exports.MetricSearchResponseResults = MetricSearchResponseResults;
/**
 * @ignore
 */
MetricSearchResponseResults.attributeTypeMap = {
    metrics: {
        baseName: "metrics",
        type: "Array<string>",
    },
};
//# sourceMappingURL=MetricSearchResponseResults.js.map

/***/ }),

/***/ 36562:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricsListResponse = void 0;
/**
 * Object listing all metric names stored by Datadog since a given time.
 */
class MetricsListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricsListResponse.attributeTypeMap;
    }
}
exports.MetricsListResponse = MetricsListResponse;
/**
 * @ignore
 */
MetricsListResponse.attributeTypeMap = {
    from: {
        baseName: "from",
        type: "string",
    },
    metrics: {
        baseName: "metrics",
        type: "Array<string>",
    },
};
//# sourceMappingURL=MetricsListResponse.js.map

/***/ }),

/***/ 18312:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricsPayload = void 0;
/**
 * The metrics' payload.
 */
class MetricsPayload {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricsPayload.attributeTypeMap;
    }
}
exports.MetricsPayload = MetricsPayload;
/**
 * @ignore
 */
MetricsPayload.attributeTypeMap = {
    series: {
        baseName: "series",
        type: "Array<Series>",
        required: true,
    },
};
//# sourceMappingURL=MetricsPayload.js.map

/***/ }),

/***/ 94266:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricsQueryMetadata = void 0;
/**
 * Object containing all metric names returned and their associated metadata.
 */
class MetricsQueryMetadata {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricsQueryMetadata.attributeTypeMap;
    }
}
exports.MetricsQueryMetadata = MetricsQueryMetadata;
/**
 * @ignore
 */
MetricsQueryMetadata.attributeTypeMap = {
    aggr: {
        baseName: "aggr",
        type: "string",
    },
    displayName: {
        baseName: "display_name",
        type: "string",
    },
    end: {
        baseName: "end",
        type: "number",
        format: "int64",
    },
    expression: {
        baseName: "expression",
        type: "string",
    },
    interval: {
        baseName: "interval",
        type: "number",
        format: "int64",
    },
    length: {
        baseName: "length",
        type: "number",
        format: "int64",
    },
    metric: {
        baseName: "metric",
        type: "string",
    },
    pointlist: {
        baseName: "pointlist",
        type: "Array<[number, number]>",
        format: "double",
    },
    queryIndex: {
        baseName: "query_index",
        type: "number",
        format: "int64",
    },
    scope: {
        baseName: "scope",
        type: "string",
    },
    start: {
        baseName: "start",
        type: "number",
        format: "int64",
    },
    tagSet: {
        baseName: "tag_set",
        type: "Array<string>",
    },
    unit: {
        baseName: "unit",
        type: "[MetricsQueryUnit, MetricsQueryUnit]",
    },
};
//# sourceMappingURL=MetricsQueryMetadata.js.map

/***/ }),

/***/ 10574:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricsQueryResponse = void 0;
/**
 * Response Object that includes your query and the list of metrics retrieved.
 */
class MetricsQueryResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricsQueryResponse.attributeTypeMap;
    }
}
exports.MetricsQueryResponse = MetricsQueryResponse;
/**
 * @ignore
 */
MetricsQueryResponse.attributeTypeMap = {
    error: {
        baseName: "error",
        type: "string",
    },
    fromDate: {
        baseName: "from_date",
        type: "number",
        format: "int64",
    },
    groupBy: {
        baseName: "group_by",
        type: "Array<string>",
    },
    message: {
        baseName: "message",
        type: "string",
    },
    query: {
        baseName: "query",
        type: "string",
    },
    resType: {
        baseName: "res_type",
        type: "string",
    },
    series: {
        baseName: "series",
        type: "Array<MetricsQueryMetadata>",
    },
    status: {
        baseName: "status",
        type: "string",
    },
    toDate: {
        baseName: "to_date",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=MetricsQueryResponse.js.map

/***/ }),

/***/ 54581:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricsQueryUnit = void 0;
/**
 * Object containing the metric unit family, scale factor, name, and short name.
 */
class MetricsQueryUnit {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricsQueryUnit.attributeTypeMap;
    }
}
exports.MetricsQueryUnit = MetricsQueryUnit;
/**
 * @ignore
 */
MetricsQueryUnit.attributeTypeMap = {
    family: {
        baseName: "family",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    plural: {
        baseName: "plural",
        type: "string",
    },
    scaleFactor: {
        baseName: "scale_factor",
        type: "number",
        format: "double",
    },
    shortName: {
        baseName: "short_name",
        type: "string",
    },
};
//# sourceMappingURL=MetricsQueryUnit.js.map

/***/ }),

/***/ 45685:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Monitor = void 0;
/**
 * Object describing a monitor.
 */
class Monitor {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return Monitor.attributeTypeMap;
    }
}
exports.Monitor = Monitor;
/**
 * @ignore
 */
Monitor.attributeTypeMap = {
    created: {
        baseName: "created",
        type: "Date",
        format: "date-time",
    },
    creator: {
        baseName: "creator",
        type: "Creator",
    },
    deleted: {
        baseName: "deleted",
        type: "Date",
        format: "date-time",
    },
    id: {
        baseName: "id",
        type: "number",
        format: "int64",
    },
    message: {
        baseName: "message",
        type: "string",
    },
    modified: {
        baseName: "modified",
        type: "Date",
        format: "date-time",
    },
    multi: {
        baseName: "multi",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    options: {
        baseName: "options",
        type: "MonitorOptions",
    },
    overallState: {
        baseName: "overall_state",
        type: "MonitorOverallStates",
    },
    priority: {
        baseName: "priority",
        type: "number",
        format: "int64",
    },
    query: {
        baseName: "query",
        type: "string",
        required: true,
    },
    restrictedRoles: {
        baseName: "restricted_roles",
        type: "Array<string>",
    },
    state: {
        baseName: "state",
        type: "MonitorState",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    type: {
        baseName: "type",
        type: "MonitorType",
        required: true,
    },
};
//# sourceMappingURL=Monitor.js.map

/***/ }),

/***/ 58983:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorFormulaAndFunctionEventQueryDefinition = void 0;
/**
 * A formula and functions events query.
 */
class MonitorFormulaAndFunctionEventQueryDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorFormulaAndFunctionEventQueryDefinition.attributeTypeMap;
    }
}
exports.MonitorFormulaAndFunctionEventQueryDefinition = MonitorFormulaAndFunctionEventQueryDefinition;
/**
 * @ignore
 */
MonitorFormulaAndFunctionEventQueryDefinition.attributeTypeMap = {
    compute: {
        baseName: "compute",
        type: "MonitorFormulaAndFunctionEventQueryDefinitionCompute",
        required: true,
    },
    dataSource: {
        baseName: "data_source",
        type: "MonitorFormulaAndFunctionEventsDataSource",
        required: true,
    },
    groupBy: {
        baseName: "group_by",
        type: "Array<MonitorFormulaAndFunctionEventQueryGroupBy>",
    },
    indexes: {
        baseName: "indexes",
        type: "Array<string>",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    search: {
        baseName: "search",
        type: "MonitorFormulaAndFunctionEventQueryDefinitionSearch",
    },
};
//# sourceMappingURL=MonitorFormulaAndFunctionEventQueryDefinition.js.map

/***/ }),

/***/ 18547:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorFormulaAndFunctionEventQueryDefinitionCompute = void 0;
/**
 * Compute options.
 */
class MonitorFormulaAndFunctionEventQueryDefinitionCompute {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorFormulaAndFunctionEventQueryDefinitionCompute.attributeTypeMap;
    }
}
exports.MonitorFormulaAndFunctionEventQueryDefinitionCompute = MonitorFormulaAndFunctionEventQueryDefinitionCompute;
/**
 * @ignore
 */
MonitorFormulaAndFunctionEventQueryDefinitionCompute.attributeTypeMap = {
    aggregation: {
        baseName: "aggregation",
        type: "MonitorFormulaAndFunctionEventAggregation",
        required: true,
    },
    interval: {
        baseName: "interval",
        type: "number",
        format: "int64",
    },
    metric: {
        baseName: "metric",
        type: "string",
    },
};
//# sourceMappingURL=MonitorFormulaAndFunctionEventQueryDefinitionCompute.js.map

/***/ }),

/***/ 22864:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorFormulaAndFunctionEventQueryDefinitionSearch = void 0;
/**
 * Search options.
 */
class MonitorFormulaAndFunctionEventQueryDefinitionSearch {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorFormulaAndFunctionEventQueryDefinitionSearch.attributeTypeMap;
    }
}
exports.MonitorFormulaAndFunctionEventQueryDefinitionSearch = MonitorFormulaAndFunctionEventQueryDefinitionSearch;
/**
 * @ignore
 */
MonitorFormulaAndFunctionEventQueryDefinitionSearch.attributeTypeMap = {
    query: {
        baseName: "query",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=MonitorFormulaAndFunctionEventQueryDefinitionSearch.js.map

/***/ }),

/***/ 23168:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorFormulaAndFunctionEventQueryGroupBy = void 0;
/**
 * List of objects used to group by.
 */
class MonitorFormulaAndFunctionEventQueryGroupBy {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorFormulaAndFunctionEventQueryGroupBy.attributeTypeMap;
    }
}
exports.MonitorFormulaAndFunctionEventQueryGroupBy = MonitorFormulaAndFunctionEventQueryGroupBy;
/**
 * @ignore
 */
MonitorFormulaAndFunctionEventQueryGroupBy.attributeTypeMap = {
    facet: {
        baseName: "facet",
        type: "string",
        required: true,
    },
    limit: {
        baseName: "limit",
        type: "number",
        format: "int64",
    },
    sort: {
        baseName: "sort",
        type: "MonitorFormulaAndFunctionEventQueryGroupBySort",
    },
};
//# sourceMappingURL=MonitorFormulaAndFunctionEventQueryGroupBy.js.map

/***/ }),

/***/ 45798:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorFormulaAndFunctionEventQueryGroupBySort = void 0;
/**
 * Options for sorting group by results.
 */
class MonitorFormulaAndFunctionEventQueryGroupBySort {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorFormulaAndFunctionEventQueryGroupBySort.attributeTypeMap;
    }
}
exports.MonitorFormulaAndFunctionEventQueryGroupBySort = MonitorFormulaAndFunctionEventQueryGroupBySort;
/**
 * @ignore
 */
MonitorFormulaAndFunctionEventQueryGroupBySort.attributeTypeMap = {
    aggregation: {
        baseName: "aggregation",
        type: "MonitorFormulaAndFunctionEventAggregation",
        required: true,
    },
    metric: {
        baseName: "metric",
        type: "string",
    },
    order: {
        baseName: "order",
        type: "QuerySortOrder",
    },
};
//# sourceMappingURL=MonitorFormulaAndFunctionEventQueryGroupBySort.js.map

/***/ }),

/***/ 25941:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorGroupSearchResponse = void 0;
/**
 * The response of a monitor group search.
 */
class MonitorGroupSearchResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorGroupSearchResponse.attributeTypeMap;
    }
}
exports.MonitorGroupSearchResponse = MonitorGroupSearchResponse;
/**
 * @ignore
 */
MonitorGroupSearchResponse.attributeTypeMap = {
    counts: {
        baseName: "counts",
        type: "MonitorGroupSearchResponseCounts",
    },
    groups: {
        baseName: "groups",
        type: "Array<MonitorGroupSearchResult>",
    },
    metadata: {
        baseName: "metadata",
        type: "MonitorSearchResponseMetadata",
    },
};
//# sourceMappingURL=MonitorGroupSearchResponse.js.map

/***/ }),

/***/ 6527:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorGroupSearchResponseCounts = void 0;
/**
 * The counts of monitor groups per different criteria.
 */
class MonitorGroupSearchResponseCounts {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorGroupSearchResponseCounts.attributeTypeMap;
    }
}
exports.MonitorGroupSearchResponseCounts = MonitorGroupSearchResponseCounts;
/**
 * @ignore
 */
MonitorGroupSearchResponseCounts.attributeTypeMap = {
    status: {
        baseName: "status",
        type: "Array<MonitorSearchCountItem>",
    },
    type: {
        baseName: "type",
        type: "Array<MonitorSearchCountItem>",
    },
};
//# sourceMappingURL=MonitorGroupSearchResponseCounts.js.map

/***/ }),

/***/ 55041:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorGroupSearchResult = void 0;
/**
 * A single monitor group search result.
 */
class MonitorGroupSearchResult {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorGroupSearchResult.attributeTypeMap;
    }
}
exports.MonitorGroupSearchResult = MonitorGroupSearchResult;
/**
 * @ignore
 */
MonitorGroupSearchResult.attributeTypeMap = {
    group: {
        baseName: "group",
        type: "string",
    },
    groupTags: {
        baseName: "group_tags",
        type: "Array<string>",
    },
    lastNodataTs: {
        baseName: "last_nodata_ts",
        type: "number",
        format: "int64",
    },
    lastTriggeredTs: {
        baseName: "last_triggered_ts",
        type: "number",
        format: "int64",
    },
    monitorId: {
        baseName: "monitor_id",
        type: "number",
        format: "int64",
    },
    monitorName: {
        baseName: "monitor_name",
        type: "string",
    },
    status: {
        baseName: "status",
        type: "MonitorOverallStates",
    },
};
//# sourceMappingURL=MonitorGroupSearchResult.js.map

/***/ }),

/***/ 48231:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorOptions = void 0;
/**
 * List of options associated with your monitor.
 */
class MonitorOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorOptions.attributeTypeMap;
    }
}
exports.MonitorOptions = MonitorOptions;
/**
 * @ignore
 */
MonitorOptions.attributeTypeMap = {
    aggregation: {
        baseName: "aggregation",
        type: "MonitorOptionsAggregation",
    },
    deviceIds: {
        baseName: "device_ids",
        type: "Array<MonitorDeviceID>",
    },
    enableLogsSample: {
        baseName: "enable_logs_sample",
        type: "boolean",
    },
    enableSamples: {
        baseName: "enable_samples",
        type: "boolean",
    },
    escalationMessage: {
        baseName: "escalation_message",
        type: "string",
    },
    evaluationDelay: {
        baseName: "evaluation_delay",
        type: "number",
        format: "int64",
    },
    groupRetentionDuration: {
        baseName: "group_retention_duration",
        type: "string",
    },
    groupbySimpleMonitor: {
        baseName: "groupby_simple_monitor",
        type: "boolean",
    },
    includeTags: {
        baseName: "include_tags",
        type: "boolean",
    },
    locked: {
        baseName: "locked",
        type: "boolean",
    },
    minFailureDuration: {
        baseName: "min_failure_duration",
        type: "number",
        format: "int64",
    },
    minLocationFailed: {
        baseName: "min_location_failed",
        type: "number",
        format: "int64",
    },
    newGroupDelay: {
        baseName: "new_group_delay",
        type: "number",
        format: "int64",
    },
    newHostDelay: {
        baseName: "new_host_delay",
        type: "number",
        format: "int64",
    },
    noDataTimeframe: {
        baseName: "no_data_timeframe",
        type: "number",
        format: "int64",
    },
    notificationPresetName: {
        baseName: "notification_preset_name",
        type: "MonitorOptionsNotificationPresets",
    },
    notifyAudit: {
        baseName: "notify_audit",
        type: "boolean",
    },
    notifyBy: {
        baseName: "notify_by",
        type: "Array<string>",
    },
    notifyNoData: {
        baseName: "notify_no_data",
        type: "boolean",
    },
    onMissingData: {
        baseName: "on_missing_data",
        type: "OnMissingDataOption",
    },
    renotifyInterval: {
        baseName: "renotify_interval",
        type: "number",
        format: "int64",
    },
    renotifyOccurrences: {
        baseName: "renotify_occurrences",
        type: "number",
        format: "int64",
    },
    renotifyStatuses: {
        baseName: "renotify_statuses",
        type: "Array<MonitorRenotifyStatusType>",
    },
    requireFullWindow: {
        baseName: "require_full_window",
        type: "boolean",
    },
    schedulingOptions: {
        baseName: "scheduling_options",
        type: "MonitorOptionsSchedulingOptions",
    },
    silenced: {
        baseName: "silenced",
        type: "{ [key: string]: number; }",
    },
    syntheticsCheckId: {
        baseName: "synthetics_check_id",
        type: "string",
    },
    thresholdWindows: {
        baseName: "threshold_windows",
        type: "MonitorThresholdWindowOptions",
    },
    thresholds: {
        baseName: "thresholds",
        type: "MonitorThresholds",
    },
    timeoutH: {
        baseName: "timeout_h",
        type: "number",
        format: "int64",
    },
    variables: {
        baseName: "variables",
        type: "Array<MonitorFormulaAndFunctionQueryDefinition>",
    },
};
//# sourceMappingURL=MonitorOptions.js.map

/***/ }),

/***/ 48316:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorOptionsAggregation = void 0;
/**
 * Type of aggregation performed in the monitor query.
 */
class MonitorOptionsAggregation {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorOptionsAggregation.attributeTypeMap;
    }
}
exports.MonitorOptionsAggregation = MonitorOptionsAggregation;
/**
 * @ignore
 */
MonitorOptionsAggregation.attributeTypeMap = {
    groupBy: {
        baseName: "group_by",
        type: "string",
    },
    metric: {
        baseName: "metric",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "string",
    },
};
//# sourceMappingURL=MonitorOptionsAggregation.js.map

/***/ }),

/***/ 55782:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorOptionsSchedulingOptions = void 0;
/**
 * Configuration options for scheduling.
 */
class MonitorOptionsSchedulingOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorOptionsSchedulingOptions.attributeTypeMap;
    }
}
exports.MonitorOptionsSchedulingOptions = MonitorOptionsSchedulingOptions;
/**
 * @ignore
 */
MonitorOptionsSchedulingOptions.attributeTypeMap = {
    evaluationWindow: {
        baseName: "evaluation_window",
        type: "MonitorOptionsSchedulingOptionsEvaluationWindow",
    },
};
//# sourceMappingURL=MonitorOptionsSchedulingOptions.js.map

/***/ }),

/***/ 1362:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorOptionsSchedulingOptionsEvaluationWindow = void 0;
/**
 * Configuration options for the evaluation window. If `hour_starts` is set, no other fields may be set. Otherwise, `day_starts` and `month_starts` must be set together.
 */
class MonitorOptionsSchedulingOptionsEvaluationWindow {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorOptionsSchedulingOptionsEvaluationWindow.attributeTypeMap;
    }
}
exports.MonitorOptionsSchedulingOptionsEvaluationWindow = MonitorOptionsSchedulingOptionsEvaluationWindow;
/**
 * @ignore
 */
MonitorOptionsSchedulingOptionsEvaluationWindow.attributeTypeMap = {
    dayStarts: {
        baseName: "day_starts",
        type: "string",
    },
    hourStarts: {
        baseName: "hour_starts",
        type: "number",
        format: "int32",
    },
    monthStarts: {
        baseName: "month_starts",
        type: "number",
        format: "int32",
    },
};
//# sourceMappingURL=MonitorOptionsSchedulingOptionsEvaluationWindow.js.map

/***/ }),

/***/ 31944:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorSearchCountItem = void 0;
/**
 * A facet item.
 */
class MonitorSearchCountItem {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorSearchCountItem.attributeTypeMap;
    }
}
exports.MonitorSearchCountItem = MonitorSearchCountItem;
/**
 * @ignore
 */
MonitorSearchCountItem.attributeTypeMap = {
    count: {
        baseName: "count",
        type: "number",
        format: "int64",
    },
    name: {
        baseName: "name",
        type: "any",
    },
};
//# sourceMappingURL=MonitorSearchCountItem.js.map

/***/ }),

/***/ 40893:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorSearchResponse = void 0;
/**
 * The response form a monitor search.
 */
class MonitorSearchResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorSearchResponse.attributeTypeMap;
    }
}
exports.MonitorSearchResponse = MonitorSearchResponse;
/**
 * @ignore
 */
MonitorSearchResponse.attributeTypeMap = {
    counts: {
        baseName: "counts",
        type: "MonitorSearchResponseCounts",
    },
    metadata: {
        baseName: "metadata",
        type: "MonitorSearchResponseMetadata",
    },
    monitors: {
        baseName: "monitors",
        type: "Array<MonitorSearchResult>",
    },
};
//# sourceMappingURL=MonitorSearchResponse.js.map

/***/ }),

/***/ 80198:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorSearchResponseCounts = void 0;
/**
 * The counts of monitors per different criteria.
 */
class MonitorSearchResponseCounts {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorSearchResponseCounts.attributeTypeMap;
    }
}
exports.MonitorSearchResponseCounts = MonitorSearchResponseCounts;
/**
 * @ignore
 */
MonitorSearchResponseCounts.attributeTypeMap = {
    muted: {
        baseName: "muted",
        type: "Array<MonitorSearchCountItem>",
    },
    status: {
        baseName: "status",
        type: "Array<MonitorSearchCountItem>",
    },
    tag: {
        baseName: "tag",
        type: "Array<MonitorSearchCountItem>",
    },
    type: {
        baseName: "type",
        type: "Array<MonitorSearchCountItem>",
    },
};
//# sourceMappingURL=MonitorSearchResponseCounts.js.map

/***/ }),

/***/ 78696:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorSearchResponseMetadata = void 0;
/**
 * Metadata about the response.
 */
class MonitorSearchResponseMetadata {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorSearchResponseMetadata.attributeTypeMap;
    }
}
exports.MonitorSearchResponseMetadata = MonitorSearchResponseMetadata;
/**
 * @ignore
 */
MonitorSearchResponseMetadata.attributeTypeMap = {
    page: {
        baseName: "page",
        type: "number",
        format: "int64",
    },
    pageCount: {
        baseName: "page_count",
        type: "number",
        format: "int64",
    },
    perPage: {
        baseName: "per_page",
        type: "number",
        format: "int64",
    },
    totalCount: {
        baseName: "total_count",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=MonitorSearchResponseMetadata.js.map

/***/ }),

/***/ 14120:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorSearchResult = void 0;
/**
 * Holds search results.
 */
class MonitorSearchResult {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorSearchResult.attributeTypeMap;
    }
}
exports.MonitorSearchResult = MonitorSearchResult;
/**
 * @ignore
 */
MonitorSearchResult.attributeTypeMap = {
    classification: {
        baseName: "classification",
        type: "string",
    },
    creator: {
        baseName: "creator",
        type: "Creator",
    },
    id: {
        baseName: "id",
        type: "number",
        format: "int64",
    },
    lastTriggeredTs: {
        baseName: "last_triggered_ts",
        type: "number",
        format: "int64",
    },
    metrics: {
        baseName: "metrics",
        type: "Array<string>",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    notifications: {
        baseName: "notifications",
        type: "Array<MonitorSearchResultNotification>",
    },
    orgId: {
        baseName: "org_id",
        type: "number",
        format: "int64",
    },
    query: {
        baseName: "query",
        type: "string",
    },
    scopes: {
        baseName: "scopes",
        type: "Array<string>",
    },
    status: {
        baseName: "status",
        type: "MonitorOverallStates",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    type: {
        baseName: "type",
        type: "MonitorType",
    },
};
//# sourceMappingURL=MonitorSearchResult.js.map

/***/ }),

/***/ 17402:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorSearchResultNotification = void 0;
/**
 * A notification triggered by the monitor.
 */
class MonitorSearchResultNotification {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorSearchResultNotification.attributeTypeMap;
    }
}
exports.MonitorSearchResultNotification = MonitorSearchResultNotification;
/**
 * @ignore
 */
MonitorSearchResultNotification.attributeTypeMap = {
    handle: {
        baseName: "handle",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=MonitorSearchResultNotification.js.map

/***/ }),

/***/ 27789:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorState = void 0;
/**
 * Wrapper object with the different monitor states.
 */
class MonitorState {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorState.attributeTypeMap;
    }
}
exports.MonitorState = MonitorState;
/**
 * @ignore
 */
MonitorState.attributeTypeMap = {
    groups: {
        baseName: "groups",
        type: "{ [key: string]: MonitorStateGroup; }",
    },
};
//# sourceMappingURL=MonitorState.js.map

/***/ }),

/***/ 68737:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorStateGroup = void 0;
/**
 * Monitor state for a single group.
 */
class MonitorStateGroup {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorStateGroup.attributeTypeMap;
    }
}
exports.MonitorStateGroup = MonitorStateGroup;
/**
 * @ignore
 */
MonitorStateGroup.attributeTypeMap = {
    lastNodataTs: {
        baseName: "last_nodata_ts",
        type: "number",
        format: "int64",
    },
    lastNotifiedTs: {
        baseName: "last_notified_ts",
        type: "number",
        format: "int64",
    },
    lastResolvedTs: {
        baseName: "last_resolved_ts",
        type: "number",
        format: "int64",
    },
    lastTriggeredTs: {
        baseName: "last_triggered_ts",
        type: "number",
        format: "int64",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    status: {
        baseName: "status",
        type: "MonitorOverallStates",
    },
};
//# sourceMappingURL=MonitorStateGroup.js.map

/***/ }),

/***/ 22788:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorSummaryWidgetDefinition = void 0;
/**
 * The monitor summary widget displays a summary view of all your Datadog monitors, or a subset based on a query. Only available on FREE layout dashboards.
 */
class MonitorSummaryWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorSummaryWidgetDefinition.attributeTypeMap;
    }
}
exports.MonitorSummaryWidgetDefinition = MonitorSummaryWidgetDefinition;
/**
 * @ignore
 */
MonitorSummaryWidgetDefinition.attributeTypeMap = {
    colorPreference: {
        baseName: "color_preference",
        type: "WidgetColorPreference",
    },
    count: {
        baseName: "count",
        type: "number",
        format: "int64",
    },
    displayFormat: {
        baseName: "display_format",
        type: "WidgetMonitorSummaryDisplayFormat",
    },
    hideZeroCounts: {
        baseName: "hide_zero_counts",
        type: "boolean",
    },
    query: {
        baseName: "query",
        type: "string",
        required: true,
    },
    showLastTriggered: {
        baseName: "show_last_triggered",
        type: "boolean",
    },
    showPriority: {
        baseName: "show_priority",
        type: "boolean",
    },
    sort: {
        baseName: "sort",
        type: "WidgetMonitorSummarySort",
    },
    start: {
        baseName: "start",
        type: "number",
        format: "int64",
    },
    summaryType: {
        baseName: "summary_type",
        type: "WidgetSummaryType",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "MonitorSummaryWidgetDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=MonitorSummaryWidgetDefinition.js.map

/***/ }),

/***/ 12780:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorThresholdWindowOptions = void 0;
/**
 * Alerting time window options.
 */
class MonitorThresholdWindowOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorThresholdWindowOptions.attributeTypeMap;
    }
}
exports.MonitorThresholdWindowOptions = MonitorThresholdWindowOptions;
/**
 * @ignore
 */
MonitorThresholdWindowOptions.attributeTypeMap = {
    recoveryWindow: {
        baseName: "recovery_window",
        type: "string",
    },
    triggerWindow: {
        baseName: "trigger_window",
        type: "string",
    },
};
//# sourceMappingURL=MonitorThresholdWindowOptions.js.map

/***/ }),

/***/ 28522:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorThresholds = void 0;
/**
 * List of the different monitor threshold available.
 */
class MonitorThresholds {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorThresholds.attributeTypeMap;
    }
}
exports.MonitorThresholds = MonitorThresholds;
/**
 * @ignore
 */
MonitorThresholds.attributeTypeMap = {
    critical: {
        baseName: "critical",
        type: "number",
        format: "double",
    },
    criticalRecovery: {
        baseName: "critical_recovery",
        type: "number",
        format: "double",
    },
    ok: {
        baseName: "ok",
        type: "number",
        format: "double",
    },
    unknown: {
        baseName: "unknown",
        type: "number",
        format: "double",
    },
    warning: {
        baseName: "warning",
        type: "number",
        format: "double",
    },
    warningRecovery: {
        baseName: "warning_recovery",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=MonitorThresholds.js.map

/***/ }),

/***/ 77039:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorUpdateRequest = void 0;
/**
 * Object describing a monitor update request.
 */
class MonitorUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorUpdateRequest.attributeTypeMap;
    }
}
exports.MonitorUpdateRequest = MonitorUpdateRequest;
/**
 * @ignore
 */
MonitorUpdateRequest.attributeTypeMap = {
    created: {
        baseName: "created",
        type: "Date",
        format: "date-time",
    },
    creator: {
        baseName: "creator",
        type: "Creator",
    },
    deleted: {
        baseName: "deleted",
        type: "Date",
        format: "date-time",
    },
    id: {
        baseName: "id",
        type: "number",
        format: "int64",
    },
    message: {
        baseName: "message",
        type: "string",
    },
    modified: {
        baseName: "modified",
        type: "Date",
        format: "date-time",
    },
    multi: {
        baseName: "multi",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    options: {
        baseName: "options",
        type: "MonitorOptions",
    },
    overallState: {
        baseName: "overall_state",
        type: "MonitorOverallStates",
    },
    priority: {
        baseName: "priority",
        type: "number",
        format: "int64",
    },
    query: {
        baseName: "query",
        type: "string",
    },
    restrictedRoles: {
        baseName: "restricted_roles",
        type: "Array<string>",
    },
    state: {
        baseName: "state",
        type: "MonitorState",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    type: {
        baseName: "type",
        type: "MonitorType",
    },
};
//# sourceMappingURL=MonitorUpdateRequest.js.map

/***/ }),

/***/ 22537:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonthlyUsageAttributionBody = void 0;
/**
 * Usage Summary by tag for a given organization.
 */
class MonthlyUsageAttributionBody {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonthlyUsageAttributionBody.attributeTypeMap;
    }
}
exports.MonthlyUsageAttributionBody = MonthlyUsageAttributionBody;
/**
 * @ignore
 */
MonthlyUsageAttributionBody.attributeTypeMap = {
    month: {
        baseName: "month",
        type: "Date",
        format: "date-time",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    tagConfigSource: {
        baseName: "tag_config_source",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "{ [key: string]: Array<string>; }",
    },
    updatedAt: {
        baseName: "updated_at",
        type: "Date",
        format: "date-time",
    },
    values: {
        baseName: "values",
        type: "MonthlyUsageAttributionValues",
    },
};
//# sourceMappingURL=MonthlyUsageAttributionBody.js.map

/***/ }),

/***/ 25116:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonthlyUsageAttributionMetadata = void 0;
/**
 * The object containing document metadata.
 */
class MonthlyUsageAttributionMetadata {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonthlyUsageAttributionMetadata.attributeTypeMap;
    }
}
exports.MonthlyUsageAttributionMetadata = MonthlyUsageAttributionMetadata;
/**
 * @ignore
 */
MonthlyUsageAttributionMetadata.attributeTypeMap = {
    aggregates: {
        baseName: "aggregates",
        type: "Array<UsageAttributionAggregatesBody>",
    },
    pagination: {
        baseName: "pagination",
        type: "MonthlyUsageAttributionPagination",
    },
};
//# sourceMappingURL=MonthlyUsageAttributionMetadata.js.map

/***/ }),

/***/ 73712:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonthlyUsageAttributionPagination = void 0;
/**
 * The metadata for the current pagination.
 */
class MonthlyUsageAttributionPagination {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonthlyUsageAttributionPagination.attributeTypeMap;
    }
}
exports.MonthlyUsageAttributionPagination = MonthlyUsageAttributionPagination;
/**
 * @ignore
 */
MonthlyUsageAttributionPagination.attributeTypeMap = {
    nextRecordId: {
        baseName: "next_record_id",
        type: "string",
    },
};
//# sourceMappingURL=MonthlyUsageAttributionPagination.js.map

/***/ }),

/***/ 95112:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonthlyUsageAttributionResponse = void 0;
/**
 * Response containing the monthly Usage Summary by tag(s).
 */
class MonthlyUsageAttributionResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonthlyUsageAttributionResponse.attributeTypeMap;
    }
}
exports.MonthlyUsageAttributionResponse = MonthlyUsageAttributionResponse;
/**
 * @ignore
 */
MonthlyUsageAttributionResponse.attributeTypeMap = {
    metadata: {
        baseName: "metadata",
        type: "MonthlyUsageAttributionMetadata",
    },
    usage: {
        baseName: "usage",
        type: "Array<MonthlyUsageAttributionBody>",
    },
};
//# sourceMappingURL=MonthlyUsageAttributionResponse.js.map

/***/ }),

/***/ 80336:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonthlyUsageAttributionValues = void 0;
/**
 * Fields in Usage Summary by tag(s).
 */
class MonthlyUsageAttributionValues {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonthlyUsageAttributionValues.attributeTypeMap;
    }
}
exports.MonthlyUsageAttributionValues = MonthlyUsageAttributionValues;
/**
 * @ignore
 */
MonthlyUsageAttributionValues.attributeTypeMap = {
    apiPercentage: {
        baseName: "api_percentage",
        type: "number",
        format: "double",
    },
    apiUsage: {
        baseName: "api_usage",
        type: "number",
        format: "double",
    },
    apmFargatePercentage: {
        baseName: "apm_fargate_percentage",
        type: "number",
        format: "double",
    },
    apmFargateUsage: {
        baseName: "apm_fargate_usage",
        type: "number",
        format: "double",
    },
    apmHostPercentage: {
        baseName: "apm_host_percentage",
        type: "number",
        format: "double",
    },
    apmHostUsage: {
        baseName: "apm_host_usage",
        type: "number",
        format: "double",
    },
    appsecFargatePercentage: {
        baseName: "appsec_fargate_percentage",
        type: "number",
        format: "double",
    },
    appsecFargateUsage: {
        baseName: "appsec_fargate_usage",
        type: "number",
        format: "double",
    },
    appsecPercentage: {
        baseName: "appsec_percentage",
        type: "number",
        format: "double",
    },
    appsecUsage: {
        baseName: "appsec_usage",
        type: "number",
        format: "double",
    },
    browserPercentage: {
        baseName: "browser_percentage",
        type: "number",
        format: "double",
    },
    browserUsage: {
        baseName: "browser_usage",
        type: "number",
        format: "double",
    },
    containerExclAgentPercentage: {
        baseName: "container_excl_agent_percentage",
        type: "number",
        format: "double",
    },
    containerExclAgentUsage: {
        baseName: "container_excl_agent_usage",
        type: "number",
        format: "double",
    },
    containerPercentage: {
        baseName: "container_percentage",
        type: "number",
        format: "double",
    },
    containerUsage: {
        baseName: "container_usage",
        type: "number",
        format: "double",
    },
    cspmContainersPercentage: {
        baseName: "cspm_containers_percentage",
        type: "number",
        format: "double",
    },
    cspmContainersUsage: {
        baseName: "cspm_containers_usage",
        type: "number",
        format: "double",
    },
    cspmHostsPercentage: {
        baseName: "cspm_hosts_percentage",
        type: "number",
        format: "double",
    },
    cspmHostsUsage: {
        baseName: "cspm_hosts_usage",
        type: "number",
        format: "double",
    },
    customTimeseriesPercentage: {
        baseName: "custom_timeseries_percentage",
        type: "number",
        format: "double",
    },
    customTimeseriesUsage: {
        baseName: "custom_timeseries_usage",
        type: "number",
        format: "double",
    },
    cwsContainersPercentage: {
        baseName: "cws_containers_percentage",
        type: "number",
        format: "double",
    },
    cwsContainersUsage: {
        baseName: "cws_containers_usage",
        type: "number",
        format: "double",
    },
    cwsHostsPercentage: {
        baseName: "cws_hosts_percentage",
        type: "number",
        format: "double",
    },
    cwsHostsUsage: {
        baseName: "cws_hosts_usage",
        type: "number",
        format: "double",
    },
    dbmHostsPercentage: {
        baseName: "dbm_hosts_percentage",
        type: "number",
        format: "double",
    },
    dbmHostsUsage: {
        baseName: "dbm_hosts_usage",
        type: "number",
        format: "double",
    },
    dbmQueriesPercentage: {
        baseName: "dbm_queries_percentage",
        type: "number",
        format: "double",
    },
    dbmQueriesUsage: {
        baseName: "dbm_queries_usage",
        type: "number",
        format: "double",
    },
    estimatedIndexedLogsPercentage: {
        baseName: "estimated_indexed_logs_percentage",
        type: "number",
        format: "double",
    },
    estimatedIndexedLogsUsage: {
        baseName: "estimated_indexed_logs_usage",
        type: "number",
        format: "double",
    },
    estimatedIndexedSpansPercentage: {
        baseName: "estimated_indexed_spans_percentage",
        type: "number",
        format: "double",
    },
    estimatedIndexedSpansUsage: {
        baseName: "estimated_indexed_spans_usage",
        type: "number",
        format: "double",
    },
    estimatedIngestedLogsPercentage: {
        baseName: "estimated_ingested_logs_percentage",
        type: "number",
        format: "double",
    },
    estimatedIngestedLogsUsage: {
        baseName: "estimated_ingested_logs_usage",
        type: "number",
        format: "double",
    },
    estimatedIngestedSpansPercentage: {
        baseName: "estimated_ingested_spans_percentage",
        type: "number",
        format: "double",
    },
    estimatedIngestedSpansUsage: {
        baseName: "estimated_ingested_spans_usage",
        type: "number",
        format: "double",
    },
    estimatedRumSessionsPercentage: {
        baseName: "estimated_rum_sessions_percentage",
        type: "number",
        format: "double",
    },
    estimatedRumSessionsUsage: {
        baseName: "estimated_rum_sessions_usage",
        type: "number",
        format: "double",
    },
    fargatePercentage: {
        baseName: "fargate_percentage",
        type: "number",
        format: "double",
    },
    fargateUsage: {
        baseName: "fargate_usage",
        type: "number",
        format: "double",
    },
    functionsPercentage: {
        baseName: "functions_percentage",
        type: "number",
        format: "double",
    },
    functionsUsage: {
        baseName: "functions_usage",
        type: "number",
        format: "double",
    },
    infraHostPercentage: {
        baseName: "infra_host_percentage",
        type: "number",
        format: "double",
    },
    infraHostUsage: {
        baseName: "infra_host_usage",
        type: "number",
        format: "double",
    },
    invocationsPercentage: {
        baseName: "invocations_percentage",
        type: "number",
        format: "double",
    },
    invocationsUsage: {
        baseName: "invocations_usage",
        type: "number",
        format: "double",
    },
    npmHostPercentage: {
        baseName: "npm_host_percentage",
        type: "number",
        format: "double",
    },
    npmHostUsage: {
        baseName: "npm_host_usage",
        type: "number",
        format: "double",
    },
    profiledContainerPercentage: {
        baseName: "profiled_container_percentage",
        type: "number",
        format: "double",
    },
    profiledContainerUsage: {
        baseName: "profiled_container_usage",
        type: "number",
        format: "double",
    },
    profiledHostPercentage: {
        baseName: "profiled_host_percentage",
        type: "number",
        format: "double",
    },
    profiledHostUsage: {
        baseName: "profiled_host_usage",
        type: "number",
        format: "double",
    },
    snmpPercentage: {
        baseName: "snmp_percentage",
        type: "number",
        format: "double",
    },
    snmpUsage: {
        baseName: "snmp_usage",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=MonthlyUsageAttributionValues.js.map

/***/ }),

/***/ 35355:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoteWidgetDefinition = void 0;
/**
 * The notes and links widget is similar to free text widget, but allows for more formatting options.
 */
class NoteWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NoteWidgetDefinition.attributeTypeMap;
    }
}
exports.NoteWidgetDefinition = NoteWidgetDefinition;
/**
 * @ignore
 */
NoteWidgetDefinition.attributeTypeMap = {
    backgroundColor: {
        baseName: "background_color",
        type: "string",
    },
    content: {
        baseName: "content",
        type: "string",
        required: true,
    },
    fontSize: {
        baseName: "font_size",
        type: "string",
    },
    hasPadding: {
        baseName: "has_padding",
        type: "boolean",
    },
    showTick: {
        baseName: "show_tick",
        type: "boolean",
    },
    textAlign: {
        baseName: "text_align",
        type: "WidgetTextAlign",
    },
    tickEdge: {
        baseName: "tick_edge",
        type: "WidgetTickEdge",
    },
    tickPos: {
        baseName: "tick_pos",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "NoteWidgetDefinitionType",
        required: true,
    },
    verticalAlign: {
        baseName: "vertical_align",
        type: "WidgetVerticalAlign",
    },
};
//# sourceMappingURL=NoteWidgetDefinition.js.map

/***/ }),

/***/ 65962:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookAbsoluteTime = void 0;
/**
 * Absolute timeframe.
 */
class NotebookAbsoluteTime {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookAbsoluteTime.attributeTypeMap;
    }
}
exports.NotebookAbsoluteTime = NotebookAbsoluteTime;
/**
 * @ignore
 */
NotebookAbsoluteTime.attributeTypeMap = {
    end: {
        baseName: "end",
        type: "Date",
        required: true,
        format: "date-time",
    },
    live: {
        baseName: "live",
        type: "boolean",
    },
    start: {
        baseName: "start",
        type: "Date",
        required: true,
        format: "date-time",
    },
};
//# sourceMappingURL=NotebookAbsoluteTime.js.map

/***/ }),

/***/ 90658:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookAuthor = void 0;
/**
 * Attributes of user object returned by the API.
 */
class NotebookAuthor {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookAuthor.attributeTypeMap;
    }
}
exports.NotebookAuthor = NotebookAuthor;
/**
 * @ignore
 */
NotebookAuthor.attributeTypeMap = {
    createdAt: {
        baseName: "created_at",
        type: "Date",
        format: "date-time",
    },
    disabled: {
        baseName: "disabled",
        type: "boolean",
    },
    email: {
        baseName: "email",
        type: "string",
    },
    handle: {
        baseName: "handle",
        type: "string",
    },
    icon: {
        baseName: "icon",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    status: {
        baseName: "status",
        type: "string",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    verified: {
        baseName: "verified",
        type: "boolean",
    },
};
//# sourceMappingURL=NotebookAuthor.js.map

/***/ }),

/***/ 62235:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookCellCreateRequest = void 0;
/**
 * The description of a notebook cell create request.
 */
class NotebookCellCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookCellCreateRequest.attributeTypeMap;
    }
}
exports.NotebookCellCreateRequest = NotebookCellCreateRequest;
/**
 * @ignore
 */
NotebookCellCreateRequest.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "NotebookCellCreateRequestAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "NotebookCellResourceType",
        required: true,
    },
};
//# sourceMappingURL=NotebookCellCreateRequest.js.map

/***/ }),

/***/ 84386:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookCellResponse = void 0;
/**
 * The description of a notebook cell response.
 */
class NotebookCellResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookCellResponse.attributeTypeMap;
    }
}
exports.NotebookCellResponse = NotebookCellResponse;
/**
 * @ignore
 */
NotebookCellResponse.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "NotebookCellResponseAttributes",
        required: true,
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "NotebookCellResourceType",
        required: true,
    },
};
//# sourceMappingURL=NotebookCellResponse.js.map

/***/ }),

/***/ 99902:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookCellUpdateRequest = void 0;
/**
 * The description of a notebook cell update request.
 */
class NotebookCellUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookCellUpdateRequest.attributeTypeMap;
    }
}
exports.NotebookCellUpdateRequest = NotebookCellUpdateRequest;
/**
 * @ignore
 */
NotebookCellUpdateRequest.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "NotebookCellUpdateRequestAttributes",
        required: true,
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "NotebookCellResourceType",
        required: true,
    },
};
//# sourceMappingURL=NotebookCellUpdateRequest.js.map

/***/ }),

/***/ 42541:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookCreateData = void 0;
/**
 * The data for a notebook create request.
 */
class NotebookCreateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookCreateData.attributeTypeMap;
    }
}
exports.NotebookCreateData = NotebookCreateData;
/**
 * @ignore
 */
NotebookCreateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "NotebookCreateDataAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "NotebookResourceType",
        required: true,
    },
};
//# sourceMappingURL=NotebookCreateData.js.map

/***/ }),

/***/ 52931:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookCreateDataAttributes = void 0;
/**
 * The data attributes of a notebook.
 */
class NotebookCreateDataAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookCreateDataAttributes.attributeTypeMap;
    }
}
exports.NotebookCreateDataAttributes = NotebookCreateDataAttributes;
/**
 * @ignore
 */
NotebookCreateDataAttributes.attributeTypeMap = {
    cells: {
        baseName: "cells",
        type: "Array<NotebookCellCreateRequest>",
        required: true,
    },
    metadata: {
        baseName: "metadata",
        type: "NotebookMetadata",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    status: {
        baseName: "status",
        type: "NotebookStatus",
    },
    time: {
        baseName: "time",
        type: "NotebookGlobalTime",
        required: true,
    },
};
//# sourceMappingURL=NotebookCreateDataAttributes.js.map

/***/ }),

/***/ 82520:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookCreateRequest = void 0;
/**
 * The description of a notebook create request.
 */
class NotebookCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookCreateRequest.attributeTypeMap;
    }
}
exports.NotebookCreateRequest = NotebookCreateRequest;
/**
 * @ignore
 */
NotebookCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "NotebookCreateData",
        required: true,
    },
};
//# sourceMappingURL=NotebookCreateRequest.js.map

/***/ }),

/***/ 87594:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookDistributionCellAttributes = void 0;
/**
 * The attributes of a notebook `distribution` cell.
 */
class NotebookDistributionCellAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookDistributionCellAttributes.attributeTypeMap;
    }
}
exports.NotebookDistributionCellAttributes = NotebookDistributionCellAttributes;
/**
 * @ignore
 */
NotebookDistributionCellAttributes.attributeTypeMap = {
    definition: {
        baseName: "definition",
        type: "DistributionWidgetDefinition",
        required: true,
    },
    graphSize: {
        baseName: "graph_size",
        type: "NotebookGraphSize",
    },
    splitBy: {
        baseName: "split_by",
        type: "NotebookSplitBy",
    },
    time: {
        baseName: "time",
        type: "NotebookCellTime",
    },
};
//# sourceMappingURL=NotebookDistributionCellAttributes.js.map

/***/ }),

/***/ 81974:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookHeatMapCellAttributes = void 0;
/**
 * The attributes of a notebook `heatmap` cell.
 */
class NotebookHeatMapCellAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookHeatMapCellAttributes.attributeTypeMap;
    }
}
exports.NotebookHeatMapCellAttributes = NotebookHeatMapCellAttributes;
/**
 * @ignore
 */
NotebookHeatMapCellAttributes.attributeTypeMap = {
    definition: {
        baseName: "definition",
        type: "HeatMapWidgetDefinition",
        required: true,
    },
    graphSize: {
        baseName: "graph_size",
        type: "NotebookGraphSize",
    },
    splitBy: {
        baseName: "split_by",
        type: "NotebookSplitBy",
    },
    time: {
        baseName: "time",
        type: "NotebookCellTime",
    },
};
//# sourceMappingURL=NotebookHeatMapCellAttributes.js.map

/***/ }),

/***/ 60761:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookLogStreamCellAttributes = void 0;
/**
 * The attributes of a notebook `log_stream` cell.
 */
class NotebookLogStreamCellAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookLogStreamCellAttributes.attributeTypeMap;
    }
}
exports.NotebookLogStreamCellAttributes = NotebookLogStreamCellAttributes;
/**
 * @ignore
 */
NotebookLogStreamCellAttributes.attributeTypeMap = {
    definition: {
        baseName: "definition",
        type: "LogStreamWidgetDefinition",
        required: true,
    },
    graphSize: {
        baseName: "graph_size",
        type: "NotebookGraphSize",
    },
    time: {
        baseName: "time",
        type: "NotebookCellTime",
    },
};
//# sourceMappingURL=NotebookLogStreamCellAttributes.js.map

/***/ }),

/***/ 3567:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookMarkdownCellAttributes = void 0;
/**
 * The attributes of a notebook `markdown` cell.
 */
class NotebookMarkdownCellAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookMarkdownCellAttributes.attributeTypeMap;
    }
}
exports.NotebookMarkdownCellAttributes = NotebookMarkdownCellAttributes;
/**
 * @ignore
 */
NotebookMarkdownCellAttributes.attributeTypeMap = {
    definition: {
        baseName: "definition",
        type: "NotebookMarkdownCellDefinition",
        required: true,
    },
};
//# sourceMappingURL=NotebookMarkdownCellAttributes.js.map

/***/ }),

/***/ 12035:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookMarkdownCellDefinition = void 0;
/**
 * Text in a notebook is formatted with [Markdown](https://daringfireball.net/projects/markdown/), which enables the use of headings, subheadings, links, images, lists, and code blocks.
 */
class NotebookMarkdownCellDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookMarkdownCellDefinition.attributeTypeMap;
    }
}
exports.NotebookMarkdownCellDefinition = NotebookMarkdownCellDefinition;
/**
 * @ignore
 */
NotebookMarkdownCellDefinition.attributeTypeMap = {
    text: {
        baseName: "text",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "NotebookMarkdownCellDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=NotebookMarkdownCellDefinition.js.map

/***/ }),

/***/ 34078:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookMetadata = void 0;
/**
 * Metadata associated with the notebook.
 */
class NotebookMetadata {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookMetadata.attributeTypeMap;
    }
}
exports.NotebookMetadata = NotebookMetadata;
/**
 * @ignore
 */
NotebookMetadata.attributeTypeMap = {
    isTemplate: {
        baseName: "is_template",
        type: "boolean",
    },
    takeSnapshots: {
        baseName: "take_snapshots",
        type: "boolean",
    },
    type: {
        baseName: "type",
        type: "NotebookMetadataType",
    },
};
//# sourceMappingURL=NotebookMetadata.js.map

/***/ }),

/***/ 94586:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookRelativeTime = void 0;
/**
 * Relative timeframe.
 */
class NotebookRelativeTime {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookRelativeTime.attributeTypeMap;
    }
}
exports.NotebookRelativeTime = NotebookRelativeTime;
/**
 * @ignore
 */
NotebookRelativeTime.attributeTypeMap = {
    liveSpan: {
        baseName: "live_span",
        type: "WidgetLiveSpan",
        required: true,
    },
};
//# sourceMappingURL=NotebookRelativeTime.js.map

/***/ }),

/***/ 43296:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookResponse = void 0;
/**
 * The description of a notebook response.
 */
class NotebookResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookResponse.attributeTypeMap;
    }
}
exports.NotebookResponse = NotebookResponse;
/**
 * @ignore
 */
NotebookResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "NotebookResponseData",
    },
};
//# sourceMappingURL=NotebookResponse.js.map

/***/ }),

/***/ 59227:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookResponseData = void 0;
/**
 * The data for a notebook.
 */
class NotebookResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookResponseData.attributeTypeMap;
    }
}
exports.NotebookResponseData = NotebookResponseData;
/**
 * @ignore
 */
NotebookResponseData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "NotebookResponseDataAttributes",
        required: true,
    },
    id: {
        baseName: "id",
        type: "number",
        required: true,
        format: "int64",
    },
    type: {
        baseName: "type",
        type: "NotebookResourceType",
        required: true,
    },
};
//# sourceMappingURL=NotebookResponseData.js.map

/***/ }),

/***/ 59433:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookResponseDataAttributes = void 0;
/**
 * The attributes of a notebook.
 */
class NotebookResponseDataAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookResponseDataAttributes.attributeTypeMap;
    }
}
exports.NotebookResponseDataAttributes = NotebookResponseDataAttributes;
/**
 * @ignore
 */
NotebookResponseDataAttributes.attributeTypeMap = {
    author: {
        baseName: "author",
        type: "NotebookAuthor",
    },
    cells: {
        baseName: "cells",
        type: "Array<NotebookCellResponse>",
        required: true,
    },
    created: {
        baseName: "created",
        type: "Date",
        format: "date-time",
    },
    metadata: {
        baseName: "metadata",
        type: "NotebookMetadata",
    },
    modified: {
        baseName: "modified",
        type: "Date",
        format: "date-time",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    status: {
        baseName: "status",
        type: "NotebookStatus",
    },
    time: {
        baseName: "time",
        type: "NotebookGlobalTime",
        required: true,
    },
};
//# sourceMappingURL=NotebookResponseDataAttributes.js.map

/***/ }),

/***/ 17911:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookSplitBy = void 0;
/**
 * Object describing how to split the graph to display multiple visualizations per request.
 */
class NotebookSplitBy {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookSplitBy.attributeTypeMap;
    }
}
exports.NotebookSplitBy = NotebookSplitBy;
/**
 * @ignore
 */
NotebookSplitBy.attributeTypeMap = {
    keys: {
        baseName: "keys",
        type: "Array<string>",
        required: true,
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
        required: true,
    },
};
//# sourceMappingURL=NotebookSplitBy.js.map

/***/ }),

/***/ 38581:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookTimeseriesCellAttributes = void 0;
/**
 * The attributes of a notebook `timeseries` cell.
 */
class NotebookTimeseriesCellAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookTimeseriesCellAttributes.attributeTypeMap;
    }
}
exports.NotebookTimeseriesCellAttributes = NotebookTimeseriesCellAttributes;
/**
 * @ignore
 */
NotebookTimeseriesCellAttributes.attributeTypeMap = {
    definition: {
        baseName: "definition",
        type: "TimeseriesWidgetDefinition",
        required: true,
    },
    graphSize: {
        baseName: "graph_size",
        type: "NotebookGraphSize",
    },
    splitBy: {
        baseName: "split_by",
        type: "NotebookSplitBy",
    },
    time: {
        baseName: "time",
        type: "NotebookCellTime",
    },
};
//# sourceMappingURL=NotebookTimeseriesCellAttributes.js.map

/***/ }),

/***/ 45652:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookToplistCellAttributes = void 0;
/**
 * The attributes of a notebook `toplist` cell.
 */
class NotebookToplistCellAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookToplistCellAttributes.attributeTypeMap;
    }
}
exports.NotebookToplistCellAttributes = NotebookToplistCellAttributes;
/**
 * @ignore
 */
NotebookToplistCellAttributes.attributeTypeMap = {
    definition: {
        baseName: "definition",
        type: "ToplistWidgetDefinition",
        required: true,
    },
    graphSize: {
        baseName: "graph_size",
        type: "NotebookGraphSize",
    },
    splitBy: {
        baseName: "split_by",
        type: "NotebookSplitBy",
    },
    time: {
        baseName: "time",
        type: "NotebookCellTime",
    },
};
//# sourceMappingURL=NotebookToplistCellAttributes.js.map

/***/ }),

/***/ 31500:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookUpdateData = void 0;
/**
 * The data for a notebook update request.
 */
class NotebookUpdateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookUpdateData.attributeTypeMap;
    }
}
exports.NotebookUpdateData = NotebookUpdateData;
/**
 * @ignore
 */
NotebookUpdateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "NotebookUpdateDataAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "NotebookResourceType",
        required: true,
    },
};
//# sourceMappingURL=NotebookUpdateData.js.map

/***/ }),

/***/ 39612:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookUpdateDataAttributes = void 0;
/**
 * The data attributes of a notebook.
 */
class NotebookUpdateDataAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookUpdateDataAttributes.attributeTypeMap;
    }
}
exports.NotebookUpdateDataAttributes = NotebookUpdateDataAttributes;
/**
 * @ignore
 */
NotebookUpdateDataAttributes.attributeTypeMap = {
    cells: {
        baseName: "cells",
        type: "Array<NotebookUpdateCell>",
        required: true,
    },
    metadata: {
        baseName: "metadata",
        type: "NotebookMetadata",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    status: {
        baseName: "status",
        type: "NotebookStatus",
    },
    time: {
        baseName: "time",
        type: "NotebookGlobalTime",
        required: true,
    },
};
//# sourceMappingURL=NotebookUpdateDataAttributes.js.map

/***/ }),

/***/ 57229:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookUpdateRequest = void 0;
/**
 * The description of a notebook update request.
 */
class NotebookUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebookUpdateRequest.attributeTypeMap;
    }
}
exports.NotebookUpdateRequest = NotebookUpdateRequest;
/**
 * @ignore
 */
NotebookUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "NotebookUpdateData",
        required: true,
    },
};
//# sourceMappingURL=NotebookUpdateRequest.js.map

/***/ }),

/***/ 34680:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebooksResponse = void 0;
/**
 * Notebooks get all response.
 */
class NotebooksResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebooksResponse.attributeTypeMap;
    }
}
exports.NotebooksResponse = NotebooksResponse;
/**
 * @ignore
 */
NotebooksResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<NotebooksResponseData>",
    },
    meta: {
        baseName: "meta",
        type: "NotebooksResponseMeta",
    },
};
//# sourceMappingURL=NotebooksResponse.js.map

/***/ }),

/***/ 92333:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebooksResponseData = void 0;
/**
 * The data for a notebook in get all response.
 */
class NotebooksResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebooksResponseData.attributeTypeMap;
    }
}
exports.NotebooksResponseData = NotebooksResponseData;
/**
 * @ignore
 */
NotebooksResponseData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "NotebooksResponseDataAttributes",
        required: true,
    },
    id: {
        baseName: "id",
        type: "number",
        required: true,
        format: "int64",
    },
    type: {
        baseName: "type",
        type: "NotebookResourceType",
        required: true,
    },
};
//# sourceMappingURL=NotebooksResponseData.js.map

/***/ }),

/***/ 67182:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebooksResponseDataAttributes = void 0;
/**
 * The attributes of a notebook in get all response.
 */
class NotebooksResponseDataAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebooksResponseDataAttributes.attributeTypeMap;
    }
}
exports.NotebooksResponseDataAttributes = NotebooksResponseDataAttributes;
/**
 * @ignore
 */
NotebooksResponseDataAttributes.attributeTypeMap = {
    author: {
        baseName: "author",
        type: "NotebookAuthor",
    },
    cells: {
        baseName: "cells",
        type: "Array<NotebookCellResponse>",
    },
    created: {
        baseName: "created",
        type: "Date",
        format: "date-time",
    },
    metadata: {
        baseName: "metadata",
        type: "NotebookMetadata",
    },
    modified: {
        baseName: "modified",
        type: "Date",
        format: "date-time",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    status: {
        baseName: "status",
        type: "NotebookStatus",
    },
    time: {
        baseName: "time",
        type: "NotebookGlobalTime",
    },
};
//# sourceMappingURL=NotebooksResponseDataAttributes.js.map

/***/ }),

/***/ 91514:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebooksResponseMeta = void 0;
/**
 * Searches metadata returned by the API.
 */
class NotebooksResponseMeta {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebooksResponseMeta.attributeTypeMap;
    }
}
exports.NotebooksResponseMeta = NotebooksResponseMeta;
/**
 * @ignore
 */
NotebooksResponseMeta.attributeTypeMap = {
    page: {
        baseName: "page",
        type: "NotebooksResponsePage",
    },
};
//# sourceMappingURL=NotebooksResponseMeta.js.map

/***/ }),

/***/ 29365:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebooksResponsePage = void 0;
/**
 * Pagination metadata returned by the API.
 */
class NotebooksResponsePage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NotebooksResponsePage.attributeTypeMap;
    }
}
exports.NotebooksResponsePage = NotebooksResponsePage;
/**
 * @ignore
 */
NotebooksResponsePage.attributeTypeMap = {
    totalCount: {
        baseName: "total_count",
        type: "number",
        format: "int64",
    },
    totalFilteredCount: {
        baseName: "total_filtered_count",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=NotebooksResponsePage.js.map

/***/ }),

/***/ 52674:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ObjectSerializer = void 0;
const APIErrorResponse_1 = __webpack_require__(94187);
const AWSAccount_1 = __webpack_require__(75107);
const AWSAccountAndLambdaRequest_1 = __webpack_require__(79616);
const AWSAccountCreateResponse_1 = __webpack_require__(205);
const AWSAccountDeleteRequest_1 = __webpack_require__(11338);
const AWSAccountListResponse_1 = __webpack_require__(51224);
const AWSLogsAsyncError_1 = __webpack_require__(62953);
const AWSLogsAsyncResponse_1 = __webpack_require__(87558);
const AWSLogsLambda_1 = __webpack_require__(99754);
const AWSLogsListResponse_1 = __webpack_require__(9120);
const AWSLogsListServicesResponse_1 = __webpack_require__(77474);
const AWSLogsServicesRequest_1 = __webpack_require__(57943);
const AWSTagFilter_1 = __webpack_require__(26166);
const AWSTagFilterCreateRequest_1 = __webpack_require__(8647);
const AWSTagFilterDeleteRequest_1 = __webpack_require__(81212);
const AWSTagFilterListResponse_1 = __webpack_require__(28788);
const AddSignalToIncidentRequest_1 = __webpack_require__(53778);
const AlertGraphWidgetDefinition_1 = __webpack_require__(30928);
const AlertValueWidgetDefinition_1 = __webpack_require__(35622);
const ApiKey_1 = __webpack_require__(4583);
const ApiKeyListResponse_1 = __webpack_require__(7164);
const ApiKeyResponse_1 = __webpack_require__(82196);
const ApmStatsQueryColumnType_1 = __webpack_require__(17056);
const ApmStatsQueryDefinition_1 = __webpack_require__(61753);
const ApplicationKey_1 = __webpack_require__(12260);
const ApplicationKeyListResponse_1 = __webpack_require__(524);
const ApplicationKeyResponse_1 = __webpack_require__(53730);
const AuthenticationValidationResponse_1 = __webpack_require__(11965);
const AzureAccount_1 = __webpack_require__(99096);
const CancelDowntimesByScopeRequest_1 = __webpack_require__(30337);
const CanceledDowntimesIds_1 = __webpack_require__(49157);
const ChangeWidgetDefinition_1 = __webpack_require__(59016);
const ChangeWidgetRequest_1 = __webpack_require__(71103);
const CheckCanDeleteMonitorResponse_1 = __webpack_require__(55696);
const CheckCanDeleteMonitorResponseData_1 = __webpack_require__(8779);
const CheckCanDeleteSLOResponse_1 = __webpack_require__(37497);
const CheckCanDeleteSLOResponseData_1 = __webpack_require__(45281);
const CheckStatusWidgetDefinition_1 = __webpack_require__(92980);
const Creator_1 = __webpack_require__(84519);
const Dashboard_1 = __webpack_require__(63114);
const DashboardBulkActionData_1 = __webpack_require__(66634);
const DashboardBulkDeleteRequest_1 = __webpack_require__(14689);
const DashboardDeleteResponse_1 = __webpack_require__(22899);
const DashboardList_1 = __webpack_require__(37165);
const DashboardListDeleteResponse_1 = __webpack_require__(40167);
const DashboardListListResponse_1 = __webpack_require__(18934);
const DashboardRestoreRequest_1 = __webpack_require__(15827);
const DashboardSummary_1 = __webpack_require__(71472);
const DashboardSummaryDefinition_1 = __webpack_require__(45087);
const DashboardTemplateVariable_1 = __webpack_require__(99326);
const DashboardTemplateVariablePreset_1 = __webpack_require__(37874);
const DashboardTemplateVariablePresetValue_1 = __webpack_require__(7037);
const DeletedMonitor_1 = __webpack_require__(4711);
const DistributionPointsPayload_1 = __webpack_require__(5990);
const DistributionPointsSeries_1 = __webpack_require__(2963);
const DistributionWidgetDefinition_1 = __webpack_require__(88954);
const DistributionWidgetRequest_1 = __webpack_require__(54139);
const DistributionWidgetXAxis_1 = __webpack_require__(59792);
const DistributionWidgetYAxis_1 = __webpack_require__(53869);
const Downtime_1 = __webpack_require__(66345);
const DowntimeChild_1 = __webpack_require__(36940);
const DowntimeRecurrence_1 = __webpack_require__(10878);
const Event_1 = __webpack_require__(68426);
const EventCreateRequest_1 = __webpack_require__(98964);
const EventCreateResponse_1 = __webpack_require__(15571);
const EventListResponse_1 = __webpack_require__(64758);
const EventQueryDefinition_1 = __webpack_require__(86630);
const EventResponse_1 = __webpack_require__(57097);
const EventStreamWidgetDefinition_1 = __webpack_require__(41446);
const EventTimelineWidgetDefinition_1 = __webpack_require__(5387);
const FormulaAndFunctionApmDependencyStatsQueryDefinition_1 = __webpack_require__(86280);
const FormulaAndFunctionApmResourceStatsQueryDefinition_1 = __webpack_require__(38483);
const FormulaAndFunctionEventQueryDefinition_1 = __webpack_require__(922);
const FormulaAndFunctionEventQueryDefinitionCompute_1 = __webpack_require__(23526);
const FormulaAndFunctionEventQueryDefinitionSearch_1 = __webpack_require__(35781);
const FormulaAndFunctionEventQueryGroupBy_1 = __webpack_require__(40218);
const FormulaAndFunctionEventQueryGroupBySort_1 = __webpack_require__(66766);
const FormulaAndFunctionMetricQueryDefinition_1 = __webpack_require__(61311);
const FormulaAndFunctionProcessQueryDefinition_1 = __webpack_require__(57572);
const FreeTextWidgetDefinition_1 = __webpack_require__(3026);
const FunnelQuery_1 = __webpack_require__(87832);
const FunnelStep_1 = __webpack_require__(15073);
const FunnelWidgetDefinition_1 = __webpack_require__(20000);
const FunnelWidgetRequest_1 = __webpack_require__(75402);
const GCPAccount_1 = __webpack_require__(78369);
const GeomapWidgetDefinition_1 = __webpack_require__(919);
const GeomapWidgetDefinitionStyle_1 = __webpack_require__(42280);
const GeomapWidgetDefinitionView_1 = __webpack_require__(92237);
const GeomapWidgetRequest_1 = __webpack_require__(47862);
const GraphSnapshot_1 = __webpack_require__(13325);
const GroupWidgetDefinition_1 = __webpack_require__(82330);
const HTTPLogError_1 = __webpack_require__(81263);
const HTTPLogItem_1 = __webpack_require__(19674);
const HeatMapWidgetDefinition_1 = __webpack_require__(84622);
const HeatMapWidgetRequest_1 = __webpack_require__(82293);
const Host_1 = __webpack_require__(49556);
const HostListResponse_1 = __webpack_require__(16915);
const HostMapRequest_1 = __webpack_require__(25910);
const HostMapWidgetDefinition_1 = __webpack_require__(59477);
const HostMapWidgetDefinitionRequests_1 = __webpack_require__(80831);
const HostMapWidgetDefinitionStyle_1 = __webpack_require__(42370);
const HostMeta_1 = __webpack_require__(48137);
const HostMetaInstallMethod_1 = __webpack_require__(33508);
const HostMetrics_1 = __webpack_require__(70176);
const HostMuteResponse_1 = __webpack_require__(43814);
const HostMuteSettings_1 = __webpack_require__(52003);
const HostTags_1 = __webpack_require__(14891);
const HostTotals_1 = __webpack_require__(78002);
const HourlyUsageAttributionBody_1 = __webpack_require__(60079);
const HourlyUsageAttributionMetadata_1 = __webpack_require__(46590);
const HourlyUsageAttributionPagination_1 = __webpack_require__(73798);
const HourlyUsageAttributionResponse_1 = __webpack_require__(81641);
const IFrameWidgetDefinition_1 = __webpack_require__(26242);
const IPPrefixesAPI_1 = __webpack_require__(9737);
const IPPrefixesAPM_1 = __webpack_require__(51806);
const IPPrefixesAgents_1 = __webpack_require__(15536);
const IPPrefixesLogs_1 = __webpack_require__(50334);
const IPPrefixesProcess_1 = __webpack_require__(16605);
const IPPrefixesSynthetics_1 = __webpack_require__(31933);
const IPPrefixesSyntheticsPrivateLocations_1 = __webpack_require__(29817);
const IPPrefixesWebhooks_1 = __webpack_require__(61031);
const IPRanges_1 = __webpack_require__(28956);
const IdpFormData_1 = __webpack_require__(43719);
const IdpResponse_1 = __webpack_require__(91992);
const ImageWidgetDefinition_1 = __webpack_require__(86051);
const IntakePayloadAccepted_1 = __webpack_require__(71328);
const ListStreamColumn_1 = __webpack_require__(91106);
const ListStreamComputeItems_1 = __webpack_require__(63069);
const ListStreamGroupByItems_1 = __webpack_require__(6326);
const ListStreamQuery_1 = __webpack_require__(44439);
const ListStreamWidgetDefinition_1 = __webpack_require__(49497);
const ListStreamWidgetRequest_1 = __webpack_require__(80951);
const Log_1 = __webpack_require__(83438);
const LogContent_1 = __webpack_require__(67704);
const LogQueryDefinition_1 = __webpack_require__(12197);
const LogQueryDefinitionGroupBy_1 = __webpack_require__(54246);
const LogQueryDefinitionGroupBySort_1 = __webpack_require__(37827);
const LogQueryDefinitionSearch_1 = __webpack_require__(20235);
const LogStreamWidgetDefinition_1 = __webpack_require__(76959);
const LogsAPIError_1 = __webpack_require__(27806);
const LogsAPIErrorResponse_1 = __webpack_require__(25074);
const LogsArithmeticProcessor_1 = __webpack_require__(15426);
const LogsAttributeRemapper_1 = __webpack_require__(70365);
const LogsByRetention_1 = __webpack_require__(97769);
const LogsByRetentionMonthlyUsage_1 = __webpack_require__(96594);
const LogsByRetentionOrgUsage_1 = __webpack_require__(79667);
const LogsByRetentionOrgs_1 = __webpack_require__(45185);
const LogsCategoryProcessor_1 = __webpack_require__(40573);
const LogsCategoryProcessorCategory_1 = __webpack_require__(10242);
const LogsDateRemapper_1 = __webpack_require__(34468);
const LogsExclusion_1 = __webpack_require__(78203);
const LogsExclusionFilter_1 = __webpack_require__(73573);
const LogsFilter_1 = __webpack_require__(96533);
const LogsGeoIPParser_1 = __webpack_require__(30810);
const LogsGrokParser_1 = __webpack_require__(86255);
const LogsGrokParserRules_1 = __webpack_require__(17200);
const LogsIndex_1 = __webpack_require__(67826);
const LogsIndexListResponse_1 = __webpack_require__(32099);
const LogsIndexUpdateRequest_1 = __webpack_require__(60006);
const LogsIndexesOrder_1 = __webpack_require__(10785);
const LogsListRequest_1 = __webpack_require__(98514);
const LogsListRequestTime_1 = __webpack_require__(21905);
const LogsListResponse_1 = __webpack_require__(49469);
const LogsLookupProcessor_1 = __webpack_require__(36335);
const LogsMessageRemapper_1 = __webpack_require__(1148);
const LogsPipeline_1 = __webpack_require__(62446);
const LogsPipelineProcessor_1 = __webpack_require__(93445);
const LogsPipelinesOrder_1 = __webpack_require__(53880);
const LogsQueryCompute_1 = __webpack_require__(6239);
const LogsRetentionAggSumUsage_1 = __webpack_require__(59107);
const LogsRetentionSumUsage_1 = __webpack_require__(93863);
const LogsServiceRemapper_1 = __webpack_require__(73178);
const LogsStatusRemapper_1 = __webpack_require__(6206);
const LogsStringBuilderProcessor_1 = __webpack_require__(54184);
const LogsTraceRemapper_1 = __webpack_require__(69922);
const LogsURLParser_1 = __webpack_require__(16650);
const LogsUserAgentParser_1 = __webpack_require__(62792);
const MetricMetadata_1 = __webpack_require__(91082);
const MetricSearchResponse_1 = __webpack_require__(5629);
const MetricSearchResponseResults_1 = __webpack_require__(32036);
const MetricsListResponse_1 = __webpack_require__(36562);
const MetricsPayload_1 = __webpack_require__(18312);
const MetricsQueryMetadata_1 = __webpack_require__(94266);
const MetricsQueryResponse_1 = __webpack_require__(10574);
const MetricsQueryUnit_1 = __webpack_require__(54581);
const Monitor_1 = __webpack_require__(45685);
const MonitorFormulaAndFunctionEventQueryDefinition_1 = __webpack_require__(58983);
const MonitorFormulaAndFunctionEventQueryDefinitionCompute_1 = __webpack_require__(18547);
const MonitorFormulaAndFunctionEventQueryDefinitionSearch_1 = __webpack_require__(22864);
const MonitorFormulaAndFunctionEventQueryGroupBy_1 = __webpack_require__(23168);
const MonitorFormulaAndFunctionEventQueryGroupBySort_1 = __webpack_require__(45798);
const MonitorGroupSearchResponse_1 = __webpack_require__(25941);
const MonitorGroupSearchResponseCounts_1 = __webpack_require__(6527);
const MonitorGroupSearchResult_1 = __webpack_require__(55041);
const MonitorOptions_1 = __webpack_require__(48231);
const MonitorOptionsAggregation_1 = __webpack_require__(48316);
const MonitorOptionsSchedulingOptions_1 = __webpack_require__(55782);
const MonitorOptionsSchedulingOptionsEvaluationWindow_1 = __webpack_require__(1362);
const MonitorSearchCountItem_1 = __webpack_require__(31944);
const MonitorSearchResponse_1 = __webpack_require__(40893);
const MonitorSearchResponseCounts_1 = __webpack_require__(80198);
const MonitorSearchResponseMetadata_1 = __webpack_require__(78696);
const MonitorSearchResult_1 = __webpack_require__(14120);
const MonitorSearchResultNotification_1 = __webpack_require__(17402);
const MonitorState_1 = __webpack_require__(27789);
const MonitorStateGroup_1 = __webpack_require__(68737);
const MonitorSummaryWidgetDefinition_1 = __webpack_require__(22788);
const MonitorThresholdWindowOptions_1 = __webpack_require__(12780);
const MonitorThresholds_1 = __webpack_require__(28522);
const MonitorUpdateRequest_1 = __webpack_require__(77039);
const MonthlyUsageAttributionBody_1 = __webpack_require__(22537);
const MonthlyUsageAttributionMetadata_1 = __webpack_require__(25116);
const MonthlyUsageAttributionPagination_1 = __webpack_require__(73712);
const MonthlyUsageAttributionResponse_1 = __webpack_require__(95112);
const MonthlyUsageAttributionValues_1 = __webpack_require__(80336);
const NoteWidgetDefinition_1 = __webpack_require__(35355);
const NotebookAbsoluteTime_1 = __webpack_require__(65962);
const NotebookAuthor_1 = __webpack_require__(90658);
const NotebookCellCreateRequest_1 = __webpack_require__(62235);
const NotebookCellResponse_1 = __webpack_require__(84386);
const NotebookCellUpdateRequest_1 = __webpack_require__(99902);
const NotebookCreateData_1 = __webpack_require__(42541);
const NotebookCreateDataAttributes_1 = __webpack_require__(52931);
const NotebookCreateRequest_1 = __webpack_require__(82520);
const NotebookDistributionCellAttributes_1 = __webpack_require__(87594);
const NotebookHeatMapCellAttributes_1 = __webpack_require__(81974);
const NotebookLogStreamCellAttributes_1 = __webpack_require__(60761);
const NotebookMarkdownCellAttributes_1 = __webpack_require__(3567);
const NotebookMarkdownCellDefinition_1 = __webpack_require__(12035);
const NotebookMetadata_1 = __webpack_require__(34078);
const NotebookRelativeTime_1 = __webpack_require__(94586);
const NotebookResponse_1 = __webpack_require__(43296);
const NotebookResponseData_1 = __webpack_require__(59227);
const NotebookResponseDataAttributes_1 = __webpack_require__(59433);
const NotebookSplitBy_1 = __webpack_require__(17911);
const NotebookTimeseriesCellAttributes_1 = __webpack_require__(38581);
const NotebookToplistCellAttributes_1 = __webpack_require__(45652);
const NotebookUpdateData_1 = __webpack_require__(31500);
const NotebookUpdateDataAttributes_1 = __webpack_require__(39612);
const NotebookUpdateRequest_1 = __webpack_require__(57229);
const NotebooksResponse_1 = __webpack_require__(34680);
const NotebooksResponseData_1 = __webpack_require__(92333);
const NotebooksResponseDataAttributes_1 = __webpack_require__(67182);
const NotebooksResponseMeta_1 = __webpack_require__(91514);
const NotebooksResponsePage_1 = __webpack_require__(29365);
const OrgDowngradedResponse_1 = __webpack_require__(15364);
const Organization_1 = __webpack_require__(5080);
const OrganizationBilling_1 = __webpack_require__(89008);
const OrganizationCreateBody_1 = __webpack_require__(16132);
const OrganizationCreateResponse_1 = __webpack_require__(24007);
const OrganizationListResponse_1 = __webpack_require__(67823);
const OrganizationResponse_1 = __webpack_require__(58106);
const OrganizationSettings_1 = __webpack_require__(49434);
const OrganizationSettingsSaml_1 = __webpack_require__(23808);
const OrganizationSettingsSamlAutocreateUsersDomains_1 = __webpack_require__(83448);
const OrganizationSettingsSamlIdpInitiatedLogin_1 = __webpack_require__(79957);
const OrganizationSettingsSamlStrictMode_1 = __webpack_require__(21101);
const OrganizationSubscription_1 = __webpack_require__(75122);
const PagerDutyService_1 = __webpack_require__(99433);
const PagerDutyServiceKey_1 = __webpack_require__(32766);
const PagerDutyServiceName_1 = __webpack_require__(44198);
const Pagination_1 = __webpack_require__(97834);
const ProcessQueryDefinition_1 = __webpack_require__(96386);
const QueryValueWidgetDefinition_1 = __webpack_require__(78268);
const QueryValueWidgetRequest_1 = __webpack_require__(10384);
const ReferenceTableLogsLookupProcessor_1 = __webpack_require__(31537);
const ResponseMetaAttributes_1 = __webpack_require__(44993);
const RunWorkflowWidgetDefinition_1 = __webpack_require__(66209);
const RunWorkflowWidgetInput_1 = __webpack_require__(71677);
const SLOBulkDeleteError_1 = __webpack_require__(6307);
const SLOBulkDeleteResponse_1 = __webpack_require__(53119);
const SLOBulkDeleteResponseData_1 = __webpack_require__(28093);
const SLOCorrection_1 = __webpack_require__(2852);
const SLOCorrectionCreateData_1 = __webpack_require__(43215);
const SLOCorrectionCreateRequest_1 = __webpack_require__(87152);
const SLOCorrectionCreateRequestAttributes_1 = __webpack_require__(26204);
const SLOCorrectionListResponse_1 = __webpack_require__(12062);
const SLOCorrectionResponse_1 = __webpack_require__(26986);
const SLOCorrectionResponseAttributes_1 = __webpack_require__(35052);
const SLOCorrectionResponseAttributesModifier_1 = __webpack_require__(88857);
const SLOCorrectionUpdateData_1 = __webpack_require__(99745);
const SLOCorrectionUpdateRequest_1 = __webpack_require__(77273);
const SLOCorrectionUpdateRequestAttributes_1 = __webpack_require__(75164);
const SLOCreator_1 = __webpack_require__(52294);
const SLODeleteResponse_1 = __webpack_require__(47941);
const SLOHistoryMetrics_1 = __webpack_require__(55029);
const SLOHistoryMetricsSeries_1 = __webpack_require__(96132);
const SLOHistoryMetricsSeriesMetadata_1 = __webpack_require__(83288);
const SLOHistoryMetricsSeriesMetadataUnit_1 = __webpack_require__(67323);
const SLOHistoryMonitor_1 = __webpack_require__(62797);
const SLOHistoryResponse_1 = __webpack_require__(27297);
const SLOHistoryResponseData_1 = __webpack_require__(81357);
const SLOHistoryResponseError_1 = __webpack_require__(30144);
const SLOHistoryResponseErrorWithType_1 = __webpack_require__(58524);
const SLOHistorySLIData_1 = __webpack_require__(6636);
const SLOListResponse_1 = __webpack_require__(19477);
const SLOListResponseMetadata_1 = __webpack_require__(95727);
const SLOListResponseMetadataPage_1 = __webpack_require__(559);
const SLOListWidgetDefinition_1 = __webpack_require__(87733);
const SLOListWidgetQuery_1 = __webpack_require__(77106);
const SLOListWidgetRequest_1 = __webpack_require__(74176);
const SLOOverallStatuses_1 = __webpack_require__(4058);
const SLORawErrorBudgetRemaining_1 = __webpack_require__(22565);
const SLOResponse_1 = __webpack_require__(58530);
const SLOResponseData_1 = __webpack_require__(98608);
const SLOThreshold_1 = __webpack_require__(96548);
const SLOWidgetDefinition_1 = __webpack_require__(32026);
const ScatterPlotRequest_1 = __webpack_require__(90691);
const ScatterPlotWidgetDefinition_1 = __webpack_require__(85820);
const ScatterPlotWidgetDefinitionRequests_1 = __webpack_require__(6095);
const ScatterplotTableRequest_1 = __webpack_require__(95803);
const ScatterplotWidgetFormula_1 = __webpack_require__(36910);
const SearchSLOQuery_1 = __webpack_require__(16851);
const SearchSLOResponse_1 = __webpack_require__(79978);
const SearchSLOResponseData_1 = __webpack_require__(64161);
const SearchSLOResponseDataAttributes_1 = __webpack_require__(17459);
const SearchSLOResponseDataAttributesFacets_1 = __webpack_require__(70209);
const SearchSLOResponseDataAttributesFacetsObjectInt_1 = __webpack_require__(58199);
const SearchSLOResponseDataAttributesFacetsObjectString_1 = __webpack_require__(67630);
const SearchSLOResponseLinks_1 = __webpack_require__(21812);
const SearchSLOResponseMeta_1 = __webpack_require__(15832);
const SearchSLOResponseMetaPage_1 = __webpack_require__(98664);
const SearchSLOThreshold_1 = __webpack_require__(23463);
const SearchServiceLevelObjective_1 = __webpack_require__(76963);
const SearchServiceLevelObjectiveAttributes_1 = __webpack_require__(21615);
const SearchServiceLevelObjectiveData_1 = __webpack_require__(31007);
const Series_1 = __webpack_require__(47757);
const ServiceCheck_1 = __webpack_require__(87544);
const ServiceLevelObjective_1 = __webpack_require__(43228);
const ServiceLevelObjectiveQuery_1 = __webpack_require__(72178);
const ServiceLevelObjectiveRequest_1 = __webpack_require__(20112);
const ServiceMapWidgetDefinition_1 = __webpack_require__(96744);
const ServiceSummaryWidgetDefinition_1 = __webpack_require__(15351);
const SignalAssigneeUpdateRequest_1 = __webpack_require__(5609);
const SignalStateUpdateRequest_1 = __webpack_require__(6223);
const SlackIntegrationChannel_1 = __webpack_require__(96032);
const SlackIntegrationChannelDisplay_1 = __webpack_require__(7456);
const SuccessfulSignalUpdateResponse_1 = __webpack_require__(80928);
const SunburstWidgetDefinition_1 = __webpack_require__(20775);
const SunburstWidgetLegendInlineAutomatic_1 = __webpack_require__(1527);
const SunburstWidgetLegendTable_1 = __webpack_require__(42284);
const SunburstWidgetRequest_1 = __webpack_require__(60511);
const SyntheticsAPIStep_1 = __webpack_require__(4175);
const SyntheticsAPITest_1 = __webpack_require__(3433);
const SyntheticsAPITestConfig_1 = __webpack_require__(60634);
const SyntheticsAPITestResultData_1 = __webpack_require__(21132);
const SyntheticsAPITestResultFull_1 = __webpack_require__(92111);
const SyntheticsAPITestResultFullCheck_1 = __webpack_require__(81032);
const SyntheticsAPITestResultShort_1 = __webpack_require__(2048);
const SyntheticsAPITestResultShortResult_1 = __webpack_require__(85380);
const SyntheticsApiTestResultFailure_1 = __webpack_require__(42098);
const SyntheticsAssertionJSONPathTarget_1 = __webpack_require__(14493);
const SyntheticsAssertionJSONPathTargetTarget_1 = __webpack_require__(46885);
const SyntheticsAssertionTarget_1 = __webpack_require__(11801);
const SyntheticsAssertionXPathTarget_1 = __webpack_require__(77700);
const SyntheticsAssertionXPathTargetTarget_1 = __webpack_require__(55117);
const SyntheticsBasicAuthDigest_1 = __webpack_require__(18046);
const SyntheticsBasicAuthNTLM_1 = __webpack_require__(82481);
const SyntheticsBasicAuthOauthClient_1 = __webpack_require__(15718);
const SyntheticsBasicAuthOauthROP_1 = __webpack_require__(3887);
const SyntheticsBasicAuthSigv4_1 = __webpack_require__(30084);
const SyntheticsBasicAuthWeb_1 = __webpack_require__(82117);
const SyntheticsBatchDetails_1 = __webpack_require__(82598);
const SyntheticsBatchDetailsData_1 = __webpack_require__(47215);
const SyntheticsBatchResult_1 = __webpack_require__(8974);
const SyntheticsBrowserError_1 = __webpack_require__(7593);
const SyntheticsBrowserTest_1 = __webpack_require__(44771);
const SyntheticsBrowserTestConfig_1 = __webpack_require__(73455);
const SyntheticsBrowserTestResultData_1 = __webpack_require__(9337);
const SyntheticsBrowserTestResultFailure_1 = __webpack_require__(80686);
const SyntheticsBrowserTestResultFull_1 = __webpack_require__(88630);
const SyntheticsBrowserTestResultFullCheck_1 = __webpack_require__(32340);
const SyntheticsBrowserTestResultShort_1 = __webpack_require__(2904);
const SyntheticsBrowserTestResultShortResult_1 = __webpack_require__(58505);
const SyntheticsBrowserTestRumSettings_1 = __webpack_require__(42556);
const SyntheticsBrowserVariable_1 = __webpack_require__(35642);
const SyntheticsCIBatchMetadata_1 = __webpack_require__(12212);
const SyntheticsCIBatchMetadataCI_1 = __webpack_require__(20102);
const SyntheticsCIBatchMetadataGit_1 = __webpack_require__(72392);
const SyntheticsCIBatchMetadataPipeline_1 = __webpack_require__(31619);
const SyntheticsCIBatchMetadataProvider_1 = __webpack_require__(75363);
const SyntheticsCITest_1 = __webpack_require__(56409);
const SyntheticsCITestBody_1 = __webpack_require__(32615);
const SyntheticsConfigVariable_1 = __webpack_require__(24023);
const SyntheticsCoreWebVitals_1 = __webpack_require__(67701);
const SyntheticsDeleteTestsPayload_1 = __webpack_require__(60972);
const SyntheticsDeleteTestsResponse_1 = __webpack_require__(80634);
const SyntheticsDeletedTest_1 = __webpack_require__(7885);
const SyntheticsDevice_1 = __webpack_require__(6906);
const SyntheticsGetAPITestLatestResultsResponse_1 = __webpack_require__(42609);
const SyntheticsGetBrowserTestLatestResultsResponse_1 = __webpack_require__(73873);
const SyntheticsGlobalVariable_1 = __webpack_require__(10404);
const SyntheticsGlobalVariableAttributes_1 = __webpack_require__(2156);
const SyntheticsGlobalVariableOptions_1 = __webpack_require__(41521);
const SyntheticsGlobalVariableParseTestOptions_1 = __webpack_require__(60172);
const SyntheticsGlobalVariableTOTPParameters_1 = __webpack_require__(6429);
const SyntheticsGlobalVariableValue_1 = __webpack_require__(50263);
const SyntheticsListGlobalVariablesResponse_1 = __webpack_require__(51341);
const SyntheticsListTestsResponse_1 = __webpack_require__(46280);
const SyntheticsLocation_1 = __webpack_require__(36515);
const SyntheticsLocations_1 = __webpack_require__(9091);
const SyntheticsParsingOptions_1 = __webpack_require__(5015);
const SyntheticsPrivateLocation_1 = __webpack_require__(6991);
const SyntheticsPrivateLocationCreationResponse_1 = __webpack_require__(31386);
const SyntheticsPrivateLocationCreationResponseResultEncryption_1 = __webpack_require__(16331);
const SyntheticsPrivateLocationMetadata_1 = __webpack_require__(89160);
const SyntheticsPrivateLocationSecrets_1 = __webpack_require__(91325);
const SyntheticsPrivateLocationSecretsAuthentication_1 = __webpack_require__(26886);
const SyntheticsPrivateLocationSecretsConfigDecryption_1 = __webpack_require__(24829);
const SyntheticsSSLCertificate_1 = __webpack_require__(24211);
const SyntheticsSSLCertificateIssuer_1 = __webpack_require__(70007);
const SyntheticsSSLCertificateSubject_1 = __webpack_require__(75798);
const SyntheticsStep_1 = __webpack_require__(96180);
const SyntheticsStepDetail_1 = __webpack_require__(86493);
const SyntheticsStepDetailWarning_1 = __webpack_require__(86754);
const SyntheticsTestCiOptions_1 = __webpack_require__(38758);
const SyntheticsTestConfig_1 = __webpack_require__(91535);
const SyntheticsTestDetails_1 = __webpack_require__(22701);
const SyntheticsTestOptions_1 = __webpack_require__(55515);
const SyntheticsTestOptionsMonitorOptions_1 = __webpack_require__(37717);
const SyntheticsTestOptionsRetry_1 = __webpack_require__(76723);
const SyntheticsTestOptionsScheduling_1 = __webpack_require__(24636);
const SyntheticsTestOptionsSchedulingTimeframe_1 = __webpack_require__(15344);
const SyntheticsTestRequest_1 = __webpack_require__(7105);
const SyntheticsTestRequestCertificate_1 = __webpack_require__(86420);
const SyntheticsTestRequestCertificateItem_1 = __webpack_require__(77558);
const SyntheticsTestRequestProxy_1 = __webpack_require__(57736);
const SyntheticsTiming_1 = __webpack_require__(30782);
const SyntheticsTriggerBody_1 = __webpack_require__(20524);
const SyntheticsTriggerCITestLocation_1 = __webpack_require__(88420);
const SyntheticsTriggerCITestRunResult_1 = __webpack_require__(63605);
const SyntheticsTriggerCITestsResponse_1 = __webpack_require__(35779);
const SyntheticsTriggerTest_1 = __webpack_require__(24099);
const SyntheticsUpdateTestPauseStatusPayload_1 = __webpack_require__(41655);
const SyntheticsVariableParser_1 = __webpack_require__(74500);
const TableWidgetDefinition_1 = __webpack_require__(17750);
const TableWidgetRequest_1 = __webpack_require__(24403);
const TagToHosts_1 = __webpack_require__(94643);
const TimeseriesBackground_1 = __webpack_require__(87235);
const TimeseriesWidgetDefinition_1 = __webpack_require__(50074);
const TimeseriesWidgetExpressionAlias_1 = __webpack_require__(91672);
const TimeseriesWidgetRequest_1 = __webpack_require__(10800);
const ToplistWidgetDefinition_1 = __webpack_require__(61970);
const ToplistWidgetRequest_1 = __webpack_require__(89181);
const TopologyMapWidgetDefinition_1 = __webpack_require__(3185);
const TopologyQuery_1 = __webpack_require__(8641);
const TopologyRequest_1 = __webpack_require__(71327);
const TreeMapWidgetDefinition_1 = __webpack_require__(84230);
const TreeMapWidgetRequest_1 = __webpack_require__(32930);
const UsageAnalyzedLogsHour_1 = __webpack_require__(46989);
const UsageAnalyzedLogsResponse_1 = __webpack_require__(18830);
const UsageAttributionAggregatesBody_1 = __webpack_require__(17881);
const UsageAttributionBody_1 = __webpack_require__(15656);
const UsageAttributionMetadata_1 = __webpack_require__(93350);
const UsageAttributionPagination_1 = __webpack_require__(72584);
const UsageAttributionResponse_1 = __webpack_require__(45011);
const UsageAttributionValues_1 = __webpack_require__(61746);
const UsageAuditLogsHour_1 = __webpack_require__(59268);
const UsageAuditLogsResponse_1 = __webpack_require__(89238);
const UsageBillableSummaryBody_1 = __webpack_require__(17329);
const UsageBillableSummaryHour_1 = __webpack_require__(52813);
const UsageBillableSummaryKeys_1 = __webpack_require__(35118);
const UsageBillableSummaryResponse_1 = __webpack_require__(84619);
const UsageCIVisibilityHour_1 = __webpack_require__(41653);
const UsageCIVisibilityResponse_1 = __webpack_require__(55005);
const UsageCWSHour_1 = __webpack_require__(18482);
const UsageCWSResponse_1 = __webpack_require__(22674);
const UsageCloudSecurityPostureManagementHour_1 = __webpack_require__(75358);
const UsageCloudSecurityPostureManagementResponse_1 = __webpack_require__(87374);
const UsageCustomReportsAttributes_1 = __webpack_require__(47558);
const UsageCustomReportsData_1 = __webpack_require__(88385);
const UsageCustomReportsMeta_1 = __webpack_require__(63185);
const UsageCustomReportsPage_1 = __webpack_require__(54974);
const UsageCustomReportsResponse_1 = __webpack_require__(55902);
const UsageDBMHour_1 = __webpack_require__(68808);
const UsageDBMResponse_1 = __webpack_require__(2026);
const UsageFargateHour_1 = __webpack_require__(57386);
const UsageFargateResponse_1 = __webpack_require__(48053);
const UsageHostHour_1 = __webpack_require__(22603);
const UsageHostsResponse_1 = __webpack_require__(31325);
const UsageIncidentManagementHour_1 = __webpack_require__(40048);
const UsageIncidentManagementResponse_1 = __webpack_require__(98434);
const UsageIndexedSpansHour_1 = __webpack_require__(66099);
const UsageIndexedSpansResponse_1 = __webpack_require__(7275);
const UsageIngestedSpansHour_1 = __webpack_require__(72078);
const UsageIngestedSpansResponse_1 = __webpack_require__(52819);
const UsageIoTHour_1 = __webpack_require__(45137);
const UsageIoTResponse_1 = __webpack_require__(73096);
const UsageLambdaHour_1 = __webpack_require__(97435);
const UsageLambdaResponse_1 = __webpack_require__(95231);
const UsageLogsByIndexHour_1 = __webpack_require__(48710);
const UsageLogsByIndexResponse_1 = __webpack_require__(18950);
const UsageLogsByRetentionHour_1 = __webpack_require__(51648);
const UsageLogsByRetentionResponse_1 = __webpack_require__(62783);
const UsageLogsHour_1 = __webpack_require__(52600);
const UsageLogsResponse_1 = __webpack_require__(1375);
const UsageNetworkFlowsHour_1 = __webpack_require__(97327);
const UsageNetworkFlowsResponse_1 = __webpack_require__(66234);
const UsageNetworkHostsHour_1 = __webpack_require__(5620);
const UsageNetworkHostsResponse_1 = __webpack_require__(4994);
const UsageOnlineArchiveHour_1 = __webpack_require__(22627);
const UsageOnlineArchiveResponse_1 = __webpack_require__(17926);
const UsageProfilingHour_1 = __webpack_require__(66510);
const UsageProfilingResponse_1 = __webpack_require__(82060);
const UsageRumSessionsHour_1 = __webpack_require__(105);
const UsageRumSessionsResponse_1 = __webpack_require__(6633);
const UsageRumUnitsHour_1 = __webpack_require__(8936);
const UsageRumUnitsResponse_1 = __webpack_require__(537);
const UsageSDSHour_1 = __webpack_require__(40876);
const UsageSDSResponse_1 = __webpack_require__(96687);
const UsageSNMPHour_1 = __webpack_require__(39577);
const UsageSNMPResponse_1 = __webpack_require__(82210);
const UsageSpecifiedCustomReportsAttributes_1 = __webpack_require__(38724);
const UsageSpecifiedCustomReportsData_1 = __webpack_require__(47586);
const UsageSpecifiedCustomReportsMeta_1 = __webpack_require__(75435);
const UsageSpecifiedCustomReportsPage_1 = __webpack_require__(60544);
const UsageSpecifiedCustomReportsResponse_1 = __webpack_require__(47226);
const UsageSummaryDate_1 = __webpack_require__(72971);
const UsageSummaryDateOrg_1 = __webpack_require__(31308);
const UsageSummaryResponse_1 = __webpack_require__(61378);
const UsageSyntheticsAPIHour_1 = __webpack_require__(80931);
const UsageSyntheticsAPIResponse_1 = __webpack_require__(36143);
const UsageSyntheticsBrowserHour_1 = __webpack_require__(68362);
const UsageSyntheticsBrowserResponse_1 = __webpack_require__(95322);
const UsageSyntheticsHour_1 = __webpack_require__(60809);
const UsageSyntheticsResponse_1 = __webpack_require__(46862);
const UsageTimeseriesHour_1 = __webpack_require__(4062);
const UsageTimeseriesResponse_1 = __webpack_require__(2516);
const UsageTopAvgMetricsHour_1 = __webpack_require__(62000);
const UsageTopAvgMetricsMetadata_1 = __webpack_require__(57758);
const UsageTopAvgMetricsPagination_1 = __webpack_require__(69015);
const UsageTopAvgMetricsResponse_1 = __webpack_require__(5587);
const User_1 = __webpack_require__(65582);
const UserDisableResponse_1 = __webpack_require__(97395);
const UserListResponse_1 = __webpack_require__(56284);
const UserResponse_1 = __webpack_require__(73865);
const WebhooksIntegration_1 = __webpack_require__(54773);
const WebhooksIntegrationCustomVariable_1 = __webpack_require__(67832);
const WebhooksIntegrationCustomVariableResponse_1 = __webpack_require__(25545);
const WebhooksIntegrationCustomVariableUpdateRequest_1 = __webpack_require__(66363);
const WebhooksIntegrationUpdateRequest_1 = __webpack_require__(86321);
const Widget_1 = __webpack_require__(6000);
const WidgetAxis_1 = __webpack_require__(36356);
const WidgetConditionalFormat_1 = __webpack_require__(68824);
const WidgetCustomLink_1 = __webpack_require__(83892);
const WidgetEvent_1 = __webpack_require__(27093);
const WidgetFieldSort_1 = __webpack_require__(95452);
const WidgetFormula_1 = __webpack_require__(96398);
const WidgetFormulaLimit_1 = __webpack_require__(16658);
const WidgetFormulaStyle_1 = __webpack_require__(39089);
const WidgetLayout_1 = __webpack_require__(29557);
const WidgetMarker_1 = __webpack_require__(35484);
const WidgetRequestStyle_1 = __webpack_require__(87457);
const WidgetStyle_1 = __webpack_require__(49795);
const WidgetTime_1 = __webpack_require__(39079);
const util_1 = __webpack_require__(25009);
const logger_1 = __webpack_require__(1141);
const primitives = [
    "string",
    "boolean",
    "double",
    "integer",
    "long",
    "float",
    "number",
];
const ARRAY_PREFIX = "Array<";
const MAP_PREFIX = "{ [key: string]: ";
const TUPLE_PREFIX = "[";
const supportedMediaTypes = {
    "application/json": Infinity,
    "text/json": 100,
    "application/octet-stream": 0,
};
const enumsMap = {
    AWSNamespace: [
        "elb",
        "application_elb",
        "sqs",
        "rds",
        "custom",
        "network_elb",
        "lambda",
    ],
    AccessRole: ["st", "adm", "ro", "ERROR"],
    AlertGraphWidgetDefinitionType: ["alert_graph"],
    AlertValueWidgetDefinitionType: ["alert_value"],
    ApmStatsQueryRowType: ["service", "resource", "span"],
    ChangeWidgetDefinitionType: ["change"],
    CheckStatusWidgetDefinitionType: ["check_status"],
    ContentEncoding: ["gzip", "deflate"],
    DashboardLayoutType: ["ordered", "free"],
    DashboardReflowType: ["auto", "fixed"],
    DashboardResourceType: ["dashboard"],
    DistributionPointsContentEncoding: ["deflate"],
    DistributionPointsType: ["distribution"],
    DistributionWidgetDefinitionType: ["distribution"],
    DistributionWidgetHistogramRequestType: ["histogram"],
    EventAlertType: [
        "error",
        "warning",
        "info",
        "success",
        "user_update",
        "recommendation",
        "snapshot",
    ],
    EventPriority: ["normal", "low"],
    EventStreamWidgetDefinitionType: ["event_stream"],
    EventTimelineWidgetDefinitionType: ["event_timeline"],
    FormulaAndFunctionApmDependencyStatName: [
        "avg_duration",
        "avg_root_duration",
        "avg_spans_per_trace",
        "error_rate",
        "pct_exec_time",
        "pct_of_traces",
        "total_traces_count",
    ],
    FormulaAndFunctionApmDependencyStatsDataSource: ["apm_dependency_stats"],
    FormulaAndFunctionApmResourceStatName: [
        "errors",
        "error_rate",
        "hits",
        "latency_avg",
        "latency_distribution",
        "latency_max",
        "latency_p50",
        "latency_p75",
        "latency_p90",
        "latency_p95",
        "latency_p99",
    ],
    FormulaAndFunctionApmResourceStatsDataSource: ["apm_resource_stats"],
    FormulaAndFunctionEventAggregation: [
        "count",
        "cardinality",
        "median",
        "pc75",
        "pc90",
        "pc95",
        "pc98",
        "pc99",
        "sum",
        "min",
        "max",
        "avg",
    ],
    FormulaAndFunctionEventsDataSource: [
        "logs",
        "spans",
        "network",
        "rum",
        "security_signals",
        "profiles",
        "audit",
        "events",
        "ci_tests",
    ],
    FormulaAndFunctionMetricAggregation: [
        "avg",
        "min",
        "max",
        "sum",
        "last",
        "area",
        "l2norm",
        "percentile",
    ],
    FormulaAndFunctionMetricDataSource: ["metrics"],
    FormulaAndFunctionProcessQueryDataSource: ["process", "container"],
    FormulaAndFunctionResponseFormat: ["timeseries", "scalar"],
    FreeTextWidgetDefinitionType: ["free_text"],
    FunnelRequestType: ["funnel"],
    FunnelSource: ["rum"],
    FunnelWidgetDefinitionType: ["funnel"],
    GeomapWidgetDefinitionType: ["geomap"],
    GroupWidgetDefinitionType: ["group"],
    HeatMapWidgetDefinitionType: ["heatmap"],
    HostMapWidgetDefinitionType: ["hostmap"],
    HourlyUsageAttributionUsageType: [
        "api_usage",
        "apm_fargate_usage",
        "apm_host_usage",
        "appsec_fargate_usage",
        "appsec_usage",
        "browser_usage",
        "container_excl_agent_usage",
        "container_usage",
        "cspm_containers_usage",
        "cspm_hosts_usage",
        "custom_timeseries_usage",
        "cws_containers_usage",
        "cws_hosts_usage",
        "dbm_hosts_usage",
        "dbm_queries_usage",
        "estimated_indexed_logs_usage",
        "estimated_ingested_logs_usage",
        "estimated_indexed_spans_usage",
        "estimated_ingested_spans_usage",
        "fargate_usage",
        "functions_usage",
        "infra_host_usage",
        "invocations_usage",
        "npm_host_usage",
        "profiled_container_usage",
        "profiled_host_usage",
        "snmp_usage",
        "estimated_rum_sessions_usage",
    ],
    IFrameWidgetDefinitionType: ["iframe"],
    ImageWidgetDefinitionType: ["image"],
    ListStreamColumnWidth: ["auto", "compact", "full"],
    ListStreamComputeAggregation: [
        "count",
        "cardinality",
        "median",
        "pc75",
        "pc90",
        "pc95",
        "pc98",
        "pc99",
        "sum",
        "min",
        "max",
        "avg",
        "earliest",
        "latest",
        "most_frequent",
    ],
    ListStreamResponseFormat: ["event_list"],
    ListStreamSource: [
        "logs_stream",
        "audit_stream",
        "rum_issue_stream",
        "apm_issue_stream",
        "logs_pattern_stream",
        "logs_transaction_stream",
        "event_stream",
    ],
    ListStreamWidgetDefinitionType: ["list_stream"],
    LogStreamWidgetDefinitionType: ["log_stream"],
    LogsArithmeticProcessorType: ["arithmetic-processor"],
    LogsAttributeRemapperType: ["attribute-remapper"],
    LogsCategoryProcessorType: ["category-processor"],
    LogsDateRemapperType: ["date-remapper"],
    LogsGeoIPParserType: ["geo-ip-parser"],
    LogsGrokParserType: ["grok-parser"],
    LogsLookupProcessorType: ["lookup-processor"],
    LogsMessageRemapperType: ["message-remapper"],
    LogsPipelineProcessorType: ["pipeline"],
    LogsServiceRemapperType: ["service-remapper"],
    LogsSort: ["asc", "desc"],
    LogsStatusRemapperType: ["status-remapper"],
    LogsStringBuilderProcessorType: ["string-builder-processor"],
    LogsTraceRemapperType: ["trace-id-remapper"],
    LogsURLParserType: ["url-parser"],
    LogsUserAgentParserType: ["user-agent-parser"],
    MetricContentEncoding: ["deflate", "gzip"],
    MonitorDeviceID: [
        "laptop_large",
        "tablet",
        "mobile_small",
        "chrome.laptop_large",
        "chrome.tablet",
        "chrome.mobile_small",
        "firefox.laptop_large",
        "firefox.tablet",
        "firefox.mobile_small",
    ],
    MonitorFormulaAndFunctionEventAggregation: [
        "count",
        "cardinality",
        "median",
        "pc75",
        "pc90",
        "pc95",
        "pc98",
        "pc99",
        "sum",
        "min",
        "max",
        "avg",
    ],
    MonitorFormulaAndFunctionEventsDataSource: [
        "rum",
        "ci_pipelines",
        "ci_tests",
        "audit",
        "events",
        "logs",
        "spans",
    ],
    MonitorOptionsNotificationPresets: [
        "show_all",
        "hide_query",
        "hide_handles",
        "hide_all",
    ],
    MonitorOverallStates: [
        "Alert",
        "Ignored",
        "No Data",
        "OK",
        "Skipped",
        "Unknown",
        "Warn",
    ],
    MonitorRenotifyStatusType: ["alert", "warn", "no data"],
    MonitorSummaryWidgetDefinitionType: ["manage_status"],
    MonitorType: [
        "composite",
        "event alert",
        "log alert",
        "metric alert",
        "process alert",
        "query alert",
        "rum alert",
        "service check",
        "synthetics alert",
        "trace-analytics alert",
        "slo alert",
        "event-v2 alert",
        "audit alert",
        "ci-pipelines alert",
        "ci-tests alert",
        "error-tracking alert",
    ],
    MonthlyUsageAttributionSupportedMetrics: [
        "api_usage",
        "api_percentage",
        "apm_fargate_usage",
        "apm_fargate_percentage",
        "appsec_fargate_usage",
        "appsec_fargate_percentage",
        "apm_host_usage",
        "apm_host_percentage",
        "appsec_usage",
        "appsec_percentage",
        "browser_usage",
        "browser_percentage",
        "container_excl_agent_usage",
        "container_excl_agent_percentage",
        "container_usage",
        "container_percentage",
        "cspm_containers_percentage",
        "cspm_containers_usage",
        "cspm_hosts_percentage",
        "cspm_hosts_usage",
        "custom_timeseries_usage",
        "custom_timeseries_percentage",
        "cws_containers_percentage",
        "cws_containers_usage",
        "cws_hosts_percentage",
        "cws_hosts_usage",
        "dbm_hosts_percentage",
        "dbm_hosts_usage",
        "dbm_queries_percentage",
        "dbm_queries_usage",
        "estimated_indexed_logs_usage",
        "estimated_indexed_logs_percentage",
        "estimated_ingested_logs_usage",
        "estimated_ingested_logs_percentage",
        "estimated_indexed_spans_usage",
        "estimated_indexed_spans_percentage",
        "estimated_ingested_spans_usage",
        "estimated_ingested_spans_percentage",
        "fargate_usage",
        "fargate_percentage",
        "functions_usage",
        "functions_percentage",
        "infra_host_usage",
        "infra_host_percentage",
        "invocations_usage",
        "invocations_percentage",
        "npm_host_usage",
        "npm_host_percentage",
        "profiled_container_usage",
        "profiled_container_percentage",
        "profiled_host_usage",
        "profiled_host_percentage",
        "snmp_usage",
        "snmp_percentage",
        "estimated_rum_sessions_usage",
        "estimated_rum_sessions_percentage",
        "*",
    ],
    NoteWidgetDefinitionType: ["note"],
    NotebookCellResourceType: ["notebook_cells"],
    NotebookGraphSize: ["xs", "s", "m", "l", "xl"],
    NotebookMarkdownCellDefinitionType: ["markdown"],
    NotebookMetadataType: [
        "postmortem",
        "runbook",
        "investigation",
        "documentation",
        "report",
    ],
    NotebookResourceType: ["notebooks"],
    NotebookStatus: ["published"],
    OnMissingDataOption: [
        "default",
        "show_no_data",
        "show_and_notify_no_data",
        "resolve",
    ],
    QuerySortOrder: ["asc", "desc"],
    QueryValueWidgetDefinitionType: ["query_value"],
    RunWorkflowWidgetDefinitionType: ["run_workflow"],
    SLOCorrectionCategory: [
        "Scheduled Maintenance",
        "Outside Business Hours",
        "Deployment",
        "Other",
    ],
    SLOCorrectionType: ["correction"],
    SLOErrorTimeframe: ["7d", "30d", "90d", "all"],
    SLOListWidgetDefinitionType: ["slo_list"],
    SLOListWidgetRequestType: ["slo_list"],
    SLOTimeframe: ["7d", "30d", "90d", "custom"],
    SLOType: ["metric", "monitor"],
    SLOTypeNumeric: [0, 1],
    SLOWidgetDefinitionType: ["slo"],
    ScatterPlotWidgetDefinitionType: ["scatterplot"],
    ScatterplotDimension: ["x", "y", "radius", "color"],
    ScatterplotWidgetAggregator: ["avg", "last", "max", "min", "sum"],
    SearchSLOTimeframe: ["7d", "30d", "90d"],
    ServiceCheckStatus: [0, 1, 2, 3],
    ServiceMapWidgetDefinitionType: ["servicemap"],
    ServiceSummaryWidgetDefinitionType: ["trace_service"],
    SignalArchiveReason: [
        "none",
        "false_positive",
        "testing_or_maintenance",
        "other",
    ],
    SignalTriageState: ["open", "archived", "under_review"],
    SunburstWidgetDefinitionType: ["sunburst"],
    SunburstWidgetLegendInlineAutomaticType: ["inline", "automatic"],
    SunburstWidgetLegendTableType: ["table", "none"],
    SyntheticsAPIStepSubtype: ["http"],
    SyntheticsAPITestType: ["api"],
    SyntheticsApiTestFailureCode: [
        "BODY_TOO_LARGE",
        "DENIED",
        "TOO_MANY_REDIRECTS",
        "AUTHENTICATION_ERROR",
        "DECRYPTION",
        "INVALID_CHAR_IN_HEADER",
        "HEADER_TOO_LARGE",
        "HEADERS_INCOMPATIBLE_CONTENT_LENGTH",
        "INVALID_REQUEST",
        "REQUIRES_UPDATE",
        "UNESCAPED_CHARACTERS_IN_REQUEST_PATH",
        "MALFORMED_RESPONSE",
        "INCORRECT_ASSERTION",
        "CONNREFUSED",
        "CONNRESET",
        "DNS",
        "HOSTUNREACH",
        "NETUNREACH",
        "TIMEOUT",
        "SSL",
        "OCSP",
        "INVALID_TEST",
        "TUNNEL",
        "WEBSOCKET",
        "UNKNOWN",
        "INTERNAL_ERROR",
    ],
    SyntheticsAssertionJSONPathOperator: ["validatesJSONPath"],
    SyntheticsAssertionOperator: [
        "contains",
        "doesNotContain",
        "is",
        "isNot",
        "lessThan",
        "lessThanOrEqual",
        "moreThan",
        "moreThanOrEqual",
        "matches",
        "doesNotMatch",
        "validates",
        "isInMoreThan",
        "isInLessThan",
        "doesNotExist",
    ],
    SyntheticsAssertionType: [
        "body",
        "header",
        "statusCode",
        "certificate",
        "responseTime",
        "property",
        "recordEvery",
        "recordSome",
        "tlsVersion",
        "minTlsVersion",
        "latency",
        "packetLossPercentage",
        "packetsReceived",
        "networkHop",
        "receivedMessage",
        "grpcHealthcheckStatus",
        "connection",
    ],
    SyntheticsAssertionXPathOperator: ["validatesXPath"],
    SyntheticsBasicAuthDigestType: ["digest"],
    SyntheticsBasicAuthNTLMType: ["ntlm"],
    SyntheticsBasicAuthOauthClientType: ["oauth-client"],
    SyntheticsBasicAuthOauthROPType: ["oauth-rop"],
    SyntheticsBasicAuthOauthTokenApiAuthentication: ["header", "body"],
    SyntheticsBasicAuthSigv4Type: ["sigv4"],
    SyntheticsBasicAuthWebType: ["web"],
    SyntheticsBrowserErrorType: ["network", "js"],
    SyntheticsBrowserTestFailureCode: [
        "API_REQUEST_FAILURE",
        "ASSERTION_FAILURE",
        "DOWNLOAD_FILE_TOO_LARGE",
        "ELEMENT_NOT_INTERACTABLE",
        "EMAIL_VARIABLE_NOT_DEFINED",
        "EVALUATE_JAVASCRIPT",
        "EVALUATE_JAVASCRIPT_CONTEXT",
        "EXTRACT_VARIABLE",
        "FORBIDDEN_URL",
        "FRAME_DETACHED",
        "INCONSISTENCIES",
        "INTERNAL_ERROR",
        "INVALID_TYPE_TEXT_DELAY",
        "INVALID_URL",
        "INVALID_VARIABLE_PATTERN",
        "INVISIBLE_ELEMENT",
        "LOCATE_ELEMENT",
        "NAVIGATE_TO_LINK",
        "OPEN_URL",
        "PRESS_KEY",
        "SERVER_CERTIFICATE",
        "SELECT_OPTION",
        "STEP_TIMEOUT",
        "SUB_TEST_NOT_PASSED",
        "TEST_TIMEOUT",
        "TOO_MANY_HTTP_REQUESTS",
        "UNAVAILABLE_BROWSER",
        "UNKNOWN",
        "UNSUPPORTED_AUTH_SCHEMA",
        "UPLOAD_FILES_ELEMENT_TYPE",
        "UPLOAD_FILES_DIALOG",
        "UPLOAD_FILES_DYNAMIC_ELEMENT",
        "UPLOAD_FILES_NAME",
    ],
    SyntheticsBrowserTestType: ["browser"],
    SyntheticsBrowserVariableType: [
        "element",
        "email",
        "global",
        "javascript",
        "text",
    ],
    SyntheticsCheckType: [
        "equals",
        "notEquals",
        "contains",
        "notContains",
        "startsWith",
        "notStartsWith",
        "greater",
        "lower",
        "greaterEquals",
        "lowerEquals",
        "matchRegex",
        "between",
        "isEmpty",
        "notIsEmpty",
    ],
    SyntheticsConfigVariableType: ["global", "text"],
    SyntheticsDeviceID: [
        "laptop_large",
        "tablet",
        "mobile_small",
        "chrome.laptop_large",
        "chrome.tablet",
        "chrome.mobile_small",
        "firefox.laptop_large",
        "firefox.tablet",
        "firefox.mobile_small",
        "edge.laptop_large",
        "edge.tablet",
        "edge.mobile_small",
    ],
    SyntheticsGlobalVariableParseTestOptionsType: [
        "http_body",
        "http_header",
        "local_variable",
    ],
    SyntheticsGlobalVariableParserType: ["raw", "json_path", "regex", "x_path"],
    SyntheticsPlayingTab: [-1, 0, 1, 2, 3],
    SyntheticsStatus: ["passed", "skipped", "failed"],
    SyntheticsStepType: [
        "assertCurrentUrl",
        "assertElementAttribute",
        "assertElementContent",
        "assertElementPresent",
        "assertEmail",
        "assertFileDownload",
        "assertFromJavascript",
        "assertPageContains",
        "assertPageLacks",
        "click",
        "extractFromJavascript",
        "extractVariable",
        "goToEmailLink",
        "goToUrl",
        "goToUrlAndMeasureTti",
        "hover",
        "playSubTest",
        "pressKey",
        "refresh",
        "runApiTest",
        "scroll",
        "selectOption",
        "typeText",
        "uploadFiles",
        "wait",
    ],
    SyntheticsTestCallType: ["healthcheck", "unary"],
    SyntheticsTestDetailsSubType: [
        "http",
        "ssl",
        "tcp",
        "dns",
        "multi",
        "icmp",
        "udp",
        "websocket",
        "grpc",
    ],
    SyntheticsTestDetailsType: ["api", "browser"],
    SyntheticsTestExecutionRule: ["blocking", "non_blocking", "skipped"],
    SyntheticsTestMonitorStatus: [0, 1, 2],
    SyntheticsTestOptionsHTTPVersion: ["http1", "http2", "any"],
    SyntheticsTestPauseStatus: ["live", "paused"],
    SyntheticsTestProcessStatus: [
        "not_scheduled",
        "scheduled",
        "finished",
        "finished_with_error",
    ],
    SyntheticsTestRequestBodyType: [
        "text/plain",
        "application/json",
        "text/xml",
        "text/html",
        "application/x-www-form-urlencoded",
        "graphql",
    ],
    SyntheticsWarningType: ["user_locator"],
    TableWidgetCellDisplayMode: ["number", "bar"],
    TableWidgetDefinitionType: ["query_table"],
    TableWidgetHasSearchBar: ["always", "never", "auto"],
    TargetFormatType: ["auto", "string", "integer", "double"],
    TimeseriesBackgroundType: ["bars", "area"],
    TimeseriesWidgetDefinitionType: ["timeseries"],
    TimeseriesWidgetLegendColumn: ["value", "avg", "sum", "min", "max"],
    TimeseriesWidgetLegendLayout: ["auto", "horizontal", "vertical"],
    ToplistWidgetDefinitionType: ["toplist"],
    TopologyMapWidgetDefinitionType: ["topology_map"],
    TopologyQueryDataSource: ["data_streams", "service_map"],
    TopologyRequestType: ["topology"],
    TreeMapColorBy: ["user"],
    TreeMapGroupBy: ["user", "family", "process"],
    TreeMapSizeBy: ["pct_cpu", "pct_mem"],
    TreeMapWidgetDefinitionType: ["treemap"],
    UsageAttributionSort: [
        "api_percentage",
        "snmp_usage",
        "apm_host_usage",
        "api_usage",
        "appsec_usage",
        "appsec_percentage",
        "container_usage",
        "custom_timeseries_percentage",
        "container_percentage",
        "apm_host_percentage",
        "npm_host_percentage",
        "browser_percentage",
        "browser_usage",
        "infra_host_percentage",
        "snmp_percentage",
        "npm_host_usage",
        "infra_host_usage",
        "custom_timeseries_usage",
        "lambda_functions_usage",
        "lambda_functions_percentage",
        "lambda_invocations_usage",
        "lambda_invocations_percentage",
        "estimated_indexed_logs_usage",
        "estimated_indexed_logs_percentage",
        "estimated_ingested_logs_usage",
        "estimated_ingested_logs_percentage",
        "estimated_indexed_spans_usage",
        "estimated_indexed_spans_percentage",
        "estimated_ingested_spans_usage",
        "estimated_ingested_spans_percentage",
        "apm_fargate_usage",
        "apm_fargate_percentage",
        "appsec_fargate_usage",
        "appsec_fargate_percentage",
        "estimated_rum_usage_attribution_usage",
        "estimated_rum_usage_attribution_percentage",
    ],
    UsageAttributionSupportedMetrics: [
        "custom_timeseries_usage",
        "container_usage",
        "snmp_percentage",
        "apm_host_usage",
        "browser_usage",
        "npm_host_percentage",
        "infra_host_usage",
        "custom_timeseries_percentage",
        "container_percentage",
        "api_usage",
        "apm_host_percentage",
        "infra_host_percentage",
        "snmp_usage",
        "browser_percentage",
        "api_percentage",
        "npm_host_usage",
        "lambda_functions_usage",
        "lambda_functions_percentage",
        "lambda_invocations_usage",
        "lambda_invocations_percentage",
        "fargate_usage",
        "fargate_percentage",
        "profiled_host_usage",
        "profiled_host_percentage",
        "profiled_container_usage",
        "profiled_container_percentage",
        "dbm_hosts_usage",
        "dbm_hosts_percentage",
        "dbm_queries_usage",
        "dbm_queries_percentage",
        "estimated_indexed_logs_usage",
        "estimated_indexed_logs_percentage",
        "estimated_ingested_logs_usage",
        "estimated_ingested_logs_percentage",
        "appsec_usage",
        "appsec_percentage",
        "estimated_indexed_spans_usage",
        "estimated_indexed_spans_percentage",
        "estimated_ingested_spans_usage",
        "estimated_ingested_spans_percentage",
        "apm_fargate_usage",
        "apm_fargate_percentage",
        "appsec_fargate_usage",
        "appsec_fargate_percentage",
        "estimated_rum_usage_attribution_usage",
        "estimated_rum_usage_attribution_percentage",
        "*",
    ],
    UsageMetricCategory: ["standard", "custom"],
    UsageReportsType: ["reports"],
    UsageSort: ["computed_on", "size", "start_date", "end_date"],
    UsageSortDirection: ["desc", "asc"],
    WebhooksIntegrationEncoding: ["json", "form"],
    WidgetAggregator: ["avg", "last", "max", "min", "sum", "percentile"],
    WidgetChangeType: ["absolute", "relative"],
    WidgetColorPreference: ["background", "text"],
    WidgetComparator: [">", ">=", "<", "<="],
    WidgetCompareTo: ["hour_before", "day_before", "week_before", "month_before"],
    WidgetDisplayType: ["area", "bars", "line"],
    WidgetEventSize: ["s", "l"],
    WidgetGrouping: ["check", "cluster"],
    WidgetHorizontalAlign: ["center", "left", "right"],
    WidgetImageSizing: [
        "fill",
        "contain",
        "cover",
        "none",
        "scale-down",
        "zoom",
        "fit",
        "center",
    ],
    WidgetLayoutType: ["ordered"],
    WidgetLineType: ["dashed", "dotted", "solid"],
    WidgetLineWidth: ["normal", "thick", "thin"],
    WidgetLiveSpan: [
        "1m",
        "5m",
        "10m",
        "15m",
        "30m",
        "1h",
        "4h",
        "1d",
        "2d",
        "1w",
        "1mo",
        "3mo",
        "6mo",
        "1y",
        "alert",
    ],
    WidgetMargin: ["sm", "md", "lg", "small", "large"],
    WidgetMessageDisplay: ["inline", "expanded-md", "expanded-lg"],
    WidgetMonitorSummaryDisplayFormat: ["counts", "countsAndList", "list"],
    WidgetMonitorSummarySort: [
        "name",
        "group",
        "status",
        "tags",
        "triggered",
        "group,asc",
        "group,desc",
        "name,asc",
        "name,desc",
        "status,asc",
        "status,desc",
        "tags,asc",
        "tags,desc",
        "triggered,asc",
        "triggered,desc",
        "priority,asc",
        "priority,desc",
    ],
    WidgetNodeType: ["host", "container"],
    WidgetOrderBy: ["change", "name", "present", "past"],
    WidgetPalette: [
        "blue",
        "custom_bg",
        "custom_image",
        "custom_text",
        "gray_on_white",
        "grey",
        "green",
        "orange",
        "red",
        "red_on_white",
        "white_on_gray",
        "white_on_green",
        "green_on_white",
        "white_on_red",
        "white_on_yellow",
        "yellow_on_white",
        "black_on_light_yellow",
        "black_on_light_green",
        "black_on_light_red",
    ],
    WidgetServiceSummaryDisplayFormat: [
        "one_column",
        "two_column",
        "three_column",
    ],
    WidgetSizeFormat: ["small", "medium", "large"],
    WidgetSort: ["asc", "desc"],
    WidgetSummaryType: ["monitors", "groups", "combined"],
    WidgetTextAlign: ["center", "left", "right"],
    WidgetTickEdge: ["bottom", "left", "right", "top"],
    WidgetTimeWindows: [
        "7d",
        "30d",
        "90d",
        "week_to_date",
        "previous_week",
        "month_to_date",
        "previous_month",
        "global_time",
    ],
    WidgetVerticalAlign: ["center", "top", "bottom"],
    WidgetViewMode: ["overall", "component", "both"],
    WidgetVizType: ["timeseries", "toplist"],
};
const typeMap = {
    APIErrorResponse: APIErrorResponse_1.APIErrorResponse,
    AWSAccount: AWSAccount_1.AWSAccount,
    AWSAccountAndLambdaRequest: AWSAccountAndLambdaRequest_1.AWSAccountAndLambdaRequest,
    AWSAccountCreateResponse: AWSAccountCreateResponse_1.AWSAccountCreateResponse,
    AWSAccountDeleteRequest: AWSAccountDeleteRequest_1.AWSAccountDeleteRequest,
    AWSAccountListResponse: AWSAccountListResponse_1.AWSAccountListResponse,
    AWSLogsAsyncError: AWSLogsAsyncError_1.AWSLogsAsyncError,
    AWSLogsAsyncResponse: AWSLogsAsyncResponse_1.AWSLogsAsyncResponse,
    AWSLogsLambda: AWSLogsLambda_1.AWSLogsLambda,
    AWSLogsListResponse: AWSLogsListResponse_1.AWSLogsListResponse,
    AWSLogsListServicesResponse: AWSLogsListServicesResponse_1.AWSLogsListServicesResponse,
    AWSLogsServicesRequest: AWSLogsServicesRequest_1.AWSLogsServicesRequest,
    AWSTagFilter: AWSTagFilter_1.AWSTagFilter,
    AWSTagFilterCreateRequest: AWSTagFilterCreateRequest_1.AWSTagFilterCreateRequest,
    AWSTagFilterDeleteRequest: AWSTagFilterDeleteRequest_1.AWSTagFilterDeleteRequest,
    AWSTagFilterListResponse: AWSTagFilterListResponse_1.AWSTagFilterListResponse,
    AddSignalToIncidentRequest: AddSignalToIncidentRequest_1.AddSignalToIncidentRequest,
    AlertGraphWidgetDefinition: AlertGraphWidgetDefinition_1.AlertGraphWidgetDefinition,
    AlertValueWidgetDefinition: AlertValueWidgetDefinition_1.AlertValueWidgetDefinition,
    ApiKey: ApiKey_1.ApiKey,
    ApiKeyListResponse: ApiKeyListResponse_1.ApiKeyListResponse,
    ApiKeyResponse: ApiKeyResponse_1.ApiKeyResponse,
    ApmStatsQueryColumnType: ApmStatsQueryColumnType_1.ApmStatsQueryColumnType,
    ApmStatsQueryDefinition: ApmStatsQueryDefinition_1.ApmStatsQueryDefinition,
    ApplicationKey: ApplicationKey_1.ApplicationKey,
    ApplicationKeyListResponse: ApplicationKeyListResponse_1.ApplicationKeyListResponse,
    ApplicationKeyResponse: ApplicationKeyResponse_1.ApplicationKeyResponse,
    AuthenticationValidationResponse: AuthenticationValidationResponse_1.AuthenticationValidationResponse,
    AzureAccount: AzureAccount_1.AzureAccount,
    CancelDowntimesByScopeRequest: CancelDowntimesByScopeRequest_1.CancelDowntimesByScopeRequest,
    CanceledDowntimesIds: CanceledDowntimesIds_1.CanceledDowntimesIds,
    ChangeWidgetDefinition: ChangeWidgetDefinition_1.ChangeWidgetDefinition,
    ChangeWidgetRequest: ChangeWidgetRequest_1.ChangeWidgetRequest,
    CheckCanDeleteMonitorResponse: CheckCanDeleteMonitorResponse_1.CheckCanDeleteMonitorResponse,
    CheckCanDeleteMonitorResponseData: CheckCanDeleteMonitorResponseData_1.CheckCanDeleteMonitorResponseData,
    CheckCanDeleteSLOResponse: CheckCanDeleteSLOResponse_1.CheckCanDeleteSLOResponse,
    CheckCanDeleteSLOResponseData: CheckCanDeleteSLOResponseData_1.CheckCanDeleteSLOResponseData,
    CheckStatusWidgetDefinition: CheckStatusWidgetDefinition_1.CheckStatusWidgetDefinition,
    Creator: Creator_1.Creator,
    Dashboard: Dashboard_1.Dashboard,
    DashboardBulkActionData: DashboardBulkActionData_1.DashboardBulkActionData,
    DashboardBulkDeleteRequest: DashboardBulkDeleteRequest_1.DashboardBulkDeleteRequest,
    DashboardDeleteResponse: DashboardDeleteResponse_1.DashboardDeleteResponse,
    DashboardList: DashboardList_1.DashboardList,
    DashboardListDeleteResponse: DashboardListDeleteResponse_1.DashboardListDeleteResponse,
    DashboardListListResponse: DashboardListListResponse_1.DashboardListListResponse,
    DashboardRestoreRequest: DashboardRestoreRequest_1.DashboardRestoreRequest,
    DashboardSummary: DashboardSummary_1.DashboardSummary,
    DashboardSummaryDefinition: DashboardSummaryDefinition_1.DashboardSummaryDefinition,
    DashboardTemplateVariable: DashboardTemplateVariable_1.DashboardTemplateVariable,
    DashboardTemplateVariablePreset: DashboardTemplateVariablePreset_1.DashboardTemplateVariablePreset,
    DashboardTemplateVariablePresetValue: DashboardTemplateVariablePresetValue_1.DashboardTemplateVariablePresetValue,
    DeletedMonitor: DeletedMonitor_1.DeletedMonitor,
    DistributionPointsPayload: DistributionPointsPayload_1.DistributionPointsPayload,
    DistributionPointsSeries: DistributionPointsSeries_1.DistributionPointsSeries,
    DistributionWidgetDefinition: DistributionWidgetDefinition_1.DistributionWidgetDefinition,
    DistributionWidgetRequest: DistributionWidgetRequest_1.DistributionWidgetRequest,
    DistributionWidgetXAxis: DistributionWidgetXAxis_1.DistributionWidgetXAxis,
    DistributionWidgetYAxis: DistributionWidgetYAxis_1.DistributionWidgetYAxis,
    Downtime: Downtime_1.Downtime,
    DowntimeChild: DowntimeChild_1.DowntimeChild,
    DowntimeRecurrence: DowntimeRecurrence_1.DowntimeRecurrence,
    Event: Event_1.Event,
    EventCreateRequest: EventCreateRequest_1.EventCreateRequest,
    EventCreateResponse: EventCreateResponse_1.EventCreateResponse,
    EventListResponse: EventListResponse_1.EventListResponse,
    EventQueryDefinition: EventQueryDefinition_1.EventQueryDefinition,
    EventResponse: EventResponse_1.EventResponse,
    EventStreamWidgetDefinition: EventStreamWidgetDefinition_1.EventStreamWidgetDefinition,
    EventTimelineWidgetDefinition: EventTimelineWidgetDefinition_1.EventTimelineWidgetDefinition,
    FormulaAndFunctionApmDependencyStatsQueryDefinition: FormulaAndFunctionApmDependencyStatsQueryDefinition_1.FormulaAndFunctionApmDependencyStatsQueryDefinition,
    FormulaAndFunctionApmResourceStatsQueryDefinition: FormulaAndFunctionApmResourceStatsQueryDefinition_1.FormulaAndFunctionApmResourceStatsQueryDefinition,
    FormulaAndFunctionEventQueryDefinition: FormulaAndFunctionEventQueryDefinition_1.FormulaAndFunctionEventQueryDefinition,
    FormulaAndFunctionEventQueryDefinitionCompute: FormulaAndFunctionEventQueryDefinitionCompute_1.FormulaAndFunctionEventQueryDefinitionCompute,
    FormulaAndFunctionEventQueryDefinitionSearch: FormulaAndFunctionEventQueryDefinitionSearch_1.FormulaAndFunctionEventQueryDefinitionSearch,
    FormulaAndFunctionEventQueryGroupBy: FormulaAndFunctionEventQueryGroupBy_1.FormulaAndFunctionEventQueryGroupBy,
    FormulaAndFunctionEventQueryGroupBySort: FormulaAndFunctionEventQueryGroupBySort_1.FormulaAndFunctionEventQueryGroupBySort,
    FormulaAndFunctionMetricQueryDefinition: FormulaAndFunctionMetricQueryDefinition_1.FormulaAndFunctionMetricQueryDefinition,
    FormulaAndFunctionProcessQueryDefinition: FormulaAndFunctionProcessQueryDefinition_1.FormulaAndFunctionProcessQueryDefinition,
    FreeTextWidgetDefinition: FreeTextWidgetDefinition_1.FreeTextWidgetDefinition,
    FunnelQuery: FunnelQuery_1.FunnelQuery,
    FunnelStep: FunnelStep_1.FunnelStep,
    FunnelWidgetDefinition: FunnelWidgetDefinition_1.FunnelWidgetDefinition,
    FunnelWidgetRequest: FunnelWidgetRequest_1.FunnelWidgetRequest,
    GCPAccount: GCPAccount_1.GCPAccount,
    GeomapWidgetDefinition: GeomapWidgetDefinition_1.GeomapWidgetDefinition,
    GeomapWidgetDefinitionStyle: GeomapWidgetDefinitionStyle_1.GeomapWidgetDefinitionStyle,
    GeomapWidgetDefinitionView: GeomapWidgetDefinitionView_1.GeomapWidgetDefinitionView,
    GeomapWidgetRequest: GeomapWidgetRequest_1.GeomapWidgetRequest,
    GraphSnapshot: GraphSnapshot_1.GraphSnapshot,
    GroupWidgetDefinition: GroupWidgetDefinition_1.GroupWidgetDefinition,
    HTTPLogError: HTTPLogError_1.HTTPLogError,
    HTTPLogItem: HTTPLogItem_1.HTTPLogItem,
    HeatMapWidgetDefinition: HeatMapWidgetDefinition_1.HeatMapWidgetDefinition,
    HeatMapWidgetRequest: HeatMapWidgetRequest_1.HeatMapWidgetRequest,
    Host: Host_1.Host,
    HostListResponse: HostListResponse_1.HostListResponse,
    HostMapRequest: HostMapRequest_1.HostMapRequest,
    HostMapWidgetDefinition: HostMapWidgetDefinition_1.HostMapWidgetDefinition,
    HostMapWidgetDefinitionRequests: HostMapWidgetDefinitionRequests_1.HostMapWidgetDefinitionRequests,
    HostMapWidgetDefinitionStyle: HostMapWidgetDefinitionStyle_1.HostMapWidgetDefinitionStyle,
    HostMeta: HostMeta_1.HostMeta,
    HostMetaInstallMethod: HostMetaInstallMethod_1.HostMetaInstallMethod,
    HostMetrics: HostMetrics_1.HostMetrics,
    HostMuteResponse: HostMuteResponse_1.HostMuteResponse,
    HostMuteSettings: HostMuteSettings_1.HostMuteSettings,
    HostTags: HostTags_1.HostTags,
    HostTotals: HostTotals_1.HostTotals,
    HourlyUsageAttributionBody: HourlyUsageAttributionBody_1.HourlyUsageAttributionBody,
    HourlyUsageAttributionMetadata: HourlyUsageAttributionMetadata_1.HourlyUsageAttributionMetadata,
    HourlyUsageAttributionPagination: HourlyUsageAttributionPagination_1.HourlyUsageAttributionPagination,
    HourlyUsageAttributionResponse: HourlyUsageAttributionResponse_1.HourlyUsageAttributionResponse,
    IFrameWidgetDefinition: IFrameWidgetDefinition_1.IFrameWidgetDefinition,
    IPPrefixesAPI: IPPrefixesAPI_1.IPPrefixesAPI,
    IPPrefixesAPM: IPPrefixesAPM_1.IPPrefixesAPM,
    IPPrefixesAgents: IPPrefixesAgents_1.IPPrefixesAgents,
    IPPrefixesLogs: IPPrefixesLogs_1.IPPrefixesLogs,
    IPPrefixesProcess: IPPrefixesProcess_1.IPPrefixesProcess,
    IPPrefixesSynthetics: IPPrefixesSynthetics_1.IPPrefixesSynthetics,
    IPPrefixesSyntheticsPrivateLocations: IPPrefixesSyntheticsPrivateLocations_1.IPPrefixesSyntheticsPrivateLocations,
    IPPrefixesWebhooks: IPPrefixesWebhooks_1.IPPrefixesWebhooks,
    IPRanges: IPRanges_1.IPRanges,
    IdpFormData: IdpFormData_1.IdpFormData,
    IdpResponse: IdpResponse_1.IdpResponse,
    ImageWidgetDefinition: ImageWidgetDefinition_1.ImageWidgetDefinition,
    IntakePayloadAccepted: IntakePayloadAccepted_1.IntakePayloadAccepted,
    ListStreamColumn: ListStreamColumn_1.ListStreamColumn,
    ListStreamComputeItems: ListStreamComputeItems_1.ListStreamComputeItems,
    ListStreamGroupByItems: ListStreamGroupByItems_1.ListStreamGroupByItems,
    ListStreamQuery: ListStreamQuery_1.ListStreamQuery,
    ListStreamWidgetDefinition: ListStreamWidgetDefinition_1.ListStreamWidgetDefinition,
    ListStreamWidgetRequest: ListStreamWidgetRequest_1.ListStreamWidgetRequest,
    Log: Log_1.Log,
    LogContent: LogContent_1.LogContent,
    LogQueryDefinition: LogQueryDefinition_1.LogQueryDefinition,
    LogQueryDefinitionGroupBy: LogQueryDefinitionGroupBy_1.LogQueryDefinitionGroupBy,
    LogQueryDefinitionGroupBySort: LogQueryDefinitionGroupBySort_1.LogQueryDefinitionGroupBySort,
    LogQueryDefinitionSearch: LogQueryDefinitionSearch_1.LogQueryDefinitionSearch,
    LogStreamWidgetDefinition: LogStreamWidgetDefinition_1.LogStreamWidgetDefinition,
    LogsAPIError: LogsAPIError_1.LogsAPIError,
    LogsAPIErrorResponse: LogsAPIErrorResponse_1.LogsAPIErrorResponse,
    LogsArithmeticProcessor: LogsArithmeticProcessor_1.LogsArithmeticProcessor,
    LogsAttributeRemapper: LogsAttributeRemapper_1.LogsAttributeRemapper,
    LogsByRetention: LogsByRetention_1.LogsByRetention,
    LogsByRetentionMonthlyUsage: LogsByRetentionMonthlyUsage_1.LogsByRetentionMonthlyUsage,
    LogsByRetentionOrgUsage: LogsByRetentionOrgUsage_1.LogsByRetentionOrgUsage,
    LogsByRetentionOrgs: LogsByRetentionOrgs_1.LogsByRetentionOrgs,
    LogsCategoryProcessor: LogsCategoryProcessor_1.LogsCategoryProcessor,
    LogsCategoryProcessorCategory: LogsCategoryProcessorCategory_1.LogsCategoryProcessorCategory,
    LogsDateRemapper: LogsDateRemapper_1.LogsDateRemapper,
    LogsExclusion: LogsExclusion_1.LogsExclusion,
    LogsExclusionFilter: LogsExclusionFilter_1.LogsExclusionFilter,
    LogsFilter: LogsFilter_1.LogsFilter,
    LogsGeoIPParser: LogsGeoIPParser_1.LogsGeoIPParser,
    LogsGrokParser: LogsGrokParser_1.LogsGrokParser,
    LogsGrokParserRules: LogsGrokParserRules_1.LogsGrokParserRules,
    LogsIndex: LogsIndex_1.LogsIndex,
    LogsIndexListResponse: LogsIndexListResponse_1.LogsIndexListResponse,
    LogsIndexUpdateRequest: LogsIndexUpdateRequest_1.LogsIndexUpdateRequest,
    LogsIndexesOrder: LogsIndexesOrder_1.LogsIndexesOrder,
    LogsListRequest: LogsListRequest_1.LogsListRequest,
    LogsListRequestTime: LogsListRequestTime_1.LogsListRequestTime,
    LogsListResponse: LogsListResponse_1.LogsListResponse,
    LogsLookupProcessor: LogsLookupProcessor_1.LogsLookupProcessor,
    LogsMessageRemapper: LogsMessageRemapper_1.LogsMessageRemapper,
    LogsPipeline: LogsPipeline_1.LogsPipeline,
    LogsPipelineProcessor: LogsPipelineProcessor_1.LogsPipelineProcessor,
    LogsPipelinesOrder: LogsPipelinesOrder_1.LogsPipelinesOrder,
    LogsQueryCompute: LogsQueryCompute_1.LogsQueryCompute,
    LogsRetentionAggSumUsage: LogsRetentionAggSumUsage_1.LogsRetentionAggSumUsage,
    LogsRetentionSumUsage: LogsRetentionSumUsage_1.LogsRetentionSumUsage,
    LogsServiceRemapper: LogsServiceRemapper_1.LogsServiceRemapper,
    LogsStatusRemapper: LogsStatusRemapper_1.LogsStatusRemapper,
    LogsStringBuilderProcessor: LogsStringBuilderProcessor_1.LogsStringBuilderProcessor,
    LogsTraceRemapper: LogsTraceRemapper_1.LogsTraceRemapper,
    LogsURLParser: LogsURLParser_1.LogsURLParser,
    LogsUserAgentParser: LogsUserAgentParser_1.LogsUserAgentParser,
    MetricMetadata: MetricMetadata_1.MetricMetadata,
    MetricSearchResponse: MetricSearchResponse_1.MetricSearchResponse,
    MetricSearchResponseResults: MetricSearchResponseResults_1.MetricSearchResponseResults,
    MetricsListResponse: MetricsListResponse_1.MetricsListResponse,
    MetricsPayload: MetricsPayload_1.MetricsPayload,
    MetricsQueryMetadata: MetricsQueryMetadata_1.MetricsQueryMetadata,
    MetricsQueryResponse: MetricsQueryResponse_1.MetricsQueryResponse,
    MetricsQueryUnit: MetricsQueryUnit_1.MetricsQueryUnit,
    Monitor: Monitor_1.Monitor,
    MonitorFormulaAndFunctionEventQueryDefinition: MonitorFormulaAndFunctionEventQueryDefinition_1.MonitorFormulaAndFunctionEventQueryDefinition,
    MonitorFormulaAndFunctionEventQueryDefinitionCompute: MonitorFormulaAndFunctionEventQueryDefinitionCompute_1.MonitorFormulaAndFunctionEventQueryDefinitionCompute,
    MonitorFormulaAndFunctionEventQueryDefinitionSearch: MonitorFormulaAndFunctionEventQueryDefinitionSearch_1.MonitorFormulaAndFunctionEventQueryDefinitionSearch,
    MonitorFormulaAndFunctionEventQueryGroupBy: MonitorFormulaAndFunctionEventQueryGroupBy_1.MonitorFormulaAndFunctionEventQueryGroupBy,
    MonitorFormulaAndFunctionEventQueryGroupBySort: MonitorFormulaAndFunctionEventQueryGroupBySort_1.MonitorFormulaAndFunctionEventQueryGroupBySort,
    MonitorGroupSearchResponse: MonitorGroupSearchResponse_1.MonitorGroupSearchResponse,
    MonitorGroupSearchResponseCounts: MonitorGroupSearchResponseCounts_1.MonitorGroupSearchResponseCounts,
    MonitorGroupSearchResult: MonitorGroupSearchResult_1.MonitorGroupSearchResult,
    MonitorOptions: MonitorOptions_1.MonitorOptions,
    MonitorOptionsAggregation: MonitorOptionsAggregation_1.MonitorOptionsAggregation,
    MonitorOptionsSchedulingOptions: MonitorOptionsSchedulingOptions_1.MonitorOptionsSchedulingOptions,
    MonitorOptionsSchedulingOptionsEvaluationWindow: MonitorOptionsSchedulingOptionsEvaluationWindow_1.MonitorOptionsSchedulingOptionsEvaluationWindow,
    MonitorSearchCountItem: MonitorSearchCountItem_1.MonitorSearchCountItem,
    MonitorSearchResponse: MonitorSearchResponse_1.MonitorSearchResponse,
    MonitorSearchResponseCounts: MonitorSearchResponseCounts_1.MonitorSearchResponseCounts,
    MonitorSearchResponseMetadata: MonitorSearchResponseMetadata_1.MonitorSearchResponseMetadata,
    MonitorSearchResult: MonitorSearchResult_1.MonitorSearchResult,
    MonitorSearchResultNotification: MonitorSearchResultNotification_1.MonitorSearchResultNotification,
    MonitorState: MonitorState_1.MonitorState,
    MonitorStateGroup: MonitorStateGroup_1.MonitorStateGroup,
    MonitorSummaryWidgetDefinition: MonitorSummaryWidgetDefinition_1.MonitorSummaryWidgetDefinition,
    MonitorThresholdWindowOptions: MonitorThresholdWindowOptions_1.MonitorThresholdWindowOptions,
    MonitorThresholds: MonitorThresholds_1.MonitorThresholds,
    MonitorUpdateRequest: MonitorUpdateRequest_1.MonitorUpdateRequest,
    MonthlyUsageAttributionBody: MonthlyUsageAttributionBody_1.MonthlyUsageAttributionBody,
    MonthlyUsageAttributionMetadata: MonthlyUsageAttributionMetadata_1.MonthlyUsageAttributionMetadata,
    MonthlyUsageAttributionPagination: MonthlyUsageAttributionPagination_1.MonthlyUsageAttributionPagination,
    MonthlyUsageAttributionResponse: MonthlyUsageAttributionResponse_1.MonthlyUsageAttributionResponse,
    MonthlyUsageAttributionValues: MonthlyUsageAttributionValues_1.MonthlyUsageAttributionValues,
    NoteWidgetDefinition: NoteWidgetDefinition_1.NoteWidgetDefinition,
    NotebookAbsoluteTime: NotebookAbsoluteTime_1.NotebookAbsoluteTime,
    NotebookAuthor: NotebookAuthor_1.NotebookAuthor,
    NotebookCellCreateRequest: NotebookCellCreateRequest_1.NotebookCellCreateRequest,
    NotebookCellResponse: NotebookCellResponse_1.NotebookCellResponse,
    NotebookCellUpdateRequest: NotebookCellUpdateRequest_1.NotebookCellUpdateRequest,
    NotebookCreateData: NotebookCreateData_1.NotebookCreateData,
    NotebookCreateDataAttributes: NotebookCreateDataAttributes_1.NotebookCreateDataAttributes,
    NotebookCreateRequest: NotebookCreateRequest_1.NotebookCreateRequest,
    NotebookDistributionCellAttributes: NotebookDistributionCellAttributes_1.NotebookDistributionCellAttributes,
    NotebookHeatMapCellAttributes: NotebookHeatMapCellAttributes_1.NotebookHeatMapCellAttributes,
    NotebookLogStreamCellAttributes: NotebookLogStreamCellAttributes_1.NotebookLogStreamCellAttributes,
    NotebookMarkdownCellAttributes: NotebookMarkdownCellAttributes_1.NotebookMarkdownCellAttributes,
    NotebookMarkdownCellDefinition: NotebookMarkdownCellDefinition_1.NotebookMarkdownCellDefinition,
    NotebookMetadata: NotebookMetadata_1.NotebookMetadata,
    NotebookRelativeTime: NotebookRelativeTime_1.NotebookRelativeTime,
    NotebookResponse: NotebookResponse_1.NotebookResponse,
    NotebookResponseData: NotebookResponseData_1.NotebookResponseData,
    NotebookResponseDataAttributes: NotebookResponseDataAttributes_1.NotebookResponseDataAttributes,
    NotebookSplitBy: NotebookSplitBy_1.NotebookSplitBy,
    NotebookTimeseriesCellAttributes: NotebookTimeseriesCellAttributes_1.NotebookTimeseriesCellAttributes,
    NotebookToplistCellAttributes: NotebookToplistCellAttributes_1.NotebookToplistCellAttributes,
    NotebookUpdateData: NotebookUpdateData_1.NotebookUpdateData,
    NotebookUpdateDataAttributes: NotebookUpdateDataAttributes_1.NotebookUpdateDataAttributes,
    NotebookUpdateRequest: NotebookUpdateRequest_1.NotebookUpdateRequest,
    NotebooksResponse: NotebooksResponse_1.NotebooksResponse,
    NotebooksResponseData: NotebooksResponseData_1.NotebooksResponseData,
    NotebooksResponseDataAttributes: NotebooksResponseDataAttributes_1.NotebooksResponseDataAttributes,
    NotebooksResponseMeta: NotebooksResponseMeta_1.NotebooksResponseMeta,
    NotebooksResponsePage: NotebooksResponsePage_1.NotebooksResponsePage,
    OrgDowngradedResponse: OrgDowngradedResponse_1.OrgDowngradedResponse,
    Organization: Organization_1.Organization,
    OrganizationBilling: OrganizationBilling_1.OrganizationBilling,
    OrganizationCreateBody: OrganizationCreateBody_1.OrganizationCreateBody,
    OrganizationCreateResponse: OrganizationCreateResponse_1.OrganizationCreateResponse,
    OrganizationListResponse: OrganizationListResponse_1.OrganizationListResponse,
    OrganizationResponse: OrganizationResponse_1.OrganizationResponse,
    OrganizationSettings: OrganizationSettings_1.OrganizationSettings,
    OrganizationSettingsSaml: OrganizationSettingsSaml_1.OrganizationSettingsSaml,
    OrganizationSettingsSamlAutocreateUsersDomains: OrganizationSettingsSamlAutocreateUsersDomains_1.OrganizationSettingsSamlAutocreateUsersDomains,
    OrganizationSettingsSamlIdpInitiatedLogin: OrganizationSettingsSamlIdpInitiatedLogin_1.OrganizationSettingsSamlIdpInitiatedLogin,
    OrganizationSettingsSamlStrictMode: OrganizationSettingsSamlStrictMode_1.OrganizationSettingsSamlStrictMode,
    OrganizationSubscription: OrganizationSubscription_1.OrganizationSubscription,
    PagerDutyService: PagerDutyService_1.PagerDutyService,
    PagerDutyServiceKey: PagerDutyServiceKey_1.PagerDutyServiceKey,
    PagerDutyServiceName: PagerDutyServiceName_1.PagerDutyServiceName,
    Pagination: Pagination_1.Pagination,
    ProcessQueryDefinition: ProcessQueryDefinition_1.ProcessQueryDefinition,
    QueryValueWidgetDefinition: QueryValueWidgetDefinition_1.QueryValueWidgetDefinition,
    QueryValueWidgetRequest: QueryValueWidgetRequest_1.QueryValueWidgetRequest,
    ReferenceTableLogsLookupProcessor: ReferenceTableLogsLookupProcessor_1.ReferenceTableLogsLookupProcessor,
    ResponseMetaAttributes: ResponseMetaAttributes_1.ResponseMetaAttributes,
    RunWorkflowWidgetDefinition: RunWorkflowWidgetDefinition_1.RunWorkflowWidgetDefinition,
    RunWorkflowWidgetInput: RunWorkflowWidgetInput_1.RunWorkflowWidgetInput,
    SLOBulkDeleteError: SLOBulkDeleteError_1.SLOBulkDeleteError,
    SLOBulkDeleteResponse: SLOBulkDeleteResponse_1.SLOBulkDeleteResponse,
    SLOBulkDeleteResponseData: SLOBulkDeleteResponseData_1.SLOBulkDeleteResponseData,
    SLOCorrection: SLOCorrection_1.SLOCorrection,
    SLOCorrectionCreateData: SLOCorrectionCreateData_1.SLOCorrectionCreateData,
    SLOCorrectionCreateRequest: SLOCorrectionCreateRequest_1.SLOCorrectionCreateRequest,
    SLOCorrectionCreateRequestAttributes: SLOCorrectionCreateRequestAttributes_1.SLOCorrectionCreateRequestAttributes,
    SLOCorrectionListResponse: SLOCorrectionListResponse_1.SLOCorrectionListResponse,
    SLOCorrectionResponse: SLOCorrectionResponse_1.SLOCorrectionResponse,
    SLOCorrectionResponseAttributes: SLOCorrectionResponseAttributes_1.SLOCorrectionResponseAttributes,
    SLOCorrectionResponseAttributesModifier: SLOCorrectionResponseAttributesModifier_1.SLOCorrectionResponseAttributesModifier,
    SLOCorrectionUpdateData: SLOCorrectionUpdateData_1.SLOCorrectionUpdateData,
    SLOCorrectionUpdateRequest: SLOCorrectionUpdateRequest_1.SLOCorrectionUpdateRequest,
    SLOCorrectionUpdateRequestAttributes: SLOCorrectionUpdateRequestAttributes_1.SLOCorrectionUpdateRequestAttributes,
    SLOCreator: SLOCreator_1.SLOCreator,
    SLODeleteResponse: SLODeleteResponse_1.SLODeleteResponse,
    SLOHistoryMetrics: SLOHistoryMetrics_1.SLOHistoryMetrics,
    SLOHistoryMetricsSeries: SLOHistoryMetricsSeries_1.SLOHistoryMetricsSeries,
    SLOHistoryMetricsSeriesMetadata: SLOHistoryMetricsSeriesMetadata_1.SLOHistoryMetricsSeriesMetadata,
    SLOHistoryMetricsSeriesMetadataUnit: SLOHistoryMetricsSeriesMetadataUnit_1.SLOHistoryMetricsSeriesMetadataUnit,
    SLOHistoryMonitor: SLOHistoryMonitor_1.SLOHistoryMonitor,
    SLOHistoryResponse: SLOHistoryResponse_1.SLOHistoryResponse,
    SLOHistoryResponseData: SLOHistoryResponseData_1.SLOHistoryResponseData,
    SLOHistoryResponseError: SLOHistoryResponseError_1.SLOHistoryResponseError,
    SLOHistoryResponseErrorWithType: SLOHistoryResponseErrorWithType_1.SLOHistoryResponseErrorWithType,
    SLOHistorySLIData: SLOHistorySLIData_1.SLOHistorySLIData,
    SLOListResponse: SLOListResponse_1.SLOListResponse,
    SLOListResponseMetadata: SLOListResponseMetadata_1.SLOListResponseMetadata,
    SLOListResponseMetadataPage: SLOListResponseMetadataPage_1.SLOListResponseMetadataPage,
    SLOListWidgetDefinition: SLOListWidgetDefinition_1.SLOListWidgetDefinition,
    SLOListWidgetQuery: SLOListWidgetQuery_1.SLOListWidgetQuery,
    SLOListWidgetRequest: SLOListWidgetRequest_1.SLOListWidgetRequest,
    SLOOverallStatuses: SLOOverallStatuses_1.SLOOverallStatuses,
    SLORawErrorBudgetRemaining: SLORawErrorBudgetRemaining_1.SLORawErrorBudgetRemaining,
    SLOResponse: SLOResponse_1.SLOResponse,
    SLOResponseData: SLOResponseData_1.SLOResponseData,
    SLOThreshold: SLOThreshold_1.SLOThreshold,
    SLOWidgetDefinition: SLOWidgetDefinition_1.SLOWidgetDefinition,
    ScatterPlotRequest: ScatterPlotRequest_1.ScatterPlotRequest,
    ScatterPlotWidgetDefinition: ScatterPlotWidgetDefinition_1.ScatterPlotWidgetDefinition,
    ScatterPlotWidgetDefinitionRequests: ScatterPlotWidgetDefinitionRequests_1.ScatterPlotWidgetDefinitionRequests,
    ScatterplotTableRequest: ScatterplotTableRequest_1.ScatterplotTableRequest,
    ScatterplotWidgetFormula: ScatterplotWidgetFormula_1.ScatterplotWidgetFormula,
    SearchSLOQuery: SearchSLOQuery_1.SearchSLOQuery,
    SearchSLOResponse: SearchSLOResponse_1.SearchSLOResponse,
    SearchSLOResponseData: SearchSLOResponseData_1.SearchSLOResponseData,
    SearchSLOResponseDataAttributes: SearchSLOResponseDataAttributes_1.SearchSLOResponseDataAttributes,
    SearchSLOResponseDataAttributesFacets: SearchSLOResponseDataAttributesFacets_1.SearchSLOResponseDataAttributesFacets,
    SearchSLOResponseDataAttributesFacetsObjectInt: SearchSLOResponseDataAttributesFacetsObjectInt_1.SearchSLOResponseDataAttributesFacetsObjectInt,
    SearchSLOResponseDataAttributesFacetsObjectString: SearchSLOResponseDataAttributesFacetsObjectString_1.SearchSLOResponseDataAttributesFacetsObjectString,
    SearchSLOResponseLinks: SearchSLOResponseLinks_1.SearchSLOResponseLinks,
    SearchSLOResponseMeta: SearchSLOResponseMeta_1.SearchSLOResponseMeta,
    SearchSLOResponseMetaPage: SearchSLOResponseMetaPage_1.SearchSLOResponseMetaPage,
    SearchSLOThreshold: SearchSLOThreshold_1.SearchSLOThreshold,
    SearchServiceLevelObjective: SearchServiceLevelObjective_1.SearchServiceLevelObjective,
    SearchServiceLevelObjectiveAttributes: SearchServiceLevelObjectiveAttributes_1.SearchServiceLevelObjectiveAttributes,
    SearchServiceLevelObjectiveData: SearchServiceLevelObjectiveData_1.SearchServiceLevelObjectiveData,
    Series: Series_1.Series,
    ServiceCheck: ServiceCheck_1.ServiceCheck,
    ServiceLevelObjective: ServiceLevelObjective_1.ServiceLevelObjective,
    ServiceLevelObjectiveQuery: ServiceLevelObjectiveQuery_1.ServiceLevelObjectiveQuery,
    ServiceLevelObjectiveRequest: ServiceLevelObjectiveRequest_1.ServiceLevelObjectiveRequest,
    ServiceMapWidgetDefinition: ServiceMapWidgetDefinition_1.ServiceMapWidgetDefinition,
    ServiceSummaryWidgetDefinition: ServiceSummaryWidgetDefinition_1.ServiceSummaryWidgetDefinition,
    SignalAssigneeUpdateRequest: SignalAssigneeUpdateRequest_1.SignalAssigneeUpdateRequest,
    SignalStateUpdateRequest: SignalStateUpdateRequest_1.SignalStateUpdateRequest,
    SlackIntegrationChannel: SlackIntegrationChannel_1.SlackIntegrationChannel,
    SlackIntegrationChannelDisplay: SlackIntegrationChannelDisplay_1.SlackIntegrationChannelDisplay,
    SuccessfulSignalUpdateResponse: SuccessfulSignalUpdateResponse_1.SuccessfulSignalUpdateResponse,
    SunburstWidgetDefinition: SunburstWidgetDefinition_1.SunburstWidgetDefinition,
    SunburstWidgetLegendInlineAutomatic: SunburstWidgetLegendInlineAutomatic_1.SunburstWidgetLegendInlineAutomatic,
    SunburstWidgetLegendTable: SunburstWidgetLegendTable_1.SunburstWidgetLegendTable,
    SunburstWidgetRequest: SunburstWidgetRequest_1.SunburstWidgetRequest,
    SyntheticsAPIStep: SyntheticsAPIStep_1.SyntheticsAPIStep,
    SyntheticsAPITest: SyntheticsAPITest_1.SyntheticsAPITest,
    SyntheticsAPITestConfig: SyntheticsAPITestConfig_1.SyntheticsAPITestConfig,
    SyntheticsAPITestResultData: SyntheticsAPITestResultData_1.SyntheticsAPITestResultData,
    SyntheticsAPITestResultFull: SyntheticsAPITestResultFull_1.SyntheticsAPITestResultFull,
    SyntheticsAPITestResultFullCheck: SyntheticsAPITestResultFullCheck_1.SyntheticsAPITestResultFullCheck,
    SyntheticsAPITestResultShort: SyntheticsAPITestResultShort_1.SyntheticsAPITestResultShort,
    SyntheticsAPITestResultShortResult: SyntheticsAPITestResultShortResult_1.SyntheticsAPITestResultShortResult,
    SyntheticsApiTestResultFailure: SyntheticsApiTestResultFailure_1.SyntheticsApiTestResultFailure,
    SyntheticsAssertionJSONPathTarget: SyntheticsAssertionJSONPathTarget_1.SyntheticsAssertionJSONPathTarget,
    SyntheticsAssertionJSONPathTargetTarget: SyntheticsAssertionJSONPathTargetTarget_1.SyntheticsAssertionJSONPathTargetTarget,
    SyntheticsAssertionTarget: SyntheticsAssertionTarget_1.SyntheticsAssertionTarget,
    SyntheticsAssertionXPathTarget: SyntheticsAssertionXPathTarget_1.SyntheticsAssertionXPathTarget,
    SyntheticsAssertionXPathTargetTarget: SyntheticsAssertionXPathTargetTarget_1.SyntheticsAssertionXPathTargetTarget,
    SyntheticsBasicAuthDigest: SyntheticsBasicAuthDigest_1.SyntheticsBasicAuthDigest,
    SyntheticsBasicAuthNTLM: SyntheticsBasicAuthNTLM_1.SyntheticsBasicAuthNTLM,
    SyntheticsBasicAuthOauthClient: SyntheticsBasicAuthOauthClient_1.SyntheticsBasicAuthOauthClient,
    SyntheticsBasicAuthOauthROP: SyntheticsBasicAuthOauthROP_1.SyntheticsBasicAuthOauthROP,
    SyntheticsBasicAuthSigv4: SyntheticsBasicAuthSigv4_1.SyntheticsBasicAuthSigv4,
    SyntheticsBasicAuthWeb: SyntheticsBasicAuthWeb_1.SyntheticsBasicAuthWeb,
    SyntheticsBatchDetails: SyntheticsBatchDetails_1.SyntheticsBatchDetails,
    SyntheticsBatchDetailsData: SyntheticsBatchDetailsData_1.SyntheticsBatchDetailsData,
    SyntheticsBatchResult: SyntheticsBatchResult_1.SyntheticsBatchResult,
    SyntheticsBrowserError: SyntheticsBrowserError_1.SyntheticsBrowserError,
    SyntheticsBrowserTest: SyntheticsBrowserTest_1.SyntheticsBrowserTest,
    SyntheticsBrowserTestConfig: SyntheticsBrowserTestConfig_1.SyntheticsBrowserTestConfig,
    SyntheticsBrowserTestResultData: SyntheticsBrowserTestResultData_1.SyntheticsBrowserTestResultData,
    SyntheticsBrowserTestResultFailure: SyntheticsBrowserTestResultFailure_1.SyntheticsBrowserTestResultFailure,
    SyntheticsBrowserTestResultFull: SyntheticsBrowserTestResultFull_1.SyntheticsBrowserTestResultFull,
    SyntheticsBrowserTestResultFullCheck: SyntheticsBrowserTestResultFullCheck_1.SyntheticsBrowserTestResultFullCheck,
    SyntheticsBrowserTestResultShort: SyntheticsBrowserTestResultShort_1.SyntheticsBrowserTestResultShort,
    SyntheticsBrowserTestResultShortResult: SyntheticsBrowserTestResultShortResult_1.SyntheticsBrowserTestResultShortResult,
    SyntheticsBrowserTestRumSettings: SyntheticsBrowserTestRumSettings_1.SyntheticsBrowserTestRumSettings,
    SyntheticsBrowserVariable: SyntheticsBrowserVariable_1.SyntheticsBrowserVariable,
    SyntheticsCIBatchMetadata: SyntheticsCIBatchMetadata_1.SyntheticsCIBatchMetadata,
    SyntheticsCIBatchMetadataCI: SyntheticsCIBatchMetadataCI_1.SyntheticsCIBatchMetadataCI,
    SyntheticsCIBatchMetadataGit: SyntheticsCIBatchMetadataGit_1.SyntheticsCIBatchMetadataGit,
    SyntheticsCIBatchMetadataPipeline: SyntheticsCIBatchMetadataPipeline_1.SyntheticsCIBatchMetadataPipeline,
    SyntheticsCIBatchMetadataProvider: SyntheticsCIBatchMetadataProvider_1.SyntheticsCIBatchMetadataProvider,
    SyntheticsCITest: SyntheticsCITest_1.SyntheticsCITest,
    SyntheticsCITestBody: SyntheticsCITestBody_1.SyntheticsCITestBody,
    SyntheticsConfigVariable: SyntheticsConfigVariable_1.SyntheticsConfigVariable,
    SyntheticsCoreWebVitals: SyntheticsCoreWebVitals_1.SyntheticsCoreWebVitals,
    SyntheticsDeleteTestsPayload: SyntheticsDeleteTestsPayload_1.SyntheticsDeleteTestsPayload,
    SyntheticsDeleteTestsResponse: SyntheticsDeleteTestsResponse_1.SyntheticsDeleteTestsResponse,
    SyntheticsDeletedTest: SyntheticsDeletedTest_1.SyntheticsDeletedTest,
    SyntheticsDevice: SyntheticsDevice_1.SyntheticsDevice,
    SyntheticsGetAPITestLatestResultsResponse: SyntheticsGetAPITestLatestResultsResponse_1.SyntheticsGetAPITestLatestResultsResponse,
    SyntheticsGetBrowserTestLatestResultsResponse: SyntheticsGetBrowserTestLatestResultsResponse_1.SyntheticsGetBrowserTestLatestResultsResponse,
    SyntheticsGlobalVariable: SyntheticsGlobalVariable_1.SyntheticsGlobalVariable,
    SyntheticsGlobalVariableAttributes: SyntheticsGlobalVariableAttributes_1.SyntheticsGlobalVariableAttributes,
    SyntheticsGlobalVariableOptions: SyntheticsGlobalVariableOptions_1.SyntheticsGlobalVariableOptions,
    SyntheticsGlobalVariableParseTestOptions: SyntheticsGlobalVariableParseTestOptions_1.SyntheticsGlobalVariableParseTestOptions,
    SyntheticsGlobalVariableTOTPParameters: SyntheticsGlobalVariableTOTPParameters_1.SyntheticsGlobalVariableTOTPParameters,
    SyntheticsGlobalVariableValue: SyntheticsGlobalVariableValue_1.SyntheticsGlobalVariableValue,
    SyntheticsListGlobalVariablesResponse: SyntheticsListGlobalVariablesResponse_1.SyntheticsListGlobalVariablesResponse,
    SyntheticsListTestsResponse: SyntheticsListTestsResponse_1.SyntheticsListTestsResponse,
    SyntheticsLocation: SyntheticsLocation_1.SyntheticsLocation,
    SyntheticsLocations: SyntheticsLocations_1.SyntheticsLocations,
    SyntheticsParsingOptions: SyntheticsParsingOptions_1.SyntheticsParsingOptions,
    SyntheticsPrivateLocation: SyntheticsPrivateLocation_1.SyntheticsPrivateLocation,
    SyntheticsPrivateLocationCreationResponse: SyntheticsPrivateLocationCreationResponse_1.SyntheticsPrivateLocationCreationResponse,
    SyntheticsPrivateLocationCreationResponseResultEncryption: SyntheticsPrivateLocationCreationResponseResultEncryption_1.SyntheticsPrivateLocationCreationResponseResultEncryption,
    SyntheticsPrivateLocationMetadata: SyntheticsPrivateLocationMetadata_1.SyntheticsPrivateLocationMetadata,
    SyntheticsPrivateLocationSecrets: SyntheticsPrivateLocationSecrets_1.SyntheticsPrivateLocationSecrets,
    SyntheticsPrivateLocationSecretsAuthentication: SyntheticsPrivateLocationSecretsAuthentication_1.SyntheticsPrivateLocationSecretsAuthentication,
    SyntheticsPrivateLocationSecretsConfigDecryption: SyntheticsPrivateLocationSecretsConfigDecryption_1.SyntheticsPrivateLocationSecretsConfigDecryption,
    SyntheticsSSLCertificate: SyntheticsSSLCertificate_1.SyntheticsSSLCertificate,
    SyntheticsSSLCertificateIssuer: SyntheticsSSLCertificateIssuer_1.SyntheticsSSLCertificateIssuer,
    SyntheticsSSLCertificateSubject: SyntheticsSSLCertificateSubject_1.SyntheticsSSLCertificateSubject,
    SyntheticsStep: SyntheticsStep_1.SyntheticsStep,
    SyntheticsStepDetail: SyntheticsStepDetail_1.SyntheticsStepDetail,
    SyntheticsStepDetailWarning: SyntheticsStepDetailWarning_1.SyntheticsStepDetailWarning,
    SyntheticsTestCiOptions: SyntheticsTestCiOptions_1.SyntheticsTestCiOptions,
    SyntheticsTestConfig: SyntheticsTestConfig_1.SyntheticsTestConfig,
    SyntheticsTestDetails: SyntheticsTestDetails_1.SyntheticsTestDetails,
    SyntheticsTestOptions: SyntheticsTestOptions_1.SyntheticsTestOptions,
    SyntheticsTestOptionsMonitorOptions: SyntheticsTestOptionsMonitorOptions_1.SyntheticsTestOptionsMonitorOptions,
    SyntheticsTestOptionsRetry: SyntheticsTestOptionsRetry_1.SyntheticsTestOptionsRetry,
    SyntheticsTestOptionsScheduling: SyntheticsTestOptionsScheduling_1.SyntheticsTestOptionsScheduling,
    SyntheticsTestOptionsSchedulingTimeframe: SyntheticsTestOptionsSchedulingTimeframe_1.SyntheticsTestOptionsSchedulingTimeframe,
    SyntheticsTestRequest: SyntheticsTestRequest_1.SyntheticsTestRequest,
    SyntheticsTestRequestCertificate: SyntheticsTestRequestCertificate_1.SyntheticsTestRequestCertificate,
    SyntheticsTestRequestCertificateItem: SyntheticsTestRequestCertificateItem_1.SyntheticsTestRequestCertificateItem,
    SyntheticsTestRequestProxy: SyntheticsTestRequestProxy_1.SyntheticsTestRequestProxy,
    SyntheticsTiming: SyntheticsTiming_1.SyntheticsTiming,
    SyntheticsTriggerBody: SyntheticsTriggerBody_1.SyntheticsTriggerBody,
    SyntheticsTriggerCITestLocation: SyntheticsTriggerCITestLocation_1.SyntheticsTriggerCITestLocation,
    SyntheticsTriggerCITestRunResult: SyntheticsTriggerCITestRunResult_1.SyntheticsTriggerCITestRunResult,
    SyntheticsTriggerCITestsResponse: SyntheticsTriggerCITestsResponse_1.SyntheticsTriggerCITestsResponse,
    SyntheticsTriggerTest: SyntheticsTriggerTest_1.SyntheticsTriggerTest,
    SyntheticsUpdateTestPauseStatusPayload: SyntheticsUpdateTestPauseStatusPayload_1.SyntheticsUpdateTestPauseStatusPayload,
    SyntheticsVariableParser: SyntheticsVariableParser_1.SyntheticsVariableParser,
    TableWidgetDefinition: TableWidgetDefinition_1.TableWidgetDefinition,
    TableWidgetRequest: TableWidgetRequest_1.TableWidgetRequest,
    TagToHosts: TagToHosts_1.TagToHosts,
    TimeseriesBackground: TimeseriesBackground_1.TimeseriesBackground,
    TimeseriesWidgetDefinition: TimeseriesWidgetDefinition_1.TimeseriesWidgetDefinition,
    TimeseriesWidgetExpressionAlias: TimeseriesWidgetExpressionAlias_1.TimeseriesWidgetExpressionAlias,
    TimeseriesWidgetRequest: TimeseriesWidgetRequest_1.TimeseriesWidgetRequest,
    ToplistWidgetDefinition: ToplistWidgetDefinition_1.ToplistWidgetDefinition,
    ToplistWidgetRequest: ToplistWidgetRequest_1.ToplistWidgetRequest,
    TopologyMapWidgetDefinition: TopologyMapWidgetDefinition_1.TopologyMapWidgetDefinition,
    TopologyQuery: TopologyQuery_1.TopologyQuery,
    TopologyRequest: TopologyRequest_1.TopologyRequest,
    TreeMapWidgetDefinition: TreeMapWidgetDefinition_1.TreeMapWidgetDefinition,
    TreeMapWidgetRequest: TreeMapWidgetRequest_1.TreeMapWidgetRequest,
    UsageAnalyzedLogsHour: UsageAnalyzedLogsHour_1.UsageAnalyzedLogsHour,
    UsageAnalyzedLogsResponse: UsageAnalyzedLogsResponse_1.UsageAnalyzedLogsResponse,
    UsageAttributionAggregatesBody: UsageAttributionAggregatesBody_1.UsageAttributionAggregatesBody,
    UsageAttributionBody: UsageAttributionBody_1.UsageAttributionBody,
    UsageAttributionMetadata: UsageAttributionMetadata_1.UsageAttributionMetadata,
    UsageAttributionPagination: UsageAttributionPagination_1.UsageAttributionPagination,
    UsageAttributionResponse: UsageAttributionResponse_1.UsageAttributionResponse,
    UsageAttributionValues: UsageAttributionValues_1.UsageAttributionValues,
    UsageAuditLogsHour: UsageAuditLogsHour_1.UsageAuditLogsHour,
    UsageAuditLogsResponse: UsageAuditLogsResponse_1.UsageAuditLogsResponse,
    UsageBillableSummaryBody: UsageBillableSummaryBody_1.UsageBillableSummaryBody,
    UsageBillableSummaryHour: UsageBillableSummaryHour_1.UsageBillableSummaryHour,
    UsageBillableSummaryKeys: UsageBillableSummaryKeys_1.UsageBillableSummaryKeys,
    UsageBillableSummaryResponse: UsageBillableSummaryResponse_1.UsageBillableSummaryResponse,
    UsageCIVisibilityHour: UsageCIVisibilityHour_1.UsageCIVisibilityHour,
    UsageCIVisibilityResponse: UsageCIVisibilityResponse_1.UsageCIVisibilityResponse,
    UsageCWSHour: UsageCWSHour_1.UsageCWSHour,
    UsageCWSResponse: UsageCWSResponse_1.UsageCWSResponse,
    UsageCloudSecurityPostureManagementHour: UsageCloudSecurityPostureManagementHour_1.UsageCloudSecurityPostureManagementHour,
    UsageCloudSecurityPostureManagementResponse: UsageCloudSecurityPostureManagementResponse_1.UsageCloudSecurityPostureManagementResponse,
    UsageCustomReportsAttributes: UsageCustomReportsAttributes_1.UsageCustomReportsAttributes,
    UsageCustomReportsData: UsageCustomReportsData_1.UsageCustomReportsData,
    UsageCustomReportsMeta: UsageCustomReportsMeta_1.UsageCustomReportsMeta,
    UsageCustomReportsPage: UsageCustomReportsPage_1.UsageCustomReportsPage,
    UsageCustomReportsResponse: UsageCustomReportsResponse_1.UsageCustomReportsResponse,
    UsageDBMHour: UsageDBMHour_1.UsageDBMHour,
    UsageDBMResponse: UsageDBMResponse_1.UsageDBMResponse,
    UsageFargateHour: UsageFargateHour_1.UsageFargateHour,
    UsageFargateResponse: UsageFargateResponse_1.UsageFargateResponse,
    UsageHostHour: UsageHostHour_1.UsageHostHour,
    UsageHostsResponse: UsageHostsResponse_1.UsageHostsResponse,
    UsageIncidentManagementHour: UsageIncidentManagementHour_1.UsageIncidentManagementHour,
    UsageIncidentManagementResponse: UsageIncidentManagementResponse_1.UsageIncidentManagementResponse,
    UsageIndexedSpansHour: UsageIndexedSpansHour_1.UsageIndexedSpansHour,
    UsageIndexedSpansResponse: UsageIndexedSpansResponse_1.UsageIndexedSpansResponse,
    UsageIngestedSpansHour: UsageIngestedSpansHour_1.UsageIngestedSpansHour,
    UsageIngestedSpansResponse: UsageIngestedSpansResponse_1.UsageIngestedSpansResponse,
    UsageIoTHour: UsageIoTHour_1.UsageIoTHour,
    UsageIoTResponse: UsageIoTResponse_1.UsageIoTResponse,
    UsageLambdaHour: UsageLambdaHour_1.UsageLambdaHour,
    UsageLambdaResponse: UsageLambdaResponse_1.UsageLambdaResponse,
    UsageLogsByIndexHour: UsageLogsByIndexHour_1.UsageLogsByIndexHour,
    UsageLogsByIndexResponse: UsageLogsByIndexResponse_1.UsageLogsByIndexResponse,
    UsageLogsByRetentionHour: UsageLogsByRetentionHour_1.UsageLogsByRetentionHour,
    UsageLogsByRetentionResponse: UsageLogsByRetentionResponse_1.UsageLogsByRetentionResponse,
    UsageLogsHour: UsageLogsHour_1.UsageLogsHour,
    UsageLogsResponse: UsageLogsResponse_1.UsageLogsResponse,
    UsageNetworkFlowsHour: UsageNetworkFlowsHour_1.UsageNetworkFlowsHour,
    UsageNetworkFlowsResponse: UsageNetworkFlowsResponse_1.UsageNetworkFlowsResponse,
    UsageNetworkHostsHour: UsageNetworkHostsHour_1.UsageNetworkHostsHour,
    UsageNetworkHostsResponse: UsageNetworkHostsResponse_1.UsageNetworkHostsResponse,
    UsageOnlineArchiveHour: UsageOnlineArchiveHour_1.UsageOnlineArchiveHour,
    UsageOnlineArchiveResponse: UsageOnlineArchiveResponse_1.UsageOnlineArchiveResponse,
    UsageProfilingHour: UsageProfilingHour_1.UsageProfilingHour,
    UsageProfilingResponse: UsageProfilingResponse_1.UsageProfilingResponse,
    UsageRumSessionsHour: UsageRumSessionsHour_1.UsageRumSessionsHour,
    UsageRumSessionsResponse: UsageRumSessionsResponse_1.UsageRumSessionsResponse,
    UsageRumUnitsHour: UsageRumUnitsHour_1.UsageRumUnitsHour,
    UsageRumUnitsResponse: UsageRumUnitsResponse_1.UsageRumUnitsResponse,
    UsageSDSHour: UsageSDSHour_1.UsageSDSHour,
    UsageSDSResponse: UsageSDSResponse_1.UsageSDSResponse,
    UsageSNMPHour: UsageSNMPHour_1.UsageSNMPHour,
    UsageSNMPResponse: UsageSNMPResponse_1.UsageSNMPResponse,
    UsageSpecifiedCustomReportsAttributes: UsageSpecifiedCustomReportsAttributes_1.UsageSpecifiedCustomReportsAttributes,
    UsageSpecifiedCustomReportsData: UsageSpecifiedCustomReportsData_1.UsageSpecifiedCustomReportsData,
    UsageSpecifiedCustomReportsMeta: UsageSpecifiedCustomReportsMeta_1.UsageSpecifiedCustomReportsMeta,
    UsageSpecifiedCustomReportsPage: UsageSpecifiedCustomReportsPage_1.UsageSpecifiedCustomReportsPage,
    UsageSpecifiedCustomReportsResponse: UsageSpecifiedCustomReportsResponse_1.UsageSpecifiedCustomReportsResponse,
    UsageSummaryDate: UsageSummaryDate_1.UsageSummaryDate,
    UsageSummaryDateOrg: UsageSummaryDateOrg_1.UsageSummaryDateOrg,
    UsageSummaryResponse: UsageSummaryResponse_1.UsageSummaryResponse,
    UsageSyntheticsAPIHour: UsageSyntheticsAPIHour_1.UsageSyntheticsAPIHour,
    UsageSyntheticsAPIResponse: UsageSyntheticsAPIResponse_1.UsageSyntheticsAPIResponse,
    UsageSyntheticsBrowserHour: UsageSyntheticsBrowserHour_1.UsageSyntheticsBrowserHour,
    UsageSyntheticsBrowserResponse: UsageSyntheticsBrowserResponse_1.UsageSyntheticsBrowserResponse,
    UsageSyntheticsHour: UsageSyntheticsHour_1.UsageSyntheticsHour,
    UsageSyntheticsResponse: UsageSyntheticsResponse_1.UsageSyntheticsResponse,
    UsageTimeseriesHour: UsageTimeseriesHour_1.UsageTimeseriesHour,
    UsageTimeseriesResponse: UsageTimeseriesResponse_1.UsageTimeseriesResponse,
    UsageTopAvgMetricsHour: UsageTopAvgMetricsHour_1.UsageTopAvgMetricsHour,
    UsageTopAvgMetricsMetadata: UsageTopAvgMetricsMetadata_1.UsageTopAvgMetricsMetadata,
    UsageTopAvgMetricsPagination: UsageTopAvgMetricsPagination_1.UsageTopAvgMetricsPagination,
    UsageTopAvgMetricsResponse: UsageTopAvgMetricsResponse_1.UsageTopAvgMetricsResponse,
    User: User_1.User,
    UserDisableResponse: UserDisableResponse_1.UserDisableResponse,
    UserListResponse: UserListResponse_1.UserListResponse,
    UserResponse: UserResponse_1.UserResponse,
    WebhooksIntegration: WebhooksIntegration_1.WebhooksIntegration,
    WebhooksIntegrationCustomVariable: WebhooksIntegrationCustomVariable_1.WebhooksIntegrationCustomVariable,
    WebhooksIntegrationCustomVariableResponse: WebhooksIntegrationCustomVariableResponse_1.WebhooksIntegrationCustomVariableResponse,
    WebhooksIntegrationCustomVariableUpdateRequest: WebhooksIntegrationCustomVariableUpdateRequest_1.WebhooksIntegrationCustomVariableUpdateRequest,
    WebhooksIntegrationUpdateRequest: WebhooksIntegrationUpdateRequest_1.WebhooksIntegrationUpdateRequest,
    Widget: Widget_1.Widget,
    WidgetAxis: WidgetAxis_1.WidgetAxis,
    WidgetConditionalFormat: WidgetConditionalFormat_1.WidgetConditionalFormat,
    WidgetCustomLink: WidgetCustomLink_1.WidgetCustomLink,
    WidgetEvent: WidgetEvent_1.WidgetEvent,
    WidgetFieldSort: WidgetFieldSort_1.WidgetFieldSort,
    WidgetFormula: WidgetFormula_1.WidgetFormula,
    WidgetFormulaLimit: WidgetFormulaLimit_1.WidgetFormulaLimit,
    WidgetFormulaStyle: WidgetFormulaStyle_1.WidgetFormulaStyle,
    WidgetLayout: WidgetLayout_1.WidgetLayout,
    WidgetMarker: WidgetMarker_1.WidgetMarker,
    WidgetRequestStyle: WidgetRequestStyle_1.WidgetRequestStyle,
    WidgetStyle: WidgetStyle_1.WidgetStyle,
    WidgetTime: WidgetTime_1.WidgetTime,
};
const oneOfMap = {
    DistributionPointItem: ["number", "Array<number>"],
    DistributionWidgetHistogramRequestQuery: [
        "FormulaAndFunctionMetricQueryDefinition",
        "FormulaAndFunctionEventQueryDefinition",
        "FormulaAndFunctionApmResourceStatsQueryDefinition",
    ],
    FormulaAndFunctionQueryDefinition: [
        "FormulaAndFunctionMetricQueryDefinition",
        "FormulaAndFunctionEventQueryDefinition",
        "FormulaAndFunctionProcessQueryDefinition",
        "FormulaAndFunctionApmDependencyStatsQueryDefinition",
        "FormulaAndFunctionApmResourceStatsQueryDefinition",
    ],
    LogsProcessor: [
        "LogsGrokParser",
        "LogsDateRemapper",
        "LogsStatusRemapper",
        "LogsServiceRemapper",
        "LogsMessageRemapper",
        "LogsAttributeRemapper",
        "LogsURLParser",
        "LogsUserAgentParser",
        "LogsCategoryProcessor",
        "LogsArithmeticProcessor",
        "LogsStringBuilderProcessor",
        "LogsPipelineProcessor",
        "LogsGeoIPParser",
        "LogsLookupProcessor",
        "ReferenceTableLogsLookupProcessor",
        "LogsTraceRemapper",
    ],
    MonitorFormulaAndFunctionQueryDefinition: [
        "MonitorFormulaAndFunctionEventQueryDefinition",
    ],
    NotebookCellCreateRequestAttributes: [
        "NotebookMarkdownCellAttributes",
        "NotebookTimeseriesCellAttributes",
        "NotebookToplistCellAttributes",
        "NotebookHeatMapCellAttributes",
        "NotebookDistributionCellAttributes",
        "NotebookLogStreamCellAttributes",
    ],
    NotebookCellResponseAttributes: [
        "NotebookMarkdownCellAttributes",
        "NotebookTimeseriesCellAttributes",
        "NotebookToplistCellAttributes",
        "NotebookHeatMapCellAttributes",
        "NotebookDistributionCellAttributes",
        "NotebookLogStreamCellAttributes",
    ],
    NotebookCellTime: ["NotebookRelativeTime", "NotebookAbsoluteTime"],
    NotebookCellUpdateRequestAttributes: [
        "NotebookMarkdownCellAttributes",
        "NotebookTimeseriesCellAttributes",
        "NotebookToplistCellAttributes",
        "NotebookHeatMapCellAttributes",
        "NotebookDistributionCellAttributes",
        "NotebookLogStreamCellAttributes",
    ],
    NotebookGlobalTime: ["NotebookRelativeTime", "NotebookAbsoluteTime"],
    NotebookUpdateCell: [
        "NotebookCellCreateRequest",
        "NotebookCellUpdateRequest",
    ],
    SunburstWidgetLegend: [
        "SunburstWidgetLegendTable",
        "SunburstWidgetLegendInlineAutomatic",
    ],
    SyntheticsAssertion: [
        "SyntheticsAssertionTarget",
        "SyntheticsAssertionJSONPathTarget",
        "SyntheticsAssertionXPathTarget",
    ],
    SyntheticsBasicAuth: [
        "SyntheticsBasicAuthWeb",
        "SyntheticsBasicAuthSigv4",
        "SyntheticsBasicAuthNTLM",
        "SyntheticsBasicAuthDigest",
        "SyntheticsBasicAuthOauthClient",
        "SyntheticsBasicAuthOauthROP",
    ],
    WidgetDefinition: [
        "AlertGraphWidgetDefinition",
        "AlertValueWidgetDefinition",
        "ChangeWidgetDefinition",
        "CheckStatusWidgetDefinition",
        "DistributionWidgetDefinition",
        "EventStreamWidgetDefinition",
        "EventTimelineWidgetDefinition",
        "FreeTextWidgetDefinition",
        "GeomapWidgetDefinition",
        "GroupWidgetDefinition",
        "HeatMapWidgetDefinition",
        "HostMapWidgetDefinition",
        "IFrameWidgetDefinition",
        "ImageWidgetDefinition",
        "LogStreamWidgetDefinition",
        "MonitorSummaryWidgetDefinition",
        "NoteWidgetDefinition",
        "QueryValueWidgetDefinition",
        "RunWorkflowWidgetDefinition",
        "ScatterPlotWidgetDefinition",
        "SLOWidgetDefinition",
        "SLOListWidgetDefinition",
        "ServiceMapWidgetDefinition",
        "ServiceSummaryWidgetDefinition",
        "SunburstWidgetDefinition",
        "TableWidgetDefinition",
        "TimeseriesWidgetDefinition",
        "ToplistWidgetDefinition",
        "TreeMapWidgetDefinition",
        "ListStreamWidgetDefinition",
        "FunnelWidgetDefinition",
        "TopologyMapWidgetDefinition",
    ],
};
class ObjectSerializer {
    static serialize(data, type, format) {
        if (data == undefined || type == "any") {
            return data;
        }
        else if (data instanceof util_1.UnparsedObject) {
            return data._data;
        }
        else if (primitives.includes(type.toLowerCase()) &&
            typeof data == type.toLowerCase()) {
            return data;
        }
        else if (type.startsWith(ARRAY_PREFIX)) {
            if (!Array.isArray(data)) {
                throw new TypeError(`mismatch types '${data}' and '${type}'`);
            }
            // Array<Type> => Type
            const subType = type.substring(ARRAY_PREFIX.length, type.length - 1);
            const transformedData = [];
            for (const element of data) {
                transformedData.push(ObjectSerializer.serialize(element, subType, format));
            }
            return transformedData;
        }
        else if (type.startsWith(TUPLE_PREFIX)) {
            // We only support homegeneus tuples
            const subType = type
                .substring(TUPLE_PREFIX.length, type.length - 1)
                .split(", ")[0];
            const transformedData = [];
            for (const element of data) {
                transformedData.push(ObjectSerializer.serialize(element, subType, format));
            }
            return transformedData;
        }
        else if (type.startsWith(MAP_PREFIX)) {
            // { [key: string]: Type; } => Type
            const subType = type.substring(MAP_PREFIX.length, type.length - 3);
            const transformedData = {};
            for (const key in data) {
                transformedData[key] = ObjectSerializer.serialize(data[key], subType, format);
            }
            return transformedData;
        }
        else if (type === "Date") {
            if ("string" == typeof data) {
                return data;
            }
            if (format == "date" || format == "date-time") {
                return (0, util_1.dateToRFC3339String)(data);
            }
            else {
                return data.toISOString();
            }
        }
        else {
            if (enumsMap[type]) {
                if (enumsMap[type].includes(data)) {
                    return data;
                }
                throw new TypeError(`unknown enum value '${data}'`);
            }
            if (oneOfMap[type]) {
                const oneOfs = [];
                for (const oneOf of oneOfMap[type]) {
                    try {
                        oneOfs.push(ObjectSerializer.serialize(data, oneOf, format));
                    }
                    catch (e) {
                        logger_1.logger.debug(`could not serialize ${oneOf} (${e})`);
                    }
                }
                if (oneOfs.length > 1) {
                    throw new TypeError(`${data} matches multiple types from ${oneOfMap[type]} ${oneOfs}`);
                }
                if (oneOfs.length == 0) {
                    throw new TypeError(`${data} doesn't match any type from ${oneOfMap[type]} ${oneOfs}`);
                }
                return oneOfs[0];
            }
            if (!typeMap[type]) {
                // dont know the type
                throw new TypeError(`unknown type '${type}'`);
            }
            // get the map for the correct type.
            const attributesMap = typeMap[type].getAttributeTypeMap();
            const instance = {};
            for (const attributeName in attributesMap) {
                const attributeObj = attributesMap[attributeName];
                if (attributeName == "additionalProperties") {
                    if (data.additionalProperties) {
                        for (const key in data.additionalProperties) {
                            instance[key] = ObjectSerializer.serialize(data.additionalProperties[key], attributeObj.type, attributeObj.format);
                        }
                    }
                    continue;
                }
                instance[attributeObj.baseName] = ObjectSerializer.serialize(data[attributeName], attributeObj.type, attributeObj.format);
                // check for required properties
                if ((attributeObj === null || attributeObj === void 0 ? void 0 : attributeObj.required) &&
                    instance[attributeObj.baseName] === undefined) {
                    throw new Error(`missing required property '${attributeObj.baseName}'`);
                }
            }
            return instance;
        }
    }
    static deserialize(data, type, format = "") {
        var _a;
        if (data == undefined || type == "any") {
            return data;
        }
        else if (primitives.includes(type.toLowerCase()) &&
            typeof data == type.toLowerCase()) {
            return data;
        }
        else if (type.startsWith(ARRAY_PREFIX)) {
            // Assert the passed data is Array type
            if (!Array.isArray(data)) {
                throw new TypeError(`mismatch types '${data}' and '${type}'`);
            }
            // Array<Type> => Type
            const subType = type.substring(ARRAY_PREFIX.length, type.length - 1);
            const transformedData = [];
            for (const element of data) {
                transformedData.push(ObjectSerializer.deserialize(element, subType, format));
            }
            return transformedData;
        }
        else if (type.startsWith(TUPLE_PREFIX)) {
            // [Type,...] => Type
            const subType = type
                .substring(TUPLE_PREFIX.length, type.length - 1)
                .split(", ")[0];
            const transformedData = [];
            for (const element of data) {
                transformedData.push(ObjectSerializer.deserialize(element, subType, format));
            }
            return transformedData;
        }
        else if (type.startsWith(MAP_PREFIX)) {
            // { [key: string]: Type; } => Type
            const subType = type.substring(MAP_PREFIX.length, type.length - 3);
            const transformedData = {};
            for (const key in data) {
                transformedData[key] = ObjectSerializer.deserialize(data[key], subType, format);
            }
            return transformedData;
        }
        else if (type === "Date") {
            return (0, util_1.dateFromRFC3339String)(data);
        }
        else {
            if (enumsMap[type]) {
                if (enumsMap[type].includes(data)) {
                    return data;
                }
                return new util_1.UnparsedObject(data);
            }
            if (oneOfMap[type]) {
                const oneOfs = [];
                for (const oneOf of oneOfMap[type]) {
                    try {
                        const d = ObjectSerializer.deserialize(data, oneOf, format);
                        if (!(d === null || d === void 0 ? void 0 : d._unparsed)) {
                            oneOfs.push(d);
                        }
                    }
                    catch (e) {
                        logger_1.logger.debug(`could not deserialize ${oneOf} (${e})`);
                    }
                }
                if (oneOfs.length != 1) {
                    return new util_1.UnparsedObject(data);
                }
                return oneOfs[0];
            }
            if (!typeMap[type]) {
                // dont know the type
                throw new TypeError(`unknown type '${type}'`);
            }
            const instance = new typeMap[type]();
            const attributesMap = typeMap[type].getAttributeTypeMap();
            let extraAttributes = [];
            if ("additionalProperties" in attributesMap) {
                const attributesBaseNames = Object.keys(attributesMap).reduce((o, key) => Object.assign(o, { [attributesMap[key].baseName]: "" }), {});
                extraAttributes = Object.keys(data).filter((key) => !Object.prototype.hasOwnProperty.call(attributesBaseNames, key));
            }
            for (const attributeName in attributesMap) {
                const attributeObj = attributesMap[attributeName];
                if (attributeName == "additionalProperties") {
                    if (extraAttributes.length > 0) {
                        if (!instance.additionalProperties) {
                            instance.additionalProperties = {};
                        }
                        for (const key in extraAttributes) {
                            instance.additionalProperties[extraAttributes[key]] =
                                ObjectSerializer.deserialize(data[extraAttributes[key]], attributeObj.type, attributeObj.format);
                        }
                    }
                    continue;
                }
                instance[attributeName] = ObjectSerializer.deserialize(data[attributeObj.baseName], attributeObj.type, attributeObj.format);
                // check for required properties
                if ((attributeObj === null || attributeObj === void 0 ? void 0 : attributeObj.required) && instance[attributeName] === undefined) {
                    throw new Error(`missing required property '${attributeName}'`);
                }
                if (instance[attributeName] instanceof util_1.UnparsedObject ||
                    ((_a = instance[attributeName]) === null || _a === void 0 ? void 0 : _a._unparsed)) {
                    instance._unparsed = true;
                }
                if (Array.isArray(instance[attributeName])) {
                    for (const d of instance[attributeName]) {
                        if (d instanceof util_1.UnparsedObject || (d === null || d === void 0 ? void 0 : d._unparsed)) {
                            instance._unparsed = true;
                            break;
                        }
                    }
                }
            }
            return instance;
        }
    }
    /**
     * Normalize media type
     *
     * We currently do not handle any media types attributes, i.e. anything
     * after a semicolon. All content is assumed to be UTF-8 compatible.
     */
    static normalizeMediaType(mediaType) {
        if (mediaType === undefined) {
            return undefined;
        }
        return mediaType.split(";")[0].trim().toLowerCase();
    }
    /**
     * From a list of possible media types, choose the one we can handle best.
     *
     * The order of the given media types does not have any impact on the choice
     * made.
     */
    static getPreferredMediaType(mediaTypes) {
        /** According to OAS 3 we should default to json */
        if (!mediaTypes) {
            return "application/json";
        }
        const normalMediaTypes = mediaTypes.map(this.normalizeMediaType);
        let selectedMediaType = undefined;
        let selectedRank = -Infinity;
        for (const mediaType of normalMediaTypes) {
            if (mediaType === undefined) {
                continue;
            }
            const supported = supportedMediaTypes[mediaType];
            if (supported !== undefined && supported > selectedRank) {
                selectedMediaType = mediaType;
                selectedRank = supported;
            }
        }
        if (selectedMediaType === undefined) {
            throw new Error("None of the given media types are supported: " + mediaTypes.join(", "));
        }
        return selectedMediaType;
    }
    /**
     * Convert data to a string according the given media type
     */
    static stringify(data, mediaType) {
        if (mediaType === "application/json" || mediaType === "text/json") {
            return JSON.stringify(data);
        }
        throw new Error("The mediaType " +
            mediaType +
            " is not supported by ObjectSerializer.stringify.");
    }
    /**
     * Parse data from a string according to the given media type
     */
    static parse(rawData, mediaType) {
        try {
            return JSON.parse(rawData);
        }
        catch (error) {
            logger_1.logger.debug(`could not parse ${mediaType}: ${error}`);
            return rawData;
        }
    }
}
exports.ObjectSerializer = ObjectSerializer;
//# sourceMappingURL=ObjectSerializer.js.map

/***/ }),

/***/ 15364:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrgDowngradedResponse = void 0;
/**
 * Status of downgrade
 */
class OrgDowngradedResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OrgDowngradedResponse.attributeTypeMap;
    }
}
exports.OrgDowngradedResponse = OrgDowngradedResponse;
/**
 * @ignore
 */
OrgDowngradedResponse.attributeTypeMap = {
    message: {
        baseName: "message",
        type: "string",
    },
};
//# sourceMappingURL=OrgDowngradedResponse.js.map

/***/ }),

/***/ 5080:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Organization = void 0;
/**
 * Create, edit, and manage organizations.
 */
class Organization {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return Organization.attributeTypeMap;
    }
}
exports.Organization = Organization;
/**
 * @ignore
 */
Organization.attributeTypeMap = {
    billing: {
        baseName: "billing",
        type: "OrganizationBilling",
    },
    created: {
        baseName: "created",
        type: "string",
    },
    description: {
        baseName: "description",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    settings: {
        baseName: "settings",
        type: "OrganizationSettings",
    },
    subscription: {
        baseName: "subscription",
        type: "OrganizationSubscription",
    },
    trial: {
        baseName: "trial",
        type: "boolean",
    },
};
//# sourceMappingURL=Organization.js.map

/***/ }),

/***/ 89008:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrganizationBilling = void 0;
/**
 * A JSON array of billing type.
 */
class OrganizationBilling {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OrganizationBilling.attributeTypeMap;
    }
}
exports.OrganizationBilling = OrganizationBilling;
/**
 * @ignore
 */
OrganizationBilling.attributeTypeMap = {
    type: {
        baseName: "type",
        type: "string",
    },
};
//# sourceMappingURL=OrganizationBilling.js.map

/***/ }),

/***/ 16132:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrganizationCreateBody = void 0;
/**
 * Object describing an organization to create.
 */
class OrganizationCreateBody {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OrganizationCreateBody.attributeTypeMap;
    }
}
exports.OrganizationCreateBody = OrganizationCreateBody;
/**
 * @ignore
 */
OrganizationCreateBody.attributeTypeMap = {
    billing: {
        baseName: "billing",
        type: "OrganizationBilling",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    subscription: {
        baseName: "subscription",
        type: "OrganizationSubscription",
    },
};
//# sourceMappingURL=OrganizationCreateBody.js.map

/***/ }),

/***/ 24007:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrganizationCreateResponse = void 0;
/**
 * Response object for an organization creation.
 */
class OrganizationCreateResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OrganizationCreateResponse.attributeTypeMap;
    }
}
exports.OrganizationCreateResponse = OrganizationCreateResponse;
/**
 * @ignore
 */
OrganizationCreateResponse.attributeTypeMap = {
    apiKey: {
        baseName: "api_key",
        type: "ApiKey",
    },
    applicationKey: {
        baseName: "application_key",
        type: "ApplicationKey",
    },
    org: {
        baseName: "org",
        type: "Organization",
    },
    user: {
        baseName: "user",
        type: "User",
    },
};
//# sourceMappingURL=OrganizationCreateResponse.js.map

/***/ }),

/***/ 67823:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrganizationListResponse = void 0;
/**
 * Response with the list of organizations.
 */
class OrganizationListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OrganizationListResponse.attributeTypeMap;
    }
}
exports.OrganizationListResponse = OrganizationListResponse;
/**
 * @ignore
 */
OrganizationListResponse.attributeTypeMap = {
    orgs: {
        baseName: "orgs",
        type: "Array<Organization>",
    },
};
//# sourceMappingURL=OrganizationListResponse.js.map

/***/ }),

/***/ 58106:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrganizationResponse = void 0;
/**
 * Response with an organization.
 */
class OrganizationResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OrganizationResponse.attributeTypeMap;
    }
}
exports.OrganizationResponse = OrganizationResponse;
/**
 * @ignore
 */
OrganizationResponse.attributeTypeMap = {
    org: {
        baseName: "org",
        type: "Organization",
    },
};
//# sourceMappingURL=OrganizationResponse.js.map

/***/ }),

/***/ 49434:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrganizationSettings = void 0;
/**
 * A JSON array of settings.
 */
class OrganizationSettings {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OrganizationSettings.attributeTypeMap;
    }
}
exports.OrganizationSettings = OrganizationSettings;
/**
 * @ignore
 */
OrganizationSettings.attributeTypeMap = {
    privateWidgetShare: {
        baseName: "private_widget_share",
        type: "boolean",
    },
    saml: {
        baseName: "saml",
        type: "OrganizationSettingsSaml",
    },
    samlAutocreateAccessRole: {
        baseName: "saml_autocreate_access_role",
        type: "AccessRole",
    },
    samlAutocreateUsersDomains: {
        baseName: "saml_autocreate_users_domains",
        type: "OrganizationSettingsSamlAutocreateUsersDomains",
    },
    samlCanBeEnabled: {
        baseName: "saml_can_be_enabled",
        type: "boolean",
    },
    samlIdpEndpoint: {
        baseName: "saml_idp_endpoint",
        type: "string",
    },
    samlIdpInitiatedLogin: {
        baseName: "saml_idp_initiated_login",
        type: "OrganizationSettingsSamlIdpInitiatedLogin",
    },
    samlIdpMetadataUploaded: {
        baseName: "saml_idp_metadata_uploaded",
        type: "boolean",
    },
    samlLoginUrl: {
        baseName: "saml_login_url",
        type: "string",
    },
    samlStrictMode: {
        baseName: "saml_strict_mode",
        type: "OrganizationSettingsSamlStrictMode",
    },
};
//# sourceMappingURL=OrganizationSettings.js.map

/***/ }),

/***/ 23808:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrganizationSettingsSaml = void 0;
/**
 * Set the boolean property enabled to enable or disable single sign on with SAML.
 * See the SAML documentation for more information about all SAML settings.
 */
class OrganizationSettingsSaml {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OrganizationSettingsSaml.attributeTypeMap;
    }
}
exports.OrganizationSettingsSaml = OrganizationSettingsSaml;
/**
 * @ignore
 */
OrganizationSettingsSaml.attributeTypeMap = {
    enabled: {
        baseName: "enabled",
        type: "boolean",
    },
};
//# sourceMappingURL=OrganizationSettingsSaml.js.map

/***/ }),

/***/ 83448:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrganizationSettingsSamlAutocreateUsersDomains = void 0;
/**
 * Has two properties, `enabled` (boolean) and `domains`, which is a list of domains without the @ symbol.
 */
class OrganizationSettingsSamlAutocreateUsersDomains {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OrganizationSettingsSamlAutocreateUsersDomains.attributeTypeMap;
    }
}
exports.OrganizationSettingsSamlAutocreateUsersDomains = OrganizationSettingsSamlAutocreateUsersDomains;
/**
 * @ignore
 */
OrganizationSettingsSamlAutocreateUsersDomains.attributeTypeMap = {
    domains: {
        baseName: "domains",
        type: "Array<string>",
    },
    enabled: {
        baseName: "enabled",
        type: "boolean",
    },
};
//# sourceMappingURL=OrganizationSettingsSamlAutocreateUsersDomains.js.map

/***/ }),

/***/ 79957:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrganizationSettingsSamlIdpInitiatedLogin = void 0;
/**
 * Has one property enabled (boolean).
 */
class OrganizationSettingsSamlIdpInitiatedLogin {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OrganizationSettingsSamlIdpInitiatedLogin.attributeTypeMap;
    }
}
exports.OrganizationSettingsSamlIdpInitiatedLogin = OrganizationSettingsSamlIdpInitiatedLogin;
/**
 * @ignore
 */
OrganizationSettingsSamlIdpInitiatedLogin.attributeTypeMap = {
    enabled: {
        baseName: "enabled",
        type: "boolean",
    },
};
//# sourceMappingURL=OrganizationSettingsSamlIdpInitiatedLogin.js.map

/***/ }),

/***/ 21101:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrganizationSettingsSamlStrictMode = void 0;
/**
 * Has one property enabled (boolean).
 */
class OrganizationSettingsSamlStrictMode {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OrganizationSettingsSamlStrictMode.attributeTypeMap;
    }
}
exports.OrganizationSettingsSamlStrictMode = OrganizationSettingsSamlStrictMode;
/**
 * @ignore
 */
OrganizationSettingsSamlStrictMode.attributeTypeMap = {
    enabled: {
        baseName: "enabled",
        type: "boolean",
    },
};
//# sourceMappingURL=OrganizationSettingsSamlStrictMode.js.map

/***/ }),

/***/ 75122:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrganizationSubscription = void 0;
/**
 * Subscription definition.
 */
class OrganizationSubscription {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OrganizationSubscription.attributeTypeMap;
    }
}
exports.OrganizationSubscription = OrganizationSubscription;
/**
 * @ignore
 */
OrganizationSubscription.attributeTypeMap = {
    type: {
        baseName: "type",
        type: "string",
    },
};
//# sourceMappingURL=OrganizationSubscription.js.map

/***/ }),

/***/ 99433:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PagerDutyService = void 0;
/**
 * The PagerDuty service that is available for integration with Datadog.
 */
class PagerDutyService {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return PagerDutyService.attributeTypeMap;
    }
}
exports.PagerDutyService = PagerDutyService;
/**
 * @ignore
 */
PagerDutyService.attributeTypeMap = {
    serviceKey: {
        baseName: "service_key",
        type: "string",
        required: true,
    },
    serviceName: {
        baseName: "service_name",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=PagerDutyService.js.map

/***/ }),

/***/ 32766:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PagerDutyServiceKey = void 0;
/**
 * PagerDuty service object key.
 */
class PagerDutyServiceKey {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return PagerDutyServiceKey.attributeTypeMap;
    }
}
exports.PagerDutyServiceKey = PagerDutyServiceKey;
/**
 * @ignore
 */
PagerDutyServiceKey.attributeTypeMap = {
    serviceKey: {
        baseName: "service_key",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=PagerDutyServiceKey.js.map

/***/ }),

/***/ 44198:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PagerDutyServiceName = void 0;
/**
 * PagerDuty service object name.
 */
class PagerDutyServiceName {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return PagerDutyServiceName.attributeTypeMap;
    }
}
exports.PagerDutyServiceName = PagerDutyServiceName;
/**
 * @ignore
 */
PagerDutyServiceName.attributeTypeMap = {
    serviceName: {
        baseName: "service_name",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=PagerDutyServiceName.js.map

/***/ }),

/***/ 97834:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pagination = void 0;
/**
 * Pagination object.
 */
class Pagination {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return Pagination.attributeTypeMap;
    }
}
exports.Pagination = Pagination;
/**
 * @ignore
 */
Pagination.attributeTypeMap = {
    totalCount: {
        baseName: "total_count",
        type: "number",
        format: "int64",
    },
    totalFilteredCount: {
        baseName: "total_filtered_count",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=Pagination.js.map

/***/ }),

/***/ 96386:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProcessQueryDefinition = void 0;
/**
 * The process query to use in the widget.
 */
class ProcessQueryDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ProcessQueryDefinition.attributeTypeMap;
    }
}
exports.ProcessQueryDefinition = ProcessQueryDefinition;
/**
 * @ignore
 */
ProcessQueryDefinition.attributeTypeMap = {
    filterBy: {
        baseName: "filter_by",
        type: "Array<string>",
    },
    limit: {
        baseName: "limit",
        type: "number",
        format: "int64",
    },
    metric: {
        baseName: "metric",
        type: "string",
        required: true,
    },
    searchBy: {
        baseName: "search_by",
        type: "string",
    },
};
//# sourceMappingURL=ProcessQueryDefinition.js.map

/***/ }),

/***/ 78268:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QueryValueWidgetDefinition = void 0;
/**
 * Query values display the current value of a given metric, APM, or log query.
 */
class QueryValueWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return QueryValueWidgetDefinition.attributeTypeMap;
    }
}
exports.QueryValueWidgetDefinition = QueryValueWidgetDefinition;
/**
 * @ignore
 */
QueryValueWidgetDefinition.attributeTypeMap = {
    autoscale: {
        baseName: "autoscale",
        type: "boolean",
    },
    customLinks: {
        baseName: "custom_links",
        type: "Array<WidgetCustomLink>",
    },
    customUnit: {
        baseName: "custom_unit",
        type: "string",
    },
    precision: {
        baseName: "precision",
        type: "number",
        format: "int64",
    },
    requests: {
        baseName: "requests",
        type: "[QueryValueWidgetRequest]",
        required: true,
    },
    textAlign: {
        baseName: "text_align",
        type: "WidgetTextAlign",
    },
    time: {
        baseName: "time",
        type: "WidgetTime",
    },
    timeseriesBackground: {
        baseName: "timeseries_background",
        type: "TimeseriesBackground",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "QueryValueWidgetDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=QueryValueWidgetDefinition.js.map

/***/ }),

/***/ 10384:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QueryValueWidgetRequest = void 0;
/**
 * Updated query value widget.
 */
class QueryValueWidgetRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return QueryValueWidgetRequest.attributeTypeMap;
    }
}
exports.QueryValueWidgetRequest = QueryValueWidgetRequest;
/**
 * @ignore
 */
QueryValueWidgetRequest.attributeTypeMap = {
    aggregator: {
        baseName: "aggregator",
        type: "WidgetAggregator",
    },
    apmQuery: {
        baseName: "apm_query",
        type: "LogQueryDefinition",
    },
    auditQuery: {
        baseName: "audit_query",
        type: "LogQueryDefinition",
    },
    conditionalFormats: {
        baseName: "conditional_formats",
        type: "Array<WidgetConditionalFormat>",
    },
    eventQuery: {
        baseName: "event_query",
        type: "LogQueryDefinition",
    },
    formulas: {
        baseName: "formulas",
        type: "Array<WidgetFormula>",
    },
    logQuery: {
        baseName: "log_query",
        type: "LogQueryDefinition",
    },
    networkQuery: {
        baseName: "network_query",
        type: "LogQueryDefinition",
    },
    processQuery: {
        baseName: "process_query",
        type: "ProcessQueryDefinition",
    },
    profileMetricsQuery: {
        baseName: "profile_metrics_query",
        type: "LogQueryDefinition",
    },
    q: {
        baseName: "q",
        type: "string",
    },
    queries: {
        baseName: "queries",
        type: "Array<FormulaAndFunctionQueryDefinition>",
    },
    responseFormat: {
        baseName: "response_format",
        type: "FormulaAndFunctionResponseFormat",
    },
    rumQuery: {
        baseName: "rum_query",
        type: "LogQueryDefinition",
    },
    securityQuery: {
        baseName: "security_query",
        type: "LogQueryDefinition",
    },
};
//# sourceMappingURL=QueryValueWidgetRequest.js.map

/***/ }),

/***/ 31537:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReferenceTableLogsLookupProcessor = void 0;
/**
 * **Note**: Reference Tables are in public beta.
 * Use the Lookup Processor to define a mapping between a log attribute
 * and a human readable value saved in a Reference Table.
 * For example, you can use the Lookup Processor to map an internal service ID
 * into a human readable service name. Alternatively, you could also use it to check
 * if the MAC address that just attempted to connect to the production
 * environment belongs to your list of stolen machines.
 */
class ReferenceTableLogsLookupProcessor {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ReferenceTableLogsLookupProcessor.attributeTypeMap;
    }
}
exports.ReferenceTableLogsLookupProcessor = ReferenceTableLogsLookupProcessor;
/**
 * @ignore
 */
ReferenceTableLogsLookupProcessor.attributeTypeMap = {
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    lookupEnrichmentTable: {
        baseName: "lookup_enrichment_table",
        type: "string",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
    },
    source: {
        baseName: "source",
        type: "string",
        required: true,
    },
    target: {
        baseName: "target",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "LogsLookupProcessorType",
        required: true,
    },
};
//# sourceMappingURL=ReferenceTableLogsLookupProcessor.js.map

/***/ }),

/***/ 44993:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ResponseMetaAttributes = void 0;
/**
 * Object describing meta attributes of response.
 */
class ResponseMetaAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ResponseMetaAttributes.attributeTypeMap;
    }
}
exports.ResponseMetaAttributes = ResponseMetaAttributes;
/**
 * @ignore
 */
ResponseMetaAttributes.attributeTypeMap = {
    page: {
        baseName: "page",
        type: "Pagination",
    },
};
//# sourceMappingURL=ResponseMetaAttributes.js.map

/***/ }),

/***/ 66209:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RunWorkflowWidgetDefinition = void 0;
/**
 * Run workflow is widget that allows you to run a workflow from a dashboard.
 */
class RunWorkflowWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RunWorkflowWidgetDefinition.attributeTypeMap;
    }
}
exports.RunWorkflowWidgetDefinition = RunWorkflowWidgetDefinition;
/**
 * @ignore
 */
RunWorkflowWidgetDefinition.attributeTypeMap = {
    customLinks: {
        baseName: "custom_links",
        type: "Array<WidgetCustomLink>",
    },
    inputs: {
        baseName: "inputs",
        type: "Array<RunWorkflowWidgetInput>",
    },
    time: {
        baseName: "time",
        type: "WidgetTime",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "RunWorkflowWidgetDefinitionType",
        required: true,
    },
    workflowId: {
        baseName: "workflow_id",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=RunWorkflowWidgetDefinition.js.map

/***/ }),

/***/ 71677:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RunWorkflowWidgetInput = void 0;
/**
 * Object to map a dashboard template variable to a workflow input.
 */
class RunWorkflowWidgetInput {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RunWorkflowWidgetInput.attributeTypeMap;
    }
}
exports.RunWorkflowWidgetInput = RunWorkflowWidgetInput;
/**
 * @ignore
 */
RunWorkflowWidgetInput.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    value: {
        baseName: "value",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=RunWorkflowWidgetInput.js.map

/***/ }),

/***/ 6307:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOBulkDeleteError = void 0;
/**
 * Object describing the error.
 */
class SLOBulkDeleteError {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOBulkDeleteError.attributeTypeMap;
    }
}
exports.SLOBulkDeleteError = SLOBulkDeleteError;
/**
 * @ignore
 */
SLOBulkDeleteError.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    message: {
        baseName: "message",
        type: "string",
        required: true,
    },
    timeframe: {
        baseName: "timeframe",
        type: "SLOErrorTimeframe",
        required: true,
    },
};
//# sourceMappingURL=SLOBulkDeleteError.js.map

/***/ }),

/***/ 53119:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOBulkDeleteResponse = void 0;
/**
 * The bulk partial delete service level objective object endpoint
 * response.
 *
 * This endpoint operates on multiple service level objective objects, so
 * it may be partially successful. In such cases, the "data" and "error"
 * fields in this response indicate which deletions succeeded and failed.
 */
class SLOBulkDeleteResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOBulkDeleteResponse.attributeTypeMap;
    }
}
exports.SLOBulkDeleteResponse = SLOBulkDeleteResponse;
/**
 * @ignore
 */
SLOBulkDeleteResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SLOBulkDeleteResponseData",
    },
    errors: {
        baseName: "errors",
        type: "Array<SLOBulkDeleteError>",
    },
};
//# sourceMappingURL=SLOBulkDeleteResponse.js.map

/***/ }),

/***/ 28093:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOBulkDeleteResponseData = void 0;
/**
 * An array of service level objective objects.
 */
class SLOBulkDeleteResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOBulkDeleteResponseData.attributeTypeMap;
    }
}
exports.SLOBulkDeleteResponseData = SLOBulkDeleteResponseData;
/**
 * @ignore
 */
SLOBulkDeleteResponseData.attributeTypeMap = {
    deleted: {
        baseName: "deleted",
        type: "Array<string>",
    },
    updated: {
        baseName: "updated",
        type: "Array<string>",
    },
};
//# sourceMappingURL=SLOBulkDeleteResponseData.js.map

/***/ }),

/***/ 2852:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOCorrection = void 0;
/**
 * The response object of a list of SLO corrections.
 */
class SLOCorrection {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOCorrection.attributeTypeMap;
    }
}
exports.SLOCorrection = SLOCorrection;
/**
 * @ignore
 */
SLOCorrection.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SLOCorrectionResponseAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "SLOCorrectionType",
    },
};
//# sourceMappingURL=SLOCorrection.js.map

/***/ }),

/***/ 43215:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOCorrectionCreateData = void 0;
/**
 * The data object associated with the SLO correction to be created.
 */
class SLOCorrectionCreateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOCorrectionCreateData.attributeTypeMap;
    }
}
exports.SLOCorrectionCreateData = SLOCorrectionCreateData;
/**
 * @ignore
 */
SLOCorrectionCreateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SLOCorrectionCreateRequestAttributes",
    },
    type: {
        baseName: "type",
        type: "SLOCorrectionType",
        required: true,
    },
};
//# sourceMappingURL=SLOCorrectionCreateData.js.map

/***/ }),

/***/ 87152:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOCorrectionCreateRequest = void 0;
/**
 * An object that defines a correction to be applied to an SLO.
 */
class SLOCorrectionCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOCorrectionCreateRequest.attributeTypeMap;
    }
}
exports.SLOCorrectionCreateRequest = SLOCorrectionCreateRequest;
/**
 * @ignore
 */
SLOCorrectionCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SLOCorrectionCreateData",
    },
};
//# sourceMappingURL=SLOCorrectionCreateRequest.js.map

/***/ }),

/***/ 26204:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOCorrectionCreateRequestAttributes = void 0;
/**
 * The attribute object associated with the SLO correction to be created.
 */
class SLOCorrectionCreateRequestAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOCorrectionCreateRequestAttributes.attributeTypeMap;
    }
}
exports.SLOCorrectionCreateRequestAttributes = SLOCorrectionCreateRequestAttributes;
/**
 * @ignore
 */
SLOCorrectionCreateRequestAttributes.attributeTypeMap = {
    category: {
        baseName: "category",
        type: "SLOCorrectionCategory",
        required: true,
    },
    description: {
        baseName: "description",
        type: "string",
    },
    duration: {
        baseName: "duration",
        type: "number",
        format: "int64",
    },
    end: {
        baseName: "end",
        type: "number",
        format: "int64",
    },
    rrule: {
        baseName: "rrule",
        type: "string",
    },
    sloId: {
        baseName: "slo_id",
        type: "string",
        required: true,
    },
    start: {
        baseName: "start",
        type: "number",
        required: true,
        format: "int64",
    },
    timezone: {
        baseName: "timezone",
        type: "string",
    },
};
//# sourceMappingURL=SLOCorrectionCreateRequestAttributes.js.map

/***/ }),

/***/ 12062:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOCorrectionListResponse = void 0;
/**
 * A list of  SLO correction objects.
 */
class SLOCorrectionListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOCorrectionListResponse.attributeTypeMap;
    }
}
exports.SLOCorrectionListResponse = SLOCorrectionListResponse;
/**
 * @ignore
 */
SLOCorrectionListResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<SLOCorrection>",
    },
    meta: {
        baseName: "meta",
        type: "ResponseMetaAttributes",
    },
};
//# sourceMappingURL=SLOCorrectionListResponse.js.map

/***/ }),

/***/ 26986:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOCorrectionResponse = void 0;
/**
 * The response object of an SLO correction.
 */
class SLOCorrectionResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOCorrectionResponse.attributeTypeMap;
    }
}
exports.SLOCorrectionResponse = SLOCorrectionResponse;
/**
 * @ignore
 */
SLOCorrectionResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SLOCorrection",
    },
};
//# sourceMappingURL=SLOCorrectionResponse.js.map

/***/ }),

/***/ 35052:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOCorrectionResponseAttributes = void 0;
/**
 * The attribute object associated with the SLO correction.
 */
class SLOCorrectionResponseAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOCorrectionResponseAttributes.attributeTypeMap;
    }
}
exports.SLOCorrectionResponseAttributes = SLOCorrectionResponseAttributes;
/**
 * @ignore
 */
SLOCorrectionResponseAttributes.attributeTypeMap = {
    category: {
        baseName: "category",
        type: "SLOCorrectionCategory",
    },
    createdAt: {
        baseName: "created_at",
        type: "number",
        format: "int64",
    },
    creator: {
        baseName: "creator",
        type: "Creator",
    },
    description: {
        baseName: "description",
        type: "string",
    },
    duration: {
        baseName: "duration",
        type: "number",
        format: "int64",
    },
    end: {
        baseName: "end",
        type: "number",
        format: "int64",
    },
    modifiedAt: {
        baseName: "modified_at",
        type: "number",
        format: "int64",
    },
    modifier: {
        baseName: "modifier",
        type: "SLOCorrectionResponseAttributesModifier",
    },
    rrule: {
        baseName: "rrule",
        type: "string",
    },
    sloId: {
        baseName: "slo_id",
        type: "string",
    },
    start: {
        baseName: "start",
        type: "number",
        format: "int64",
    },
    timezone: {
        baseName: "timezone",
        type: "string",
    },
};
//# sourceMappingURL=SLOCorrectionResponseAttributes.js.map

/***/ }),

/***/ 88857:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOCorrectionResponseAttributesModifier = void 0;
/**
 * Modifier of the object.
 */
class SLOCorrectionResponseAttributesModifier {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOCorrectionResponseAttributesModifier.attributeTypeMap;
    }
}
exports.SLOCorrectionResponseAttributesModifier = SLOCorrectionResponseAttributesModifier;
/**
 * @ignore
 */
SLOCorrectionResponseAttributesModifier.attributeTypeMap = {
    email: {
        baseName: "email",
        type: "string",
    },
    handle: {
        baseName: "handle",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=SLOCorrectionResponseAttributesModifier.js.map

/***/ }),

/***/ 99745:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOCorrectionUpdateData = void 0;
/**
 * The data object associated with the SLO correction to be updated.
 */
class SLOCorrectionUpdateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOCorrectionUpdateData.attributeTypeMap;
    }
}
exports.SLOCorrectionUpdateData = SLOCorrectionUpdateData;
/**
 * @ignore
 */
SLOCorrectionUpdateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SLOCorrectionUpdateRequestAttributes",
    },
    type: {
        baseName: "type",
        type: "SLOCorrectionType",
    },
};
//# sourceMappingURL=SLOCorrectionUpdateData.js.map

/***/ }),

/***/ 77273:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOCorrectionUpdateRequest = void 0;
/**
 * An object that defines a correction to be applied to an SLO.
 */
class SLOCorrectionUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOCorrectionUpdateRequest.attributeTypeMap;
    }
}
exports.SLOCorrectionUpdateRequest = SLOCorrectionUpdateRequest;
/**
 * @ignore
 */
SLOCorrectionUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SLOCorrectionUpdateData",
    },
};
//# sourceMappingURL=SLOCorrectionUpdateRequest.js.map

/***/ }),

/***/ 75164:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOCorrectionUpdateRequestAttributes = void 0;
/**
 * The attribute object associated with the SLO correction to be updated.
 */
class SLOCorrectionUpdateRequestAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOCorrectionUpdateRequestAttributes.attributeTypeMap;
    }
}
exports.SLOCorrectionUpdateRequestAttributes = SLOCorrectionUpdateRequestAttributes;
/**
 * @ignore
 */
SLOCorrectionUpdateRequestAttributes.attributeTypeMap = {
    category: {
        baseName: "category",
        type: "SLOCorrectionCategory",
    },
    description: {
        baseName: "description",
        type: "string",
    },
    duration: {
        baseName: "duration",
        type: "number",
        format: "int64",
    },
    end: {
        baseName: "end",
        type: "number",
        format: "int64",
    },
    rrule: {
        baseName: "rrule",
        type: "string",
    },
    start: {
        baseName: "start",
        type: "number",
        format: "int64",
    },
    timezone: {
        baseName: "timezone",
        type: "string",
    },
};
//# sourceMappingURL=SLOCorrectionUpdateRequestAttributes.js.map

/***/ }),

/***/ 52294:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOCreator = void 0;
/**
 * The creator of the SLO
 */
class SLOCreator {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOCreator.attributeTypeMap;
    }
}
exports.SLOCreator = SLOCreator;
/**
 * @ignore
 */
SLOCreator.attributeTypeMap = {
    email: {
        baseName: "email",
        type: "string",
    },
    id: {
        baseName: "id",
        type: "number",
        format: "int64",
    },
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=SLOCreator.js.map

/***/ }),

/***/ 47941:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLODeleteResponse = void 0;
/**
 * A response list of all service level objective deleted.
 */
class SLODeleteResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLODeleteResponse.attributeTypeMap;
    }
}
exports.SLODeleteResponse = SLODeleteResponse;
/**
 * @ignore
 */
SLODeleteResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<string>",
    },
    errors: {
        baseName: "errors",
        type: "{ [key: string]: string; }",
    },
};
//# sourceMappingURL=SLODeleteResponse.js.map

/***/ }),

/***/ 55029:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOHistoryMetrics = void 0;
/**
 * A `metric` based SLO history response.
 *
 * This is not included in responses for `monitor` based SLOs.
 */
class SLOHistoryMetrics {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOHistoryMetrics.attributeTypeMap;
    }
}
exports.SLOHistoryMetrics = SLOHistoryMetrics;
/**
 * @ignore
 */
SLOHistoryMetrics.attributeTypeMap = {
    denominator: {
        baseName: "denominator",
        type: "SLOHistoryMetricsSeries",
        required: true,
    },
    interval: {
        baseName: "interval",
        type: "number",
        required: true,
        format: "int64",
    },
    message: {
        baseName: "message",
        type: "string",
    },
    numerator: {
        baseName: "numerator",
        type: "SLOHistoryMetricsSeries",
        required: true,
    },
    query: {
        baseName: "query",
        type: "string",
        required: true,
    },
    resType: {
        baseName: "res_type",
        type: "string",
        required: true,
    },
    respVersion: {
        baseName: "resp_version",
        type: "number",
        required: true,
        format: "int64",
    },
    times: {
        baseName: "times",
        type: "Array<number>",
        required: true,
        format: "double",
    },
};
//# sourceMappingURL=SLOHistoryMetrics.js.map

/***/ }),

/***/ 96132:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOHistoryMetricsSeries = void 0;
/**
 * A representation of `metric` based SLO time series for the provided queries.
 * This is the same response type from `batch_query` endpoint.
 */
class SLOHistoryMetricsSeries {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOHistoryMetricsSeries.attributeTypeMap;
    }
}
exports.SLOHistoryMetricsSeries = SLOHistoryMetricsSeries;
/**
 * @ignore
 */
SLOHistoryMetricsSeries.attributeTypeMap = {
    count: {
        baseName: "count",
        type: "number",
        required: true,
        format: "int64",
    },
    metadata: {
        baseName: "metadata",
        type: "SLOHistoryMetricsSeriesMetadata",
    },
    sum: {
        baseName: "sum",
        type: "number",
        required: true,
        format: "double",
    },
    values: {
        baseName: "values",
        type: "Array<number>",
        required: true,
        format: "double",
    },
};
//# sourceMappingURL=SLOHistoryMetricsSeries.js.map

/***/ }),

/***/ 83288:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOHistoryMetricsSeriesMetadata = void 0;
/**
 * Query metadata.
 */
class SLOHistoryMetricsSeriesMetadata {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOHistoryMetricsSeriesMetadata.attributeTypeMap;
    }
}
exports.SLOHistoryMetricsSeriesMetadata = SLOHistoryMetricsSeriesMetadata;
/**
 * @ignore
 */
SLOHistoryMetricsSeriesMetadata.attributeTypeMap = {
    aggr: {
        baseName: "aggr",
        type: "string",
    },
    expression: {
        baseName: "expression",
        type: "string",
    },
    metric: {
        baseName: "metric",
        type: "string",
    },
    queryIndex: {
        baseName: "query_index",
        type: "number",
        format: "int64",
    },
    scope: {
        baseName: "scope",
        type: "string",
    },
    unit: {
        baseName: "unit",
        type: "Array<SLOHistoryMetricsSeriesMetadataUnit>",
    },
};
//# sourceMappingURL=SLOHistoryMetricsSeriesMetadata.js.map

/***/ }),

/***/ 67323:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOHistoryMetricsSeriesMetadataUnit = void 0;
/**
 * An Object of metric units.
 */
class SLOHistoryMetricsSeriesMetadataUnit {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOHistoryMetricsSeriesMetadataUnit.attributeTypeMap;
    }
}
exports.SLOHistoryMetricsSeriesMetadataUnit = SLOHistoryMetricsSeriesMetadataUnit;
/**
 * @ignore
 */
SLOHistoryMetricsSeriesMetadataUnit.attributeTypeMap = {
    family: {
        baseName: "family",
        type: "string",
    },
    id: {
        baseName: "id",
        type: "number",
        format: "int64",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    plural: {
        baseName: "plural",
        type: "string",
    },
    scaleFactor: {
        baseName: "scale_factor",
        type: "number",
        format: "double",
    },
    shortName: {
        baseName: "short_name",
        type: "string",
    },
};
//# sourceMappingURL=SLOHistoryMetricsSeriesMetadataUnit.js.map

/***/ }),

/***/ 62797:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOHistoryMonitor = void 0;
/**
 * An object that holds an SLI value and its associated data. It can represent an SLO's overall SLI value.
 * This can also represent the SLI value for a specific monitor in multi-monitor SLOs, or a group in grouped SLOs.
 */
class SLOHistoryMonitor {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOHistoryMonitor.attributeTypeMap;
    }
}
exports.SLOHistoryMonitor = SLOHistoryMonitor;
/**
 * @ignore
 */
SLOHistoryMonitor.attributeTypeMap = {
    errorBudgetRemaining: {
        baseName: "error_budget_remaining",
        type: "{ [key: string]: number; }",
    },
    errors: {
        baseName: "errors",
        type: "Array<SLOHistoryResponseErrorWithType>",
    },
    group: {
        baseName: "group",
        type: "string",
    },
    history: {
        baseName: "history",
        type: "Array<[number, number]>",
        format: "double",
    },
    monitorModified: {
        baseName: "monitor_modified",
        type: "number",
        format: "int64",
    },
    monitorType: {
        baseName: "monitor_type",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    precision: {
        baseName: "precision",
        type: "number",
        format: "double",
    },
    preview: {
        baseName: "preview",
        type: "boolean",
    },
    sliValue: {
        baseName: "sli_value",
        type: "number",
        format: "double",
    },
    spanPrecision: {
        baseName: "span_precision",
        type: "number",
        format: "double",
    },
    uptime: {
        baseName: "uptime",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=SLOHistoryMonitor.js.map

/***/ }),

/***/ 27297:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOHistoryResponse = void 0;
/**
 * A service level objective history response.
 */
class SLOHistoryResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOHistoryResponse.attributeTypeMap;
    }
}
exports.SLOHistoryResponse = SLOHistoryResponse;
/**
 * @ignore
 */
SLOHistoryResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SLOHistoryResponseData",
    },
    errors: {
        baseName: "errors",
        type: "Array<SLOHistoryResponseError>",
    },
};
//# sourceMappingURL=SLOHistoryResponse.js.map

/***/ }),

/***/ 81357:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOHistoryResponseData = void 0;
/**
 * An array of service level objective objects.
 */
class SLOHistoryResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOHistoryResponseData.attributeTypeMap;
    }
}
exports.SLOHistoryResponseData = SLOHistoryResponseData;
/**
 * @ignore
 */
SLOHistoryResponseData.attributeTypeMap = {
    fromTs: {
        baseName: "from_ts",
        type: "number",
        format: "int64",
    },
    groupBy: {
        baseName: "group_by",
        type: "Array<string>",
    },
    groups: {
        baseName: "groups",
        type: "Array<SLOHistoryMonitor>",
    },
    monitors: {
        baseName: "monitors",
        type: "Array<SLOHistoryMonitor>",
    },
    overall: {
        baseName: "overall",
        type: "SLOHistorySLIData",
    },
    series: {
        baseName: "series",
        type: "SLOHistoryMetrics",
    },
    thresholds: {
        baseName: "thresholds",
        type: "{ [key: string]: SLOThreshold; }",
    },
    toTs: {
        baseName: "to_ts",
        type: "number",
        format: "int64",
    },
    type: {
        baseName: "type",
        type: "SLOType",
    },
    typeId: {
        baseName: "type_id",
        type: "SLOTypeNumeric",
        format: "int32",
    },
};
//# sourceMappingURL=SLOHistoryResponseData.js.map

/***/ }),

/***/ 30144:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOHistoryResponseError = void 0;
/**
 * A list of errors while querying the history data for the service level objective.
 */
class SLOHistoryResponseError {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOHistoryResponseError.attributeTypeMap;
    }
}
exports.SLOHistoryResponseError = SLOHistoryResponseError;
/**
 * @ignore
 */
SLOHistoryResponseError.attributeTypeMap = {
    error: {
        baseName: "error",
        type: "string",
    },
};
//# sourceMappingURL=SLOHistoryResponseError.js.map

/***/ }),

/***/ 58524:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOHistoryResponseErrorWithType = void 0;
/**
 * An object describing the error with error type and error message.
 */
class SLOHistoryResponseErrorWithType {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOHistoryResponseErrorWithType.attributeTypeMap;
    }
}
exports.SLOHistoryResponseErrorWithType = SLOHistoryResponseErrorWithType;
/**
 * @ignore
 */
SLOHistoryResponseErrorWithType.attributeTypeMap = {
    errorMessage: {
        baseName: "error_message",
        type: "string",
        required: true,
    },
    errorType: {
        baseName: "error_type",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=SLOHistoryResponseErrorWithType.js.map

/***/ }),

/***/ 6636:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOHistorySLIData = void 0;
/**
 * An object that holds an SLI value and its associated data. It can represent an SLO's overall SLI value.
 * This can also represent the SLI value for a specific monitor in multi-monitor SLOs, or a group in grouped SLOs.
 */
class SLOHistorySLIData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOHistorySLIData.attributeTypeMap;
    }
}
exports.SLOHistorySLIData = SLOHistorySLIData;
/**
 * @ignore
 */
SLOHistorySLIData.attributeTypeMap = {
    errorBudgetRemaining: {
        baseName: "error_budget_remaining",
        type: "{ [key: string]: number; }",
    },
    errors: {
        baseName: "errors",
        type: "Array<SLOHistoryResponseErrorWithType>",
    },
    group: {
        baseName: "group",
        type: "string",
    },
    history: {
        baseName: "history",
        type: "Array<[number, number]>",
        format: "double",
    },
    monitorModified: {
        baseName: "monitor_modified",
        type: "number",
        format: "int64",
    },
    monitorType: {
        baseName: "monitor_type",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    precision: {
        baseName: "precision",
        type: "{ [key: string]: number; }",
    },
    preview: {
        baseName: "preview",
        type: "boolean",
    },
    sliValue: {
        baseName: "sli_value",
        type: "number",
        format: "double",
    },
    spanPrecision: {
        baseName: "span_precision",
        type: "number",
        format: "double",
    },
    uptime: {
        baseName: "uptime",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=SLOHistorySLIData.js.map

/***/ }),

/***/ 19477:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOListResponse = void 0;
/**
 * A response with one or more service level objective.
 */
class SLOListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOListResponse.attributeTypeMap;
    }
}
exports.SLOListResponse = SLOListResponse;
/**
 * @ignore
 */
SLOListResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<ServiceLevelObjective>",
    },
    errors: {
        baseName: "errors",
        type: "Array<string>",
    },
    metadata: {
        baseName: "metadata",
        type: "SLOListResponseMetadata",
    },
};
//# sourceMappingURL=SLOListResponse.js.map

/***/ }),

/***/ 95727:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOListResponseMetadata = void 0;
/**
 * The metadata object containing additional information about the list of SLOs.
 */
class SLOListResponseMetadata {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOListResponseMetadata.attributeTypeMap;
    }
}
exports.SLOListResponseMetadata = SLOListResponseMetadata;
/**
 * @ignore
 */
SLOListResponseMetadata.attributeTypeMap = {
    page: {
        baseName: "page",
        type: "SLOListResponseMetadataPage",
    },
};
//# sourceMappingURL=SLOListResponseMetadata.js.map

/***/ }),

/***/ 559:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOListResponseMetadataPage = void 0;
/**
 * The object containing information about the pages of the list of SLOs.
 */
class SLOListResponseMetadataPage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOListResponseMetadataPage.attributeTypeMap;
    }
}
exports.SLOListResponseMetadataPage = SLOListResponseMetadataPage;
/**
 * @ignore
 */
SLOListResponseMetadataPage.attributeTypeMap = {
    totalCount: {
        baseName: "total_count",
        type: "number",
        format: "int64",
    },
    totalFilteredCount: {
        baseName: "total_filtered_count",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=SLOListResponseMetadataPage.js.map

/***/ }),

/***/ 87733:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOListWidgetDefinition = void 0;
/**
 * Use the SLO List widget to track your SLOs (Service Level Objectives) on dashboards.
 */
class SLOListWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOListWidgetDefinition.attributeTypeMap;
    }
}
exports.SLOListWidgetDefinition = SLOListWidgetDefinition;
/**
 * @ignore
 */
SLOListWidgetDefinition.attributeTypeMap = {
    requests: {
        baseName: "requests",
        type: "[SLOListWidgetRequest]",
        required: true,
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "SLOListWidgetDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=SLOListWidgetDefinition.js.map

/***/ }),

/***/ 77106:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOListWidgetQuery = void 0;
/**
 * Updated SLO List widget.
 */
class SLOListWidgetQuery {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOListWidgetQuery.attributeTypeMap;
    }
}
exports.SLOListWidgetQuery = SLOListWidgetQuery;
/**
 * @ignore
 */
SLOListWidgetQuery.attributeTypeMap = {
    limit: {
        baseName: "limit",
        type: "number",
        format: "int64",
    },
    queryString: {
        baseName: "query_string",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=SLOListWidgetQuery.js.map

/***/ }),

/***/ 74176:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOListWidgetRequest = void 0;
/**
 * Updated SLO List widget.
 */
class SLOListWidgetRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOListWidgetRequest.attributeTypeMap;
    }
}
exports.SLOListWidgetRequest = SLOListWidgetRequest;
/**
 * @ignore
 */
SLOListWidgetRequest.attributeTypeMap = {
    query: {
        baseName: "query",
        type: "SLOListWidgetQuery",
        required: true,
    },
    requestType: {
        baseName: "request_type",
        type: "SLOListWidgetRequestType",
        required: true,
    },
};
//# sourceMappingURL=SLOListWidgetRequest.js.map

/***/ }),

/***/ 4058:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOOverallStatuses = void 0;
/**
 * Overall status of the SLO by timeframes.
 */
class SLOOverallStatuses {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOOverallStatuses.attributeTypeMap;
    }
}
exports.SLOOverallStatuses = SLOOverallStatuses;
/**
 * @ignore
 */
SLOOverallStatuses.attributeTypeMap = {
    error: {
        baseName: "error",
        type: "string",
    },
    indexedAt: {
        baseName: "indexed_at",
        type: "number",
        format: "int64",
    },
    rawErrorBudgetRemaining: {
        baseName: "raw_error_budget_remaining",
        type: "SLORawErrorBudgetRemaining",
    },
    spanPrecision: {
        baseName: "span_precision",
        type: "number",
        format: "int64",
    },
    status: {
        baseName: "status",
        type: "number",
        format: "double",
    },
    target: {
        baseName: "target",
        type: "number",
        format: "double",
    },
    timeframe: {
        baseName: "timeframe",
        type: "SLOTimeframe",
    },
};
//# sourceMappingURL=SLOOverallStatuses.js.map

/***/ }),

/***/ 22565:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLORawErrorBudgetRemaining = void 0;
/**
 * Error budget remaining for an SLO.
 */
class SLORawErrorBudgetRemaining {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLORawErrorBudgetRemaining.attributeTypeMap;
    }
}
exports.SLORawErrorBudgetRemaining = SLORawErrorBudgetRemaining;
/**
 * @ignore
 */
SLORawErrorBudgetRemaining.attributeTypeMap = {
    unit: {
        baseName: "unit",
        type: "string",
    },
    value: {
        baseName: "value",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=SLORawErrorBudgetRemaining.js.map

/***/ }),

/***/ 58530:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOResponse = void 0;
/**
 * A service level objective response containing a single service level objective.
 */
class SLOResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOResponse.attributeTypeMap;
    }
}
exports.SLOResponse = SLOResponse;
/**
 * @ignore
 */
SLOResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SLOResponseData",
    },
    errors: {
        baseName: "errors",
        type: "Array<string>",
    },
};
//# sourceMappingURL=SLOResponse.js.map

/***/ }),

/***/ 98608:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOResponseData = void 0;
/**
 * A service level objective object includes a service level indicator, thresholds
 * for one or more timeframes, and metadata (`name`, `description`, `tags`, etc.).
 */
class SLOResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOResponseData.attributeTypeMap;
    }
}
exports.SLOResponseData = SLOResponseData;
/**
 * @ignore
 */
SLOResponseData.attributeTypeMap = {
    configuredAlertIds: {
        baseName: "configured_alert_ids",
        type: "Array<number>",
        format: "int64",
    },
    createdAt: {
        baseName: "created_at",
        type: "number",
        format: "int64",
    },
    creator: {
        baseName: "creator",
        type: "Creator",
    },
    description: {
        baseName: "description",
        type: "string",
    },
    groups: {
        baseName: "groups",
        type: "Array<string>",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    modifiedAt: {
        baseName: "modified_at",
        type: "number",
        format: "int64",
    },
    monitorIds: {
        baseName: "monitor_ids",
        type: "Array<number>",
        format: "int64",
    },
    monitorTags: {
        baseName: "monitor_tags",
        type: "Array<string>",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    query: {
        baseName: "query",
        type: "ServiceLevelObjectiveQuery",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    targetThreshold: {
        baseName: "target_threshold",
        type: "number",
        format: "double",
    },
    thresholds: {
        baseName: "thresholds",
        type: "Array<SLOThreshold>",
    },
    timeframe: {
        baseName: "timeframe",
        type: "SLOTimeframe",
    },
    type: {
        baseName: "type",
        type: "SLOType",
    },
    warningThreshold: {
        baseName: "warning_threshold",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=SLOResponseData.js.map

/***/ }),

/***/ 96548:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOThreshold = void 0;
/**
 * SLO thresholds (target and optionally warning) for a single time window.
 */
class SLOThreshold {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOThreshold.attributeTypeMap;
    }
}
exports.SLOThreshold = SLOThreshold;
/**
 * @ignore
 */
SLOThreshold.attributeTypeMap = {
    target: {
        baseName: "target",
        type: "number",
        required: true,
        format: "double",
    },
    targetDisplay: {
        baseName: "target_display",
        type: "string",
    },
    timeframe: {
        baseName: "timeframe",
        type: "SLOTimeframe",
        required: true,
    },
    warning: {
        baseName: "warning",
        type: "number",
        format: "double",
    },
    warningDisplay: {
        baseName: "warning_display",
        type: "string",
    },
};
//# sourceMappingURL=SLOThreshold.js.map

/***/ }),

/***/ 32026:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SLOWidgetDefinition = void 0;
/**
 * Use the SLO and uptime widget to track your SLOs (Service Level Objectives) and uptime on screenboards and timeboards.
 */
class SLOWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SLOWidgetDefinition.attributeTypeMap;
    }
}
exports.SLOWidgetDefinition = SLOWidgetDefinition;
/**
 * @ignore
 */
SLOWidgetDefinition.attributeTypeMap = {
    globalTimeTarget: {
        baseName: "global_time_target",
        type: "string",
    },
    showErrorBudget: {
        baseName: "show_error_budget",
        type: "boolean",
    },
    sloId: {
        baseName: "slo_id",
        type: "string",
    },
    timeWindows: {
        baseName: "time_windows",
        type: "Array<WidgetTimeWindows>",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "SLOWidgetDefinitionType",
        required: true,
    },
    viewMode: {
        baseName: "view_mode",
        type: "WidgetViewMode",
    },
    viewType: {
        baseName: "view_type",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=SLOWidgetDefinition.js.map

/***/ }),

/***/ 90691:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScatterPlotRequest = void 0;
/**
 * Updated scatter plot.
 */
class ScatterPlotRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ScatterPlotRequest.attributeTypeMap;
    }
}
exports.ScatterPlotRequest = ScatterPlotRequest;
/**
 * @ignore
 */
ScatterPlotRequest.attributeTypeMap = {
    aggregator: {
        baseName: "aggregator",
        type: "ScatterplotWidgetAggregator",
    },
    apmQuery: {
        baseName: "apm_query",
        type: "LogQueryDefinition",
    },
    eventQuery: {
        baseName: "event_query",
        type: "LogQueryDefinition",
    },
    logQuery: {
        baseName: "log_query",
        type: "LogQueryDefinition",
    },
    networkQuery: {
        baseName: "network_query",
        type: "LogQueryDefinition",
    },
    processQuery: {
        baseName: "process_query",
        type: "ProcessQueryDefinition",
    },
    profileMetricsQuery: {
        baseName: "profile_metrics_query",
        type: "LogQueryDefinition",
    },
    q: {
        baseName: "q",
        type: "string",
    },
    rumQuery: {
        baseName: "rum_query",
        type: "LogQueryDefinition",
    },
    securityQuery: {
        baseName: "security_query",
        type: "LogQueryDefinition",
    },
};
//# sourceMappingURL=ScatterPlotRequest.js.map

/***/ }),

/***/ 85820:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScatterPlotWidgetDefinition = void 0;
/**
 * The scatter plot visualization allows you to graph a chosen scope over two different metrics with their respective aggregation.
 */
class ScatterPlotWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ScatterPlotWidgetDefinition.attributeTypeMap;
    }
}
exports.ScatterPlotWidgetDefinition = ScatterPlotWidgetDefinition;
/**
 * @ignore
 */
ScatterPlotWidgetDefinition.attributeTypeMap = {
    colorByGroups: {
        baseName: "color_by_groups",
        type: "Array<string>",
    },
    customLinks: {
        baseName: "custom_links",
        type: "Array<WidgetCustomLink>",
    },
    requests: {
        baseName: "requests",
        type: "ScatterPlotWidgetDefinitionRequests",
        required: true,
    },
    time: {
        baseName: "time",
        type: "WidgetTime",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "ScatterPlotWidgetDefinitionType",
        required: true,
    },
    xaxis: {
        baseName: "xaxis",
        type: "WidgetAxis",
    },
    yaxis: {
        baseName: "yaxis",
        type: "WidgetAxis",
    },
};
//# sourceMappingURL=ScatterPlotWidgetDefinition.js.map

/***/ }),

/***/ 6095:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScatterPlotWidgetDefinitionRequests = void 0;
/**
 * Widget definition.
 */
class ScatterPlotWidgetDefinitionRequests {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ScatterPlotWidgetDefinitionRequests.attributeTypeMap;
    }
}
exports.ScatterPlotWidgetDefinitionRequests = ScatterPlotWidgetDefinitionRequests;
/**
 * @ignore
 */
ScatterPlotWidgetDefinitionRequests.attributeTypeMap = {
    table: {
        baseName: "table",
        type: "ScatterplotTableRequest",
    },
    x: {
        baseName: "x",
        type: "ScatterPlotRequest",
    },
    y: {
        baseName: "y",
        type: "ScatterPlotRequest",
    },
};
//# sourceMappingURL=ScatterPlotWidgetDefinitionRequests.js.map

/***/ }),

/***/ 95803:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScatterplotTableRequest = void 0;
/**
 * Scatterplot request containing formulas and functions.
 */
class ScatterplotTableRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ScatterplotTableRequest.attributeTypeMap;
    }
}
exports.ScatterplotTableRequest = ScatterplotTableRequest;
/**
 * @ignore
 */
ScatterplotTableRequest.attributeTypeMap = {
    formulas: {
        baseName: "formulas",
        type: "Array<ScatterplotWidgetFormula>",
    },
    queries: {
        baseName: "queries",
        type: "Array<FormulaAndFunctionQueryDefinition>",
    },
    responseFormat: {
        baseName: "response_format",
        type: "FormulaAndFunctionResponseFormat",
    },
};
//# sourceMappingURL=ScatterplotTableRequest.js.map

/***/ }),

/***/ 36910:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScatterplotWidgetFormula = void 0;
/**
 * Formula to be used in a Scatterplot widget query.
 */
class ScatterplotWidgetFormula {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ScatterplotWidgetFormula.attributeTypeMap;
    }
}
exports.ScatterplotWidgetFormula = ScatterplotWidgetFormula;
/**
 * @ignore
 */
ScatterplotWidgetFormula.attributeTypeMap = {
    alias: {
        baseName: "alias",
        type: "string",
    },
    dimension: {
        baseName: "dimension",
        type: "ScatterplotDimension",
        required: true,
    },
    formula: {
        baseName: "formula",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=ScatterplotWidgetFormula.js.map

/***/ }),

/***/ 16851:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchSLOQuery = void 0;
/**
 * A metric-based SLO. **Required if type is `metric`**. Note that Datadog only allows the sum by aggregator
 * to be used because this will sum up all request counts instead of averaging them, or taking the max or
 * min of all of those requests.
 */
class SearchSLOQuery {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SearchSLOQuery.attributeTypeMap;
    }
}
exports.SearchSLOQuery = SearchSLOQuery;
/**
 * @ignore
 */
SearchSLOQuery.attributeTypeMap = {
    denominator: {
        baseName: "denominator",
        type: "string",
    },
    metrics: {
        baseName: "metrics",
        type: "Array<string>",
    },
    numerator: {
        baseName: "numerator",
        type: "string",
    },
};
//# sourceMappingURL=SearchSLOQuery.js.map

/***/ }),

/***/ 79978:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchSLOResponse = void 0;
/**
 * A search SLO response containing results from the search query.
 */
class SearchSLOResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SearchSLOResponse.attributeTypeMap;
    }
}
exports.SearchSLOResponse = SearchSLOResponse;
/**
 * @ignore
 */
SearchSLOResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SearchSLOResponseData",
    },
    links: {
        baseName: "links",
        type: "SearchSLOResponseLinks",
    },
    meta: {
        baseName: "meta",
        type: "SearchSLOResponseMeta",
    },
};
//# sourceMappingURL=SearchSLOResponse.js.map

/***/ }),

/***/ 64161:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchSLOResponseData = void 0;
/**
 * Data from search SLO response.
 */
class SearchSLOResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SearchSLOResponseData.attributeTypeMap;
    }
}
exports.SearchSLOResponseData = SearchSLOResponseData;
/**
 * @ignore
 */
SearchSLOResponseData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SearchSLOResponseDataAttributes",
    },
    type: {
        baseName: "type",
        type: "string",
    },
};
//# sourceMappingURL=SearchSLOResponseData.js.map

/***/ }),

/***/ 17459:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchSLOResponseDataAttributes = void 0;
/**
 * Attributes
 */
class SearchSLOResponseDataAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SearchSLOResponseDataAttributes.attributeTypeMap;
    }
}
exports.SearchSLOResponseDataAttributes = SearchSLOResponseDataAttributes;
/**
 * @ignore
 */
SearchSLOResponseDataAttributes.attributeTypeMap = {
    facets: {
        baseName: "facets",
        type: "SearchSLOResponseDataAttributesFacets",
    },
    slos: {
        baseName: "slos",
        type: "Array<SearchServiceLevelObjective>",
    },
};
//# sourceMappingURL=SearchSLOResponseDataAttributes.js.map

/***/ }),

/***/ 70209:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchSLOResponseDataAttributesFacets = void 0;
/**
 * Facets
 */
class SearchSLOResponseDataAttributesFacets {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SearchSLOResponseDataAttributesFacets.attributeTypeMap;
    }
}
exports.SearchSLOResponseDataAttributesFacets = SearchSLOResponseDataAttributesFacets;
/**
 * @ignore
 */
SearchSLOResponseDataAttributesFacets.attributeTypeMap = {
    allTags: {
        baseName: "all_tags",
        type: "Array<SearchSLOResponseDataAttributesFacetsObjectString>",
    },
    creatorName: {
        baseName: "creator_name",
        type: "Array<SearchSLOResponseDataAttributesFacetsObjectString>",
    },
    envTags: {
        baseName: "env_tags",
        type: "Array<SearchSLOResponseDataAttributesFacetsObjectString>",
    },
    serviceTags: {
        baseName: "service_tags",
        type: "Array<SearchSLOResponseDataAttributesFacetsObjectString>",
    },
    sloType: {
        baseName: "slo_type",
        type: "Array<SearchSLOResponseDataAttributesFacetsObjectInt>",
    },
    target: {
        baseName: "target",
        type: "Array<SearchSLOResponseDataAttributesFacetsObjectInt>",
    },
    teamTags: {
        baseName: "team_tags",
        type: "Array<SearchSLOResponseDataAttributesFacetsObjectString>",
    },
    timeframe: {
        baseName: "timeframe",
        type: "Array<SearchSLOResponseDataAttributesFacetsObjectString>",
    },
};
//# sourceMappingURL=SearchSLOResponseDataAttributesFacets.js.map

/***/ }),

/***/ 58199:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchSLOResponseDataAttributesFacetsObjectInt = void 0;
/**
 * Facet
 */
class SearchSLOResponseDataAttributesFacetsObjectInt {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SearchSLOResponseDataAttributesFacetsObjectInt.attributeTypeMap;
    }
}
exports.SearchSLOResponseDataAttributesFacetsObjectInt = SearchSLOResponseDataAttributesFacetsObjectInt;
/**
 * @ignore
 */
SearchSLOResponseDataAttributesFacetsObjectInt.attributeTypeMap = {
    count: {
        baseName: "count",
        type: "number",
        format: "int64",
    },
    name: {
        baseName: "name",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=SearchSLOResponseDataAttributesFacetsObjectInt.js.map

/***/ }),

/***/ 67630:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchSLOResponseDataAttributesFacetsObjectString = void 0;
/**
 * Facet
 */
class SearchSLOResponseDataAttributesFacetsObjectString {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SearchSLOResponseDataAttributesFacetsObjectString.attributeTypeMap;
    }
}
exports.SearchSLOResponseDataAttributesFacetsObjectString = SearchSLOResponseDataAttributesFacetsObjectString;
/**
 * @ignore
 */
SearchSLOResponseDataAttributesFacetsObjectString.attributeTypeMap = {
    count: {
        baseName: "count",
        type: "number",
        format: "int64",
    },
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=SearchSLOResponseDataAttributesFacetsObjectString.js.map

/***/ }),

/***/ 21812:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchSLOResponseLinks = void 0;
/**
 * Pagination links.
 */
class SearchSLOResponseLinks {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SearchSLOResponseLinks.attributeTypeMap;
    }
}
exports.SearchSLOResponseLinks = SearchSLOResponseLinks;
/**
 * @ignore
 */
SearchSLOResponseLinks.attributeTypeMap = {
    first: {
        baseName: "first",
        type: "string",
    },
    last: {
        baseName: "last",
        type: "string",
    },
    next: {
        baseName: "next",
        type: "string",
    },
    prev: {
        baseName: "prev",
        type: "string",
    },
    self: {
        baseName: "self",
        type: "string",
    },
};
//# sourceMappingURL=SearchSLOResponseLinks.js.map

/***/ }),

/***/ 15832:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchSLOResponseMeta = void 0;
/**
 * Searches metadata returned by the API.
 */
class SearchSLOResponseMeta {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SearchSLOResponseMeta.attributeTypeMap;
    }
}
exports.SearchSLOResponseMeta = SearchSLOResponseMeta;
/**
 * @ignore
 */
SearchSLOResponseMeta.attributeTypeMap = {
    pagination: {
        baseName: "pagination",
        type: "SearchSLOResponseMetaPage",
    },
};
//# sourceMappingURL=SearchSLOResponseMeta.js.map

/***/ }),

/***/ 98664:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchSLOResponseMetaPage = void 0;
/**
 * Pagination metadata returned by the API.
 */
class SearchSLOResponseMetaPage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SearchSLOResponseMetaPage.attributeTypeMap;
    }
}
exports.SearchSLOResponseMetaPage = SearchSLOResponseMetaPage;
/**
 * @ignore
 */
SearchSLOResponseMetaPage.attributeTypeMap = {
    firstNumber: {
        baseName: "first_number",
        type: "number",
        format: "int64",
    },
    lastNumber: {
        baseName: "last_number",
        type: "number",
        format: "int64",
    },
    nextNumber: {
        baseName: "next_number",
        type: "number",
        format: "int64",
    },
    number: {
        baseName: "number",
        type: "number",
        format: "int64",
    },
    prevNumber: {
        baseName: "prev_number",
        type: "number",
        format: "int64",
    },
    size: {
        baseName: "size",
        type: "number",
        format: "int64",
    },
    total: {
        baseName: "total",
        type: "number",
        format: "int64",
    },
    type: {
        baseName: "type",
        type: "string",
    },
};
//# sourceMappingURL=SearchSLOResponseMetaPage.js.map

/***/ }),

/***/ 23463:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchSLOThreshold = void 0;
/**
 * SLO thresholds (target and optionally warning) for a single time window.
 */
class SearchSLOThreshold {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SearchSLOThreshold.attributeTypeMap;
    }
}
exports.SearchSLOThreshold = SearchSLOThreshold;
/**
 * @ignore
 */
SearchSLOThreshold.attributeTypeMap = {
    target: {
        baseName: "target",
        type: "number",
        required: true,
        format: "double",
    },
    targetDisplay: {
        baseName: "target_display",
        type: "string",
    },
    timeframe: {
        baseName: "timeframe",
        type: "SearchSLOTimeframe",
        required: true,
    },
    warning: {
        baseName: "warning",
        type: "number",
        format: "double",
    },
    warningDisplay: {
        baseName: "warning_display",
        type: "string",
    },
};
//# sourceMappingURL=SearchSLOThreshold.js.map

/***/ }),

/***/ 76963:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchServiceLevelObjective = void 0;
/**
 * A service level objective data container.
 */
class SearchServiceLevelObjective {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SearchServiceLevelObjective.attributeTypeMap;
    }
}
exports.SearchServiceLevelObjective = SearchServiceLevelObjective;
/**
 * @ignore
 */
SearchServiceLevelObjective.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SearchServiceLevelObjectiveData",
    },
};
//# sourceMappingURL=SearchServiceLevelObjective.js.map

/***/ }),

/***/ 21615:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchServiceLevelObjectiveAttributes = void 0;
/**
 * A service level objective object includes a service level indicator, thresholds
 * for one or more timeframes, and metadata (`name`, `description`, and `tags`).
 */
class SearchServiceLevelObjectiveAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SearchServiceLevelObjectiveAttributes.attributeTypeMap;
    }
}
exports.SearchServiceLevelObjectiveAttributes = SearchServiceLevelObjectiveAttributes;
/**
 * @ignore
 */
SearchServiceLevelObjectiveAttributes.attributeTypeMap = {
    allTags: {
        baseName: "all_tags",
        type: "Array<string>",
    },
    createdAt: {
        baseName: "created_at",
        type: "number",
        format: "int64",
    },
    creator: {
        baseName: "creator",
        type: "SLOCreator",
    },
    description: {
        baseName: "description",
        type: "string",
    },
    envTags: {
        baseName: "env_tags",
        type: "Array<string>",
    },
    groups: {
        baseName: "groups",
        type: "Array<string>",
    },
    modifiedAt: {
        baseName: "modified_at",
        type: "number",
        format: "int64",
    },
    monitorIds: {
        baseName: "monitor_ids",
        type: "Array<number>",
        format: "int64",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    overallStatus: {
        baseName: "overall_status",
        type: "Array<SLOOverallStatuses>",
    },
    query: {
        baseName: "query",
        type: "SearchSLOQuery",
    },
    serviceTags: {
        baseName: "service_tags",
        type: "Array<string>",
    },
    sloType: {
        baseName: "slo_type",
        type: "SLOType",
    },
    teamTags: {
        baseName: "team_tags",
        type: "Array<string>",
    },
    thresholds: {
        baseName: "thresholds",
        type: "Array<SearchSLOThreshold>",
    },
};
//# sourceMappingURL=SearchServiceLevelObjectiveAttributes.js.map

/***/ }),

/***/ 31007:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchServiceLevelObjectiveData = void 0;
/**
 * A service level objective ID and attributes.
 */
class SearchServiceLevelObjectiveData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SearchServiceLevelObjectiveData.attributeTypeMap;
    }
}
exports.SearchServiceLevelObjectiveData = SearchServiceLevelObjectiveData;
/**
 * @ignore
 */
SearchServiceLevelObjectiveData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SearchServiceLevelObjectiveAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "string",
    },
};
//# sourceMappingURL=SearchServiceLevelObjectiveData.js.map

/***/ }),

/***/ 47757:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Series = void 0;
/**
 * A metric to submit to Datadog.
 * See [Datadog metrics](https://docs.datadoghq.com/developers/metrics/#custom-metrics-properties).
 */
class Series {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return Series.attributeTypeMap;
    }
}
exports.Series = Series;
/**
 * @ignore
 */
Series.attributeTypeMap = {
    host: {
        baseName: "host",
        type: "string",
    },
    interval: {
        baseName: "interval",
        type: "number",
        format: "int64",
    },
    metric: {
        baseName: "metric",
        type: "string",
        required: true,
    },
    points: {
        baseName: "points",
        type: "Array<[number, number]>",
        required: true,
        format: "double",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    type: {
        baseName: "type",
        type: "string",
    },
};
//# sourceMappingURL=Series.js.map

/***/ }),

/***/ 87544:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceCheck = void 0;
/**
 * An object containing service check and status.
 */
class ServiceCheck {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceCheck.attributeTypeMap;
    }
}
exports.ServiceCheck = ServiceCheck;
/**
 * @ignore
 */
ServiceCheck.attributeTypeMap = {
    check: {
        baseName: "check",
        type: "string",
        required: true,
    },
    hostName: {
        baseName: "host_name",
        type: "string",
        required: true,
    },
    message: {
        baseName: "message",
        type: "string",
    },
    status: {
        baseName: "status",
        type: "ServiceCheckStatus",
        required: true,
        format: "int32",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
        required: true,
    },
    timestamp: {
        baseName: "timestamp",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=ServiceCheck.js.map

/***/ }),

/***/ 43228:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceLevelObjective = void 0;
/**
 * A service level objective object includes a service level indicator, thresholds
 * for one or more timeframes, and metadata (`name`, `description`, `tags`, etc.).
 */
class ServiceLevelObjective {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceLevelObjective.attributeTypeMap;
    }
}
exports.ServiceLevelObjective = ServiceLevelObjective;
/**
 * @ignore
 */
ServiceLevelObjective.attributeTypeMap = {
    createdAt: {
        baseName: "created_at",
        type: "number",
        format: "int64",
    },
    creator: {
        baseName: "creator",
        type: "Creator",
    },
    description: {
        baseName: "description",
        type: "string",
    },
    groups: {
        baseName: "groups",
        type: "Array<string>",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    modifiedAt: {
        baseName: "modified_at",
        type: "number",
        format: "int64",
    },
    monitorIds: {
        baseName: "monitor_ids",
        type: "Array<number>",
        format: "int64",
    },
    monitorTags: {
        baseName: "monitor_tags",
        type: "Array<string>",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    query: {
        baseName: "query",
        type: "ServiceLevelObjectiveQuery",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    targetThreshold: {
        baseName: "target_threshold",
        type: "number",
        format: "double",
    },
    thresholds: {
        baseName: "thresholds",
        type: "Array<SLOThreshold>",
        required: true,
    },
    timeframe: {
        baseName: "timeframe",
        type: "SLOTimeframe",
    },
    type: {
        baseName: "type",
        type: "SLOType",
        required: true,
    },
    warningThreshold: {
        baseName: "warning_threshold",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=ServiceLevelObjective.js.map

/***/ }),

/***/ 72178:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceLevelObjectiveQuery = void 0;
/**
 * A metric-based SLO. **Required if type is `metric`**. Note that Datadog only allows the sum by aggregator
 * to be used because this will sum up all request counts instead of averaging them, or taking the max or
 * min of all of those requests.
 */
class ServiceLevelObjectiveQuery {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceLevelObjectiveQuery.attributeTypeMap;
    }
}
exports.ServiceLevelObjectiveQuery = ServiceLevelObjectiveQuery;
/**
 * @ignore
 */
ServiceLevelObjectiveQuery.attributeTypeMap = {
    denominator: {
        baseName: "denominator",
        type: "string",
        required: true,
    },
    numerator: {
        baseName: "numerator",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=ServiceLevelObjectiveQuery.js.map

/***/ }),

/***/ 20112:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceLevelObjectiveRequest = void 0;
/**
 * A service level objective object includes a service level indicator, thresholds
 * for one or more timeframes, and metadata (`name`, `description`, `tags`, etc.).
 */
class ServiceLevelObjectiveRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceLevelObjectiveRequest.attributeTypeMap;
    }
}
exports.ServiceLevelObjectiveRequest = ServiceLevelObjectiveRequest;
/**
 * @ignore
 */
ServiceLevelObjectiveRequest.attributeTypeMap = {
    description: {
        baseName: "description",
        type: "string",
    },
    groups: {
        baseName: "groups",
        type: "Array<string>",
    },
    monitorIds: {
        baseName: "monitor_ids",
        type: "Array<number>",
        format: "int64",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    query: {
        baseName: "query",
        type: "ServiceLevelObjectiveQuery",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    targetThreshold: {
        baseName: "target_threshold",
        type: "number",
        format: "double",
    },
    thresholds: {
        baseName: "thresholds",
        type: "Array<SLOThreshold>",
        required: true,
    },
    timeframe: {
        baseName: "timeframe",
        type: "SLOTimeframe",
    },
    type: {
        baseName: "type",
        type: "SLOType",
        required: true,
    },
    warningThreshold: {
        baseName: "warning_threshold",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=ServiceLevelObjectiveRequest.js.map

/***/ }),

/***/ 96744:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceMapWidgetDefinition = void 0;
/**
 * This widget displays a map of a service to all of the services that call it, and all of the services that it calls.
 */
class ServiceMapWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceMapWidgetDefinition.attributeTypeMap;
    }
}
exports.ServiceMapWidgetDefinition = ServiceMapWidgetDefinition;
/**
 * @ignore
 */
ServiceMapWidgetDefinition.attributeTypeMap = {
    customLinks: {
        baseName: "custom_links",
        type: "Array<WidgetCustomLink>",
    },
    filters: {
        baseName: "filters",
        type: "Array<string>",
        required: true,
    },
    service: {
        baseName: "service",
        type: "string",
        required: true,
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "ServiceMapWidgetDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=ServiceMapWidgetDefinition.js.map

/***/ }),

/***/ 15351:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceSummaryWidgetDefinition = void 0;
/**
 * The service summary displays the graphs of a chosen service in your screenboard. Only available on FREE layout dashboards.
 */
class ServiceSummaryWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceSummaryWidgetDefinition.attributeTypeMap;
    }
}
exports.ServiceSummaryWidgetDefinition = ServiceSummaryWidgetDefinition;
/**
 * @ignore
 */
ServiceSummaryWidgetDefinition.attributeTypeMap = {
    displayFormat: {
        baseName: "display_format",
        type: "WidgetServiceSummaryDisplayFormat",
    },
    env: {
        baseName: "env",
        type: "string",
        required: true,
    },
    service: {
        baseName: "service",
        type: "string",
        required: true,
    },
    showBreakdown: {
        baseName: "show_breakdown",
        type: "boolean",
    },
    showDistribution: {
        baseName: "show_distribution",
        type: "boolean",
    },
    showErrors: {
        baseName: "show_errors",
        type: "boolean",
    },
    showHits: {
        baseName: "show_hits",
        type: "boolean",
    },
    showLatency: {
        baseName: "show_latency",
        type: "boolean",
    },
    showResourceList: {
        baseName: "show_resource_list",
        type: "boolean",
    },
    sizeFormat: {
        baseName: "size_format",
        type: "WidgetSizeFormat",
    },
    spanName: {
        baseName: "span_name",
        type: "string",
        required: true,
    },
    time: {
        baseName: "time",
        type: "WidgetTime",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "ServiceSummaryWidgetDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=ServiceSummaryWidgetDefinition.js.map

/***/ }),

/***/ 5609:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignalAssigneeUpdateRequest = void 0;
/**
 * Attributes describing an assignee update operation over a security signal.
 */
class SignalAssigneeUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SignalAssigneeUpdateRequest.attributeTypeMap;
    }
}
exports.SignalAssigneeUpdateRequest = SignalAssigneeUpdateRequest;
/**
 * @ignore
 */
SignalAssigneeUpdateRequest.attributeTypeMap = {
    assignee: {
        baseName: "assignee",
        type: "string",
        required: true,
    },
    version: {
        baseName: "version",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=SignalAssigneeUpdateRequest.js.map

/***/ }),

/***/ 6223:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignalStateUpdateRequest = void 0;
/**
 * Attributes describing the change of state for a given state.
 */
class SignalStateUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SignalStateUpdateRequest.attributeTypeMap;
    }
}
exports.SignalStateUpdateRequest = SignalStateUpdateRequest;
/**
 * @ignore
 */
SignalStateUpdateRequest.attributeTypeMap = {
    archiveComment: {
        baseName: "archiveComment",
        type: "string",
    },
    archiveReason: {
        baseName: "archiveReason",
        type: "SignalArchiveReason",
    },
    state: {
        baseName: "state",
        type: "SignalTriageState",
        required: true,
    },
    version: {
        baseName: "version",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=SignalStateUpdateRequest.js.map

/***/ }),

/***/ 96032:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SlackIntegrationChannel = void 0;
/**
 * The Slack channel configuration.
 */
class SlackIntegrationChannel {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SlackIntegrationChannel.attributeTypeMap;
    }
}
exports.SlackIntegrationChannel = SlackIntegrationChannel;
/**
 * @ignore
 */
SlackIntegrationChannel.attributeTypeMap = {
    display: {
        baseName: "display",
        type: "SlackIntegrationChannelDisplay",
    },
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=SlackIntegrationChannel.js.map

/***/ }),

/***/ 7456:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SlackIntegrationChannelDisplay = void 0;
/**
 * Configuration options for what is shown in an alert event message.
 */
class SlackIntegrationChannelDisplay {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SlackIntegrationChannelDisplay.attributeTypeMap;
    }
}
exports.SlackIntegrationChannelDisplay = SlackIntegrationChannelDisplay;
/**
 * @ignore
 */
SlackIntegrationChannelDisplay.attributeTypeMap = {
    message: {
        baseName: "message",
        type: "boolean",
    },
    notified: {
        baseName: "notified",
        type: "boolean",
    },
    snapshot: {
        baseName: "snapshot",
        type: "boolean",
    },
    tags: {
        baseName: "tags",
        type: "boolean",
    },
};
//# sourceMappingURL=SlackIntegrationChannelDisplay.js.map

/***/ }),

/***/ 80928:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuccessfulSignalUpdateResponse = void 0;
/**
 * Updated signal data following a successfully performed update.
 */
class SuccessfulSignalUpdateResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SuccessfulSignalUpdateResponse.attributeTypeMap;
    }
}
exports.SuccessfulSignalUpdateResponse = SuccessfulSignalUpdateResponse;
/**
 * @ignore
 */
SuccessfulSignalUpdateResponse.attributeTypeMap = {
    status: {
        baseName: "status",
        type: "string",
    },
};
//# sourceMappingURL=SuccessfulSignalUpdateResponse.js.map

/***/ }),

/***/ 20775:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SunburstWidgetDefinition = void 0;
/**
 * Sunbursts are spot on to highlight how groups contribute to the total of a query.
 */
class SunburstWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SunburstWidgetDefinition.attributeTypeMap;
    }
}
exports.SunburstWidgetDefinition = SunburstWidgetDefinition;
/**
 * @ignore
 */
SunburstWidgetDefinition.attributeTypeMap = {
    customLinks: {
        baseName: "custom_links",
        type: "Array<WidgetCustomLink>",
    },
    hideTotal: {
        baseName: "hide_total",
        type: "boolean",
    },
    legend: {
        baseName: "legend",
        type: "SunburstWidgetLegend",
    },
    requests: {
        baseName: "requests",
        type: "Array<SunburstWidgetRequest>",
        required: true,
    },
    time: {
        baseName: "time",
        type: "WidgetTime",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "SunburstWidgetDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=SunburstWidgetDefinition.js.map

/***/ }),

/***/ 1527:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SunburstWidgetLegendInlineAutomatic = void 0;
/**
 * Configuration of inline or automatic legends.
 */
class SunburstWidgetLegendInlineAutomatic {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SunburstWidgetLegendInlineAutomatic.attributeTypeMap;
    }
}
exports.SunburstWidgetLegendInlineAutomatic = SunburstWidgetLegendInlineAutomatic;
/**
 * @ignore
 */
SunburstWidgetLegendInlineAutomatic.attributeTypeMap = {
    hidePercent: {
        baseName: "hide_percent",
        type: "boolean",
    },
    hideValue: {
        baseName: "hide_value",
        type: "boolean",
    },
    type: {
        baseName: "type",
        type: "SunburstWidgetLegendInlineAutomaticType",
        required: true,
    },
};
//# sourceMappingURL=SunburstWidgetLegendInlineAutomatic.js.map

/***/ }),

/***/ 42284:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SunburstWidgetLegendTable = void 0;
/**
 * Configuration of table-based legend.
 */
class SunburstWidgetLegendTable {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SunburstWidgetLegendTable.attributeTypeMap;
    }
}
exports.SunburstWidgetLegendTable = SunburstWidgetLegendTable;
/**
 * @ignore
 */
SunburstWidgetLegendTable.attributeTypeMap = {
    type: {
        baseName: "type",
        type: "SunburstWidgetLegendTableType",
        required: true,
    },
};
//# sourceMappingURL=SunburstWidgetLegendTable.js.map

/***/ }),

/***/ 60511:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SunburstWidgetRequest = void 0;
/**
 * Request definition of sunburst widget.
 */
class SunburstWidgetRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SunburstWidgetRequest.attributeTypeMap;
    }
}
exports.SunburstWidgetRequest = SunburstWidgetRequest;
/**
 * @ignore
 */
SunburstWidgetRequest.attributeTypeMap = {
    apmQuery: {
        baseName: "apm_query",
        type: "LogQueryDefinition",
    },
    auditQuery: {
        baseName: "audit_query",
        type: "LogQueryDefinition",
    },
    eventQuery: {
        baseName: "event_query",
        type: "LogQueryDefinition",
    },
    formulas: {
        baseName: "formulas",
        type: "Array<WidgetFormula>",
    },
    logQuery: {
        baseName: "log_query",
        type: "LogQueryDefinition",
    },
    networkQuery: {
        baseName: "network_query",
        type: "LogQueryDefinition",
    },
    processQuery: {
        baseName: "process_query",
        type: "ProcessQueryDefinition",
    },
    profileMetricsQuery: {
        baseName: "profile_metrics_query",
        type: "LogQueryDefinition",
    },
    q: {
        baseName: "q",
        type: "string",
    },
    queries: {
        baseName: "queries",
        type: "Array<FormulaAndFunctionQueryDefinition>",
    },
    responseFormat: {
        baseName: "response_format",
        type: "FormulaAndFunctionResponseFormat",
    },
    rumQuery: {
        baseName: "rum_query",
        type: "LogQueryDefinition",
    },
    securityQuery: {
        baseName: "security_query",
        type: "LogQueryDefinition",
    },
};
//# sourceMappingURL=SunburstWidgetRequest.js.map

/***/ }),

/***/ 4175:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsAPIStep = void 0;
/**
 * The steps used in a Synthetics multistep API test.
 */
class SyntheticsAPIStep {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsAPIStep.attributeTypeMap;
    }
}
exports.SyntheticsAPIStep = SyntheticsAPIStep;
/**
 * @ignore
 */
SyntheticsAPIStep.attributeTypeMap = {
    allowFailure: {
        baseName: "allowFailure",
        type: "boolean",
    },
    assertions: {
        baseName: "assertions",
        type: "Array<SyntheticsAssertion>",
        required: true,
    },
    extractedValues: {
        baseName: "extractedValues",
        type: "Array<SyntheticsParsingOptions>",
    },
    isCritical: {
        baseName: "isCritical",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    request: {
        baseName: "request",
        type: "SyntheticsTestRequest",
        required: true,
    },
    retry: {
        baseName: "retry",
        type: "SyntheticsTestOptionsRetry",
    },
    subtype: {
        baseName: "subtype",
        type: "SyntheticsAPIStepSubtype",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsAPIStep.js.map

/***/ }),

/***/ 3433:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsAPITest = void 0;
/**
 * Object containing details about a Synthetic API test.
 */
class SyntheticsAPITest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsAPITest.attributeTypeMap;
    }
}
exports.SyntheticsAPITest = SyntheticsAPITest;
/**
 * @ignore
 */
SyntheticsAPITest.attributeTypeMap = {
    config: {
        baseName: "config",
        type: "SyntheticsAPITestConfig",
        required: true,
    },
    locations: {
        baseName: "locations",
        type: "Array<string>",
        required: true,
    },
    message: {
        baseName: "message",
        type: "string",
        required: true,
    },
    monitorId: {
        baseName: "monitor_id",
        type: "number",
        format: "int64",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    options: {
        baseName: "options",
        type: "SyntheticsTestOptions",
        required: true,
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    status: {
        baseName: "status",
        type: "SyntheticsTestPauseStatus",
    },
    subtype: {
        baseName: "subtype",
        type: "SyntheticsTestDetailsSubType",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    type: {
        baseName: "type",
        type: "SyntheticsAPITestType",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsAPITest.js.map

/***/ }),

/***/ 60634:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsAPITestConfig = void 0;
/**
 * Configuration object for a Synthetic API test.
 */
class SyntheticsAPITestConfig {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsAPITestConfig.attributeTypeMap;
    }
}
exports.SyntheticsAPITestConfig = SyntheticsAPITestConfig;
/**
 * @ignore
 */
SyntheticsAPITestConfig.attributeTypeMap = {
    assertions: {
        baseName: "assertions",
        type: "Array<SyntheticsAssertion>",
    },
    configVariables: {
        baseName: "configVariables",
        type: "Array<SyntheticsConfigVariable>",
    },
    request: {
        baseName: "request",
        type: "SyntheticsTestRequest",
    },
    steps: {
        baseName: "steps",
        type: "Array<SyntheticsAPIStep>",
    },
};
//# sourceMappingURL=SyntheticsAPITestConfig.js.map

/***/ }),

/***/ 21132:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsAPITestResultData = void 0;
/**
 * Object containing results for your Synthetic API test.
 */
class SyntheticsAPITestResultData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsAPITestResultData.attributeTypeMap;
    }
}
exports.SyntheticsAPITestResultData = SyntheticsAPITestResultData;
/**
 * @ignore
 */
SyntheticsAPITestResultData.attributeTypeMap = {
    cert: {
        baseName: "cert",
        type: "SyntheticsSSLCertificate",
    },
    eventType: {
        baseName: "eventType",
        type: "SyntheticsTestProcessStatus",
    },
    failure: {
        baseName: "failure",
        type: "SyntheticsApiTestResultFailure",
    },
    httpStatusCode: {
        baseName: "httpStatusCode",
        type: "number",
        format: "int64",
    },
    requestHeaders: {
        baseName: "requestHeaders",
        type: "{ [key: string]: any; }",
    },
    responseBody: {
        baseName: "responseBody",
        type: "string",
    },
    responseHeaders: {
        baseName: "responseHeaders",
        type: "{ [key: string]: any; }",
    },
    responseSize: {
        baseName: "responseSize",
        type: "number",
        format: "int64",
    },
    timings: {
        baseName: "timings",
        type: "SyntheticsTiming",
    },
};
//# sourceMappingURL=SyntheticsAPITestResultData.js.map

/***/ }),

/***/ 92111:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsAPITestResultFull = void 0;
/**
 * Object returned describing a API test result.
 */
class SyntheticsAPITestResultFull {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsAPITestResultFull.attributeTypeMap;
    }
}
exports.SyntheticsAPITestResultFull = SyntheticsAPITestResultFull;
/**
 * @ignore
 */
SyntheticsAPITestResultFull.attributeTypeMap = {
    check: {
        baseName: "check",
        type: "SyntheticsAPITestResultFullCheck",
    },
    checkTime: {
        baseName: "check_time",
        type: "number",
        format: "double",
    },
    checkVersion: {
        baseName: "check_version",
        type: "number",
        format: "int64",
    },
    probeDc: {
        baseName: "probe_dc",
        type: "string",
    },
    result: {
        baseName: "result",
        type: "SyntheticsAPITestResultData",
    },
    resultId: {
        baseName: "result_id",
        type: "string",
    },
    status: {
        baseName: "status",
        type: "SyntheticsTestMonitorStatus",
        format: "int64",
    },
};
//# sourceMappingURL=SyntheticsAPITestResultFull.js.map

/***/ }),

/***/ 81032:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsAPITestResultFullCheck = void 0;
/**
 * Object describing the API test configuration.
 */
class SyntheticsAPITestResultFullCheck {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsAPITestResultFullCheck.attributeTypeMap;
    }
}
exports.SyntheticsAPITestResultFullCheck = SyntheticsAPITestResultFullCheck;
/**
 * @ignore
 */
SyntheticsAPITestResultFullCheck.attributeTypeMap = {
    config: {
        baseName: "config",
        type: "SyntheticsTestConfig",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsAPITestResultFullCheck.js.map

/***/ }),

/***/ 2048:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsAPITestResultShort = void 0;
/**
 * Object with the results of a single Synthetic API test.
 */
class SyntheticsAPITestResultShort {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsAPITestResultShort.attributeTypeMap;
    }
}
exports.SyntheticsAPITestResultShort = SyntheticsAPITestResultShort;
/**
 * @ignore
 */
SyntheticsAPITestResultShort.attributeTypeMap = {
    checkTime: {
        baseName: "check_time",
        type: "number",
        format: "double",
    },
    probeDc: {
        baseName: "probe_dc",
        type: "string",
    },
    result: {
        baseName: "result",
        type: "SyntheticsAPITestResultShortResult",
    },
    resultId: {
        baseName: "result_id",
        type: "string",
    },
    status: {
        baseName: "status",
        type: "SyntheticsTestMonitorStatus",
        format: "int64",
    },
};
//# sourceMappingURL=SyntheticsAPITestResultShort.js.map

/***/ }),

/***/ 85380:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsAPITestResultShortResult = void 0;
/**
 * Result of the last API test run.
 */
class SyntheticsAPITestResultShortResult {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsAPITestResultShortResult.attributeTypeMap;
    }
}
exports.SyntheticsAPITestResultShortResult = SyntheticsAPITestResultShortResult;
/**
 * @ignore
 */
SyntheticsAPITestResultShortResult.attributeTypeMap = {
    passed: {
        baseName: "passed",
        type: "boolean",
    },
    timings: {
        baseName: "timings",
        type: "SyntheticsTiming",
    },
};
//# sourceMappingURL=SyntheticsAPITestResultShortResult.js.map

/***/ }),

/***/ 42098:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsApiTestResultFailure = void 0;
/**
 * The API test failure details.
 */
class SyntheticsApiTestResultFailure {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsApiTestResultFailure.attributeTypeMap;
    }
}
exports.SyntheticsApiTestResultFailure = SyntheticsApiTestResultFailure;
/**
 * @ignore
 */
SyntheticsApiTestResultFailure.attributeTypeMap = {
    code: {
        baseName: "code",
        type: "SyntheticsApiTestFailureCode",
    },
    message: {
        baseName: "message",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsApiTestResultFailure.js.map

/***/ }),

/***/ 14493:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsAssertionJSONPathTarget = void 0;
/**
 * An assertion for the `validatesJSONPath` operator.
 */
class SyntheticsAssertionJSONPathTarget {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsAssertionJSONPathTarget.attributeTypeMap;
    }
}
exports.SyntheticsAssertionJSONPathTarget = SyntheticsAssertionJSONPathTarget;
/**
 * @ignore
 */
SyntheticsAssertionJSONPathTarget.attributeTypeMap = {
    operator: {
        baseName: "operator",
        type: "SyntheticsAssertionJSONPathOperator",
        required: true,
    },
    property: {
        baseName: "property",
        type: "string",
    },
    target: {
        baseName: "target",
        type: "SyntheticsAssertionJSONPathTargetTarget",
    },
    type: {
        baseName: "type",
        type: "SyntheticsAssertionType",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsAssertionJSONPathTarget.js.map

/***/ }),

/***/ 46885:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsAssertionJSONPathTargetTarget = void 0;
/**
 * Composed target for `validatesJSONPath` operator.
 */
class SyntheticsAssertionJSONPathTargetTarget {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsAssertionJSONPathTargetTarget.attributeTypeMap;
    }
}
exports.SyntheticsAssertionJSONPathTargetTarget = SyntheticsAssertionJSONPathTargetTarget;
/**
 * @ignore
 */
SyntheticsAssertionJSONPathTargetTarget.attributeTypeMap = {
    jsonPath: {
        baseName: "jsonPath",
        type: "string",
    },
    operator: {
        baseName: "operator",
        type: "string",
    },
    targetValue: {
        baseName: "targetValue",
        type: "any",
    },
};
//# sourceMappingURL=SyntheticsAssertionJSONPathTargetTarget.js.map

/***/ }),

/***/ 11801:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsAssertionTarget = void 0;
/**
 * An assertion which uses a simple target.
 */
class SyntheticsAssertionTarget {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsAssertionTarget.attributeTypeMap;
    }
}
exports.SyntheticsAssertionTarget = SyntheticsAssertionTarget;
/**
 * @ignore
 */
SyntheticsAssertionTarget.attributeTypeMap = {
    operator: {
        baseName: "operator",
        type: "SyntheticsAssertionOperator",
        required: true,
    },
    property: {
        baseName: "property",
        type: "string",
    },
    target: {
        baseName: "target",
        type: "any",
        required: true,
    },
    type: {
        baseName: "type",
        type: "SyntheticsAssertionType",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsAssertionTarget.js.map

/***/ }),

/***/ 77700:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsAssertionXPathTarget = void 0;
/**
 * An assertion for the `validatesXPath` operator.
 */
class SyntheticsAssertionXPathTarget {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsAssertionXPathTarget.attributeTypeMap;
    }
}
exports.SyntheticsAssertionXPathTarget = SyntheticsAssertionXPathTarget;
/**
 * @ignore
 */
SyntheticsAssertionXPathTarget.attributeTypeMap = {
    operator: {
        baseName: "operator",
        type: "SyntheticsAssertionXPathOperator",
        required: true,
    },
    property: {
        baseName: "property",
        type: "string",
    },
    target: {
        baseName: "target",
        type: "SyntheticsAssertionXPathTargetTarget",
    },
    type: {
        baseName: "type",
        type: "SyntheticsAssertionType",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsAssertionXPathTarget.js.map

/***/ }),

/***/ 55117:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsAssertionXPathTargetTarget = void 0;
/**
 * Composed target for `validatesXPath` operator.
 */
class SyntheticsAssertionXPathTargetTarget {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsAssertionXPathTargetTarget.attributeTypeMap;
    }
}
exports.SyntheticsAssertionXPathTargetTarget = SyntheticsAssertionXPathTargetTarget;
/**
 * @ignore
 */
SyntheticsAssertionXPathTargetTarget.attributeTypeMap = {
    operator: {
        baseName: "operator",
        type: "string",
    },
    targetValue: {
        baseName: "targetValue",
        type: "any",
    },
    xPath: {
        baseName: "xPath",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsAssertionXPathTargetTarget.js.map

/***/ }),

/***/ 18046:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsBasicAuthDigest = void 0;
/**
 * Object to handle digest authentication when performing the test.
 */
class SyntheticsBasicAuthDigest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsBasicAuthDigest.attributeTypeMap;
    }
}
exports.SyntheticsBasicAuthDigest = SyntheticsBasicAuthDigest;
/**
 * @ignore
 */
SyntheticsBasicAuthDigest.attributeTypeMap = {
    password: {
        baseName: "password",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "SyntheticsBasicAuthDigestType",
    },
    username: {
        baseName: "username",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsBasicAuthDigest.js.map

/***/ }),

/***/ 82481:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsBasicAuthNTLM = void 0;
/**
 * Object to handle `NTLM` authentication when performing the test.
 */
class SyntheticsBasicAuthNTLM {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsBasicAuthNTLM.attributeTypeMap;
    }
}
exports.SyntheticsBasicAuthNTLM = SyntheticsBasicAuthNTLM;
/**
 * @ignore
 */
SyntheticsBasicAuthNTLM.attributeTypeMap = {
    domain: {
        baseName: "domain",
        type: "string",
    },
    password: {
        baseName: "password",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "SyntheticsBasicAuthNTLMType",
        required: true,
    },
    username: {
        baseName: "username",
        type: "string",
    },
    workstation: {
        baseName: "workstation",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsBasicAuthNTLM.js.map

/***/ }),

/***/ 15718:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsBasicAuthOauthClient = void 0;
/**
 * Object to handle `oauth client` authentication when performing the test.
 */
class SyntheticsBasicAuthOauthClient {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsBasicAuthOauthClient.attributeTypeMap;
    }
}
exports.SyntheticsBasicAuthOauthClient = SyntheticsBasicAuthOauthClient;
/**
 * @ignore
 */
SyntheticsBasicAuthOauthClient.attributeTypeMap = {
    accessTokenUrl: {
        baseName: "accessTokenUrl",
        type: "string",
        required: true,
    },
    audience: {
        baseName: "audience",
        type: "string",
    },
    clientId: {
        baseName: "clientId",
        type: "string",
        required: true,
    },
    clientSecret: {
        baseName: "clientSecret",
        type: "string",
        required: true,
    },
    resource: {
        baseName: "resource",
        type: "string",
    },
    scope: {
        baseName: "scope",
        type: "string",
    },
    tokenApiAuthentication: {
        baseName: "tokenApiAuthentication",
        type: "SyntheticsBasicAuthOauthTokenApiAuthentication",
        required: true,
    },
    type: {
        baseName: "type",
        type: "SyntheticsBasicAuthOauthClientType",
    },
};
//# sourceMappingURL=SyntheticsBasicAuthOauthClient.js.map

/***/ }),

/***/ 3887:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsBasicAuthOauthROP = void 0;
/**
 * Object to handle `oauth rop` authentication when performing the test.
 */
class SyntheticsBasicAuthOauthROP {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsBasicAuthOauthROP.attributeTypeMap;
    }
}
exports.SyntheticsBasicAuthOauthROP = SyntheticsBasicAuthOauthROP;
/**
 * @ignore
 */
SyntheticsBasicAuthOauthROP.attributeTypeMap = {
    accessTokenUrl: {
        baseName: "accessTokenUrl",
        type: "string",
        required: true,
    },
    audience: {
        baseName: "audience",
        type: "string",
    },
    clientId: {
        baseName: "clientId",
        type: "string",
    },
    clientSecret: {
        baseName: "clientSecret",
        type: "string",
    },
    password: {
        baseName: "password",
        type: "string",
        required: true,
    },
    resource: {
        baseName: "resource",
        type: "string",
    },
    scope: {
        baseName: "scope",
        type: "string",
    },
    tokenApiAuthentication: {
        baseName: "tokenApiAuthentication",
        type: "SyntheticsBasicAuthOauthTokenApiAuthentication",
        required: true,
    },
    type: {
        baseName: "type",
        type: "SyntheticsBasicAuthOauthROPType",
    },
    username: {
        baseName: "username",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsBasicAuthOauthROP.js.map

/***/ }),

/***/ 30084:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsBasicAuthSigv4 = void 0;
/**
 * Object to handle `SIGV4` authentication when performing the test.
 */
class SyntheticsBasicAuthSigv4 {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsBasicAuthSigv4.attributeTypeMap;
    }
}
exports.SyntheticsBasicAuthSigv4 = SyntheticsBasicAuthSigv4;
/**
 * @ignore
 */
SyntheticsBasicAuthSigv4.attributeTypeMap = {
    accessKey: {
        baseName: "accessKey",
        type: "string",
        required: true,
    },
    region: {
        baseName: "region",
        type: "string",
    },
    secretKey: {
        baseName: "secretKey",
        type: "string",
        required: true,
    },
    serviceName: {
        baseName: "serviceName",
        type: "string",
    },
    sessionToken: {
        baseName: "sessionToken",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "SyntheticsBasicAuthSigv4Type",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsBasicAuthSigv4.js.map

/***/ }),

/***/ 82117:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsBasicAuthWeb = void 0;
/**
 * Object to handle basic authentication when performing the test.
 */
class SyntheticsBasicAuthWeb {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsBasicAuthWeb.attributeTypeMap;
    }
}
exports.SyntheticsBasicAuthWeb = SyntheticsBasicAuthWeb;
/**
 * @ignore
 */
SyntheticsBasicAuthWeb.attributeTypeMap = {
    password: {
        baseName: "password",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "SyntheticsBasicAuthWebType",
    },
    username: {
        baseName: "username",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsBasicAuthWeb.js.map

/***/ }),

/***/ 82598:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsBatchDetails = void 0;
/**
 * Details about a batch response.
 */
class SyntheticsBatchDetails {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsBatchDetails.attributeTypeMap;
    }
}
exports.SyntheticsBatchDetails = SyntheticsBatchDetails;
/**
 * @ignore
 */
SyntheticsBatchDetails.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SyntheticsBatchDetailsData",
    },
};
//# sourceMappingURL=SyntheticsBatchDetails.js.map

/***/ }),

/***/ 47215:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsBatchDetailsData = void 0;
/**
 * Wrapper object that contains the details of a batch.
 */
class SyntheticsBatchDetailsData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsBatchDetailsData.attributeTypeMap;
    }
}
exports.SyntheticsBatchDetailsData = SyntheticsBatchDetailsData;
/**
 * @ignore
 */
SyntheticsBatchDetailsData.attributeTypeMap = {
    metadata: {
        baseName: "metadata",
        type: "SyntheticsCIBatchMetadata",
    },
    results: {
        baseName: "results",
        type: "Array<SyntheticsBatchResult>",
    },
    status: {
        baseName: "status",
        type: "SyntheticsStatus",
    },
};
//# sourceMappingURL=SyntheticsBatchDetailsData.js.map

/***/ }),

/***/ 8974:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsBatchResult = void 0;
/**
 * Object with the results of a Synthetics batch.
 */
class SyntheticsBatchResult {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsBatchResult.attributeTypeMap;
    }
}
exports.SyntheticsBatchResult = SyntheticsBatchResult;
/**
 * @ignore
 */
SyntheticsBatchResult.attributeTypeMap = {
    device: {
        baseName: "device",
        type: "SyntheticsDeviceID",
    },
    duration: {
        baseName: "duration",
        type: "number",
        format: "double",
    },
    executionRule: {
        baseName: "execution_rule",
        type: "SyntheticsTestExecutionRule",
    },
    location: {
        baseName: "location",
        type: "string",
    },
    resultId: {
        baseName: "result_id",
        type: "string",
    },
    retries: {
        baseName: "retries",
        type: "number",
        format: "double",
    },
    status: {
        baseName: "status",
        type: "SyntheticsStatus",
    },
    testName: {
        baseName: "test_name",
        type: "string",
    },
    testPublicId: {
        baseName: "test_public_id",
        type: "string",
    },
    testType: {
        baseName: "test_type",
        type: "SyntheticsTestDetailsType",
    },
};
//# sourceMappingURL=SyntheticsBatchResult.js.map

/***/ }),

/***/ 7593:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsBrowserError = void 0;
/**
 * Error response object for a browser test.
 */
class SyntheticsBrowserError {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsBrowserError.attributeTypeMap;
    }
}
exports.SyntheticsBrowserError = SyntheticsBrowserError;
/**
 * @ignore
 */
SyntheticsBrowserError.attributeTypeMap = {
    description: {
        baseName: "description",
        type: "string",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    status: {
        baseName: "status",
        type: "number",
        format: "int64",
    },
    type: {
        baseName: "type",
        type: "SyntheticsBrowserErrorType",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsBrowserError.js.map

/***/ }),

/***/ 44771:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsBrowserTest = void 0;
/**
 * Object containing details about a Synthetic browser test.
 */
class SyntheticsBrowserTest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsBrowserTest.attributeTypeMap;
    }
}
exports.SyntheticsBrowserTest = SyntheticsBrowserTest;
/**
 * @ignore
 */
SyntheticsBrowserTest.attributeTypeMap = {
    config: {
        baseName: "config",
        type: "SyntheticsBrowserTestConfig",
        required: true,
    },
    locations: {
        baseName: "locations",
        type: "Array<string>",
        required: true,
    },
    message: {
        baseName: "message",
        type: "string",
        required: true,
    },
    monitorId: {
        baseName: "monitor_id",
        type: "number",
        format: "int64",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    options: {
        baseName: "options",
        type: "SyntheticsTestOptions",
        required: true,
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    status: {
        baseName: "status",
        type: "SyntheticsTestPauseStatus",
    },
    steps: {
        baseName: "steps",
        type: "Array<SyntheticsStep>",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    type: {
        baseName: "type",
        type: "SyntheticsBrowserTestType",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsBrowserTest.js.map

/***/ }),

/***/ 73455:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsBrowserTestConfig = void 0;
/**
 * Configuration object for a Synthetic browser test.
 */
class SyntheticsBrowserTestConfig {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsBrowserTestConfig.attributeTypeMap;
    }
}
exports.SyntheticsBrowserTestConfig = SyntheticsBrowserTestConfig;
/**
 * @ignore
 */
SyntheticsBrowserTestConfig.attributeTypeMap = {
    assertions: {
        baseName: "assertions",
        type: "Array<SyntheticsAssertion>",
        required: true,
    },
    configVariables: {
        baseName: "configVariables",
        type: "Array<SyntheticsConfigVariable>",
    },
    request: {
        baseName: "request",
        type: "SyntheticsTestRequest",
        required: true,
    },
    setCookie: {
        baseName: "setCookie",
        type: "string",
    },
    variables: {
        baseName: "variables",
        type: "Array<SyntheticsBrowserVariable>",
    },
};
//# sourceMappingURL=SyntheticsBrowserTestConfig.js.map

/***/ }),

/***/ 9337:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsBrowserTestResultData = void 0;
/**
 * Object containing results for your Synthetic browser test.
 */
class SyntheticsBrowserTestResultData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsBrowserTestResultData.attributeTypeMap;
    }
}
exports.SyntheticsBrowserTestResultData = SyntheticsBrowserTestResultData;
/**
 * @ignore
 */
SyntheticsBrowserTestResultData.attributeTypeMap = {
    browserType: {
        baseName: "browserType",
        type: "string",
    },
    browserVersion: {
        baseName: "browserVersion",
        type: "string",
    },
    device: {
        baseName: "device",
        type: "SyntheticsDevice",
    },
    duration: {
        baseName: "duration",
        type: "number",
        format: "double",
    },
    error: {
        baseName: "error",
        type: "string",
    },
    failure: {
        baseName: "failure",
        type: "SyntheticsBrowserTestResultFailure",
    },
    passed: {
        baseName: "passed",
        type: "boolean",
    },
    receivedEmailCount: {
        baseName: "receivedEmailCount",
        type: "number",
        format: "int64",
    },
    startUrl: {
        baseName: "startUrl",
        type: "string",
    },
    stepDetails: {
        baseName: "stepDetails",
        type: "Array<SyntheticsStepDetail>",
    },
    thumbnailsBucketKey: {
        baseName: "thumbnailsBucketKey",
        type: "boolean",
    },
    timeToInteractive: {
        baseName: "timeToInteractive",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=SyntheticsBrowserTestResultData.js.map

/***/ }),

/***/ 80686:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsBrowserTestResultFailure = void 0;
/**
 * The browser test failure details.
 */
class SyntheticsBrowserTestResultFailure {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsBrowserTestResultFailure.attributeTypeMap;
    }
}
exports.SyntheticsBrowserTestResultFailure = SyntheticsBrowserTestResultFailure;
/**
 * @ignore
 */
SyntheticsBrowserTestResultFailure.attributeTypeMap = {
    code: {
        baseName: "code",
        type: "SyntheticsBrowserTestFailureCode",
    },
    message: {
        baseName: "message",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsBrowserTestResultFailure.js.map

/***/ }),

/***/ 88630:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsBrowserTestResultFull = void 0;
/**
 * Object returned describing a browser test result.
 */
class SyntheticsBrowserTestResultFull {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsBrowserTestResultFull.attributeTypeMap;
    }
}
exports.SyntheticsBrowserTestResultFull = SyntheticsBrowserTestResultFull;
/**
 * @ignore
 */
SyntheticsBrowserTestResultFull.attributeTypeMap = {
    check: {
        baseName: "check",
        type: "SyntheticsBrowserTestResultFullCheck",
    },
    checkTime: {
        baseName: "check_time",
        type: "number",
        format: "double",
    },
    checkVersion: {
        baseName: "check_version",
        type: "number",
        format: "int64",
    },
    probeDc: {
        baseName: "probe_dc",
        type: "string",
    },
    result: {
        baseName: "result",
        type: "SyntheticsBrowserTestResultData",
    },
    resultId: {
        baseName: "result_id",
        type: "string",
    },
    status: {
        baseName: "status",
        type: "SyntheticsTestMonitorStatus",
        format: "int64",
    },
};
//# sourceMappingURL=SyntheticsBrowserTestResultFull.js.map

/***/ }),

/***/ 32340:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsBrowserTestResultFullCheck = void 0;
/**
 * Object describing the browser test configuration.
 */
class SyntheticsBrowserTestResultFullCheck {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsBrowserTestResultFullCheck.attributeTypeMap;
    }
}
exports.SyntheticsBrowserTestResultFullCheck = SyntheticsBrowserTestResultFullCheck;
/**
 * @ignore
 */
SyntheticsBrowserTestResultFullCheck.attributeTypeMap = {
    config: {
        baseName: "config",
        type: "SyntheticsTestConfig",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsBrowserTestResultFullCheck.js.map

/***/ }),

/***/ 2904:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsBrowserTestResultShort = void 0;
/**
 * Object with the results of a single Synthetic browser test.
 */
class SyntheticsBrowserTestResultShort {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsBrowserTestResultShort.attributeTypeMap;
    }
}
exports.SyntheticsBrowserTestResultShort = SyntheticsBrowserTestResultShort;
/**
 * @ignore
 */
SyntheticsBrowserTestResultShort.attributeTypeMap = {
    checkTime: {
        baseName: "check_time",
        type: "number",
        format: "double",
    },
    probeDc: {
        baseName: "probe_dc",
        type: "string",
    },
    result: {
        baseName: "result",
        type: "SyntheticsBrowserTestResultShortResult",
    },
    resultId: {
        baseName: "result_id",
        type: "string",
    },
    status: {
        baseName: "status",
        type: "SyntheticsTestMonitorStatus",
        format: "int64",
    },
};
//# sourceMappingURL=SyntheticsBrowserTestResultShort.js.map

/***/ }),

/***/ 58505:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsBrowserTestResultShortResult = void 0;
/**
 * Object with the result of the last browser test run.
 */
class SyntheticsBrowserTestResultShortResult {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsBrowserTestResultShortResult.attributeTypeMap;
    }
}
exports.SyntheticsBrowserTestResultShortResult = SyntheticsBrowserTestResultShortResult;
/**
 * @ignore
 */
SyntheticsBrowserTestResultShortResult.attributeTypeMap = {
    device: {
        baseName: "device",
        type: "SyntheticsDevice",
    },
    duration: {
        baseName: "duration",
        type: "number",
        format: "double",
    },
    errorCount: {
        baseName: "errorCount",
        type: "number",
        format: "int64",
    },
    stepCountCompleted: {
        baseName: "stepCountCompleted",
        type: "number",
        format: "int64",
    },
    stepCountTotal: {
        baseName: "stepCountTotal",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=SyntheticsBrowserTestResultShortResult.js.map

/***/ }),

/***/ 42556:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsBrowserTestRumSettings = void 0;
/**
 * The RUM data collection settings for the Synthetic browser test.
 * **Note:** There are 3 ways to format RUM settings:
 *
 * `{ isEnabled: false }`
 * RUM data is not collected.
 *
 * `{ isEnabled: true }`
 * RUM data is collected from the Synthetic test's default application.
 *
 * `{ isEnabled: true, applicationId: "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx", clientTokenId: 12345 }`
 * RUM data is collected using the specified application.
 */
class SyntheticsBrowserTestRumSettings {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsBrowserTestRumSettings.attributeTypeMap;
    }
}
exports.SyntheticsBrowserTestRumSettings = SyntheticsBrowserTestRumSettings;
/**
 * @ignore
 */
SyntheticsBrowserTestRumSettings.attributeTypeMap = {
    applicationId: {
        baseName: "applicationId",
        type: "string",
    },
    clientTokenId: {
        baseName: "clientTokenId",
        type: "number",
        format: "int64",
    },
    isEnabled: {
        baseName: "isEnabled",
        type: "boolean",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsBrowserTestRumSettings.js.map

/***/ }),

/***/ 35642:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsBrowserVariable = void 0;
/**
 * Object defining a variable that can be used in your browser test.
 * Learn more in the [Browser test Actions documentation](https://docs.datadoghq.com/synthetics/browser_tests/actions#variable).
 */
class SyntheticsBrowserVariable {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsBrowserVariable.attributeTypeMap;
    }
}
exports.SyntheticsBrowserVariable = SyntheticsBrowserVariable;
/**
 * @ignore
 */
SyntheticsBrowserVariable.attributeTypeMap = {
    example: {
        baseName: "example",
        type: "string",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    pattern: {
        baseName: "pattern",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "SyntheticsBrowserVariableType",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsBrowserVariable.js.map

/***/ }),

/***/ 12212:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsCIBatchMetadata = void 0;
/**
 * Metadata for the Synthetics tests run.
 */
class SyntheticsCIBatchMetadata {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsCIBatchMetadata.attributeTypeMap;
    }
}
exports.SyntheticsCIBatchMetadata = SyntheticsCIBatchMetadata;
/**
 * @ignore
 */
SyntheticsCIBatchMetadata.attributeTypeMap = {
    ci: {
        baseName: "ci",
        type: "SyntheticsCIBatchMetadataCI",
    },
    git: {
        baseName: "git",
        type: "SyntheticsCIBatchMetadataGit",
    },
};
//# sourceMappingURL=SyntheticsCIBatchMetadata.js.map

/***/ }),

/***/ 20102:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsCIBatchMetadataCI = void 0;
/**
 * Description of the CI provider.
 */
class SyntheticsCIBatchMetadataCI {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsCIBatchMetadataCI.attributeTypeMap;
    }
}
exports.SyntheticsCIBatchMetadataCI = SyntheticsCIBatchMetadataCI;
/**
 * @ignore
 */
SyntheticsCIBatchMetadataCI.attributeTypeMap = {
    pipeline: {
        baseName: "pipeline",
        type: "SyntheticsCIBatchMetadataPipeline",
    },
    provider: {
        baseName: "provider",
        type: "SyntheticsCIBatchMetadataProvider",
    },
};
//# sourceMappingURL=SyntheticsCIBatchMetadataCI.js.map

/***/ }),

/***/ 72392:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsCIBatchMetadataGit = void 0;
/**
 * Git information.
 */
class SyntheticsCIBatchMetadataGit {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsCIBatchMetadataGit.attributeTypeMap;
    }
}
exports.SyntheticsCIBatchMetadataGit = SyntheticsCIBatchMetadataGit;
/**
 * @ignore
 */
SyntheticsCIBatchMetadataGit.attributeTypeMap = {
    branch: {
        baseName: "branch",
        type: "string",
    },
    commitSha: {
        baseName: "commitSha",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsCIBatchMetadataGit.js.map

/***/ }),

/***/ 31619:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsCIBatchMetadataPipeline = void 0;
/**
 * Description of the CI pipeline.
 */
class SyntheticsCIBatchMetadataPipeline {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsCIBatchMetadataPipeline.attributeTypeMap;
    }
}
exports.SyntheticsCIBatchMetadataPipeline = SyntheticsCIBatchMetadataPipeline;
/**
 * @ignore
 */
SyntheticsCIBatchMetadataPipeline.attributeTypeMap = {
    url: {
        baseName: "url",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsCIBatchMetadataPipeline.js.map

/***/ }),

/***/ 75363:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsCIBatchMetadataProvider = void 0;
/**
 * Description of the CI provider.
 */
class SyntheticsCIBatchMetadataProvider {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsCIBatchMetadataProvider.attributeTypeMap;
    }
}
exports.SyntheticsCIBatchMetadataProvider = SyntheticsCIBatchMetadataProvider;
/**
 * @ignore
 */
SyntheticsCIBatchMetadataProvider.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsCIBatchMetadataProvider.js.map

/***/ }),

/***/ 56409:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsCITest = void 0;
/**
 * Test configuration for Synthetics CI
 */
class SyntheticsCITest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsCITest.attributeTypeMap;
    }
}
exports.SyntheticsCITest = SyntheticsCITest;
/**
 * @ignore
 */
SyntheticsCITest.attributeTypeMap = {
    allowInsecureCertificates: {
        baseName: "allowInsecureCertificates",
        type: "boolean",
    },
    basicAuth: {
        baseName: "basicAuth",
        type: "SyntheticsBasicAuth",
    },
    body: {
        baseName: "body",
        type: "string",
    },
    bodyType: {
        baseName: "bodyType",
        type: "string",
    },
    cookies: {
        baseName: "cookies",
        type: "string",
    },
    deviceIds: {
        baseName: "deviceIds",
        type: "Array<SyntheticsDeviceID>",
    },
    followRedirects: {
        baseName: "followRedirects",
        type: "boolean",
    },
    headers: {
        baseName: "headers",
        type: "{ [key: string]: string; }",
    },
    locations: {
        baseName: "locations",
        type: "Array<string>",
    },
    metadata: {
        baseName: "metadata",
        type: "SyntheticsCIBatchMetadata",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
        required: true,
    },
    retry: {
        baseName: "retry",
        type: "SyntheticsTestOptionsRetry",
    },
    startUrl: {
        baseName: "startUrl",
        type: "string",
    },
    variables: {
        baseName: "variables",
        type: "{ [key: string]: string; }",
    },
};
//# sourceMappingURL=SyntheticsCITest.js.map

/***/ }),

/***/ 32615:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsCITestBody = void 0;
/**
 * Object describing the synthetics tests to trigger.
 */
class SyntheticsCITestBody {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsCITestBody.attributeTypeMap;
    }
}
exports.SyntheticsCITestBody = SyntheticsCITestBody;
/**
 * @ignore
 */
SyntheticsCITestBody.attributeTypeMap = {
    tests: {
        baseName: "tests",
        type: "Array<SyntheticsCITest>",
    },
};
//# sourceMappingURL=SyntheticsCITestBody.js.map

/***/ }),

/***/ 24023:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsConfigVariable = void 0;
/**
 * Object defining a variable that can be used in your test configuration.
 */
class SyntheticsConfigVariable {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsConfigVariable.attributeTypeMap;
    }
}
exports.SyntheticsConfigVariable = SyntheticsConfigVariable;
/**
 * @ignore
 */
SyntheticsConfigVariable.attributeTypeMap = {
    example: {
        baseName: "example",
        type: "string",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    pattern: {
        baseName: "pattern",
        type: "string",
    },
    secure: {
        baseName: "secure",
        type: "boolean",
    },
    type: {
        baseName: "type",
        type: "SyntheticsConfigVariableType",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsConfigVariable.js.map

/***/ }),

/***/ 67701:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsCoreWebVitals = void 0;
/**
 * Core Web Vitals attached to a browser test step.
 */
class SyntheticsCoreWebVitals {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsCoreWebVitals.attributeTypeMap;
    }
}
exports.SyntheticsCoreWebVitals = SyntheticsCoreWebVitals;
/**
 * @ignore
 */
SyntheticsCoreWebVitals.attributeTypeMap = {
    cls: {
        baseName: "cls",
        type: "number",
        format: "double",
    },
    lcp: {
        baseName: "lcp",
        type: "number",
        format: "double",
    },
    url: {
        baseName: "url",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsCoreWebVitals.js.map

/***/ }),

/***/ 60972:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsDeleteTestsPayload = void 0;
/**
 * A JSON list of the ID or IDs of the Synthetic tests that you want
 * to delete.
 */
class SyntheticsDeleteTestsPayload {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsDeleteTestsPayload.attributeTypeMap;
    }
}
exports.SyntheticsDeleteTestsPayload = SyntheticsDeleteTestsPayload;
/**
 * @ignore
 */
SyntheticsDeleteTestsPayload.attributeTypeMap = {
    publicIds: {
        baseName: "public_ids",
        type: "Array<string>",
    },
};
//# sourceMappingURL=SyntheticsDeleteTestsPayload.js.map

/***/ }),

/***/ 80634:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsDeleteTestsResponse = void 0;
/**
 * Response object for deleting Synthetic tests.
 */
class SyntheticsDeleteTestsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsDeleteTestsResponse.attributeTypeMap;
    }
}
exports.SyntheticsDeleteTestsResponse = SyntheticsDeleteTestsResponse;
/**
 * @ignore
 */
SyntheticsDeleteTestsResponse.attributeTypeMap = {
    deletedTests: {
        baseName: "deleted_tests",
        type: "Array<SyntheticsDeletedTest>",
    },
};
//# sourceMappingURL=SyntheticsDeleteTestsResponse.js.map

/***/ }),

/***/ 7885:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsDeletedTest = void 0;
/**
 * Object containing a deleted Synthetic test ID with the associated
 * deletion timestamp.
 */
class SyntheticsDeletedTest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsDeletedTest.attributeTypeMap;
    }
}
exports.SyntheticsDeletedTest = SyntheticsDeletedTest;
/**
 * @ignore
 */
SyntheticsDeletedTest.attributeTypeMap = {
    deletedAt: {
        baseName: "deleted_at",
        type: "Date",
        format: "date-time",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsDeletedTest.js.map

/***/ }),

/***/ 6906:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsDevice = void 0;
/**
 * Object describing the device used to perform the Synthetic test.
 */
class SyntheticsDevice {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsDevice.attributeTypeMap;
    }
}
exports.SyntheticsDevice = SyntheticsDevice;
/**
 * @ignore
 */
SyntheticsDevice.attributeTypeMap = {
    height: {
        baseName: "height",
        type: "number",
        required: true,
        format: "int64",
    },
    id: {
        baseName: "id",
        type: "SyntheticsDeviceID",
        required: true,
    },
    isMobile: {
        baseName: "isMobile",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    width: {
        baseName: "width",
        type: "number",
        required: true,
        format: "int64",
    },
};
//# sourceMappingURL=SyntheticsDevice.js.map

/***/ }),

/***/ 42609:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsGetAPITestLatestResultsResponse = void 0;
/**
 * Object with the latest Synthetic API test run.
 */
class SyntheticsGetAPITestLatestResultsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsGetAPITestLatestResultsResponse.attributeTypeMap;
    }
}
exports.SyntheticsGetAPITestLatestResultsResponse = SyntheticsGetAPITestLatestResultsResponse;
/**
 * @ignore
 */
SyntheticsGetAPITestLatestResultsResponse.attributeTypeMap = {
    lastTimestampFetched: {
        baseName: "last_timestamp_fetched",
        type: "number",
        format: "int64",
    },
    results: {
        baseName: "results",
        type: "Array<SyntheticsAPITestResultShort>",
    },
};
//# sourceMappingURL=SyntheticsGetAPITestLatestResultsResponse.js.map

/***/ }),

/***/ 73873:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsGetBrowserTestLatestResultsResponse = void 0;
/**
 * Object with the latest Synthetic browser test run.
 */
class SyntheticsGetBrowserTestLatestResultsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsGetBrowserTestLatestResultsResponse.attributeTypeMap;
    }
}
exports.SyntheticsGetBrowserTestLatestResultsResponse = SyntheticsGetBrowserTestLatestResultsResponse;
/**
 * @ignore
 */
SyntheticsGetBrowserTestLatestResultsResponse.attributeTypeMap = {
    lastTimestampFetched: {
        baseName: "last_timestamp_fetched",
        type: "number",
        format: "int64",
    },
    results: {
        baseName: "results",
        type: "Array<SyntheticsBrowserTestResultShort>",
    },
};
//# sourceMappingURL=SyntheticsGetBrowserTestLatestResultsResponse.js.map

/***/ }),

/***/ 10404:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsGlobalVariable = void 0;
/**
 * Synthetics global variable.
 */
class SyntheticsGlobalVariable {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsGlobalVariable.attributeTypeMap;
    }
}
exports.SyntheticsGlobalVariable = SyntheticsGlobalVariable;
/**
 * @ignore
 */
SyntheticsGlobalVariable.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SyntheticsGlobalVariableAttributes",
    },
    description: {
        baseName: "description",
        type: "string",
        required: true,
    },
    id: {
        baseName: "id",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    parseTestOptions: {
        baseName: "parse_test_options",
        type: "SyntheticsGlobalVariableParseTestOptions",
    },
    parseTestPublicId: {
        baseName: "parse_test_public_id",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
        required: true,
    },
    value: {
        baseName: "value",
        type: "SyntheticsGlobalVariableValue",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsGlobalVariable.js.map

/***/ }),

/***/ 2156:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsGlobalVariableAttributes = void 0;
/**
 * Attributes of the global variable.
 */
class SyntheticsGlobalVariableAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsGlobalVariableAttributes.attributeTypeMap;
    }
}
exports.SyntheticsGlobalVariableAttributes = SyntheticsGlobalVariableAttributes;
/**
 * @ignore
 */
SyntheticsGlobalVariableAttributes.attributeTypeMap = {
    restrictedRoles: {
        baseName: "restricted_roles",
        type: "Array<string>",
    },
};
//# sourceMappingURL=SyntheticsGlobalVariableAttributes.js.map

/***/ }),

/***/ 41521:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsGlobalVariableOptions = void 0;
/**
 * Options for the Global Variable for MFA.
 */
class SyntheticsGlobalVariableOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsGlobalVariableOptions.attributeTypeMap;
    }
}
exports.SyntheticsGlobalVariableOptions = SyntheticsGlobalVariableOptions;
/**
 * @ignore
 */
SyntheticsGlobalVariableOptions.attributeTypeMap = {
    totpParameters: {
        baseName: "totp_parameters",
        type: "SyntheticsGlobalVariableTOTPParameters",
    },
};
//# sourceMappingURL=SyntheticsGlobalVariableOptions.js.map

/***/ }),

/***/ 60172:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsGlobalVariableParseTestOptions = void 0;
/**
 * Parser options to use for retrieving a Synthetics global variable from a Synthetics Test. Used in conjunction with `parse_test_public_id`.
 */
class SyntheticsGlobalVariableParseTestOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsGlobalVariableParseTestOptions.attributeTypeMap;
    }
}
exports.SyntheticsGlobalVariableParseTestOptions = SyntheticsGlobalVariableParseTestOptions;
/**
 * @ignore
 */
SyntheticsGlobalVariableParseTestOptions.attributeTypeMap = {
    field: {
        baseName: "field",
        type: "string",
    },
    localVariableName: {
        baseName: "localVariableName",
        type: "string",
    },
    parser: {
        baseName: "parser",
        type: "SyntheticsVariableParser",
    },
    type: {
        baseName: "type",
        type: "SyntheticsGlobalVariableParseTestOptionsType",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsGlobalVariableParseTestOptions.js.map

/***/ }),

/***/ 6429:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsGlobalVariableTOTPParameters = void 0;
/**
 * Parameters for the TOTP/MFA variable
 */
class SyntheticsGlobalVariableTOTPParameters {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsGlobalVariableTOTPParameters.attributeTypeMap;
    }
}
exports.SyntheticsGlobalVariableTOTPParameters = SyntheticsGlobalVariableTOTPParameters;
/**
 * @ignore
 */
SyntheticsGlobalVariableTOTPParameters.attributeTypeMap = {
    digits: {
        baseName: "digits",
        type: "number",
        format: "int32",
    },
    refreshInterval: {
        baseName: "refresh_interval",
        type: "number",
        format: "int32",
    },
};
//# sourceMappingURL=SyntheticsGlobalVariableTOTPParameters.js.map

/***/ }),

/***/ 50263:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsGlobalVariableValue = void 0;
/**
 * Value of the global variable.
 */
class SyntheticsGlobalVariableValue {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsGlobalVariableValue.attributeTypeMap;
    }
}
exports.SyntheticsGlobalVariableValue = SyntheticsGlobalVariableValue;
/**
 * @ignore
 */
SyntheticsGlobalVariableValue.attributeTypeMap = {
    options: {
        baseName: "options",
        type: "SyntheticsGlobalVariableOptions",
    },
    secure: {
        baseName: "secure",
        type: "boolean",
    },
    value: {
        baseName: "value",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsGlobalVariableValue.js.map

/***/ }),

/***/ 51341:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsListGlobalVariablesResponse = void 0;
/**
 * Object containing an array of Synthetic global variables.
 */
class SyntheticsListGlobalVariablesResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsListGlobalVariablesResponse.attributeTypeMap;
    }
}
exports.SyntheticsListGlobalVariablesResponse = SyntheticsListGlobalVariablesResponse;
/**
 * @ignore
 */
SyntheticsListGlobalVariablesResponse.attributeTypeMap = {
    variables: {
        baseName: "variables",
        type: "Array<SyntheticsGlobalVariable>",
    },
};
//# sourceMappingURL=SyntheticsListGlobalVariablesResponse.js.map

/***/ }),

/***/ 46280:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsListTestsResponse = void 0;
/**
 * Object containing an array of Synthetic tests configuration.
 */
class SyntheticsListTestsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsListTestsResponse.attributeTypeMap;
    }
}
exports.SyntheticsListTestsResponse = SyntheticsListTestsResponse;
/**
 * @ignore
 */
SyntheticsListTestsResponse.attributeTypeMap = {
    tests: {
        baseName: "tests",
        type: "Array<SyntheticsTestDetails>",
    },
};
//# sourceMappingURL=SyntheticsListTestsResponse.js.map

/***/ }),

/***/ 36515:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsLocation = void 0;
/**
 * Synthetic location that can be used when creating or editing a
 * test.
 */
class SyntheticsLocation {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsLocation.attributeTypeMap;
    }
}
exports.SyntheticsLocation = SyntheticsLocation;
/**
 * @ignore
 */
SyntheticsLocation.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsLocation.js.map

/***/ }),

/***/ 9091:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsLocations = void 0;
/**
 * List of Synthetics locations.
 */
class SyntheticsLocations {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsLocations.attributeTypeMap;
    }
}
exports.SyntheticsLocations = SyntheticsLocations;
/**
 * @ignore
 */
SyntheticsLocations.attributeTypeMap = {
    locations: {
        baseName: "locations",
        type: "Array<SyntheticsLocation>",
    },
};
//# sourceMappingURL=SyntheticsLocations.js.map

/***/ }),

/***/ 5015:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsParsingOptions = void 0;
/**
 * Parsing options for variables to extract.
 */
class SyntheticsParsingOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsParsingOptions.attributeTypeMap;
    }
}
exports.SyntheticsParsingOptions = SyntheticsParsingOptions;
/**
 * @ignore
 */
SyntheticsParsingOptions.attributeTypeMap = {
    field: {
        baseName: "field",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    parser: {
        baseName: "parser",
        type: "SyntheticsVariableParser",
    },
    type: {
        baseName: "type",
        type: "SyntheticsGlobalVariableParseTestOptionsType",
    },
};
//# sourceMappingURL=SyntheticsParsingOptions.js.map

/***/ }),

/***/ 6991:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsPrivateLocation = void 0;
/**
 * Object containing information about the private location to create.
 */
class SyntheticsPrivateLocation {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsPrivateLocation.attributeTypeMap;
    }
}
exports.SyntheticsPrivateLocation = SyntheticsPrivateLocation;
/**
 * @ignore
 */
SyntheticsPrivateLocation.attributeTypeMap = {
    description: {
        baseName: "description",
        type: "string",
        required: true,
    },
    id: {
        baseName: "id",
        type: "string",
    },
    metadata: {
        baseName: "metadata",
        type: "SyntheticsPrivateLocationMetadata",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    secrets: {
        baseName: "secrets",
        type: "SyntheticsPrivateLocationSecrets",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsPrivateLocation.js.map

/***/ }),

/***/ 31386:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsPrivateLocationCreationResponse = void 0;
/**
 * Object that contains the new private location, the public key for result encryption, and the configuration skeleton.
 */
class SyntheticsPrivateLocationCreationResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsPrivateLocationCreationResponse.attributeTypeMap;
    }
}
exports.SyntheticsPrivateLocationCreationResponse = SyntheticsPrivateLocationCreationResponse;
/**
 * @ignore
 */
SyntheticsPrivateLocationCreationResponse.attributeTypeMap = {
    config: {
        baseName: "config",
        type: "any",
    },
    privateLocation: {
        baseName: "private_location",
        type: "SyntheticsPrivateLocation",
    },
    resultEncryption: {
        baseName: "result_encryption",
        type: "SyntheticsPrivateLocationCreationResponseResultEncryption",
    },
};
//# sourceMappingURL=SyntheticsPrivateLocationCreationResponse.js.map

/***/ }),

/***/ 16331:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsPrivateLocationCreationResponseResultEncryption = void 0;
/**
 * Public key for the result encryption.
 */
class SyntheticsPrivateLocationCreationResponseResultEncryption {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsPrivateLocationCreationResponseResultEncryption.attributeTypeMap;
    }
}
exports.SyntheticsPrivateLocationCreationResponseResultEncryption = SyntheticsPrivateLocationCreationResponseResultEncryption;
/**
 * @ignore
 */
SyntheticsPrivateLocationCreationResponseResultEncryption.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
    },
    key: {
        baseName: "key",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsPrivateLocationCreationResponseResultEncryption.js.map

/***/ }),

/***/ 89160:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsPrivateLocationMetadata = void 0;
/**
 * Object containing metadata about the private location.
 */
class SyntheticsPrivateLocationMetadata {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsPrivateLocationMetadata.attributeTypeMap;
    }
}
exports.SyntheticsPrivateLocationMetadata = SyntheticsPrivateLocationMetadata;
/**
 * @ignore
 */
SyntheticsPrivateLocationMetadata.attributeTypeMap = {
    restrictedRoles: {
        baseName: "restricted_roles",
        type: "Array<string>",
    },
};
//# sourceMappingURL=SyntheticsPrivateLocationMetadata.js.map

/***/ }),

/***/ 91325:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsPrivateLocationSecrets = void 0;
/**
 * Secrets for the private location. Only present in the response when creating the private location.
 */
class SyntheticsPrivateLocationSecrets {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsPrivateLocationSecrets.attributeTypeMap;
    }
}
exports.SyntheticsPrivateLocationSecrets = SyntheticsPrivateLocationSecrets;
/**
 * @ignore
 */
SyntheticsPrivateLocationSecrets.attributeTypeMap = {
    authentication: {
        baseName: "authentication",
        type: "SyntheticsPrivateLocationSecretsAuthentication",
    },
    configDecryption: {
        baseName: "config_decryption",
        type: "SyntheticsPrivateLocationSecretsConfigDecryption",
    },
};
//# sourceMappingURL=SyntheticsPrivateLocationSecrets.js.map

/***/ }),

/***/ 26886:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsPrivateLocationSecretsAuthentication = void 0;
/**
 * Authentication part of the secrets.
 */
class SyntheticsPrivateLocationSecretsAuthentication {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsPrivateLocationSecretsAuthentication.attributeTypeMap;
    }
}
exports.SyntheticsPrivateLocationSecretsAuthentication = SyntheticsPrivateLocationSecretsAuthentication;
/**
 * @ignore
 */
SyntheticsPrivateLocationSecretsAuthentication.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
    },
    key: {
        baseName: "key",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsPrivateLocationSecretsAuthentication.js.map

/***/ }),

/***/ 24829:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsPrivateLocationSecretsConfigDecryption = void 0;
/**
 * Private key for the private location.
 */
class SyntheticsPrivateLocationSecretsConfigDecryption {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsPrivateLocationSecretsConfigDecryption.attributeTypeMap;
    }
}
exports.SyntheticsPrivateLocationSecretsConfigDecryption = SyntheticsPrivateLocationSecretsConfigDecryption;
/**
 * @ignore
 */
SyntheticsPrivateLocationSecretsConfigDecryption.attributeTypeMap = {
    key: {
        baseName: "key",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsPrivateLocationSecretsConfigDecryption.js.map

/***/ }),

/***/ 24211:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsSSLCertificate = void 0;
/**
 * Object describing the SSL certificate used for a Synthetic test.
 */
class SyntheticsSSLCertificate {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsSSLCertificate.attributeTypeMap;
    }
}
exports.SyntheticsSSLCertificate = SyntheticsSSLCertificate;
/**
 * @ignore
 */
SyntheticsSSLCertificate.attributeTypeMap = {
    cipher: {
        baseName: "cipher",
        type: "string",
    },
    exponent: {
        baseName: "exponent",
        type: "number",
        format: "double",
    },
    extKeyUsage: {
        baseName: "extKeyUsage",
        type: "Array<string>",
    },
    fingerprint: {
        baseName: "fingerprint",
        type: "string",
    },
    fingerprint256: {
        baseName: "fingerprint256",
        type: "string",
    },
    issuer: {
        baseName: "issuer",
        type: "SyntheticsSSLCertificateIssuer",
    },
    modulus: {
        baseName: "modulus",
        type: "string",
    },
    protocol: {
        baseName: "protocol",
        type: "string",
    },
    serialNumber: {
        baseName: "serialNumber",
        type: "string",
    },
    subject: {
        baseName: "subject",
        type: "SyntheticsSSLCertificateSubject",
    },
    validFrom: {
        baseName: "validFrom",
        type: "Date",
        format: "date-time",
    },
    validTo: {
        baseName: "validTo",
        type: "Date",
        format: "date-time",
    },
};
//# sourceMappingURL=SyntheticsSSLCertificate.js.map

/***/ }),

/***/ 70007:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsSSLCertificateIssuer = void 0;
/**
 * Object describing the issuer of a SSL certificate.
 */
class SyntheticsSSLCertificateIssuer {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsSSLCertificateIssuer.attributeTypeMap;
    }
}
exports.SyntheticsSSLCertificateIssuer = SyntheticsSSLCertificateIssuer;
/**
 * @ignore
 */
SyntheticsSSLCertificateIssuer.attributeTypeMap = {
    C: {
        baseName: "C",
        type: "string",
    },
    CN: {
        baseName: "CN",
        type: "string",
    },
    L: {
        baseName: "L",
        type: "string",
    },
    O: {
        baseName: "O",
        type: "string",
    },
    OU: {
        baseName: "OU",
        type: "string",
    },
    ST: {
        baseName: "ST",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsSSLCertificateIssuer.js.map

/***/ }),

/***/ 75798:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsSSLCertificateSubject = void 0;
/**
 * Object describing the SSL certificate used for the test.
 */
class SyntheticsSSLCertificateSubject {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsSSLCertificateSubject.attributeTypeMap;
    }
}
exports.SyntheticsSSLCertificateSubject = SyntheticsSSLCertificateSubject;
/**
 * @ignore
 */
SyntheticsSSLCertificateSubject.attributeTypeMap = {
    C: {
        baseName: "C",
        type: "string",
    },
    CN: {
        baseName: "CN",
        type: "string",
    },
    L: {
        baseName: "L",
        type: "string",
    },
    O: {
        baseName: "O",
        type: "string",
    },
    OU: {
        baseName: "OU",
        type: "string",
    },
    ST: {
        baseName: "ST",
        type: "string",
    },
    altName: {
        baseName: "altName",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsSSLCertificateSubject.js.map

/***/ }),

/***/ 96180:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsStep = void 0;
/**
 * The steps used in a Synthetics browser test.
 */
class SyntheticsStep {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsStep.attributeTypeMap;
    }
}
exports.SyntheticsStep = SyntheticsStep;
/**
 * @ignore
 */
SyntheticsStep.attributeTypeMap = {
    allowFailure: {
        baseName: "allowFailure",
        type: "boolean",
    },
    isCritical: {
        baseName: "isCritical",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    noScreenshot: {
        baseName: "noScreenshot",
        type: "boolean",
    },
    params: {
        baseName: "params",
        type: "any",
    },
    timeout: {
        baseName: "timeout",
        type: "number",
        format: "int64",
    },
    type: {
        baseName: "type",
        type: "SyntheticsStepType",
    },
};
//# sourceMappingURL=SyntheticsStep.js.map

/***/ }),

/***/ 86493:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsStepDetail = void 0;
/**
 * Object describing a step for a Synthetic test.
 */
class SyntheticsStepDetail {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsStepDetail.attributeTypeMap;
    }
}
exports.SyntheticsStepDetail = SyntheticsStepDetail;
/**
 * @ignore
 */
SyntheticsStepDetail.attributeTypeMap = {
    browserErrors: {
        baseName: "browserErrors",
        type: "Array<SyntheticsBrowserError>",
    },
    checkType: {
        baseName: "checkType",
        type: "SyntheticsCheckType",
    },
    description: {
        baseName: "description",
        type: "string",
    },
    duration: {
        baseName: "duration",
        type: "number",
        format: "double",
    },
    error: {
        baseName: "error",
        type: "string",
    },
    playingTab: {
        baseName: "playingTab",
        type: "SyntheticsPlayingTab",
        format: "int64",
    },
    screenshotBucketKey: {
        baseName: "screenshotBucketKey",
        type: "boolean",
    },
    skipped: {
        baseName: "skipped",
        type: "boolean",
    },
    snapshotBucketKey: {
        baseName: "snapshotBucketKey",
        type: "boolean",
    },
    stepId: {
        baseName: "stepId",
        type: "number",
        format: "int64",
    },
    subTestStepDetails: {
        baseName: "subTestStepDetails",
        type: "Array<SyntheticsStepDetail>",
    },
    timeToInteractive: {
        baseName: "timeToInteractive",
        type: "number",
        format: "double",
    },
    type: {
        baseName: "type",
        type: "SyntheticsStepType",
    },
    url: {
        baseName: "url",
        type: "string",
    },
    value: {
        baseName: "value",
        type: "any",
    },
    vitalsMetrics: {
        baseName: "vitalsMetrics",
        type: "Array<SyntheticsCoreWebVitals>",
    },
    warnings: {
        baseName: "warnings",
        type: "Array<SyntheticsStepDetailWarning>",
    },
};
//# sourceMappingURL=SyntheticsStepDetail.js.map

/***/ }),

/***/ 86754:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsStepDetailWarning = void 0;
/**
 * Object collecting warnings for a given step.
 */
class SyntheticsStepDetailWarning {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsStepDetailWarning.attributeTypeMap;
    }
}
exports.SyntheticsStepDetailWarning = SyntheticsStepDetailWarning;
/**
 * @ignore
 */
SyntheticsStepDetailWarning.attributeTypeMap = {
    message: {
        baseName: "message",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "SyntheticsWarningType",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsStepDetailWarning.js.map

/***/ }),

/***/ 38758:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsTestCiOptions = void 0;
/**
 * CI/CD options for a Synthetic test.
 */
class SyntheticsTestCiOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsTestCiOptions.attributeTypeMap;
    }
}
exports.SyntheticsTestCiOptions = SyntheticsTestCiOptions;
/**
 * @ignore
 */
SyntheticsTestCiOptions.attributeTypeMap = {
    executionRule: {
        baseName: "executionRule",
        type: "SyntheticsTestExecutionRule",
    },
};
//# sourceMappingURL=SyntheticsTestCiOptions.js.map

/***/ }),

/***/ 91535:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsTestConfig = void 0;
/**
 * Configuration object for a Synthetic test.
 */
class SyntheticsTestConfig {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsTestConfig.attributeTypeMap;
    }
}
exports.SyntheticsTestConfig = SyntheticsTestConfig;
/**
 * @ignore
 */
SyntheticsTestConfig.attributeTypeMap = {
    assertions: {
        baseName: "assertions",
        type: "Array<SyntheticsAssertion>",
    },
    configVariables: {
        baseName: "configVariables",
        type: "Array<SyntheticsConfigVariable>",
    },
    request: {
        baseName: "request",
        type: "SyntheticsTestRequest",
    },
    variables: {
        baseName: "variables",
        type: "Array<SyntheticsBrowserVariable>",
    },
};
//# sourceMappingURL=SyntheticsTestConfig.js.map

/***/ }),

/***/ 22701:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsTestDetails = void 0;
/**
 * Object containing details about your Synthetic test.
 */
class SyntheticsTestDetails {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsTestDetails.attributeTypeMap;
    }
}
exports.SyntheticsTestDetails = SyntheticsTestDetails;
/**
 * @ignore
 */
SyntheticsTestDetails.attributeTypeMap = {
    config: {
        baseName: "config",
        type: "SyntheticsTestConfig",
    },
    creator: {
        baseName: "creator",
        type: "Creator",
    },
    locations: {
        baseName: "locations",
        type: "Array<string>",
    },
    message: {
        baseName: "message",
        type: "string",
    },
    monitorId: {
        baseName: "monitor_id",
        type: "number",
        format: "int64",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    options: {
        baseName: "options",
        type: "SyntheticsTestOptions",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    status: {
        baseName: "status",
        type: "SyntheticsTestPauseStatus",
    },
    steps: {
        baseName: "steps",
        type: "Array<SyntheticsStep>",
    },
    subtype: {
        baseName: "subtype",
        type: "SyntheticsTestDetailsSubType",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    type: {
        baseName: "type",
        type: "SyntheticsTestDetailsType",
    },
};
//# sourceMappingURL=SyntheticsTestDetails.js.map

/***/ }),

/***/ 55515:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsTestOptions = void 0;
/**
 * Object describing the extra options for a Synthetic test.
 */
class SyntheticsTestOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsTestOptions.attributeTypeMap;
    }
}
exports.SyntheticsTestOptions = SyntheticsTestOptions;
/**
 * @ignore
 */
SyntheticsTestOptions.attributeTypeMap = {
    acceptSelfSigned: {
        baseName: "accept_self_signed",
        type: "boolean",
    },
    allowInsecure: {
        baseName: "allow_insecure",
        type: "boolean",
    },
    checkCertificateRevocation: {
        baseName: "checkCertificateRevocation",
        type: "boolean",
    },
    ci: {
        baseName: "ci",
        type: "SyntheticsTestCiOptions",
    },
    deviceIds: {
        baseName: "device_ids",
        type: "Array<SyntheticsDeviceID>",
    },
    disableCors: {
        baseName: "disableCors",
        type: "boolean",
    },
    disableCsp: {
        baseName: "disableCsp",
        type: "boolean",
    },
    followRedirects: {
        baseName: "follow_redirects",
        type: "boolean",
    },
    httpVersion: {
        baseName: "httpVersion",
        type: "SyntheticsTestOptionsHTTPVersion",
    },
    ignoreServerCertificateError: {
        baseName: "ignoreServerCertificateError",
        type: "boolean",
    },
    initialNavigationTimeout: {
        baseName: "initialNavigationTimeout",
        type: "number",
        format: "int64",
    },
    minFailureDuration: {
        baseName: "min_failure_duration",
        type: "number",
        format: "int64",
    },
    minLocationFailed: {
        baseName: "min_location_failed",
        type: "number",
        format: "int64",
    },
    monitorName: {
        baseName: "monitor_name",
        type: "string",
    },
    monitorOptions: {
        baseName: "monitor_options",
        type: "SyntheticsTestOptionsMonitorOptions",
    },
    monitorPriority: {
        baseName: "monitor_priority",
        type: "number",
        format: "int32",
    },
    noScreenshot: {
        baseName: "noScreenshot",
        type: "boolean",
    },
    restrictedRoles: {
        baseName: "restricted_roles",
        type: "Array<string>",
    },
    retry: {
        baseName: "retry",
        type: "SyntheticsTestOptionsRetry",
    },
    rumSettings: {
        baseName: "rumSettings",
        type: "SyntheticsBrowserTestRumSettings",
    },
    scheduling: {
        baseName: "scheduling",
        type: "SyntheticsTestOptionsScheduling",
    },
    tickEvery: {
        baseName: "tick_every",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=SyntheticsTestOptions.js.map

/***/ }),

/***/ 37717:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsTestOptionsMonitorOptions = void 0;
/**
 * Object containing the options for a Synthetic test as a monitor
 * (for example, renotification).
 */
class SyntheticsTestOptionsMonitorOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsTestOptionsMonitorOptions.attributeTypeMap;
    }
}
exports.SyntheticsTestOptionsMonitorOptions = SyntheticsTestOptionsMonitorOptions;
/**
 * @ignore
 */
SyntheticsTestOptionsMonitorOptions.attributeTypeMap = {
    renotifyInterval: {
        baseName: "renotify_interval",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=SyntheticsTestOptionsMonitorOptions.js.map

/***/ }),

/***/ 76723:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsTestOptionsRetry = void 0;
/**
 * Object describing the retry strategy to apply to a Synthetic test.
 */
class SyntheticsTestOptionsRetry {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsTestOptionsRetry.attributeTypeMap;
    }
}
exports.SyntheticsTestOptionsRetry = SyntheticsTestOptionsRetry;
/**
 * @ignore
 */
SyntheticsTestOptionsRetry.attributeTypeMap = {
    count: {
        baseName: "count",
        type: "number",
        format: "int64",
    },
    interval: {
        baseName: "interval",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=SyntheticsTestOptionsRetry.js.map

/***/ }),

/***/ 24636:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsTestOptionsScheduling = void 0;
/**
 * Object containing timeframes and timezone used for advanced scheduling.
 */
class SyntheticsTestOptionsScheduling {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsTestOptionsScheduling.attributeTypeMap;
    }
}
exports.SyntheticsTestOptionsScheduling = SyntheticsTestOptionsScheduling;
/**
 * @ignore
 */
SyntheticsTestOptionsScheduling.attributeTypeMap = {
    timeframes: {
        baseName: "timeframes",
        type: "Array<SyntheticsTestOptionsSchedulingTimeframe>",
    },
    timezone: {
        baseName: "timezone",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsTestOptionsScheduling.js.map

/***/ }),

/***/ 15344:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsTestOptionsSchedulingTimeframe = void 0;
/**
 * Object describing a timeframe.
 */
class SyntheticsTestOptionsSchedulingTimeframe {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsTestOptionsSchedulingTimeframe.attributeTypeMap;
    }
}
exports.SyntheticsTestOptionsSchedulingTimeframe = SyntheticsTestOptionsSchedulingTimeframe;
/**
 * @ignore
 */
SyntheticsTestOptionsSchedulingTimeframe.attributeTypeMap = {
    day: {
        baseName: "day",
        type: "number",
        format: "int32",
    },
    from: {
        baseName: "from",
        type: "string",
    },
    to: {
        baseName: "to",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsTestOptionsSchedulingTimeframe.js.map

/***/ }),

/***/ 7105:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsTestRequest = void 0;
/**
 * Object describing the Synthetic test request.
 */
class SyntheticsTestRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsTestRequest.attributeTypeMap;
    }
}
exports.SyntheticsTestRequest = SyntheticsTestRequest;
/**
 * @ignore
 */
SyntheticsTestRequest.attributeTypeMap = {
    allowInsecure: {
        baseName: "allow_insecure",
        type: "boolean",
    },
    basicAuth: {
        baseName: "basicAuth",
        type: "SyntheticsBasicAuth",
    },
    body: {
        baseName: "body",
        type: "string",
    },
    bodyType: {
        baseName: "bodyType",
        type: "SyntheticsTestRequestBodyType",
    },
    callType: {
        baseName: "callType",
        type: "SyntheticsTestCallType",
    },
    certificate: {
        baseName: "certificate",
        type: "SyntheticsTestRequestCertificate",
    },
    certificateDomains: {
        baseName: "certificateDomains",
        type: "Array<string>",
    },
    dnsServer: {
        baseName: "dnsServer",
        type: "string",
    },
    dnsServerPort: {
        baseName: "dnsServerPort",
        type: "number",
        format: "int32",
    },
    followRedirects: {
        baseName: "follow_redirects",
        type: "boolean",
    },
    headers: {
        baseName: "headers",
        type: "{ [key: string]: string; }",
    },
    host: {
        baseName: "host",
        type: "string",
    },
    message: {
        baseName: "message",
        type: "string",
    },
    metadata: {
        baseName: "metadata",
        type: "{ [key: string]: string; }",
    },
    method: {
        baseName: "method",
        type: "string",
    },
    noSavingResponseBody: {
        baseName: "noSavingResponseBody",
        type: "boolean",
    },
    numberOfPackets: {
        baseName: "numberOfPackets",
        type: "number",
        format: "int32",
    },
    port: {
        baseName: "port",
        type: "number",
        format: "int64",
    },
    proxy: {
        baseName: "proxy",
        type: "SyntheticsTestRequestProxy",
    },
    query: {
        baseName: "query",
        type: "any",
    },
    servername: {
        baseName: "servername",
        type: "string",
    },
    service: {
        baseName: "service",
        type: "string",
    },
    shouldTrackHops: {
        baseName: "shouldTrackHops",
        type: "boolean",
    },
    timeout: {
        baseName: "timeout",
        type: "number",
        format: "double",
    },
    url: {
        baseName: "url",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsTestRequest.js.map

/***/ }),

/***/ 86420:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsTestRequestCertificate = void 0;
/**
 * Client certificate to use when performing the test request.
 */
class SyntheticsTestRequestCertificate {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsTestRequestCertificate.attributeTypeMap;
    }
}
exports.SyntheticsTestRequestCertificate = SyntheticsTestRequestCertificate;
/**
 * @ignore
 */
SyntheticsTestRequestCertificate.attributeTypeMap = {
    cert: {
        baseName: "cert",
        type: "SyntheticsTestRequestCertificateItem",
    },
    key: {
        baseName: "key",
        type: "SyntheticsTestRequestCertificateItem",
    },
};
//# sourceMappingURL=SyntheticsTestRequestCertificate.js.map

/***/ }),

/***/ 77558:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsTestRequestCertificateItem = void 0;
/**
 * Define a request certificate.
 */
class SyntheticsTestRequestCertificateItem {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsTestRequestCertificateItem.attributeTypeMap;
    }
}
exports.SyntheticsTestRequestCertificateItem = SyntheticsTestRequestCertificateItem;
/**
 * @ignore
 */
SyntheticsTestRequestCertificateItem.attributeTypeMap = {
    content: {
        baseName: "content",
        type: "string",
    },
    filename: {
        baseName: "filename",
        type: "string",
    },
    updatedAt: {
        baseName: "updatedAt",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsTestRequestCertificateItem.js.map

/***/ }),

/***/ 57736:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsTestRequestProxy = void 0;
/**
 * The proxy to perform the test.
 */
class SyntheticsTestRequestProxy {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsTestRequestProxy.attributeTypeMap;
    }
}
exports.SyntheticsTestRequestProxy = SyntheticsTestRequestProxy;
/**
 * @ignore
 */
SyntheticsTestRequestProxy.attributeTypeMap = {
    headers: {
        baseName: "headers",
        type: "{ [key: string]: string; }",
    },
    url: {
        baseName: "url",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsTestRequestProxy.js.map

/***/ }),

/***/ 30782:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsTiming = void 0;
/**
 * Object containing all metrics and their values collected for a Synthetic API test.
 * Learn more about those metrics in [Synthetics documentation](https://docs.datadoghq.com/synthetics/#metrics).
 */
class SyntheticsTiming {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsTiming.attributeTypeMap;
    }
}
exports.SyntheticsTiming = SyntheticsTiming;
/**
 * @ignore
 */
SyntheticsTiming.attributeTypeMap = {
    dns: {
        baseName: "dns",
        type: "number",
        format: "double",
    },
    download: {
        baseName: "download",
        type: "number",
        format: "double",
    },
    firstByte: {
        baseName: "firstByte",
        type: "number",
        format: "double",
    },
    handshake: {
        baseName: "handshake",
        type: "number",
        format: "double",
    },
    redirect: {
        baseName: "redirect",
        type: "number",
        format: "double",
    },
    ssl: {
        baseName: "ssl",
        type: "number",
        format: "double",
    },
    tcp: {
        baseName: "tcp",
        type: "number",
        format: "double",
    },
    total: {
        baseName: "total",
        type: "number",
        format: "double",
    },
    wait: {
        baseName: "wait",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=SyntheticsTiming.js.map

/***/ }),

/***/ 20524:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsTriggerBody = void 0;
/**
 * Object describing the synthetics tests to trigger.
 */
class SyntheticsTriggerBody {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsTriggerBody.attributeTypeMap;
    }
}
exports.SyntheticsTriggerBody = SyntheticsTriggerBody;
/**
 * @ignore
 */
SyntheticsTriggerBody.attributeTypeMap = {
    tests: {
        baseName: "tests",
        type: "Array<SyntheticsTriggerTest>",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsTriggerBody.js.map

/***/ }),

/***/ 88420:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsTriggerCITestLocation = void 0;
/**
 * Synthetics location.
 */
class SyntheticsTriggerCITestLocation {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsTriggerCITestLocation.attributeTypeMap;
    }
}
exports.SyntheticsTriggerCITestLocation = SyntheticsTriggerCITestLocation;
/**
 * @ignore
 */
SyntheticsTriggerCITestLocation.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "number",
        format: "int64",
    },
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsTriggerCITestLocation.js.map

/***/ }),

/***/ 63605:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsTriggerCITestRunResult = void 0;
/**
 * Information about a single test run.
 */
class SyntheticsTriggerCITestRunResult {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsTriggerCITestRunResult.attributeTypeMap;
    }
}
exports.SyntheticsTriggerCITestRunResult = SyntheticsTriggerCITestRunResult;
/**
 * @ignore
 */
SyntheticsTriggerCITestRunResult.attributeTypeMap = {
    device: {
        baseName: "device",
        type: "SyntheticsDeviceID",
    },
    location: {
        baseName: "location",
        type: "number",
        format: "int64",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    resultId: {
        baseName: "result_id",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsTriggerCITestRunResult.js.map

/***/ }),

/***/ 35779:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsTriggerCITestsResponse = void 0;
/**
 * Object containing information about the tests triggered.
 */
class SyntheticsTriggerCITestsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsTriggerCITestsResponse.attributeTypeMap;
    }
}
exports.SyntheticsTriggerCITestsResponse = SyntheticsTriggerCITestsResponse;
/**
 * @ignore
 */
SyntheticsTriggerCITestsResponse.attributeTypeMap = {
    batchId: {
        baseName: "batch_id",
        type: "string",
    },
    locations: {
        baseName: "locations",
        type: "Array<SyntheticsTriggerCITestLocation>",
    },
    results: {
        baseName: "results",
        type: "Array<SyntheticsTriggerCITestRunResult>",
    },
    triggeredCheckIds: {
        baseName: "triggered_check_ids",
        type: "Array<string>",
    },
};
//# sourceMappingURL=SyntheticsTriggerCITestsResponse.js.map

/***/ }),

/***/ 24099:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsTriggerTest = void 0;
/**
 * Test configuration for Synthetics
 */
class SyntheticsTriggerTest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsTriggerTest.attributeTypeMap;
    }
}
exports.SyntheticsTriggerTest = SyntheticsTriggerTest;
/**
 * @ignore
 */
SyntheticsTriggerTest.attributeTypeMap = {
    metadata: {
        baseName: "metadata",
        type: "SyntheticsCIBatchMetadata",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=SyntheticsTriggerTest.js.map

/***/ }),

/***/ 41655:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsUpdateTestPauseStatusPayload = void 0;
/**
 * Object to start or pause an existing Synthetic test.
 */
class SyntheticsUpdateTestPauseStatusPayload {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsUpdateTestPauseStatusPayload.attributeTypeMap;
    }
}
exports.SyntheticsUpdateTestPauseStatusPayload = SyntheticsUpdateTestPauseStatusPayload;
/**
 * @ignore
 */
SyntheticsUpdateTestPauseStatusPayload.attributeTypeMap = {
    newStatus: {
        baseName: "new_status",
        type: "SyntheticsTestPauseStatus",
    },
};
//# sourceMappingURL=SyntheticsUpdateTestPauseStatusPayload.js.map

/***/ }),

/***/ 74500:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntheticsVariableParser = void 0;
/**
 * Details of the parser to use for the global variable.
 */
class SyntheticsVariableParser {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SyntheticsVariableParser.attributeTypeMap;
    }
}
exports.SyntheticsVariableParser = SyntheticsVariableParser;
/**
 * @ignore
 */
SyntheticsVariableParser.attributeTypeMap = {
    type: {
        baseName: "type",
        type: "SyntheticsGlobalVariableParserType",
        required: true,
    },
    value: {
        baseName: "value",
        type: "string",
    },
};
//# sourceMappingURL=SyntheticsVariableParser.js.map

/***/ }),

/***/ 17750:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TableWidgetDefinition = void 0;
/**
 * The table visualization is available on timeboards and screenboards. It displays columns of metrics grouped by tag key.
 */
class TableWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return TableWidgetDefinition.attributeTypeMap;
    }
}
exports.TableWidgetDefinition = TableWidgetDefinition;
/**
 * @ignore
 */
TableWidgetDefinition.attributeTypeMap = {
    customLinks: {
        baseName: "custom_links",
        type: "Array<WidgetCustomLink>",
    },
    hasSearchBar: {
        baseName: "has_search_bar",
        type: "TableWidgetHasSearchBar",
    },
    requests: {
        baseName: "requests",
        type: "Array<TableWidgetRequest>",
        required: true,
    },
    time: {
        baseName: "time",
        type: "WidgetTime",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "TableWidgetDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=TableWidgetDefinition.js.map

/***/ }),

/***/ 24403:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TableWidgetRequest = void 0;
/**
 * Updated table widget.
 */
class TableWidgetRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return TableWidgetRequest.attributeTypeMap;
    }
}
exports.TableWidgetRequest = TableWidgetRequest;
/**
 * @ignore
 */
TableWidgetRequest.attributeTypeMap = {
    aggregator: {
        baseName: "aggregator",
        type: "WidgetAggregator",
    },
    alias: {
        baseName: "alias",
        type: "string",
    },
    apmQuery: {
        baseName: "apm_query",
        type: "LogQueryDefinition",
    },
    apmStatsQuery: {
        baseName: "apm_stats_query",
        type: "ApmStatsQueryDefinition",
    },
    cellDisplayMode: {
        baseName: "cell_display_mode",
        type: "Array<TableWidgetCellDisplayMode>",
    },
    conditionalFormats: {
        baseName: "conditional_formats",
        type: "Array<WidgetConditionalFormat>",
    },
    eventQuery: {
        baseName: "event_query",
        type: "LogQueryDefinition",
    },
    formulas: {
        baseName: "formulas",
        type: "Array<WidgetFormula>",
    },
    limit: {
        baseName: "limit",
        type: "number",
        format: "int64",
    },
    logQuery: {
        baseName: "log_query",
        type: "LogQueryDefinition",
    },
    networkQuery: {
        baseName: "network_query",
        type: "LogQueryDefinition",
    },
    order: {
        baseName: "order",
        type: "WidgetSort",
    },
    processQuery: {
        baseName: "process_query",
        type: "ProcessQueryDefinition",
    },
    profileMetricsQuery: {
        baseName: "profile_metrics_query",
        type: "LogQueryDefinition",
    },
    q: {
        baseName: "q",
        type: "string",
    },
    queries: {
        baseName: "queries",
        type: "Array<FormulaAndFunctionQueryDefinition>",
    },
    responseFormat: {
        baseName: "response_format",
        type: "FormulaAndFunctionResponseFormat",
    },
    rumQuery: {
        baseName: "rum_query",
        type: "LogQueryDefinition",
    },
    securityQuery: {
        baseName: "security_query",
        type: "LogQueryDefinition",
    },
};
//# sourceMappingURL=TableWidgetRequest.js.map

/***/ }),

/***/ 94643:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TagToHosts = void 0;
/**
 * In this object, the key is the tag, the value is a list of host names that are reporting that tag.
 */
class TagToHosts {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return TagToHosts.attributeTypeMap;
    }
}
exports.TagToHosts = TagToHosts;
/**
 * @ignore
 */
TagToHosts.attributeTypeMap = {
    tags: {
        baseName: "tags",
        type: "{ [key: string]: Array<string>; }",
    },
};
//# sourceMappingURL=TagToHosts.js.map

/***/ }),

/***/ 87235:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeseriesBackground = void 0;
/**
 * Set a timeseries on the widget background.
 */
class TimeseriesBackground {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return TimeseriesBackground.attributeTypeMap;
    }
}
exports.TimeseriesBackground = TimeseriesBackground;
/**
 * @ignore
 */
TimeseriesBackground.attributeTypeMap = {
    type: {
        baseName: "type",
        type: "TimeseriesBackgroundType",
        required: true,
    },
    yaxis: {
        baseName: "yaxis",
        type: "WidgetAxis",
    },
};
//# sourceMappingURL=TimeseriesBackground.js.map

/***/ }),

/***/ 50074:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeseriesWidgetDefinition = void 0;
/**
 * The timeseries visualization allows you to display the evolution of one or more metrics, log events, or Indexed Spans over time.
 */
class TimeseriesWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return TimeseriesWidgetDefinition.attributeTypeMap;
    }
}
exports.TimeseriesWidgetDefinition = TimeseriesWidgetDefinition;
/**
 * @ignore
 */
TimeseriesWidgetDefinition.attributeTypeMap = {
    customLinks: {
        baseName: "custom_links",
        type: "Array<WidgetCustomLink>",
    },
    events: {
        baseName: "events",
        type: "Array<WidgetEvent>",
    },
    legendColumns: {
        baseName: "legend_columns",
        type: "Array<TimeseriesWidgetLegendColumn>",
    },
    legendLayout: {
        baseName: "legend_layout",
        type: "TimeseriesWidgetLegendLayout",
    },
    legendSize: {
        baseName: "legend_size",
        type: "string",
    },
    markers: {
        baseName: "markers",
        type: "Array<WidgetMarker>",
    },
    requests: {
        baseName: "requests",
        type: "Array<TimeseriesWidgetRequest>",
        required: true,
    },
    rightYaxis: {
        baseName: "right_yaxis",
        type: "WidgetAxis",
    },
    showLegend: {
        baseName: "show_legend",
        type: "boolean",
    },
    time: {
        baseName: "time",
        type: "WidgetTime",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "TimeseriesWidgetDefinitionType",
        required: true,
    },
    yaxis: {
        baseName: "yaxis",
        type: "WidgetAxis",
    },
};
//# sourceMappingURL=TimeseriesWidgetDefinition.js.map

/***/ }),

/***/ 91672:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeseriesWidgetExpressionAlias = void 0;
/**
 * Define an expression alias.
 */
class TimeseriesWidgetExpressionAlias {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return TimeseriesWidgetExpressionAlias.attributeTypeMap;
    }
}
exports.TimeseriesWidgetExpressionAlias = TimeseriesWidgetExpressionAlias;
/**
 * @ignore
 */
TimeseriesWidgetExpressionAlias.attributeTypeMap = {
    aliasName: {
        baseName: "alias_name",
        type: "string",
    },
    expression: {
        baseName: "expression",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=TimeseriesWidgetExpressionAlias.js.map

/***/ }),

/***/ 10800:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeseriesWidgetRequest = void 0;
/**
 * Updated timeseries widget.
 */
class TimeseriesWidgetRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return TimeseriesWidgetRequest.attributeTypeMap;
    }
}
exports.TimeseriesWidgetRequest = TimeseriesWidgetRequest;
/**
 * @ignore
 */
TimeseriesWidgetRequest.attributeTypeMap = {
    apmQuery: {
        baseName: "apm_query",
        type: "LogQueryDefinition",
    },
    auditQuery: {
        baseName: "audit_query",
        type: "LogQueryDefinition",
    },
    displayType: {
        baseName: "display_type",
        type: "WidgetDisplayType",
    },
    eventQuery: {
        baseName: "event_query",
        type: "LogQueryDefinition",
    },
    formulas: {
        baseName: "formulas",
        type: "Array<WidgetFormula>",
    },
    logQuery: {
        baseName: "log_query",
        type: "LogQueryDefinition",
    },
    metadata: {
        baseName: "metadata",
        type: "Array<TimeseriesWidgetExpressionAlias>",
    },
    networkQuery: {
        baseName: "network_query",
        type: "LogQueryDefinition",
    },
    onRightYaxis: {
        baseName: "on_right_yaxis",
        type: "boolean",
    },
    processQuery: {
        baseName: "process_query",
        type: "ProcessQueryDefinition",
    },
    profileMetricsQuery: {
        baseName: "profile_metrics_query",
        type: "LogQueryDefinition",
    },
    q: {
        baseName: "q",
        type: "string",
    },
    queries: {
        baseName: "queries",
        type: "Array<FormulaAndFunctionQueryDefinition>",
    },
    responseFormat: {
        baseName: "response_format",
        type: "FormulaAndFunctionResponseFormat",
    },
    rumQuery: {
        baseName: "rum_query",
        type: "LogQueryDefinition",
    },
    securityQuery: {
        baseName: "security_query",
        type: "LogQueryDefinition",
    },
    style: {
        baseName: "style",
        type: "WidgetRequestStyle",
    },
};
//# sourceMappingURL=TimeseriesWidgetRequest.js.map

/***/ }),

/***/ 61970:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ToplistWidgetDefinition = void 0;
/**
 * The top list visualization enables you to display a list of Tag value like hostname or service with the most or least of any metric value, such as highest consumers of CPU, hosts with the least disk space, etc.
 */
class ToplistWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ToplistWidgetDefinition.attributeTypeMap;
    }
}
exports.ToplistWidgetDefinition = ToplistWidgetDefinition;
/**
 * @ignore
 */
ToplistWidgetDefinition.attributeTypeMap = {
    customLinks: {
        baseName: "custom_links",
        type: "Array<WidgetCustomLink>",
    },
    requests: {
        baseName: "requests",
        type: "Array<ToplistWidgetRequest>",
        required: true,
    },
    time: {
        baseName: "time",
        type: "WidgetTime",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "ToplistWidgetDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=ToplistWidgetDefinition.js.map

/***/ }),

/***/ 89181:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ToplistWidgetRequest = void 0;
/**
 * Updated top list widget.
 */
class ToplistWidgetRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ToplistWidgetRequest.attributeTypeMap;
    }
}
exports.ToplistWidgetRequest = ToplistWidgetRequest;
/**
 * @ignore
 */
ToplistWidgetRequest.attributeTypeMap = {
    apmQuery: {
        baseName: "apm_query",
        type: "LogQueryDefinition",
    },
    auditQuery: {
        baseName: "audit_query",
        type: "LogQueryDefinition",
    },
    conditionalFormats: {
        baseName: "conditional_formats",
        type: "Array<WidgetConditionalFormat>",
    },
    eventQuery: {
        baseName: "event_query",
        type: "LogQueryDefinition",
    },
    formulas: {
        baseName: "formulas",
        type: "Array<WidgetFormula>",
    },
    logQuery: {
        baseName: "log_query",
        type: "LogQueryDefinition",
    },
    networkQuery: {
        baseName: "network_query",
        type: "LogQueryDefinition",
    },
    processQuery: {
        baseName: "process_query",
        type: "ProcessQueryDefinition",
    },
    profileMetricsQuery: {
        baseName: "profile_metrics_query",
        type: "LogQueryDefinition",
    },
    q: {
        baseName: "q",
        type: "string",
    },
    queries: {
        baseName: "queries",
        type: "Array<FormulaAndFunctionQueryDefinition>",
    },
    responseFormat: {
        baseName: "response_format",
        type: "FormulaAndFunctionResponseFormat",
    },
    rumQuery: {
        baseName: "rum_query",
        type: "LogQueryDefinition",
    },
    securityQuery: {
        baseName: "security_query",
        type: "LogQueryDefinition",
    },
    style: {
        baseName: "style",
        type: "WidgetRequestStyle",
    },
};
//# sourceMappingURL=ToplistWidgetRequest.js.map

/***/ }),

/***/ 3185:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TopologyMapWidgetDefinition = void 0;
/**
 * This widget displays a topology of nodes and edges for different data sources. It replaces the service map widget.
 */
class TopologyMapWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return TopologyMapWidgetDefinition.attributeTypeMap;
    }
}
exports.TopologyMapWidgetDefinition = TopologyMapWidgetDefinition;
/**
 * @ignore
 */
TopologyMapWidgetDefinition.attributeTypeMap = {
    customLinks: {
        baseName: "custom_links",
        type: "Array<WidgetCustomLink>",
    },
    requests: {
        baseName: "requests",
        type: "Array<TopologyRequest>",
        required: true,
    },
    title: {
        baseName: "title",
        type: "string",
    },
    titleAlign: {
        baseName: "title_align",
        type: "WidgetTextAlign",
    },
    titleSize: {
        baseName: "title_size",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "TopologyMapWidgetDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=TopologyMapWidgetDefinition.js.map

/***/ }),

/***/ 8641:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TopologyQuery = void 0;
/**
 * Query to service-based topology data sources like the service map or data streams.
 */
class TopologyQuery {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return TopologyQuery.attributeTypeMap;
    }
}
exports.TopologyQuery = TopologyQuery;
/**
 * @ignore
 */
TopologyQuery.attributeTypeMap = {
    dataSource: {
        baseName: "data_source",
        type: "TopologyQueryDataSource",
    },
    filters: {
        baseName: "filters",
        type: "Array<string>",
    },
    service: {
        baseName: "service",
        type: "string",
    },
};
//# sourceMappingURL=TopologyQuery.js.map

/***/ }),

/***/ 71327:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TopologyRequest = void 0;
/**
 * Request that will return nodes and edges to be used by topology map.
 */
class TopologyRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return TopologyRequest.attributeTypeMap;
    }
}
exports.TopologyRequest = TopologyRequest;
/**
 * @ignore
 */
TopologyRequest.attributeTypeMap = {
    query: {
        baseName: "query",
        type: "TopologyQuery",
    },
    requestType: {
        baseName: "request_type",
        type: "TopologyRequestType",
    },
};
//# sourceMappingURL=TopologyRequest.js.map

/***/ }),

/***/ 84230:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TreeMapWidgetDefinition = void 0;
/**
 * The treemap visualization enables you to display hierarchical and nested data. It is well suited for queries that describe part-whole relationships, such as resource usage by availability zone, data center, or team.
 */
class TreeMapWidgetDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return TreeMapWidgetDefinition.attributeTypeMap;
    }
}
exports.TreeMapWidgetDefinition = TreeMapWidgetDefinition;
/**
 * @ignore
 */
TreeMapWidgetDefinition.attributeTypeMap = {
    colorBy: {
        baseName: "color_by",
        type: "TreeMapColorBy",
    },
    customLinks: {
        baseName: "custom_links",
        type: "Array<WidgetCustomLink>",
    },
    groupBy: {
        baseName: "group_by",
        type: "TreeMapGroupBy",
    },
    requests: {
        baseName: "requests",
        type: "[TreeMapWidgetRequest]",
        required: true,
    },
    sizeBy: {
        baseName: "size_by",
        type: "TreeMapSizeBy",
    },
    time: {
        baseName: "time",
        type: "WidgetTime",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "TreeMapWidgetDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=TreeMapWidgetDefinition.js.map

/***/ }),

/***/ 32930:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TreeMapWidgetRequest = void 0;
/**
 * An updated treemap widget.
 */
class TreeMapWidgetRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return TreeMapWidgetRequest.attributeTypeMap;
    }
}
exports.TreeMapWidgetRequest = TreeMapWidgetRequest;
/**
 * @ignore
 */
TreeMapWidgetRequest.attributeTypeMap = {
    formulas: {
        baseName: "formulas",
        type: "Array<WidgetFormula>",
    },
    q: {
        baseName: "q",
        type: "string",
    },
    queries: {
        baseName: "queries",
        type: "Array<FormulaAndFunctionQueryDefinition>",
    },
    responseFormat: {
        baseName: "response_format",
        type: "FormulaAndFunctionResponseFormat",
    },
};
//# sourceMappingURL=TreeMapWidgetRequest.js.map

/***/ }),

/***/ 46989:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageAnalyzedLogsHour = void 0;
/**
 * The number of analyzed logs for each hour for a given organization.
 */
class UsageAnalyzedLogsHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageAnalyzedLogsHour.attributeTypeMap;
    }
}
exports.UsageAnalyzedLogsHour = UsageAnalyzedLogsHour;
/**
 * @ignore
 */
UsageAnalyzedLogsHour.attributeTypeMap = {
    analyzedLogs: {
        baseName: "analyzed_logs",
        type: "number",
        format: "int64",
    },
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=UsageAnalyzedLogsHour.js.map

/***/ }),

/***/ 18830:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageAnalyzedLogsResponse = void 0;
/**
 * A response containing the number of analyzed logs for each hour for a given organization.
 */
class UsageAnalyzedLogsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageAnalyzedLogsResponse.attributeTypeMap;
    }
}
exports.UsageAnalyzedLogsResponse = UsageAnalyzedLogsResponse;
/**
 * @ignore
 */
UsageAnalyzedLogsResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageAnalyzedLogsHour>",
    },
};
//# sourceMappingURL=UsageAnalyzedLogsResponse.js.map

/***/ }),

/***/ 17881:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageAttributionAggregatesBody = void 0;
/**
 * The object containing the aggregates.
 */
class UsageAttributionAggregatesBody {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageAttributionAggregatesBody.attributeTypeMap;
    }
}
exports.UsageAttributionAggregatesBody = UsageAttributionAggregatesBody;
/**
 * @ignore
 */
UsageAttributionAggregatesBody.attributeTypeMap = {
    aggType: {
        baseName: "agg_type",
        type: "string",
    },
    field: {
        baseName: "field",
        type: "string",
    },
    value: {
        baseName: "value",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=UsageAttributionAggregatesBody.js.map

/***/ }),

/***/ 15656:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageAttributionBody = void 0;
/**
 * Usage Summary by tag for a given organization.
 */
class UsageAttributionBody {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageAttributionBody.attributeTypeMap;
    }
}
exports.UsageAttributionBody = UsageAttributionBody;
/**
 * @ignore
 */
UsageAttributionBody.attributeTypeMap = {
    month: {
        baseName: "month",
        type: "Date",
        format: "date-time",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    tagConfigSource: {
        baseName: "tag_config_source",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "{ [key: string]: Array<string>; }",
    },
    updatedAt: {
        baseName: "updated_at",
        type: "string",
    },
    values: {
        baseName: "values",
        type: "UsageAttributionValues",
    },
};
//# sourceMappingURL=UsageAttributionBody.js.map

/***/ }),

/***/ 93350:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageAttributionMetadata = void 0;
/**
 * The object containing document metadata.
 */
class UsageAttributionMetadata {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageAttributionMetadata.attributeTypeMap;
    }
}
exports.UsageAttributionMetadata = UsageAttributionMetadata;
/**
 * @ignore
 */
UsageAttributionMetadata.attributeTypeMap = {
    aggregates: {
        baseName: "aggregates",
        type: "Array<UsageAttributionAggregatesBody>",
    },
    pagination: {
        baseName: "pagination",
        type: "UsageAttributionPagination",
    },
};
//# sourceMappingURL=UsageAttributionMetadata.js.map

/***/ }),

/***/ 72584:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageAttributionPagination = void 0;
/**
 * The metadata for the current pagination.
 */
class UsageAttributionPagination {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageAttributionPagination.attributeTypeMap;
    }
}
exports.UsageAttributionPagination = UsageAttributionPagination;
/**
 * @ignore
 */
UsageAttributionPagination.attributeTypeMap = {
    limit: {
        baseName: "limit",
        type: "number",
        format: "int64",
    },
    offset: {
        baseName: "offset",
        type: "number",
        format: "int64",
    },
    sortDirection: {
        baseName: "sort_direction",
        type: "string",
    },
    sortName: {
        baseName: "sort_name",
        type: "string",
    },
    totalNumberOfRecords: {
        baseName: "total_number_of_records",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=UsageAttributionPagination.js.map

/***/ }),

/***/ 45011:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageAttributionResponse = void 0;
/**
 * Response containing the Usage Summary by tag(s).
 */
class UsageAttributionResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageAttributionResponse.attributeTypeMap;
    }
}
exports.UsageAttributionResponse = UsageAttributionResponse;
/**
 * @ignore
 */
UsageAttributionResponse.attributeTypeMap = {
    metadata: {
        baseName: "metadata",
        type: "UsageAttributionMetadata",
    },
    usage: {
        baseName: "usage",
        type: "Array<UsageAttributionBody>",
    },
};
//# sourceMappingURL=UsageAttributionResponse.js.map

/***/ }),

/***/ 61746:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageAttributionValues = void 0;
/**
 * Fields in Usage Summary by tag(s).
 */
class UsageAttributionValues {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageAttributionValues.attributeTypeMap;
    }
}
exports.UsageAttributionValues = UsageAttributionValues;
/**
 * @ignore
 */
UsageAttributionValues.attributeTypeMap = {
    apiPercentage: {
        baseName: "api_percentage",
        type: "number",
        format: "double",
    },
    apiUsage: {
        baseName: "api_usage",
        type: "number",
        format: "double",
    },
    apmFargatePercentage: {
        baseName: "apm_fargate_percentage",
        type: "number",
        format: "double",
    },
    apmFargateUsage: {
        baseName: "apm_fargate_usage",
        type: "number",
        format: "double",
    },
    apmHostPercentage: {
        baseName: "apm_host_percentage",
        type: "number",
        format: "double",
    },
    apmHostUsage: {
        baseName: "apm_host_usage",
        type: "number",
        format: "double",
    },
    appsecFargatePercentage: {
        baseName: "appsec_fargate_percentage",
        type: "number",
        format: "double",
    },
    appsecFargateUsage: {
        baseName: "appsec_fargate_usage",
        type: "number",
        format: "double",
    },
    appsecPercentage: {
        baseName: "appsec_percentage",
        type: "number",
        format: "double",
    },
    appsecUsage: {
        baseName: "appsec_usage",
        type: "number",
        format: "double",
    },
    browserPercentage: {
        baseName: "browser_percentage",
        type: "number",
        format: "double",
    },
    browserUsage: {
        baseName: "browser_usage",
        type: "number",
        format: "double",
    },
    containerPercentage: {
        baseName: "container_percentage",
        type: "number",
        format: "double",
    },
    containerUsage: {
        baseName: "container_usage",
        type: "number",
        format: "double",
    },
    cspmContainerPercentage: {
        baseName: "cspm_container_percentage",
        type: "number",
        format: "double",
    },
    cspmContainerUsage: {
        baseName: "cspm_container_usage",
        type: "number",
        format: "double",
    },
    cspmHostPercentage: {
        baseName: "cspm_host_percentage",
        type: "number",
        format: "double",
    },
    cspmHostUsage: {
        baseName: "cspm_host_usage",
        type: "number",
        format: "double",
    },
    customTimeseriesPercentage: {
        baseName: "custom_timeseries_percentage",
        type: "number",
        format: "double",
    },
    customTimeseriesUsage: {
        baseName: "custom_timeseries_usage",
        type: "number",
        format: "double",
    },
    cwsContainerPercentage: {
        baseName: "cws_container_percentage",
        type: "number",
        format: "double",
    },
    cwsContainerUsage: {
        baseName: "cws_container_usage",
        type: "number",
        format: "double",
    },
    cwsHostPercentage: {
        baseName: "cws_host_percentage",
        type: "number",
        format: "double",
    },
    cwsHostUsage: {
        baseName: "cws_host_usage",
        type: "number",
        format: "double",
    },
    dbmHostsPercentage: {
        baseName: "dbm_hosts_percentage",
        type: "number",
        format: "double",
    },
    dbmHostsUsage: {
        baseName: "dbm_hosts_usage",
        type: "number",
        format: "double",
    },
    dbmQueriesPercentage: {
        baseName: "dbm_queries_percentage",
        type: "number",
        format: "double",
    },
    dbmQueriesUsage: {
        baseName: "dbm_queries_usage",
        type: "number",
        format: "double",
    },
    estimatedIndexedLogsPercentage: {
        baseName: "estimated_indexed_logs_percentage",
        type: "number",
        format: "double",
    },
    estimatedIndexedLogsUsage: {
        baseName: "estimated_indexed_logs_usage",
        type: "number",
        format: "double",
    },
    estimatedIndexedSpansPercentage: {
        baseName: "estimated_indexed_spans_percentage",
        type: "number",
        format: "double",
    },
    estimatedIndexedSpansUsage: {
        baseName: "estimated_indexed_spans_usage",
        type: "number",
        format: "double",
    },
    estimatedIngestedLogsPercentage: {
        baseName: "estimated_ingested_logs_percentage",
        type: "number",
        format: "double",
    },
    estimatedIngestedLogsUsage: {
        baseName: "estimated_ingested_logs_usage",
        type: "number",
        format: "double",
    },
    estimatedIngestedSpansPercentage: {
        baseName: "estimated_ingested_spans_percentage",
        type: "number",
        format: "double",
    },
    estimatedIngestedSpansUsage: {
        baseName: "estimated_ingested_spans_usage",
        type: "number",
        format: "double",
    },
    estimatedRumSessionsPercentage: {
        baseName: "estimated_rum_sessions_percentage",
        type: "number",
        format: "double",
    },
    estimatedRumSessionsUsage: {
        baseName: "estimated_rum_sessions_usage",
        type: "number",
        format: "double",
    },
    infraHostPercentage: {
        baseName: "infra_host_percentage",
        type: "number",
        format: "double",
    },
    infraHostUsage: {
        baseName: "infra_host_usage",
        type: "number",
        format: "double",
    },
    lambdaFunctionsPercentage: {
        baseName: "lambda_functions_percentage",
        type: "number",
        format: "double",
    },
    lambdaFunctionsUsage: {
        baseName: "lambda_functions_usage",
        type: "number",
        format: "double",
    },
    lambdaInvocationsPercentage: {
        baseName: "lambda_invocations_percentage",
        type: "number",
        format: "double",
    },
    lambdaInvocationsUsage: {
        baseName: "lambda_invocations_usage",
        type: "number",
        format: "double",
    },
    npmHostPercentage: {
        baseName: "npm_host_percentage",
        type: "number",
        format: "double",
    },
    npmHostUsage: {
        baseName: "npm_host_usage",
        type: "number",
        format: "double",
    },
    profiledContainerPercentage: {
        baseName: "profiled_container_percentage",
        type: "number",
        format: "double",
    },
    profiledContainerUsage: {
        baseName: "profiled_container_usage",
        type: "number",
        format: "double",
    },
    profiledHostsPercentage: {
        baseName: "profiled_hosts_percentage",
        type: "number",
        format: "double",
    },
    profiledHostsUsage: {
        baseName: "profiled_hosts_usage",
        type: "number",
        format: "double",
    },
    snmpPercentage: {
        baseName: "snmp_percentage",
        type: "number",
        format: "double",
    },
    snmpUsage: {
        baseName: "snmp_usage",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=UsageAttributionValues.js.map

/***/ }),

/***/ 59268:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageAuditLogsHour = void 0;
/**
 * Audit logs usage for a given organization for a given hour.
 */
class UsageAuditLogsHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageAuditLogsHour.attributeTypeMap;
    }
}
exports.UsageAuditLogsHour = UsageAuditLogsHour;
/**
 * @ignore
 */
UsageAuditLogsHour.attributeTypeMap = {
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    linesIndexed: {
        baseName: "lines_indexed",
        type: "number",
        format: "int64",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=UsageAuditLogsHour.js.map

/***/ }),

/***/ 89238:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageAuditLogsResponse = void 0;
/**
 * Response containing the audit logs usage for each hour for a given organization.
 */
class UsageAuditLogsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageAuditLogsResponse.attributeTypeMap;
    }
}
exports.UsageAuditLogsResponse = UsageAuditLogsResponse;
/**
 * @ignore
 */
UsageAuditLogsResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageAuditLogsHour>",
    },
};
//# sourceMappingURL=UsageAuditLogsResponse.js.map

/***/ }),

/***/ 17329:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageBillableSummaryBody = void 0;
/**
 * Response with properties for each aggregated usage type.
 */
class UsageBillableSummaryBody {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageBillableSummaryBody.attributeTypeMap;
    }
}
exports.UsageBillableSummaryBody = UsageBillableSummaryBody;
/**
 * @ignore
 */
UsageBillableSummaryBody.attributeTypeMap = {
    accountBillableUsage: {
        baseName: "account_billable_usage",
        type: "number",
        format: "int64",
    },
    elapsedUsageHours: {
        baseName: "elapsed_usage_hours",
        type: "number",
        format: "int64",
    },
    firstBillableUsageHour: {
        baseName: "first_billable_usage_hour",
        type: "Date",
        format: "date-time",
    },
    lastBillableUsageHour: {
        baseName: "last_billable_usage_hour",
        type: "Date",
        format: "date-time",
    },
    orgBillableUsage: {
        baseName: "org_billable_usage",
        type: "number",
        format: "int64",
    },
    percentageInAccount: {
        baseName: "percentage_in_account",
        type: "number",
        format: "double",
    },
    usageUnit: {
        baseName: "usage_unit",
        type: "string",
    },
};
//# sourceMappingURL=UsageBillableSummaryBody.js.map

/***/ }),

/***/ 52813:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageBillableSummaryHour = void 0;
/**
 * Response with monthly summary of data billed by Datadog.
 */
class UsageBillableSummaryHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageBillableSummaryHour.attributeTypeMap;
    }
}
exports.UsageBillableSummaryHour = UsageBillableSummaryHour;
/**
 * @ignore
 */
UsageBillableSummaryHour.attributeTypeMap = {
    billingPlan: {
        baseName: "billing_plan",
        type: "string",
    },
    endDate: {
        baseName: "end_date",
        type: "Date",
        format: "date-time",
    },
    numOrgs: {
        baseName: "num_orgs",
        type: "number",
        format: "int64",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    ratioInMonth: {
        baseName: "ratio_in_month",
        type: "number",
        format: "double",
    },
    region: {
        baseName: "region",
        type: "string",
    },
    startDate: {
        baseName: "start_date",
        type: "Date",
        format: "date-time",
    },
    usage: {
        baseName: "usage",
        type: "UsageBillableSummaryKeys",
    },
};
//# sourceMappingURL=UsageBillableSummaryHour.js.map

/***/ }),

/***/ 35118:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageBillableSummaryKeys = void 0;
/**
 * Response with aggregated usage types.
 */
class UsageBillableSummaryKeys {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageBillableSummaryKeys.attributeTypeMap;
    }
}
exports.UsageBillableSummaryKeys = UsageBillableSummaryKeys;
/**
 * @ignore
 */
UsageBillableSummaryKeys.attributeTypeMap = {
    apmFargateAverage: {
        baseName: "apm_fargate_average",
        type: "UsageBillableSummaryBody",
    },
    apmFargateSum: {
        baseName: "apm_fargate_sum",
        type: "UsageBillableSummaryBody",
    },
    apmHostSum: {
        baseName: "apm_host_sum",
        type: "UsageBillableSummaryBody",
    },
    apmHostTop99p: {
        baseName: "apm_host_top99p",
        type: "UsageBillableSummaryBody",
    },
    apmProfilerHostSum: {
        baseName: "apm_profiler_host_sum",
        type: "UsageBillableSummaryBody",
    },
    apmProfilerHostTop99p: {
        baseName: "apm_profiler_host_top99p",
        type: "UsageBillableSummaryBody",
    },
    apmTraceSearchSum: {
        baseName: "apm_trace_search_sum",
        type: "UsageBillableSummaryBody",
    },
    applicationSecurityFargateAverage: {
        baseName: "application_security_fargate_average",
        type: "UsageBillableSummaryBody",
    },
    applicationSecurityHostSum: {
        baseName: "application_security_host_sum",
        type: "UsageBillableSummaryBody",
    },
    applicationSecurityHostTop99: {
        baseName: "application_security_host_top99",
        type: "UsageBillableSummaryBody",
    },
    ciPipelineIndexedSpansSum: {
        baseName: "ci_pipeline_indexed_spans_sum",
        type: "UsageBillableSummaryBody",
    },
    ciPipelineMaximum: {
        baseName: "ci_pipeline_maximum",
        type: "UsageBillableSummaryBody",
    },
    ciPipelineSum: {
        baseName: "ci_pipeline_sum",
        type: "UsageBillableSummaryBody",
    },
    ciTestIndexedSpansSum: {
        baseName: "ci_test_indexed_spans_sum",
        type: "UsageBillableSummaryBody",
    },
    ciTestingMaximum: {
        baseName: "ci_testing_maximum",
        type: "UsageBillableSummaryBody",
    },
    ciTestingSum: {
        baseName: "ci_testing_sum",
        type: "UsageBillableSummaryBody",
    },
    cloudCostManagementAverage: {
        baseName: "cloud_cost_management_average",
        type: "UsageBillableSummaryBody",
    },
    cloudCostManagementSum: {
        baseName: "cloud_cost_management_sum",
        type: "UsageBillableSummaryBody",
    },
    cspmContainerSum: {
        baseName: "cspm_container_sum",
        type: "UsageBillableSummaryBody",
    },
    cspmHostSum: {
        baseName: "cspm_host_sum",
        type: "UsageBillableSummaryBody",
    },
    cspmHostTop99p: {
        baseName: "cspm_host_top99p",
        type: "UsageBillableSummaryBody",
    },
    customEventSum: {
        baseName: "custom_event_sum",
        type: "UsageBillableSummaryBody",
    },
    cwsContainerSum: {
        baseName: "cws_container_sum",
        type: "UsageBillableSummaryBody",
    },
    cwsHostSum: {
        baseName: "cws_host_sum",
        type: "UsageBillableSummaryBody",
    },
    cwsHostTop99p: {
        baseName: "cws_host_top99p",
        type: "UsageBillableSummaryBody",
    },
    dbmHostSum: {
        baseName: "dbm_host_sum",
        type: "UsageBillableSummaryBody",
    },
    dbmHostTop99p: {
        baseName: "dbm_host_top99p",
        type: "UsageBillableSummaryBody",
    },
    dbmNormalizedQueriesAverage: {
        baseName: "dbm_normalized_queries_average",
        type: "UsageBillableSummaryBody",
    },
    dbmNormalizedQueriesSum: {
        baseName: "dbm_normalized_queries_sum",
        type: "UsageBillableSummaryBody",
    },
    fargateContainerApmAndProfilerAverage: {
        baseName: "fargate_container_apm_and_profiler_average",
        type: "UsageBillableSummaryBody",
    },
    fargateContainerApmAndProfilerSum: {
        baseName: "fargate_container_apm_and_profiler_sum",
        type: "UsageBillableSummaryBody",
    },
    fargateContainerAverage: {
        baseName: "fargate_container_average",
        type: "UsageBillableSummaryBody",
    },
    fargateContainerProfilerAverage: {
        baseName: "fargate_container_profiler_average",
        type: "UsageBillableSummaryBody",
    },
    fargateContainerProfilerSum: {
        baseName: "fargate_container_profiler_sum",
        type: "UsageBillableSummaryBody",
    },
    fargateContainerSum: {
        baseName: "fargate_container_sum",
        type: "UsageBillableSummaryBody",
    },
    incidentManagementMaximum: {
        baseName: "incident_management_maximum",
        type: "UsageBillableSummaryBody",
    },
    incidentManagementSum: {
        baseName: "incident_management_sum",
        type: "UsageBillableSummaryBody",
    },
    infraAndApmHostSum: {
        baseName: "infra_and_apm_host_sum",
        type: "UsageBillableSummaryBody",
    },
    infraAndApmHostTop99p: {
        baseName: "infra_and_apm_host_top99p",
        type: "UsageBillableSummaryBody",
    },
    infraContainerSum: {
        baseName: "infra_container_sum",
        type: "UsageBillableSummaryBody",
    },
    infraHostSum: {
        baseName: "infra_host_sum",
        type: "UsageBillableSummaryBody",
    },
    infraHostTop99p: {
        baseName: "infra_host_top99p",
        type: "UsageBillableSummaryBody",
    },
    ingestedSpansSum: {
        baseName: "ingested_spans_sum",
        type: "UsageBillableSummaryBody",
    },
    ingestedTimeseriesAverage: {
        baseName: "ingested_timeseries_average",
        type: "UsageBillableSummaryBody",
    },
    ingestedTimeseriesSum: {
        baseName: "ingested_timeseries_sum",
        type: "UsageBillableSummaryBody",
    },
    iotSum: {
        baseName: "iot_sum",
        type: "UsageBillableSummaryBody",
    },
    iotTop99p: {
        baseName: "iot_top99p",
        type: "UsageBillableSummaryBody",
    },
    lambdaFunctionAverage: {
        baseName: "lambda_function_average",
        type: "UsageBillableSummaryBody",
    },
    lambdaFunctionSum: {
        baseName: "lambda_function_sum",
        type: "UsageBillableSummaryBody",
    },
    logsForwardingSum: {
        baseName: "logs_forwarding_sum",
        type: "UsageBillableSummaryBody",
    },
    logsIndexed15daySum: {
        baseName: "logs_indexed_15day_sum",
        type: "UsageBillableSummaryBody",
    },
    logsIndexed180daySum: {
        baseName: "logs_indexed_180day_sum",
        type: "UsageBillableSummaryBody",
    },
    logsIndexed30daySum: {
        baseName: "logs_indexed_30day_sum",
        type: "UsageBillableSummaryBody",
    },
    logsIndexed360daySum: {
        baseName: "logs_indexed_360day_sum",
        type: "UsageBillableSummaryBody",
    },
    logsIndexed3daySum: {
        baseName: "logs_indexed_3day_sum",
        type: "UsageBillableSummaryBody",
    },
    logsIndexed45daySum: {
        baseName: "logs_indexed_45day_sum",
        type: "UsageBillableSummaryBody",
    },
    logsIndexed60daySum: {
        baseName: "logs_indexed_60day_sum",
        type: "UsageBillableSummaryBody",
    },
    logsIndexed7daySum: {
        baseName: "logs_indexed_7day_sum",
        type: "UsageBillableSummaryBody",
    },
    logsIndexed90daySum: {
        baseName: "logs_indexed_90day_sum",
        type: "UsageBillableSummaryBody",
    },
    logsIndexedCustomRetentionSum: {
        baseName: "logs_indexed_custom_retention_sum",
        type: "UsageBillableSummaryBody",
    },
    logsIndexedSum: {
        baseName: "logs_indexed_sum",
        type: "UsageBillableSummaryBody",
    },
    logsIngestedSum: {
        baseName: "logs_ingested_sum",
        type: "UsageBillableSummaryBody",
    },
    networkDeviceSum: {
        baseName: "network_device_sum",
        type: "UsageBillableSummaryBody",
    },
    networkDeviceTop99p: {
        baseName: "network_device_top99p",
        type: "UsageBillableSummaryBody",
    },
    npmFlowSum: {
        baseName: "npm_flow_sum",
        type: "UsageBillableSummaryBody",
    },
    npmHostSum: {
        baseName: "npm_host_sum",
        type: "UsageBillableSummaryBody",
    },
    npmHostTop99p: {
        baseName: "npm_host_top99p",
        type: "UsageBillableSummaryBody",
    },
    observabilityPipelineSum: {
        baseName: "observability_pipeline_sum",
        type: "UsageBillableSummaryBody",
    },
    onlineArchiveSum: {
        baseName: "online_archive_sum",
        type: "UsageBillableSummaryBody",
    },
    profContainerSum: {
        baseName: "prof_container_sum",
        type: "UsageBillableSummaryBody",
    },
    profHostSum: {
        baseName: "prof_host_sum",
        type: "UsageBillableSummaryBody",
    },
    profHostTop99p: {
        baseName: "prof_host_top99p",
        type: "UsageBillableSummaryBody",
    },
    rumLiteSum: {
        baseName: "rum_lite_sum",
        type: "UsageBillableSummaryBody",
    },
    rumReplaySum: {
        baseName: "rum_replay_sum",
        type: "UsageBillableSummaryBody",
    },
    rumSum: {
        baseName: "rum_sum",
        type: "UsageBillableSummaryBody",
    },
    rumUnitsSum: {
        baseName: "rum_units_sum",
        type: "UsageBillableSummaryBody",
    },
    sensitiveDataScannerSum: {
        baseName: "sensitive_data_scanner_sum",
        type: "UsageBillableSummaryBody",
    },
    serverlessApmSum: {
        baseName: "serverless_apm_sum",
        type: "UsageBillableSummaryBody",
    },
    serverlessInfraAverage: {
        baseName: "serverless_infra_average",
        type: "UsageBillableSummaryBody",
    },
    serverlessInfraSum: {
        baseName: "serverless_infra_sum",
        type: "UsageBillableSummaryBody",
    },
    serverlessInvocationSum: {
        baseName: "serverless_invocation_sum",
        type: "UsageBillableSummaryBody",
    },
    siemSum: {
        baseName: "siem_sum",
        type: "UsageBillableSummaryBody",
    },
    standardTimeseriesAverage: {
        baseName: "standard_timeseries_average",
        type: "UsageBillableSummaryBody",
    },
    syntheticsApiTestsSum: {
        baseName: "synthetics_api_tests_sum",
        type: "UsageBillableSummaryBody",
    },
    syntheticsAppTestingMaximum: {
        baseName: "synthetics_app_testing_maximum",
        type: "UsageBillableSummaryBody",
    },
    syntheticsBrowserChecksSum: {
        baseName: "synthetics_browser_checks_sum",
        type: "UsageBillableSummaryBody",
    },
    timeseriesAverage: {
        baseName: "timeseries_average",
        type: "UsageBillableSummaryBody",
    },
    timeseriesSum: {
        baseName: "timeseries_sum",
        type: "UsageBillableSummaryBody",
    },
};
//# sourceMappingURL=UsageBillableSummaryKeys.js.map

/***/ }),

/***/ 84619:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageBillableSummaryResponse = void 0;
/**
 * Response with monthly summary of data billed by Datadog.
 */
class UsageBillableSummaryResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageBillableSummaryResponse.attributeTypeMap;
    }
}
exports.UsageBillableSummaryResponse = UsageBillableSummaryResponse;
/**
 * @ignore
 */
UsageBillableSummaryResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageBillableSummaryHour>",
    },
};
//# sourceMappingURL=UsageBillableSummaryResponse.js.map

/***/ }),

/***/ 41653:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageCIVisibilityHour = void 0;
/**
 * CI visibility usage in a given hour.
 */
class UsageCIVisibilityHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageCIVisibilityHour.attributeTypeMap;
    }
}
exports.UsageCIVisibilityHour = UsageCIVisibilityHour;
/**
 * @ignore
 */
UsageCIVisibilityHour.attributeTypeMap = {
    ciPipelineIndexedSpans: {
        baseName: "ci_pipeline_indexed_spans",
        type: "number",
        format: "int64",
    },
    ciTestIndexedSpans: {
        baseName: "ci_test_indexed_spans",
        type: "number",
        format: "int64",
    },
    ciVisibilityPipelineCommitters: {
        baseName: "ci_visibility_pipeline_committers",
        type: "number",
        format: "int64",
    },
    ciVisibilityTestCommitters: {
        baseName: "ci_visibility_test_committers",
        type: "number",
        format: "int64",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=UsageCIVisibilityHour.js.map

/***/ }),

/***/ 55005:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageCIVisibilityResponse = void 0;
/**
 * CI visibility usage response
 */
class UsageCIVisibilityResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageCIVisibilityResponse.attributeTypeMap;
    }
}
exports.UsageCIVisibilityResponse = UsageCIVisibilityResponse;
/**
 * @ignore
 */
UsageCIVisibilityResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageCIVisibilityHour>",
    },
};
//# sourceMappingURL=UsageCIVisibilityResponse.js.map

/***/ }),

/***/ 18482:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageCWSHour = void 0;
/**
 * Cloud Workload Security usage for a given organization for a given hour.
 */
class UsageCWSHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageCWSHour.attributeTypeMap;
    }
}
exports.UsageCWSHour = UsageCWSHour;
/**
 * @ignore
 */
UsageCWSHour.attributeTypeMap = {
    cwsContainerCount: {
        baseName: "cws_container_count",
        type: "number",
        format: "int64",
    },
    cwsHostCount: {
        baseName: "cws_host_count",
        type: "number",
        format: "int64",
    },
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=UsageCWSHour.js.map

/***/ }),

/***/ 22674:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageCWSResponse = void 0;
/**
 * Response containing the Cloud Workload Security usage for each hour for a given organization.
 */
class UsageCWSResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageCWSResponse.attributeTypeMap;
    }
}
exports.UsageCWSResponse = UsageCWSResponse;
/**
 * @ignore
 */
UsageCWSResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageCWSHour>",
    },
};
//# sourceMappingURL=UsageCWSResponse.js.map

/***/ }),

/***/ 75358:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageCloudSecurityPostureManagementHour = void 0;
/**
 * Cloud Security Posture Management usage for a given organization for a given hour.
 */
class UsageCloudSecurityPostureManagementHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageCloudSecurityPostureManagementHour.attributeTypeMap;
    }
}
exports.UsageCloudSecurityPostureManagementHour = UsageCloudSecurityPostureManagementHour;
/**
 * @ignore
 */
UsageCloudSecurityPostureManagementHour.attributeTypeMap = {
    aasHostCount: {
        baseName: "aas_host_count",
        type: "number",
        format: "double",
    },
    awsHostCount: {
        baseName: "aws_host_count",
        type: "number",
        format: "double",
    },
    azureHostCount: {
        baseName: "azure_host_count",
        type: "number",
        format: "double",
    },
    complianceHostCount: {
        baseName: "compliance_host_count",
        type: "number",
        format: "double",
    },
    containerCount: {
        baseName: "container_count",
        type: "number",
        format: "double",
    },
    gcpHostCount: {
        baseName: "gcp_host_count",
        type: "number",
        format: "double",
    },
    hostCount: {
        baseName: "host_count",
        type: "number",
        format: "double",
    },
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=UsageCloudSecurityPostureManagementHour.js.map

/***/ }),

/***/ 87374:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageCloudSecurityPostureManagementResponse = void 0;
/**
 * The response containing the Cloud Security Posture Management usage for each hour for a given organization.
 */
class UsageCloudSecurityPostureManagementResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageCloudSecurityPostureManagementResponse.attributeTypeMap;
    }
}
exports.UsageCloudSecurityPostureManagementResponse = UsageCloudSecurityPostureManagementResponse;
/**
 * @ignore
 */
UsageCloudSecurityPostureManagementResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageCloudSecurityPostureManagementHour>",
    },
};
//# sourceMappingURL=UsageCloudSecurityPostureManagementResponse.js.map

/***/ }),

/***/ 47558:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageCustomReportsAttributes = void 0;
/**
 * The response containing attributes for custom reports.
 */
class UsageCustomReportsAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageCustomReportsAttributes.attributeTypeMap;
    }
}
exports.UsageCustomReportsAttributes = UsageCustomReportsAttributes;
/**
 * @ignore
 */
UsageCustomReportsAttributes.attributeTypeMap = {
    computedOn: {
        baseName: "computed_on",
        type: "string",
    },
    endDate: {
        baseName: "end_date",
        type: "string",
    },
    size: {
        baseName: "size",
        type: "number",
        format: "int64",
    },
    startDate: {
        baseName: "start_date",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
};
//# sourceMappingURL=UsageCustomReportsAttributes.js.map

/***/ }),

/***/ 88385:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageCustomReportsData = void 0;
/**
 * The response containing the date and type for custom reports.
 */
class UsageCustomReportsData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageCustomReportsData.attributeTypeMap;
    }
}
exports.UsageCustomReportsData = UsageCustomReportsData;
/**
 * @ignore
 */
UsageCustomReportsData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "UsageCustomReportsAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "UsageReportsType",
    },
};
//# sourceMappingURL=UsageCustomReportsData.js.map

/***/ }),

/***/ 63185:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageCustomReportsMeta = void 0;
/**
 * The object containing document metadata.
 */
class UsageCustomReportsMeta {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageCustomReportsMeta.attributeTypeMap;
    }
}
exports.UsageCustomReportsMeta = UsageCustomReportsMeta;
/**
 * @ignore
 */
UsageCustomReportsMeta.attributeTypeMap = {
    page: {
        baseName: "page",
        type: "UsageCustomReportsPage",
    },
};
//# sourceMappingURL=UsageCustomReportsMeta.js.map

/***/ }),

/***/ 54974:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageCustomReportsPage = void 0;
/**
 * The object containing page total count.
 */
class UsageCustomReportsPage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageCustomReportsPage.attributeTypeMap;
    }
}
exports.UsageCustomReportsPage = UsageCustomReportsPage;
/**
 * @ignore
 */
UsageCustomReportsPage.attributeTypeMap = {
    totalCount: {
        baseName: "total_count",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=UsageCustomReportsPage.js.map

/***/ }),

/***/ 55902:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageCustomReportsResponse = void 0;
/**
 * Response containing available custom reports.
 */
class UsageCustomReportsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageCustomReportsResponse.attributeTypeMap;
    }
}
exports.UsageCustomReportsResponse = UsageCustomReportsResponse;
/**
 * @ignore
 */
UsageCustomReportsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<UsageCustomReportsData>",
    },
    meta: {
        baseName: "meta",
        type: "UsageCustomReportsMeta",
    },
};
//# sourceMappingURL=UsageCustomReportsResponse.js.map

/***/ }),

/***/ 68808:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageDBMHour = void 0;
/**
 * Database Monitoring usage for a given organization for a given hour.
 */
class UsageDBMHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageDBMHour.attributeTypeMap;
    }
}
exports.UsageDBMHour = UsageDBMHour;
/**
 * @ignore
 */
UsageDBMHour.attributeTypeMap = {
    dbmHostCount: {
        baseName: "dbm_host_count",
        type: "number",
        format: "int64",
    },
    dbmQueriesCount: {
        baseName: "dbm_queries_count",
        type: "number",
        format: "int64",
    },
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=UsageDBMHour.js.map

/***/ }),

/***/ 2026:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageDBMResponse = void 0;
/**
 * Response containing the Database Monitoring usage for each hour for a given organization.
 */
class UsageDBMResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageDBMResponse.attributeTypeMap;
    }
}
exports.UsageDBMResponse = UsageDBMResponse;
/**
 * @ignore
 */
UsageDBMResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageDBMHour>",
    },
};
//# sourceMappingURL=UsageDBMResponse.js.map

/***/ }),

/***/ 57386:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageFargateHour = void 0;
/**
 * Number of Fargate tasks run and hourly usage.
 */
class UsageFargateHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageFargateHour.attributeTypeMap;
    }
}
exports.UsageFargateHour = UsageFargateHour;
/**
 * @ignore
 */
UsageFargateHour.attributeTypeMap = {
    apmFargateCount: {
        baseName: "apm_fargate_count",
        type: "number",
        format: "int64",
    },
    appsecFargateCount: {
        baseName: "appsec_fargate_count",
        type: "number",
        format: "int64",
    },
    avgProfiledFargateTasks: {
        baseName: "avg_profiled_fargate_tasks",
        type: "number",
        format: "int64",
    },
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    tasksCount: {
        baseName: "tasks_count",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=UsageFargateHour.js.map

/***/ }),

/***/ 48053:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageFargateResponse = void 0;
/**
 * Response containing the number of Fargate tasks run and hourly usage.
 */
class UsageFargateResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageFargateResponse.attributeTypeMap;
    }
}
exports.UsageFargateResponse = UsageFargateResponse;
/**
 * @ignore
 */
UsageFargateResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageFargateHour>",
    },
};
//# sourceMappingURL=UsageFargateResponse.js.map

/***/ }),

/***/ 22603:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageHostHour = void 0;
/**
 * Number of hosts/containers recorded for each hour for a given organization.
 */
class UsageHostHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageHostHour.attributeTypeMap;
    }
}
exports.UsageHostHour = UsageHostHour;
/**
 * @ignore
 */
UsageHostHour.attributeTypeMap = {
    agentHostCount: {
        baseName: "agent_host_count",
        type: "number",
        format: "int64",
    },
    alibabaHostCount: {
        baseName: "alibaba_host_count",
        type: "number",
        format: "int64",
    },
    apmAzureAppServiceHostCount: {
        baseName: "apm_azure_app_service_host_count",
        type: "number",
        format: "int64",
    },
    apmHostCount: {
        baseName: "apm_host_count",
        type: "number",
        format: "int64",
    },
    awsHostCount: {
        baseName: "aws_host_count",
        type: "number",
        format: "int64",
    },
    azureHostCount: {
        baseName: "azure_host_count",
        type: "number",
        format: "int64",
    },
    containerCount: {
        baseName: "container_count",
        type: "number",
        format: "int64",
    },
    gcpHostCount: {
        baseName: "gcp_host_count",
        type: "number",
        format: "int64",
    },
    herokuHostCount: {
        baseName: "heroku_host_count",
        type: "number",
        format: "int64",
    },
    hostCount: {
        baseName: "host_count",
        type: "number",
        format: "int64",
    },
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    infraAzureAppService: {
        baseName: "infra_azure_app_service",
        type: "number",
        format: "int64",
    },
    opentelemetryApmHostCount: {
        baseName: "opentelemetry_apm_host_count",
        type: "number",
        format: "int64",
    },
    opentelemetryHostCount: {
        baseName: "opentelemetry_host_count",
        type: "number",
        format: "int64",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    vsphereHostCount: {
        baseName: "vsphere_host_count",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=UsageHostHour.js.map

/***/ }),

/***/ 31325:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageHostsResponse = void 0;
/**
 * Host usage response.
 */
class UsageHostsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageHostsResponse.attributeTypeMap;
    }
}
exports.UsageHostsResponse = UsageHostsResponse;
/**
 * @ignore
 */
UsageHostsResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageHostHour>",
    },
};
//# sourceMappingURL=UsageHostsResponse.js.map

/***/ }),

/***/ 40048:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageIncidentManagementHour = void 0;
/**
 * Incident management usage for a given organization for a given hour.
 */
class UsageIncidentManagementHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageIncidentManagementHour.attributeTypeMap;
    }
}
exports.UsageIncidentManagementHour = UsageIncidentManagementHour;
/**
 * @ignore
 */
UsageIncidentManagementHour.attributeTypeMap = {
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    monthlyActiveUsers: {
        baseName: "monthly_active_users",
        type: "number",
        format: "int64",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=UsageIncidentManagementHour.js.map

/***/ }),

/***/ 98434:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageIncidentManagementResponse = void 0;
/**
 * Response containing the incident management usage for each hour for a given organization.
 */
class UsageIncidentManagementResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageIncidentManagementResponse.attributeTypeMap;
    }
}
exports.UsageIncidentManagementResponse = UsageIncidentManagementResponse;
/**
 * @ignore
 */
UsageIncidentManagementResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageIncidentManagementHour>",
    },
};
//# sourceMappingURL=UsageIncidentManagementResponse.js.map

/***/ }),

/***/ 66099:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageIndexedSpansHour = void 0;
/**
 * The hours of indexed spans usage.
 */
class UsageIndexedSpansHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageIndexedSpansHour.attributeTypeMap;
    }
}
exports.UsageIndexedSpansHour = UsageIndexedSpansHour;
/**
 * @ignore
 */
UsageIndexedSpansHour.attributeTypeMap = {
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    indexedEventsCount: {
        baseName: "indexed_events_count",
        type: "number",
        format: "int64",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=UsageIndexedSpansHour.js.map

/***/ }),

/***/ 7275:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageIndexedSpansResponse = void 0;
/**
 * A response containing indexed spans usage.
 */
class UsageIndexedSpansResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageIndexedSpansResponse.attributeTypeMap;
    }
}
exports.UsageIndexedSpansResponse = UsageIndexedSpansResponse;
/**
 * @ignore
 */
UsageIndexedSpansResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageIndexedSpansHour>",
    },
};
//# sourceMappingURL=UsageIndexedSpansResponse.js.map

/***/ }),

/***/ 72078:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageIngestedSpansHour = void 0;
/**
 * Ingested spans usage for a given organization for a given hour.
 */
class UsageIngestedSpansHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageIngestedSpansHour.attributeTypeMap;
    }
}
exports.UsageIngestedSpansHour = UsageIngestedSpansHour;
/**
 * @ignore
 */
UsageIngestedSpansHour.attributeTypeMap = {
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    ingestedEventsBytes: {
        baseName: "ingested_events_bytes",
        type: "number",
        format: "int64",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=UsageIngestedSpansHour.js.map

/***/ }),

/***/ 52819:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageIngestedSpansResponse = void 0;
/**
 * Response containing the ingested spans usage for each hour for a given organization.
 */
class UsageIngestedSpansResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageIngestedSpansResponse.attributeTypeMap;
    }
}
exports.UsageIngestedSpansResponse = UsageIngestedSpansResponse;
/**
 * @ignore
 */
UsageIngestedSpansResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageIngestedSpansHour>",
    },
};
//# sourceMappingURL=UsageIngestedSpansResponse.js.map

/***/ }),

/***/ 45137:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageIoTHour = void 0;
/**
 * IoT usage for a given organization for a given hour.
 */
class UsageIoTHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageIoTHour.attributeTypeMap;
    }
}
exports.UsageIoTHour = UsageIoTHour;
/**
 * @ignore
 */
UsageIoTHour.attributeTypeMap = {
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    iotDeviceCount: {
        baseName: "iot_device_count",
        type: "number",
        format: "int64",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=UsageIoTHour.js.map

/***/ }),

/***/ 73096:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageIoTResponse = void 0;
/**
 * Response containing the IoT usage for each hour for a given organization.
 */
class UsageIoTResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageIoTResponse.attributeTypeMap;
    }
}
exports.UsageIoTResponse = UsageIoTResponse;
/**
 * @ignore
 */
UsageIoTResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageIoTHour>",
    },
};
//# sourceMappingURL=UsageIoTResponse.js.map

/***/ }),

/***/ 97435:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageLambdaHour = void 0;
/**
 * Number of lambda functions and sum of the invocations of all lambda functions
 * for each hour for a given organization.
 */
class UsageLambdaHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageLambdaHour.attributeTypeMap;
    }
}
exports.UsageLambdaHour = UsageLambdaHour;
/**
 * @ignore
 */
UsageLambdaHour.attributeTypeMap = {
    funcCount: {
        baseName: "func_count",
        type: "number",
        format: "int64",
    },
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    invocationsSum: {
        baseName: "invocations_sum",
        type: "number",
        format: "int64",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=UsageLambdaHour.js.map

/***/ }),

/***/ 95231:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageLambdaResponse = void 0;
/**
 * Response containing the number of lambda functions and sum of the invocations of all lambda functions
 * for each hour for a given organization.
 */
class UsageLambdaResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageLambdaResponse.attributeTypeMap;
    }
}
exports.UsageLambdaResponse = UsageLambdaResponse;
/**
 * @ignore
 */
UsageLambdaResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageLambdaHour>",
    },
};
//# sourceMappingURL=UsageLambdaResponse.js.map

/***/ }),

/***/ 48710:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageLogsByIndexHour = void 0;
/**
 * Number of indexed logs for each hour and index for a given organization.
 */
class UsageLogsByIndexHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageLogsByIndexHour.attributeTypeMap;
    }
}
exports.UsageLogsByIndexHour = UsageLogsByIndexHour;
/**
 * @ignore
 */
UsageLogsByIndexHour.attributeTypeMap = {
    eventCount: {
        baseName: "event_count",
        type: "number",
        format: "int64",
    },
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    indexId: {
        baseName: "index_id",
        type: "string",
    },
    indexName: {
        baseName: "index_name",
        type: "string",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    retention: {
        baseName: "retention",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=UsageLogsByIndexHour.js.map

/***/ }),

/***/ 18950:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageLogsByIndexResponse = void 0;
/**
 * Response containing the number of indexed logs for each hour and index for a given organization.
 */
class UsageLogsByIndexResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageLogsByIndexResponse.attributeTypeMap;
    }
}
exports.UsageLogsByIndexResponse = UsageLogsByIndexResponse;
/**
 * @ignore
 */
UsageLogsByIndexResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageLogsByIndexHour>",
    },
};
//# sourceMappingURL=UsageLogsByIndexResponse.js.map

/***/ }),

/***/ 51648:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageLogsByRetentionHour = void 0;
/**
 * The number of indexed logs for each hour for a given organization broken down by retention period.
 */
class UsageLogsByRetentionHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageLogsByRetentionHour.attributeTypeMap;
    }
}
exports.UsageLogsByRetentionHour = UsageLogsByRetentionHour;
/**
 * @ignore
 */
UsageLogsByRetentionHour.attributeTypeMap = {
    indexedEventsCount: {
        baseName: "indexed_events_count",
        type: "number",
        format: "int64",
    },
    liveIndexedEventsCount: {
        baseName: "live_indexed_events_count",
        type: "number",
        format: "int64",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    rehydratedIndexedEventsCount: {
        baseName: "rehydrated_indexed_events_count",
        type: "number",
        format: "int64",
    },
    retention: {
        baseName: "retention",
        type: "string",
    },
};
//# sourceMappingURL=UsageLogsByRetentionHour.js.map

/***/ }),

/***/ 62783:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageLogsByRetentionResponse = void 0;
/**
 * Response containing the indexed logs usage broken down by retention period for an organization during a given hour.
 */
class UsageLogsByRetentionResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageLogsByRetentionResponse.attributeTypeMap;
    }
}
exports.UsageLogsByRetentionResponse = UsageLogsByRetentionResponse;
/**
 * @ignore
 */
UsageLogsByRetentionResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageLogsByRetentionHour>",
    },
};
//# sourceMappingURL=UsageLogsByRetentionResponse.js.map

/***/ }),

/***/ 52600:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageLogsHour = void 0;
/**
 * Hour usage for logs.
 */
class UsageLogsHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageLogsHour.attributeTypeMap;
    }
}
exports.UsageLogsHour = UsageLogsHour;
/**
 * @ignore
 */
UsageLogsHour.attributeTypeMap = {
    billableIngestedBytes: {
        baseName: "billable_ingested_bytes",
        type: "number",
        format: "int64",
    },
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    indexedEventsCount: {
        baseName: "indexed_events_count",
        type: "number",
        format: "int64",
    },
    ingestedEventsBytes: {
        baseName: "ingested_events_bytes",
        type: "number",
        format: "int64",
    },
    logsLiveIndexedCount: {
        baseName: "logs_live_indexed_count",
        type: "number",
        format: "int64",
    },
    logsLiveIngestedBytes: {
        baseName: "logs_live_ingested_bytes",
        type: "number",
        format: "int64",
    },
    logsRehydratedIndexedCount: {
        baseName: "logs_rehydrated_indexed_count",
        type: "number",
        format: "int64",
    },
    logsRehydratedIngestedBytes: {
        baseName: "logs_rehydrated_ingested_bytes",
        type: "number",
        format: "int64",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=UsageLogsHour.js.map

/***/ }),

/***/ 1375:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageLogsResponse = void 0;
/**
 * Response containing the number of logs for each hour.
 */
class UsageLogsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageLogsResponse.attributeTypeMap;
    }
}
exports.UsageLogsResponse = UsageLogsResponse;
/**
 * @ignore
 */
UsageLogsResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageLogsHour>",
    },
};
//# sourceMappingURL=UsageLogsResponse.js.map

/***/ }),

/***/ 97327:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageNetworkFlowsHour = void 0;
/**
 * Number of netflow events indexed for each hour for a given organization.
 */
class UsageNetworkFlowsHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageNetworkFlowsHour.attributeTypeMap;
    }
}
exports.UsageNetworkFlowsHour = UsageNetworkFlowsHour;
/**
 * @ignore
 */
UsageNetworkFlowsHour.attributeTypeMap = {
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    indexedEventsCount: {
        baseName: "indexed_events_count",
        type: "number",
        format: "int64",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=UsageNetworkFlowsHour.js.map

/***/ }),

/***/ 66234:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageNetworkFlowsResponse = void 0;
/**
 * Response containing the number of netflow events indexed for each hour for a given organization.
 */
class UsageNetworkFlowsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageNetworkFlowsResponse.attributeTypeMap;
    }
}
exports.UsageNetworkFlowsResponse = UsageNetworkFlowsResponse;
/**
 * @ignore
 */
UsageNetworkFlowsResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageNetworkFlowsHour>",
    },
};
//# sourceMappingURL=UsageNetworkFlowsResponse.js.map

/***/ }),

/***/ 5620:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageNetworkHostsHour = void 0;
/**
 * Number of active NPM hosts for each hour for a given organization.
 */
class UsageNetworkHostsHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageNetworkHostsHour.attributeTypeMap;
    }
}
exports.UsageNetworkHostsHour = UsageNetworkHostsHour;
/**
 * @ignore
 */
UsageNetworkHostsHour.attributeTypeMap = {
    hostCount: {
        baseName: "host_count",
        type: "number",
        format: "int64",
    },
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=UsageNetworkHostsHour.js.map

/***/ }),

/***/ 4994:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageNetworkHostsResponse = void 0;
/**
 * Response containing the number of active NPM hosts for each hour for a given organization.
 */
class UsageNetworkHostsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageNetworkHostsResponse.attributeTypeMap;
    }
}
exports.UsageNetworkHostsResponse = UsageNetworkHostsResponse;
/**
 * @ignore
 */
UsageNetworkHostsResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageNetworkHostsHour>",
    },
};
//# sourceMappingURL=UsageNetworkHostsResponse.js.map

/***/ }),

/***/ 22627:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageOnlineArchiveHour = void 0;
/**
 * Online Archive usage in a given hour.
 */
class UsageOnlineArchiveHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageOnlineArchiveHour.attributeTypeMap;
    }
}
exports.UsageOnlineArchiveHour = UsageOnlineArchiveHour;
/**
 * @ignore
 */
UsageOnlineArchiveHour.attributeTypeMap = {
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    onlineArchiveEventsCount: {
        baseName: "online_archive_events_count",
        type: "number",
        format: "int64",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=UsageOnlineArchiveHour.js.map

/***/ }),

/***/ 17926:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageOnlineArchiveResponse = void 0;
/**
 * Online Archive usage response.
 */
class UsageOnlineArchiveResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageOnlineArchiveResponse.attributeTypeMap;
    }
}
exports.UsageOnlineArchiveResponse = UsageOnlineArchiveResponse;
/**
 * @ignore
 */
UsageOnlineArchiveResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageOnlineArchiveHour>",
    },
};
//# sourceMappingURL=UsageOnlineArchiveResponse.js.map

/***/ }),

/***/ 66510:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageProfilingHour = void 0;
/**
 * The number of profiled hosts for each hour for a given organization.
 */
class UsageProfilingHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageProfilingHour.attributeTypeMap;
    }
}
exports.UsageProfilingHour = UsageProfilingHour;
/**
 * @ignore
 */
UsageProfilingHour.attributeTypeMap = {
    avgContainerAgentCount: {
        baseName: "avg_container_agent_count",
        type: "number",
        format: "int64",
    },
    hostCount: {
        baseName: "host_count",
        type: "number",
        format: "int64",
    },
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=UsageProfilingHour.js.map

/***/ }),

/***/ 82060:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageProfilingResponse = void 0;
/**
 * Response containing the number of profiled hosts for each hour for a given organization.
 */
class UsageProfilingResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageProfilingResponse.attributeTypeMap;
    }
}
exports.UsageProfilingResponse = UsageProfilingResponse;
/**
 * @ignore
 */
UsageProfilingResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageProfilingHour>",
    },
};
//# sourceMappingURL=UsageProfilingResponse.js.map

/***/ }),

/***/ 105:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageRumSessionsHour = void 0;
/**
 * Number of RUM Sessions recorded for each hour for a given organization.
 */
class UsageRumSessionsHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageRumSessionsHour.attributeTypeMap;
    }
}
exports.UsageRumSessionsHour = UsageRumSessionsHour;
/**
 * @ignore
 */
UsageRumSessionsHour.attributeTypeMap = {
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    replaySessionCount: {
        baseName: "replay_session_count",
        type: "number",
        format: "int64",
    },
    sessionCount: {
        baseName: "session_count",
        type: "number",
        format: "int64",
    },
    sessionCountAndroid: {
        baseName: "session_count_android",
        type: "number",
        format: "int64",
    },
    sessionCountIos: {
        baseName: "session_count_ios",
        type: "number",
        format: "int64",
    },
    sessionCountReactnative: {
        baseName: "session_count_reactnative",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=UsageRumSessionsHour.js.map

/***/ }),

/***/ 6633:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageRumSessionsResponse = void 0;
/**
 * Response containing the number of RUM Sessions for each hour for a given organization.
 */
class UsageRumSessionsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageRumSessionsResponse.attributeTypeMap;
    }
}
exports.UsageRumSessionsResponse = UsageRumSessionsResponse;
/**
 * @ignore
 */
UsageRumSessionsResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageRumSessionsHour>",
    },
};
//# sourceMappingURL=UsageRumSessionsResponse.js.map

/***/ }),

/***/ 8936:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageRumUnitsHour = void 0;
/**
 * Number of RUM Units used for each hour for a given organization (data available as of November 1, 2021).
 */
class UsageRumUnitsHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageRumUnitsHour.attributeTypeMap;
    }
}
exports.UsageRumUnitsHour = UsageRumUnitsHour;
/**
 * @ignore
 */
UsageRumUnitsHour.attributeTypeMap = {
    browserRumUnits: {
        baseName: "browser_rum_units",
        type: "number",
        format: "int64",
    },
    mobileRumUnits: {
        baseName: "mobile_rum_units",
        type: "number",
        format: "int64",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    rumUnits: {
        baseName: "rum_units",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=UsageRumUnitsHour.js.map

/***/ }),

/***/ 537:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageRumUnitsResponse = void 0;
/**
 * Response containing the number of RUM Units for each hour for a given organization.
 */
class UsageRumUnitsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageRumUnitsResponse.attributeTypeMap;
    }
}
exports.UsageRumUnitsResponse = UsageRumUnitsResponse;
/**
 * @ignore
 */
UsageRumUnitsResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageRumUnitsHour>",
    },
};
//# sourceMappingURL=UsageRumUnitsResponse.js.map

/***/ }),

/***/ 40876:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageSDSHour = void 0;
/**
 * Sensitive Data Scanner usage for a given organization for a given hour.
 */
class UsageSDSHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageSDSHour.attributeTypeMap;
    }
}
exports.UsageSDSHour = UsageSDSHour;
/**
 * @ignore
 */
UsageSDSHour.attributeTypeMap = {
    apmScannedBytes: {
        baseName: "apm_scanned_bytes",
        type: "number",
        format: "int64",
    },
    eventsScannedBytes: {
        baseName: "events_scanned_bytes",
        type: "number",
        format: "int64",
    },
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    logsScannedBytes: {
        baseName: "logs_scanned_bytes",
        type: "number",
        format: "int64",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    rumScannedBytes: {
        baseName: "rum_scanned_bytes",
        type: "number",
        format: "int64",
    },
    totalScannedBytes: {
        baseName: "total_scanned_bytes",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=UsageSDSHour.js.map

/***/ }),

/***/ 96687:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageSDSResponse = void 0;
/**
 * Response containing the Sensitive Data Scanner usage for each hour for a given organization.
 */
class UsageSDSResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageSDSResponse.attributeTypeMap;
    }
}
exports.UsageSDSResponse = UsageSDSResponse;
/**
 * @ignore
 */
UsageSDSResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageSDSHour>",
    },
};
//# sourceMappingURL=UsageSDSResponse.js.map

/***/ }),

/***/ 39577:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageSNMPHour = void 0;
/**
 * The number of SNMP devices for each hour for a given organization.
 */
class UsageSNMPHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageSNMPHour.attributeTypeMap;
    }
}
exports.UsageSNMPHour = UsageSNMPHour;
/**
 * @ignore
 */
UsageSNMPHour.attributeTypeMap = {
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    snmpDevices: {
        baseName: "snmp_devices",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=UsageSNMPHour.js.map

/***/ }),

/***/ 82210:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageSNMPResponse = void 0;
/**
 * Response containing the number of SNMP devices for each hour for a given organization.
 */
class UsageSNMPResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageSNMPResponse.attributeTypeMap;
    }
}
exports.UsageSNMPResponse = UsageSNMPResponse;
/**
 * @ignore
 */
UsageSNMPResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageSNMPHour>",
    },
};
//# sourceMappingURL=UsageSNMPResponse.js.map

/***/ }),

/***/ 38724:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageSpecifiedCustomReportsAttributes = void 0;
/**
 * The response containing attributes for specified custom reports.
 */
class UsageSpecifiedCustomReportsAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageSpecifiedCustomReportsAttributes.attributeTypeMap;
    }
}
exports.UsageSpecifiedCustomReportsAttributes = UsageSpecifiedCustomReportsAttributes;
/**
 * @ignore
 */
UsageSpecifiedCustomReportsAttributes.attributeTypeMap = {
    computedOn: {
        baseName: "computed_on",
        type: "string",
    },
    endDate: {
        baseName: "end_date",
        type: "string",
    },
    location: {
        baseName: "location",
        type: "string",
    },
    size: {
        baseName: "size",
        type: "number",
        format: "int64",
    },
    startDate: {
        baseName: "start_date",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
};
//# sourceMappingURL=UsageSpecifiedCustomReportsAttributes.js.map

/***/ }),

/***/ 47586:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageSpecifiedCustomReportsData = void 0;
/**
 * Response containing date and type for specified custom reports.
 */
class UsageSpecifiedCustomReportsData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageSpecifiedCustomReportsData.attributeTypeMap;
    }
}
exports.UsageSpecifiedCustomReportsData = UsageSpecifiedCustomReportsData;
/**
 * @ignore
 */
UsageSpecifiedCustomReportsData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "UsageSpecifiedCustomReportsAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "UsageReportsType",
    },
};
//# sourceMappingURL=UsageSpecifiedCustomReportsData.js.map

/***/ }),

/***/ 75435:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageSpecifiedCustomReportsMeta = void 0;
/**
 * The object containing document metadata.
 */
class UsageSpecifiedCustomReportsMeta {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageSpecifiedCustomReportsMeta.attributeTypeMap;
    }
}
exports.UsageSpecifiedCustomReportsMeta = UsageSpecifiedCustomReportsMeta;
/**
 * @ignore
 */
UsageSpecifiedCustomReportsMeta.attributeTypeMap = {
    page: {
        baseName: "page",
        type: "UsageSpecifiedCustomReportsPage",
    },
};
//# sourceMappingURL=UsageSpecifiedCustomReportsMeta.js.map

/***/ }),

/***/ 60544:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageSpecifiedCustomReportsPage = void 0;
/**
 * The object containing page total count for specified ID.
 */
class UsageSpecifiedCustomReportsPage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageSpecifiedCustomReportsPage.attributeTypeMap;
    }
}
exports.UsageSpecifiedCustomReportsPage = UsageSpecifiedCustomReportsPage;
/**
 * @ignore
 */
UsageSpecifiedCustomReportsPage.attributeTypeMap = {
    totalCount: {
        baseName: "total_count",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=UsageSpecifiedCustomReportsPage.js.map

/***/ }),

/***/ 47226:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageSpecifiedCustomReportsResponse = void 0;
/**
 * Returns available specified custom reports.
 */
class UsageSpecifiedCustomReportsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageSpecifiedCustomReportsResponse.attributeTypeMap;
    }
}
exports.UsageSpecifiedCustomReportsResponse = UsageSpecifiedCustomReportsResponse;
/**
 * @ignore
 */
UsageSpecifiedCustomReportsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "UsageSpecifiedCustomReportsData",
    },
    meta: {
        baseName: "meta",
        type: "UsageSpecifiedCustomReportsMeta",
    },
};
//# sourceMappingURL=UsageSpecifiedCustomReportsResponse.js.map

/***/ }),

/***/ 72971:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageSummaryDate = void 0;
/**
 * Response with hourly report of all data billed by Datadog all organizations.
 */
class UsageSummaryDate {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageSummaryDate.attributeTypeMap;
    }
}
exports.UsageSummaryDate = UsageSummaryDate;
/**
 * @ignore
 */
UsageSummaryDate.attributeTypeMap = {
    agentHostTop99p: {
        baseName: "agent_host_top99p",
        type: "number",
        format: "int64",
    },
    apmAzureAppServiceHostTop99p: {
        baseName: "apm_azure_app_service_host_top99p",
        type: "number",
        format: "int64",
    },
    apmFargateCountAvg: {
        baseName: "apm_fargate_count_avg",
        type: "number",
        format: "int64",
    },
    apmHostTop99p: {
        baseName: "apm_host_top99p",
        type: "number",
        format: "int64",
    },
    appsecFargateCountAvg: {
        baseName: "appsec_fargate_count_avg",
        type: "number",
        format: "int64",
    },
    auditLogsLinesIndexedSum: {
        baseName: "audit_logs_lines_indexed_sum",
        type: "number",
        format: "int64",
    },
    avgProfiledFargateTasks: {
        baseName: "avg_profiled_fargate_tasks",
        type: "number",
        format: "int64",
    },
    awsHostTop99p: {
        baseName: "aws_host_top99p",
        type: "number",
        format: "int64",
    },
    awsLambdaFuncCount: {
        baseName: "aws_lambda_func_count",
        type: "number",
        format: "int64",
    },
    awsLambdaInvocationsSum: {
        baseName: "aws_lambda_invocations_sum",
        type: "number",
        format: "int64",
    },
    azureAppServiceTop99p: {
        baseName: "azure_app_service_top99p",
        type: "number",
        format: "int64",
    },
    billableIngestedBytesSum: {
        baseName: "billable_ingested_bytes_sum",
        type: "number",
        format: "int64",
    },
    browserRumLiteSessionCountSum: {
        baseName: "browser_rum_lite_session_count_sum",
        type: "number",
        format: "int64",
    },
    browserRumReplaySessionCountSum: {
        baseName: "browser_rum_replay_session_count_sum",
        type: "number",
        format: "int64",
    },
    browserRumUnitsSum: {
        baseName: "browser_rum_units_sum",
        type: "number",
        format: "int64",
    },
    ciPipelineIndexedSpansSum: {
        baseName: "ci_pipeline_indexed_spans_sum",
        type: "number",
        format: "int64",
    },
    ciTestIndexedSpansSum: {
        baseName: "ci_test_indexed_spans_sum",
        type: "number",
        format: "int64",
    },
    ciVisibilityPipelineCommittersHwm: {
        baseName: "ci_visibility_pipeline_committers_hwm",
        type: "number",
        format: "int64",
    },
    ciVisibilityTestCommittersHwm: {
        baseName: "ci_visibility_test_committers_hwm",
        type: "number",
        format: "int64",
    },
    containerAvg: {
        baseName: "container_avg",
        type: "number",
        format: "int64",
    },
    containerHwm: {
        baseName: "container_hwm",
        type: "number",
        format: "int64",
    },
    cspmAasHostTop99p: {
        baseName: "cspm_aas_host_top99p",
        type: "number",
        format: "int64",
    },
    cspmAwsHostTop99p: {
        baseName: "cspm_aws_host_top99p",
        type: "number",
        format: "int64",
    },
    cspmAzureHostTop99p: {
        baseName: "cspm_azure_host_top99p",
        type: "number",
        format: "int64",
    },
    cspmContainerAvg: {
        baseName: "cspm_container_avg",
        type: "number",
        format: "int64",
    },
    cspmContainerHwm: {
        baseName: "cspm_container_hwm",
        type: "number",
        format: "int64",
    },
    cspmGcpHostTop99p: {
        baseName: "cspm_gcp_host_top99p",
        type: "number",
        format: "int64",
    },
    cspmHostTop99p: {
        baseName: "cspm_host_top99p",
        type: "number",
        format: "int64",
    },
    customTsAvg: {
        baseName: "custom_ts_avg",
        type: "number",
        format: "int64",
    },
    cwsContainerCountAvg: {
        baseName: "cws_container_count_avg",
        type: "number",
        format: "int64",
    },
    cwsHostTop99p: {
        baseName: "cws_host_top99p",
        type: "number",
        format: "int64",
    },
    date: {
        baseName: "date",
        type: "Date",
        format: "date-time",
    },
    dbmHostTop99p: {
        baseName: "dbm_host_top99p",
        type: "number",
        format: "int64",
    },
    dbmQueriesCountAvg: {
        baseName: "dbm_queries_count_avg",
        type: "number",
        format: "int64",
    },
    fargateTasksCountAvg: {
        baseName: "fargate_tasks_count_avg",
        type: "number",
        format: "int64",
    },
    fargateTasksCountHwm: {
        baseName: "fargate_tasks_count_hwm",
        type: "number",
        format: "int64",
    },
    gcpHostTop99p: {
        baseName: "gcp_host_top99p",
        type: "number",
        format: "int64",
    },
    herokuHostTop99p: {
        baseName: "heroku_host_top99p",
        type: "number",
        format: "int64",
    },
    incidentManagementMonthlyActiveUsersHwm: {
        baseName: "incident_management_monthly_active_users_hwm",
        type: "number",
        format: "int64",
    },
    indexedEventsCountSum: {
        baseName: "indexed_events_count_sum",
        type: "number",
        format: "int64",
    },
    infraHostTop99p: {
        baseName: "infra_host_top99p",
        type: "number",
        format: "int64",
    },
    ingestedEventsBytesSum: {
        baseName: "ingested_events_bytes_sum",
        type: "number",
        format: "int64",
    },
    iotDeviceSum: {
        baseName: "iot_device_sum",
        type: "number",
        format: "int64",
    },
    iotDeviceTop99p: {
        baseName: "iot_device_top99p",
        type: "number",
        format: "int64",
    },
    mobileRumLiteSessionCountSum: {
        baseName: "mobile_rum_lite_session_count_sum",
        type: "number",
        format: "int64",
    },
    mobileRumSessionCountAndroidSum: {
        baseName: "mobile_rum_session_count_android_sum",
        type: "number",
        format: "int64",
    },
    mobileRumSessionCountIosSum: {
        baseName: "mobile_rum_session_count_ios_sum",
        type: "number",
        format: "int64",
    },
    mobileRumSessionCountReactnativeSum: {
        baseName: "mobile_rum_session_count_reactnative_sum",
        type: "number",
        format: "int64",
    },
    mobileRumSessionCountSum: {
        baseName: "mobile_rum_session_count_sum",
        type: "number",
        format: "int64",
    },
    mobileRumUnitsSum: {
        baseName: "mobile_rum_units_sum",
        type: "number",
        format: "int64",
    },
    netflowIndexedEventsCountSum: {
        baseName: "netflow_indexed_events_count_sum",
        type: "number",
        format: "int64",
    },
    npmHostTop99p: {
        baseName: "npm_host_top99p",
        type: "number",
        format: "int64",
    },
    observabilityPipelinesBytesProcessedSum: {
        baseName: "observability_pipelines_bytes_processed_sum",
        type: "number",
        format: "int64",
    },
    onlineArchiveEventsCountSum: {
        baseName: "online_archive_events_count_sum",
        type: "number",
        format: "int64",
    },
    opentelemetryApmHostTop99p: {
        baseName: "opentelemetry_apm_host_top99p",
        type: "number",
        format: "int64",
    },
    opentelemetryHostTop99p: {
        baseName: "opentelemetry_host_top99p",
        type: "number",
        format: "int64",
    },
    orgs: {
        baseName: "orgs",
        type: "Array<UsageSummaryDateOrg>",
    },
    profilingHostTop99p: {
        baseName: "profiling_host_top99p",
        type: "number",
        format: "int64",
    },
    rumBrowserAndMobileSessionCount: {
        baseName: "rum_browser_and_mobile_session_count",
        type: "number",
        format: "int64",
    },
    rumSessionCountSum: {
        baseName: "rum_session_count_sum",
        type: "number",
        format: "int64",
    },
    rumTotalSessionCountSum: {
        baseName: "rum_total_session_count_sum",
        type: "number",
        format: "int64",
    },
    rumUnitsSum: {
        baseName: "rum_units_sum",
        type: "number",
        format: "int64",
    },
    sdsApmScannedBytesSum: {
        baseName: "sds_apm_scanned_bytes_sum",
        type: "number",
        format: "int64",
    },
    sdsEventsScannedBytesSum: {
        baseName: "sds_events_scanned_bytes_sum",
        type: "number",
        format: "int64",
    },
    sdsLogsScannedBytesSum: {
        baseName: "sds_logs_scanned_bytes_sum",
        type: "number",
        format: "int64",
    },
    sdsRumScannedBytesSum: {
        baseName: "sds_rum_scanned_bytes_sum",
        type: "number",
        format: "int64",
    },
    sdsTotalScannedBytesSum: {
        baseName: "sds_total_scanned_bytes_sum",
        type: "number",
        format: "int64",
    },
    syntheticsBrowserCheckCallsCountSum: {
        baseName: "synthetics_browser_check_calls_count_sum",
        type: "number",
        format: "int64",
    },
    syntheticsCheckCallsCountSum: {
        baseName: "synthetics_check_calls_count_sum",
        type: "number",
        format: "int64",
    },
    syntheticsParallelTestingMaxSlotsHwm: {
        baseName: "synthetics_parallel_testing_max_slots_hwm",
        type: "number",
        format: "int64",
    },
    traceSearchIndexedEventsCountSum: {
        baseName: "trace_search_indexed_events_count_sum",
        type: "number",
        format: "int64",
    },
    twolIngestedEventsBytesSum: {
        baseName: "twol_ingested_events_bytes_sum",
        type: "number",
        format: "int64",
    },
    vsphereHostTop99p: {
        baseName: "vsphere_host_top99p",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=UsageSummaryDate.js.map

/***/ }),

/***/ 31308:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageSummaryDateOrg = void 0;
/**
 * Global hourly report of all data billed by Datadog for a given organization.
 */
class UsageSummaryDateOrg {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageSummaryDateOrg.attributeTypeMap;
    }
}
exports.UsageSummaryDateOrg = UsageSummaryDateOrg;
/**
 * @ignore
 */
UsageSummaryDateOrg.attributeTypeMap = {
    agentHostTop99p: {
        baseName: "agent_host_top99p",
        type: "number",
        format: "int64",
    },
    apmAzureAppServiceHostTop99p: {
        baseName: "apm_azure_app_service_host_top99p",
        type: "number",
        format: "int64",
    },
    apmFargateCountAvg: {
        baseName: "apm_fargate_count_avg",
        type: "number",
        format: "int64",
    },
    apmHostTop99p: {
        baseName: "apm_host_top99p",
        type: "number",
        format: "int64",
    },
    appsecFargateCountAvg: {
        baseName: "appsec_fargate_count_avg",
        type: "number",
        format: "int64",
    },
    auditLogsLinesIndexedSum: {
        baseName: "audit_logs_lines_indexed_sum",
        type: "number",
        format: "int64",
    },
    avgProfiledFargateTasks: {
        baseName: "avg_profiled_fargate_tasks",
        type: "number",
        format: "int64",
    },
    awsHostTop99p: {
        baseName: "aws_host_top99p",
        type: "number",
        format: "int64",
    },
    awsLambdaFuncCount: {
        baseName: "aws_lambda_func_count",
        type: "number",
        format: "int64",
    },
    awsLambdaInvocationsSum: {
        baseName: "aws_lambda_invocations_sum",
        type: "number",
        format: "int64",
    },
    azureAppServiceTop99p: {
        baseName: "azure_app_service_top99p",
        type: "number",
        format: "int64",
    },
    billableIngestedBytesSum: {
        baseName: "billable_ingested_bytes_sum",
        type: "number",
        format: "int64",
    },
    browserRumLiteSessionCountSum: {
        baseName: "browser_rum_lite_session_count_sum",
        type: "number",
        format: "int64",
    },
    browserRumReplaySessionCountSum: {
        baseName: "browser_rum_replay_session_count_sum",
        type: "number",
        format: "int64",
    },
    browserRumUnitsSum: {
        baseName: "browser_rum_units_sum",
        type: "number",
        format: "int64",
    },
    ciPipelineIndexedSpansSum: {
        baseName: "ci_pipeline_indexed_spans_sum",
        type: "number",
        format: "int64",
    },
    ciTestIndexedSpansSum: {
        baseName: "ci_test_indexed_spans_sum",
        type: "number",
        format: "int64",
    },
    ciVisibilityPipelineCommittersHwm: {
        baseName: "ci_visibility_pipeline_committers_hwm",
        type: "number",
        format: "int64",
    },
    ciVisibilityTestCommittersHwm: {
        baseName: "ci_visibility_test_committers_hwm",
        type: "number",
        format: "int64",
    },
    containerAvg: {
        baseName: "container_avg",
        type: "number",
        format: "int64",
    },
    containerHwm: {
        baseName: "container_hwm",
        type: "number",
        format: "int64",
    },
    cspmAasHostTop99p: {
        baseName: "cspm_aas_host_top99p",
        type: "number",
        format: "int64",
    },
    cspmAwsHostTop99p: {
        baseName: "cspm_aws_host_top99p",
        type: "number",
        format: "int64",
    },
    cspmAzureHostTop99p: {
        baseName: "cspm_azure_host_top99p",
        type: "number",
        format: "int64",
    },
    cspmContainerAvg: {
        baseName: "cspm_container_avg",
        type: "number",
        format: "int64",
    },
    cspmContainerHwm: {
        baseName: "cspm_container_hwm",
        type: "number",
        format: "int64",
    },
    cspmGcpHostTop99p: {
        baseName: "cspm_gcp_host_top99p",
        type: "number",
        format: "int64",
    },
    cspmHostTop99p: {
        baseName: "cspm_host_top99p",
        type: "number",
        format: "int64",
    },
    customTsAvg: {
        baseName: "custom_ts_avg",
        type: "number",
        format: "int64",
    },
    cwsContainerCountAvg: {
        baseName: "cws_container_count_avg",
        type: "number",
        format: "int64",
    },
    cwsHostTop99p: {
        baseName: "cws_host_top99p",
        type: "number",
        format: "int64",
    },
    dbmHostTop99pSum: {
        baseName: "dbm_host_top99p_sum",
        type: "number",
        format: "int64",
    },
    dbmQueriesAvgSum: {
        baseName: "dbm_queries_avg_sum",
        type: "number",
        format: "int64",
    },
    fargateTasksCountAvg: {
        baseName: "fargate_tasks_count_avg",
        type: "number",
        format: "int64",
    },
    fargateTasksCountHwm: {
        baseName: "fargate_tasks_count_hwm",
        type: "number",
        format: "int64",
    },
    gcpHostTop99p: {
        baseName: "gcp_host_top99p",
        type: "number",
        format: "int64",
    },
    herokuHostTop99p: {
        baseName: "heroku_host_top99p",
        type: "number",
        format: "int64",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    incidentManagementMonthlyActiveUsersHwm: {
        baseName: "incident_management_monthly_active_users_hwm",
        type: "number",
        format: "int64",
    },
    indexedEventsCountSum: {
        baseName: "indexed_events_count_sum",
        type: "number",
        format: "int64",
    },
    infraHostTop99p: {
        baseName: "infra_host_top99p",
        type: "number",
        format: "int64",
    },
    ingestedEventsBytesSum: {
        baseName: "ingested_events_bytes_sum",
        type: "number",
        format: "int64",
    },
    iotDeviceAggSum: {
        baseName: "iot_device_agg_sum",
        type: "number",
        format: "int64",
    },
    iotDeviceTop99pSum: {
        baseName: "iot_device_top99p_sum",
        type: "number",
        format: "int64",
    },
    mobileRumLiteSessionCountSum: {
        baseName: "mobile_rum_lite_session_count_sum",
        type: "number",
        format: "int64",
    },
    mobileRumSessionCountAndroidSum: {
        baseName: "mobile_rum_session_count_android_sum",
        type: "number",
        format: "int64",
    },
    mobileRumSessionCountIosSum: {
        baseName: "mobile_rum_session_count_ios_sum",
        type: "number",
        format: "int64",
    },
    mobileRumSessionCountReactnativeSum: {
        baseName: "mobile_rum_session_count_reactnative_sum",
        type: "number",
        format: "int64",
    },
    mobileRumSessionCountSum: {
        baseName: "mobile_rum_session_count_sum",
        type: "number",
        format: "int64",
    },
    mobileRumUnitsSum: {
        baseName: "mobile_rum_units_sum",
        type: "number",
        format: "int64",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    netflowIndexedEventsCountSum: {
        baseName: "netflow_indexed_events_count_sum",
        type: "number",
        format: "int64",
    },
    npmHostTop99p: {
        baseName: "npm_host_top99p",
        type: "number",
        format: "int64",
    },
    observabilityPipelinesBytesProcessedSum: {
        baseName: "observability_pipelines_bytes_processed_sum",
        type: "number",
        format: "int64",
    },
    onlineArchiveEventsCountSum: {
        baseName: "online_archive_events_count_sum",
        type: "number",
        format: "int64",
    },
    opentelemetryApmHostTop99p: {
        baseName: "opentelemetry_apm_host_top99p",
        type: "number",
        format: "int64",
    },
    opentelemetryHostTop99p: {
        baseName: "opentelemetry_host_top99p",
        type: "number",
        format: "int64",
    },
    profilingHostTop99p: {
        baseName: "profiling_host_top99p",
        type: "number",
        format: "int64",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    region: {
        baseName: "region",
        type: "string",
    },
    rumBrowserAndMobileSessionCount: {
        baseName: "rum_browser_and_mobile_session_count",
        type: "number",
        format: "int64",
    },
    rumSessionCountSum: {
        baseName: "rum_session_count_sum",
        type: "number",
        format: "int64",
    },
    rumTotalSessionCountSum: {
        baseName: "rum_total_session_count_sum",
        type: "number",
        format: "int64",
    },
    rumUnitsSum: {
        baseName: "rum_units_sum",
        type: "number",
        format: "int64",
    },
    sdsApmScannedBytesSum: {
        baseName: "sds_apm_scanned_bytes_sum",
        type: "number",
        format: "int64",
    },
    sdsEventsScannedBytesSum: {
        baseName: "sds_events_scanned_bytes_sum",
        type: "number",
        format: "int64",
    },
    sdsLogsScannedBytesSum: {
        baseName: "sds_logs_scanned_bytes_sum",
        type: "number",
        format: "int64",
    },
    sdsRumScannedBytesSum: {
        baseName: "sds_rum_scanned_bytes_sum",
        type: "number",
        format: "int64",
    },
    sdsTotalScannedBytesSum: {
        baseName: "sds_total_scanned_bytes_sum",
        type: "number",
        format: "int64",
    },
    syntheticsBrowserCheckCallsCountSum: {
        baseName: "synthetics_browser_check_calls_count_sum",
        type: "number",
        format: "int64",
    },
    syntheticsCheckCallsCountSum: {
        baseName: "synthetics_check_calls_count_sum",
        type: "number",
        format: "int64",
    },
    syntheticsParallelTestingMaxSlotsHwm: {
        baseName: "synthetics_parallel_testing_max_slots_hwm",
        type: "number",
        format: "int64",
    },
    traceSearchIndexedEventsCountSum: {
        baseName: "trace_search_indexed_events_count_sum",
        type: "number",
        format: "int64",
    },
    twolIngestedEventsBytesSum: {
        baseName: "twol_ingested_events_bytes_sum",
        type: "number",
        format: "int64",
    },
    vsphereHostTop99p: {
        baseName: "vsphere_host_top99p",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=UsageSummaryDateOrg.js.map

/***/ }),

/***/ 61378:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageSummaryResponse = void 0;
/**
 * Response summarizing all usage aggregated across the months in the request for all organizations, and broken down by month and by organization.
 */
class UsageSummaryResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageSummaryResponse.attributeTypeMap;
    }
}
exports.UsageSummaryResponse = UsageSummaryResponse;
/**
 * @ignore
 */
UsageSummaryResponse.attributeTypeMap = {
    agentHostTop99pSum: {
        baseName: "agent_host_top99p_sum",
        type: "number",
        format: "int64",
    },
    apmAzureAppServiceHostTop99pSum: {
        baseName: "apm_azure_app_service_host_top99p_sum",
        type: "number",
        format: "int64",
    },
    apmFargateCountAvgSum: {
        baseName: "apm_fargate_count_avg_sum",
        type: "number",
        format: "int64",
    },
    apmHostTop99pSum: {
        baseName: "apm_host_top99p_sum",
        type: "number",
        format: "int64",
    },
    appsecFargateCountAvgSum: {
        baseName: "appsec_fargate_count_avg_sum",
        type: "number",
        format: "int64",
    },
    auditLogsLinesIndexedAggSum: {
        baseName: "audit_logs_lines_indexed_agg_sum",
        type: "number",
        format: "int64",
    },
    avgProfiledFargateTasksSum: {
        baseName: "avg_profiled_fargate_tasks_sum",
        type: "number",
        format: "int64",
    },
    awsHostTop99pSum: {
        baseName: "aws_host_top99p_sum",
        type: "number",
        format: "int64",
    },
    awsLambdaFuncCount: {
        baseName: "aws_lambda_func_count",
        type: "number",
        format: "int64",
    },
    awsLambdaInvocationsSum: {
        baseName: "aws_lambda_invocations_sum",
        type: "number",
        format: "int64",
    },
    azureAppServiceTop99pSum: {
        baseName: "azure_app_service_top99p_sum",
        type: "number",
        format: "int64",
    },
    azureHostTop99pSum: {
        baseName: "azure_host_top99p_sum",
        type: "number",
        format: "int64",
    },
    billableIngestedBytesAggSum: {
        baseName: "billable_ingested_bytes_agg_sum",
        type: "number",
        format: "int64",
    },
    browserRumLiteSessionCountAggSum: {
        baseName: "browser_rum_lite_session_count_agg_sum",
        type: "number",
        format: "int64",
    },
    browserRumReplaySessionCountAggSum: {
        baseName: "browser_rum_replay_session_count_agg_sum",
        type: "number",
        format: "int64",
    },
    browserRumUnitsAggSum: {
        baseName: "browser_rum_units_agg_sum",
        type: "number",
        format: "int64",
    },
    ciPipelineIndexedSpansAggSum: {
        baseName: "ci_pipeline_indexed_spans_agg_sum",
        type: "number",
        format: "int64",
    },
    ciTestIndexedSpansAggSum: {
        baseName: "ci_test_indexed_spans_agg_sum",
        type: "number",
        format: "int64",
    },
    ciVisibilityPipelineCommittersHwmSum: {
        baseName: "ci_visibility_pipeline_committers_hwm_sum",
        type: "number",
        format: "int64",
    },
    ciVisibilityTestCommittersHwmSum: {
        baseName: "ci_visibility_test_committers_hwm_sum",
        type: "number",
        format: "int64",
    },
    containerAvgSum: {
        baseName: "container_avg_sum",
        type: "number",
        format: "int64",
    },
    containerHwmSum: {
        baseName: "container_hwm_sum",
        type: "number",
        format: "int64",
    },
    cspmAasHostTop99pSum: {
        baseName: "cspm_aas_host_top99p_sum",
        type: "number",
        format: "int64",
    },
    cspmAwsHostTop99pSum: {
        baseName: "cspm_aws_host_top99p_sum",
        type: "number",
        format: "int64",
    },
    cspmAzureHostTop99pSum: {
        baseName: "cspm_azure_host_top99p_sum",
        type: "number",
        format: "int64",
    },
    cspmContainerAvgSum: {
        baseName: "cspm_container_avg_sum",
        type: "number",
        format: "int64",
    },
    cspmContainerHwmSum: {
        baseName: "cspm_container_hwm_sum",
        type: "number",
        format: "int64",
    },
    cspmGcpHostTop99pSum: {
        baseName: "cspm_gcp_host_top99p_sum",
        type: "number",
        format: "int64",
    },
    cspmHostTop99pSum: {
        baseName: "cspm_host_top99p_sum",
        type: "number",
        format: "int64",
    },
    customTsSum: {
        baseName: "custom_ts_sum",
        type: "number",
        format: "int64",
    },
    cwsContainersAvgSum: {
        baseName: "cws_containers_avg_sum",
        type: "number",
        format: "int64",
    },
    cwsHostTop99pSum: {
        baseName: "cws_host_top99p_sum",
        type: "number",
        format: "int64",
    },
    dbmHostTop99pSum: {
        baseName: "dbm_host_top99p_sum",
        type: "number",
        format: "int64",
    },
    dbmQueriesAvgSum: {
        baseName: "dbm_queries_avg_sum",
        type: "number",
        format: "int64",
    },
    endDate: {
        baseName: "end_date",
        type: "Date",
        format: "date-time",
    },
    fargateTasksCountAvgSum: {
        baseName: "fargate_tasks_count_avg_sum",
        type: "number",
        format: "int64",
    },
    fargateTasksCountHwmSum: {
        baseName: "fargate_tasks_count_hwm_sum",
        type: "number",
        format: "int64",
    },
    gcpHostTop99pSum: {
        baseName: "gcp_host_top99p_sum",
        type: "number",
        format: "int64",
    },
    herokuHostTop99pSum: {
        baseName: "heroku_host_top99p_sum",
        type: "number",
        format: "int64",
    },
    incidentManagementMonthlyActiveUsersHwmSum: {
        baseName: "incident_management_monthly_active_users_hwm_sum",
        type: "number",
        format: "int64",
    },
    indexedEventsCountAggSum: {
        baseName: "indexed_events_count_agg_sum",
        type: "number",
        format: "int64",
    },
    infraHostTop99pSum: {
        baseName: "infra_host_top99p_sum",
        type: "number",
        format: "int64",
    },
    ingestedEventsBytesAggSum: {
        baseName: "ingested_events_bytes_agg_sum",
        type: "number",
        format: "int64",
    },
    iotDeviceAggSum: {
        baseName: "iot_device_agg_sum",
        type: "number",
        format: "int64",
    },
    iotDeviceTop99pSum: {
        baseName: "iot_device_top99p_sum",
        type: "number",
        format: "int64",
    },
    lastUpdated: {
        baseName: "last_updated",
        type: "Date",
        format: "date-time",
    },
    liveIndexedEventsAggSum: {
        baseName: "live_indexed_events_agg_sum",
        type: "number",
        format: "int64",
    },
    liveIngestedBytesAggSum: {
        baseName: "live_ingested_bytes_agg_sum",
        type: "number",
        format: "int64",
    },
    logsByRetention: {
        baseName: "logs_by_retention",
        type: "LogsByRetention",
    },
    mobileRumLiteSessionCountAggSum: {
        baseName: "mobile_rum_lite_session_count_agg_sum",
        type: "number",
        format: "int64",
    },
    mobileRumSessionCountAggSum: {
        baseName: "mobile_rum_session_count_agg_sum",
        type: "number",
        format: "int64",
    },
    mobileRumSessionCountAndroidAggSum: {
        baseName: "mobile_rum_session_count_android_agg_sum",
        type: "number",
        format: "int64",
    },
    mobileRumSessionCountIosAggSum: {
        baseName: "mobile_rum_session_count_ios_agg_sum",
        type: "number",
        format: "int64",
    },
    mobileRumSessionCountReactnativeAggSum: {
        baseName: "mobile_rum_session_count_reactnative_agg_sum",
        type: "number",
        format: "int64",
    },
    mobileRumUnitsAggSum: {
        baseName: "mobile_rum_units_agg_sum",
        type: "number",
        format: "int64",
    },
    netflowIndexedEventsCountAggSum: {
        baseName: "netflow_indexed_events_count_agg_sum",
        type: "number",
        format: "int64",
    },
    npmHostTop99pSum: {
        baseName: "npm_host_top99p_sum",
        type: "number",
        format: "int64",
    },
    observabilityPipelinesBytesProcessedAggSum: {
        baseName: "observability_pipelines_bytes_processed_agg_sum",
        type: "number",
        format: "int64",
    },
    onlineArchiveEventsCountAggSum: {
        baseName: "online_archive_events_count_agg_sum",
        type: "number",
        format: "int64",
    },
    opentelemetryApmHostTop99pSum: {
        baseName: "opentelemetry_apm_host_top99p_sum",
        type: "number",
        format: "int64",
    },
    opentelemetryHostTop99pSum: {
        baseName: "opentelemetry_host_top99p_sum",
        type: "number",
        format: "int64",
    },
    profilingContainerAgentCountAvg: {
        baseName: "profiling_container_agent_count_avg",
        type: "number",
        format: "int64",
    },
    profilingHostCountTop99pSum: {
        baseName: "profiling_host_count_top99p_sum",
        type: "number",
        format: "int64",
    },
    rehydratedIndexedEventsAggSum: {
        baseName: "rehydrated_indexed_events_agg_sum",
        type: "number",
        format: "int64",
    },
    rehydratedIngestedBytesAggSum: {
        baseName: "rehydrated_ingested_bytes_agg_sum",
        type: "number",
        format: "int64",
    },
    rumBrowserAndMobileSessionCount: {
        baseName: "rum_browser_and_mobile_session_count",
        type: "number",
        format: "int64",
    },
    rumSessionCountAggSum: {
        baseName: "rum_session_count_agg_sum",
        type: "number",
        format: "int64",
    },
    rumTotalSessionCountAggSum: {
        baseName: "rum_total_session_count_agg_sum",
        type: "number",
        format: "int64",
    },
    rumUnitsAggSum: {
        baseName: "rum_units_agg_sum",
        type: "number",
        format: "int64",
    },
    sdsApmScannedBytesSum: {
        baseName: "sds_apm_scanned_bytes_sum",
        type: "number",
        format: "int64",
    },
    sdsEventsScannedBytesSum: {
        baseName: "sds_events_scanned_bytes_sum",
        type: "number",
        format: "int64",
    },
    sdsLogsScannedBytesSum: {
        baseName: "sds_logs_scanned_bytes_sum",
        type: "number",
        format: "int64",
    },
    sdsRumScannedBytesSum: {
        baseName: "sds_rum_scanned_bytes_sum",
        type: "number",
        format: "int64",
    },
    sdsTotalScannedBytesSum: {
        baseName: "sds_total_scanned_bytes_sum",
        type: "number",
        format: "int64",
    },
    startDate: {
        baseName: "start_date",
        type: "Date",
        format: "date-time",
    },
    syntheticsBrowserCheckCallsCountAggSum: {
        baseName: "synthetics_browser_check_calls_count_agg_sum",
        type: "number",
        format: "int64",
    },
    syntheticsCheckCallsCountAggSum: {
        baseName: "synthetics_check_calls_count_agg_sum",
        type: "number",
        format: "int64",
    },
    syntheticsParallelTestingMaxSlotsHwmSum: {
        baseName: "synthetics_parallel_testing_max_slots_hwm_sum",
        type: "number",
        format: "int64",
    },
    traceSearchIndexedEventsCountAggSum: {
        baseName: "trace_search_indexed_events_count_agg_sum",
        type: "number",
        format: "int64",
    },
    twolIngestedEventsBytesAggSum: {
        baseName: "twol_ingested_events_bytes_agg_sum",
        type: "number",
        format: "int64",
    },
    usage: {
        baseName: "usage",
        type: "Array<UsageSummaryDate>",
    },
    vsphereHostTop99pSum: {
        baseName: "vsphere_host_top99p_sum",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=UsageSummaryResponse.js.map

/***/ }),

/***/ 80931:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageSyntheticsAPIHour = void 0;
/**
 * Number of Synthetics API tests run for each hour for a given organization.
 */
class UsageSyntheticsAPIHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageSyntheticsAPIHour.attributeTypeMap;
    }
}
exports.UsageSyntheticsAPIHour = UsageSyntheticsAPIHour;
/**
 * @ignore
 */
UsageSyntheticsAPIHour.attributeTypeMap = {
    checkCallsCount: {
        baseName: "check_calls_count",
        type: "number",
        format: "int64",
    },
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=UsageSyntheticsAPIHour.js.map

/***/ }),

/***/ 36143:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageSyntheticsAPIResponse = void 0;
/**
 * Response containing the number of Synthetics API tests run for each hour for a given organization.
 */
class UsageSyntheticsAPIResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageSyntheticsAPIResponse.attributeTypeMap;
    }
}
exports.UsageSyntheticsAPIResponse = UsageSyntheticsAPIResponse;
/**
 * @ignore
 */
UsageSyntheticsAPIResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageSyntheticsAPIHour>",
    },
};
//# sourceMappingURL=UsageSyntheticsAPIResponse.js.map

/***/ }),

/***/ 68362:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageSyntheticsBrowserHour = void 0;
/**
 * Number of Synthetics Browser tests run for each hour for a given organization.
 */
class UsageSyntheticsBrowserHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageSyntheticsBrowserHour.attributeTypeMap;
    }
}
exports.UsageSyntheticsBrowserHour = UsageSyntheticsBrowserHour;
/**
 * @ignore
 */
UsageSyntheticsBrowserHour.attributeTypeMap = {
    browserCheckCallsCount: {
        baseName: "browser_check_calls_count",
        type: "number",
        format: "int64",
    },
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=UsageSyntheticsBrowserHour.js.map

/***/ }),

/***/ 95322:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageSyntheticsBrowserResponse = void 0;
/**
 * Response containing the number of Synthetics Browser tests run for each hour for a given organization.
 */
class UsageSyntheticsBrowserResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageSyntheticsBrowserResponse.attributeTypeMap;
    }
}
exports.UsageSyntheticsBrowserResponse = UsageSyntheticsBrowserResponse;
/**
 * @ignore
 */
UsageSyntheticsBrowserResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageSyntheticsBrowserHour>",
    },
};
//# sourceMappingURL=UsageSyntheticsBrowserResponse.js.map

/***/ }),

/***/ 60809:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageSyntheticsHour = void 0;
/**
 * The number of synthetics tests run for each hour for a given organization.
 */
class UsageSyntheticsHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageSyntheticsHour.attributeTypeMap;
    }
}
exports.UsageSyntheticsHour = UsageSyntheticsHour;
/**
 * @ignore
 */
UsageSyntheticsHour.attributeTypeMap = {
    checkCallsCount: {
        baseName: "check_calls_count",
        type: "number",
        format: "int64",
    },
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=UsageSyntheticsHour.js.map

/***/ }),

/***/ 46862:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageSyntheticsResponse = void 0;
/**
 * Response containing the number of Synthetics API tests run for each hour for a given organization.
 */
class UsageSyntheticsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageSyntheticsResponse.attributeTypeMap;
    }
}
exports.UsageSyntheticsResponse = UsageSyntheticsResponse;
/**
 * @ignore
 */
UsageSyntheticsResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageSyntheticsHour>",
    },
};
//# sourceMappingURL=UsageSyntheticsResponse.js.map

/***/ }),

/***/ 4062:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageTimeseriesHour = void 0;
/**
 * The hourly usage of timeseries.
 */
class UsageTimeseriesHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageTimeseriesHour.attributeTypeMap;
    }
}
exports.UsageTimeseriesHour = UsageTimeseriesHour;
/**
 * @ignore
 */
UsageTimeseriesHour.attributeTypeMap = {
    hour: {
        baseName: "hour",
        type: "Date",
        format: "date-time",
    },
    numCustomInputTimeseries: {
        baseName: "num_custom_input_timeseries",
        type: "number",
        format: "int64",
    },
    numCustomOutputTimeseries: {
        baseName: "num_custom_output_timeseries",
        type: "number",
        format: "int64",
    },
    numCustomTimeseries: {
        baseName: "num_custom_timeseries",
        type: "number",
        format: "int64",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
};
//# sourceMappingURL=UsageTimeseriesHour.js.map

/***/ }),

/***/ 2516:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageTimeseriesResponse = void 0;
/**
 * Response containing hourly usage of timeseries.
 */
class UsageTimeseriesResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageTimeseriesResponse.attributeTypeMap;
    }
}
exports.UsageTimeseriesResponse = UsageTimeseriesResponse;
/**
 * @ignore
 */
UsageTimeseriesResponse.attributeTypeMap = {
    usage: {
        baseName: "usage",
        type: "Array<UsageTimeseriesHour>",
    },
};
//# sourceMappingURL=UsageTimeseriesResponse.js.map

/***/ }),

/***/ 62000:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageTopAvgMetricsHour = void 0;
/**
 * Number of hourly recorded custom metrics for a given organization.
 */
class UsageTopAvgMetricsHour {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageTopAvgMetricsHour.attributeTypeMap;
    }
}
exports.UsageTopAvgMetricsHour = UsageTopAvgMetricsHour;
/**
 * @ignore
 */
UsageTopAvgMetricsHour.attributeTypeMap = {
    avgMetricHour: {
        baseName: "avg_metric_hour",
        type: "number",
        format: "int64",
    },
    maxMetricHour: {
        baseName: "max_metric_hour",
        type: "number",
        format: "int64",
    },
    metricCategory: {
        baseName: "metric_category",
        type: "UsageMetricCategory",
    },
    metricName: {
        baseName: "metric_name",
        type: "string",
    },
};
//# sourceMappingURL=UsageTopAvgMetricsHour.js.map

/***/ }),

/***/ 57758:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageTopAvgMetricsMetadata = void 0;
/**
 * The object containing document metadata.
 */
class UsageTopAvgMetricsMetadata {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageTopAvgMetricsMetadata.attributeTypeMap;
    }
}
exports.UsageTopAvgMetricsMetadata = UsageTopAvgMetricsMetadata;
/**
 * @ignore
 */
UsageTopAvgMetricsMetadata.attributeTypeMap = {
    day: {
        baseName: "day",
        type: "Date",
        format: "date-time",
    },
    month: {
        baseName: "month",
        type: "Date",
        format: "date-time",
    },
    pagination: {
        baseName: "pagination",
        type: "UsageTopAvgMetricsPagination",
    },
};
//# sourceMappingURL=UsageTopAvgMetricsMetadata.js.map

/***/ }),

/***/ 69015:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageTopAvgMetricsPagination = void 0;
/**
 * The metadata for the current pagination.
 */
class UsageTopAvgMetricsPagination {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageTopAvgMetricsPagination.attributeTypeMap;
    }
}
exports.UsageTopAvgMetricsPagination = UsageTopAvgMetricsPagination;
/**
 * @ignore
 */
UsageTopAvgMetricsPagination.attributeTypeMap = {
    limit: {
        baseName: "limit",
        type: "number",
        format: "int64",
    },
    nextRecordId: {
        baseName: "next_record_id",
        type: "string",
    },
    totalNumberOfRecords: {
        baseName: "total_number_of_records",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=UsageTopAvgMetricsPagination.js.map

/***/ }),

/***/ 5587:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageTopAvgMetricsResponse = void 0;
/**
 * Response containing the number of hourly recorded custom metrics for a given organization.
 */
class UsageTopAvgMetricsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageTopAvgMetricsResponse.attributeTypeMap;
    }
}
exports.UsageTopAvgMetricsResponse = UsageTopAvgMetricsResponse;
/**
 * @ignore
 */
UsageTopAvgMetricsResponse.attributeTypeMap = {
    metadata: {
        baseName: "metadata",
        type: "UsageTopAvgMetricsMetadata",
    },
    usage: {
        baseName: "usage",
        type: "Array<UsageTopAvgMetricsHour>",
    },
};
//# sourceMappingURL=UsageTopAvgMetricsResponse.js.map

/***/ }),

/***/ 65582:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.User = void 0;
/**
 * Create, edit, and disable users.
 */
class User {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return User.attributeTypeMap;
    }
}
exports.User = User;
/**
 * @ignore
 */
User.attributeTypeMap = {
    accessRole: {
        baseName: "access_role",
        type: "AccessRole",
    },
    disabled: {
        baseName: "disabled",
        type: "boolean",
    },
    email: {
        baseName: "email",
        type: "string",
        format: "email",
    },
    handle: {
        baseName: "handle",
        type: "string",
        format: "email",
    },
    icon: {
        baseName: "icon",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    verified: {
        baseName: "verified",
        type: "boolean",
    },
};
//# sourceMappingURL=User.js.map

/***/ }),

/***/ 97395:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserDisableResponse = void 0;
/**
 * Array of user disabled for a given organization.
 */
class UserDisableResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UserDisableResponse.attributeTypeMap;
    }
}
exports.UserDisableResponse = UserDisableResponse;
/**
 * @ignore
 */
UserDisableResponse.attributeTypeMap = {
    message: {
        baseName: "message",
        type: "string",
    },
};
//# sourceMappingURL=UserDisableResponse.js.map

/***/ }),

/***/ 56284:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserListResponse = void 0;
/**
 * Array of Datadog users for a given organization.
 */
class UserListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UserListResponse.attributeTypeMap;
    }
}
exports.UserListResponse = UserListResponse;
/**
 * @ignore
 */
UserListResponse.attributeTypeMap = {
    users: {
        baseName: "users",
        type: "Array<User>",
    },
};
//# sourceMappingURL=UserListResponse.js.map

/***/ }),

/***/ 73865:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserResponse = void 0;
/**
 * A Datadog User.
 */
class UserResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UserResponse.attributeTypeMap;
    }
}
exports.UserResponse = UserResponse;
/**
 * @ignore
 */
UserResponse.attributeTypeMap = {
    user: {
        baseName: "user",
        type: "User",
    },
};
//# sourceMappingURL=UserResponse.js.map

/***/ }),

/***/ 54773:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebhooksIntegration = void 0;
/**
 * Datadog-Webhooks integration.
 */
class WebhooksIntegration {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return WebhooksIntegration.attributeTypeMap;
    }
}
exports.WebhooksIntegration = WebhooksIntegration;
/**
 * @ignore
 */
WebhooksIntegration.attributeTypeMap = {
    customHeaders: {
        baseName: "custom_headers",
        type: "string",
    },
    encodeAs: {
        baseName: "encode_as",
        type: "WebhooksIntegrationEncoding",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    payload: {
        baseName: "payload",
        type: "string",
    },
    url: {
        baseName: "url",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=WebhooksIntegration.js.map

/***/ }),

/***/ 67832:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebhooksIntegrationCustomVariable = void 0;
/**
 * Custom variable for Webhook integration.
 */
class WebhooksIntegrationCustomVariable {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return WebhooksIntegrationCustomVariable.attributeTypeMap;
    }
}
exports.WebhooksIntegrationCustomVariable = WebhooksIntegrationCustomVariable;
/**
 * @ignore
 */
WebhooksIntegrationCustomVariable.attributeTypeMap = {
    isSecret: {
        baseName: "is_secret",
        type: "boolean",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    value: {
        baseName: "value",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=WebhooksIntegrationCustomVariable.js.map

/***/ }),

/***/ 25545:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebhooksIntegrationCustomVariableResponse = void 0;
/**
 * Custom variable for Webhook integration.
 */
class WebhooksIntegrationCustomVariableResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return WebhooksIntegrationCustomVariableResponse.attributeTypeMap;
    }
}
exports.WebhooksIntegrationCustomVariableResponse = WebhooksIntegrationCustomVariableResponse;
/**
 * @ignore
 */
WebhooksIntegrationCustomVariableResponse.attributeTypeMap = {
    isSecret: {
        baseName: "is_secret",
        type: "boolean",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    value: {
        baseName: "value",
        type: "string",
    },
};
//# sourceMappingURL=WebhooksIntegrationCustomVariableResponse.js.map

/***/ }),

/***/ 66363:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebhooksIntegrationCustomVariableUpdateRequest = void 0;
/**
 * Update request of a custom variable object.
 *
 * *All properties are optional.*
 */
class WebhooksIntegrationCustomVariableUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return WebhooksIntegrationCustomVariableUpdateRequest.attributeTypeMap;
    }
}
exports.WebhooksIntegrationCustomVariableUpdateRequest = WebhooksIntegrationCustomVariableUpdateRequest;
/**
 * @ignore
 */
WebhooksIntegrationCustomVariableUpdateRequest.attributeTypeMap = {
    isSecret: {
        baseName: "is_secret",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    value: {
        baseName: "value",
        type: "string",
    },
};
//# sourceMappingURL=WebhooksIntegrationCustomVariableUpdateRequest.js.map

/***/ }),

/***/ 86321:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebhooksIntegrationUpdateRequest = void 0;
/**
 * Update request of a Webhooks integration object.
 *
 * *All properties are optional.*
 */
class WebhooksIntegrationUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return WebhooksIntegrationUpdateRequest.attributeTypeMap;
    }
}
exports.WebhooksIntegrationUpdateRequest = WebhooksIntegrationUpdateRequest;
/**
 * @ignore
 */
WebhooksIntegrationUpdateRequest.attributeTypeMap = {
    customHeaders: {
        baseName: "custom_headers",
        type: "string",
    },
    encodeAs: {
        baseName: "encode_as",
        type: "WebhooksIntegrationEncoding",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    payload: {
        baseName: "payload",
        type: "string",
    },
    url: {
        baseName: "url",
        type: "string",
    },
};
//# sourceMappingURL=WebhooksIntegrationUpdateRequest.js.map

/***/ }),

/***/ 6000:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Widget = void 0;
/**
 * Information about widget.
 *
 * **Note**: The `layout` property is required for widgets in dashboards with `free` `layout_type`.
 *       For the **new dashboard layout**, the `layout` property depends on the `reflow_type` of the dashboard.
 *       - If `reflow_type` is `fixed`, `layout` is required.
 *       - If `reflow_type` is `auto`, `layout` should not be set.
 */
class Widget {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return Widget.attributeTypeMap;
    }
}
exports.Widget = Widget;
/**
 * @ignore
 */
Widget.attributeTypeMap = {
    definition: {
        baseName: "definition",
        type: "WidgetDefinition",
        required: true,
    },
    id: {
        baseName: "id",
        type: "number",
        format: "int64",
    },
    layout: {
        baseName: "layout",
        type: "WidgetLayout",
    },
};
//# sourceMappingURL=Widget.js.map

/***/ }),

/***/ 36356:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WidgetAxis = void 0;
/**
 * Axis controls for the widget.
 */
class WidgetAxis {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return WidgetAxis.attributeTypeMap;
    }
}
exports.WidgetAxis = WidgetAxis;
/**
 * @ignore
 */
WidgetAxis.attributeTypeMap = {
    includeZero: {
        baseName: "include_zero",
        type: "boolean",
    },
    label: {
        baseName: "label",
        type: "string",
    },
    max: {
        baseName: "max",
        type: "string",
    },
    min: {
        baseName: "min",
        type: "string",
    },
    scale: {
        baseName: "scale",
        type: "string",
    },
};
//# sourceMappingURL=WidgetAxis.js.map

/***/ }),

/***/ 68824:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WidgetConditionalFormat = void 0;
/**
 * Define a conditional format for the widget.
 */
class WidgetConditionalFormat {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return WidgetConditionalFormat.attributeTypeMap;
    }
}
exports.WidgetConditionalFormat = WidgetConditionalFormat;
/**
 * @ignore
 */
WidgetConditionalFormat.attributeTypeMap = {
    comparator: {
        baseName: "comparator",
        type: "WidgetComparator",
        required: true,
    },
    customBgColor: {
        baseName: "custom_bg_color",
        type: "string",
    },
    customFgColor: {
        baseName: "custom_fg_color",
        type: "string",
    },
    hideValue: {
        baseName: "hide_value",
        type: "boolean",
    },
    imageUrl: {
        baseName: "image_url",
        type: "string",
    },
    metric: {
        baseName: "metric",
        type: "string",
    },
    palette: {
        baseName: "palette",
        type: "WidgetPalette",
        required: true,
    },
    timeframe: {
        baseName: "timeframe",
        type: "string",
    },
    value: {
        baseName: "value",
        type: "number",
        required: true,
        format: "double",
    },
};
//# sourceMappingURL=WidgetConditionalFormat.js.map

/***/ }),

/***/ 83892:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WidgetCustomLink = void 0;
/**
 * Custom links help you connect a data value to a URL, like a Datadog page or your AWS console.
 */
class WidgetCustomLink {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return WidgetCustomLink.attributeTypeMap;
    }
}
exports.WidgetCustomLink = WidgetCustomLink;
/**
 * @ignore
 */
WidgetCustomLink.attributeTypeMap = {
    isHidden: {
        baseName: "is_hidden",
        type: "boolean",
    },
    label: {
        baseName: "label",
        type: "string",
    },
    link: {
        baseName: "link",
        type: "string",
    },
    overrideLabel: {
        baseName: "override_label",
        type: "string",
    },
};
//# sourceMappingURL=WidgetCustomLink.js.map

/***/ }),

/***/ 27093:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WidgetEvent = void 0;
/**
 * Event overlay control options.
 *
 * See the dedicated [Events JSON schema documentation](https://docs.datadoghq.com/dashboards/graphing_json/widget_json/#events-schema)
 * to learn how to build the `<EVENTS_SCHEMA>`.
 */
class WidgetEvent {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return WidgetEvent.attributeTypeMap;
    }
}
exports.WidgetEvent = WidgetEvent;
/**
 * @ignore
 */
WidgetEvent.attributeTypeMap = {
    q: {
        baseName: "q",
        type: "string",
        required: true,
    },
    tagsExecution: {
        baseName: "tags_execution",
        type: "string",
    },
};
//# sourceMappingURL=WidgetEvent.js.map

/***/ }),

/***/ 95452:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WidgetFieldSort = void 0;
/**
 * Which column and order to sort by
 */
class WidgetFieldSort {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return WidgetFieldSort.attributeTypeMap;
    }
}
exports.WidgetFieldSort = WidgetFieldSort;
/**
 * @ignore
 */
WidgetFieldSort.attributeTypeMap = {
    column: {
        baseName: "column",
        type: "string",
        required: true,
    },
    order: {
        baseName: "order",
        type: "WidgetSort",
        required: true,
    },
};
//# sourceMappingURL=WidgetFieldSort.js.map

/***/ }),

/***/ 96398:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WidgetFormula = void 0;
/**
 * Formula to be used in a widget query.
 */
class WidgetFormula {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return WidgetFormula.attributeTypeMap;
    }
}
exports.WidgetFormula = WidgetFormula;
/**
 * @ignore
 */
WidgetFormula.attributeTypeMap = {
    alias: {
        baseName: "alias",
        type: "string",
    },
    cellDisplayMode: {
        baseName: "cell_display_mode",
        type: "TableWidgetCellDisplayMode",
    },
    conditionalFormats: {
        baseName: "conditional_formats",
        type: "Array<WidgetConditionalFormat>",
    },
    formula: {
        baseName: "formula",
        type: "string",
        required: true,
    },
    limit: {
        baseName: "limit",
        type: "WidgetFormulaLimit",
    },
    style: {
        baseName: "style",
        type: "WidgetFormulaStyle",
    },
};
//# sourceMappingURL=WidgetFormula.js.map

/***/ }),

/***/ 16658:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WidgetFormulaLimit = void 0;
/**
 * Options for limiting results returned.
 */
class WidgetFormulaLimit {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return WidgetFormulaLimit.attributeTypeMap;
    }
}
exports.WidgetFormulaLimit = WidgetFormulaLimit;
/**
 * @ignore
 */
WidgetFormulaLimit.attributeTypeMap = {
    count: {
        baseName: "count",
        type: "number",
        format: "int64",
    },
    order: {
        baseName: "order",
        type: "QuerySortOrder",
    },
};
//# sourceMappingURL=WidgetFormulaLimit.js.map

/***/ }),

/***/ 39089:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WidgetFormulaStyle = void 0;
/**
 * Styling options for widget formulas.
 */
class WidgetFormulaStyle {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return WidgetFormulaStyle.attributeTypeMap;
    }
}
exports.WidgetFormulaStyle = WidgetFormulaStyle;
/**
 * @ignore
 */
WidgetFormulaStyle.attributeTypeMap = {
    palette: {
        baseName: "palette",
        type: "string",
    },
    paletteIndex: {
        baseName: "palette_index",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=WidgetFormulaStyle.js.map

/***/ }),

/***/ 29557:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WidgetLayout = void 0;
/**
 * The layout for a widget on a `free` or **new dashboard layout** dashboard.
 */
class WidgetLayout {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return WidgetLayout.attributeTypeMap;
    }
}
exports.WidgetLayout = WidgetLayout;
/**
 * @ignore
 */
WidgetLayout.attributeTypeMap = {
    height: {
        baseName: "height",
        type: "number",
        required: true,
        format: "int64",
    },
    isColumnBreak: {
        baseName: "is_column_break",
        type: "boolean",
    },
    width: {
        baseName: "width",
        type: "number",
        required: true,
        format: "int64",
    },
    x: {
        baseName: "x",
        type: "number",
        required: true,
        format: "int64",
    },
    y: {
        baseName: "y",
        type: "number",
        required: true,
        format: "int64",
    },
};
//# sourceMappingURL=WidgetLayout.js.map

/***/ }),

/***/ 35484:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WidgetMarker = void 0;
/**
 * Markers allow you to add visual conditional formatting for your graphs.
 */
class WidgetMarker {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return WidgetMarker.attributeTypeMap;
    }
}
exports.WidgetMarker = WidgetMarker;
/**
 * @ignore
 */
WidgetMarker.attributeTypeMap = {
    displayType: {
        baseName: "display_type",
        type: "string",
    },
    label: {
        baseName: "label",
        type: "string",
    },
    time: {
        baseName: "time",
        type: "string",
    },
    value: {
        baseName: "value",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=WidgetMarker.js.map

/***/ }),

/***/ 87457:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WidgetRequestStyle = void 0;
/**
 * Define request widget style.
 */
class WidgetRequestStyle {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return WidgetRequestStyle.attributeTypeMap;
    }
}
exports.WidgetRequestStyle = WidgetRequestStyle;
/**
 * @ignore
 */
WidgetRequestStyle.attributeTypeMap = {
    lineType: {
        baseName: "line_type",
        type: "WidgetLineType",
    },
    lineWidth: {
        baseName: "line_width",
        type: "WidgetLineWidth",
    },
    palette: {
        baseName: "palette",
        type: "string",
    },
};
//# sourceMappingURL=WidgetRequestStyle.js.map

/***/ }),

/***/ 49795:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WidgetStyle = void 0;
/**
 * Widget style definition.
 */
class WidgetStyle {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return WidgetStyle.attributeTypeMap;
    }
}
exports.WidgetStyle = WidgetStyle;
/**
 * @ignore
 */
WidgetStyle.attributeTypeMap = {
    palette: {
        baseName: "palette",
        type: "string",
    },
};
//# sourceMappingURL=WidgetStyle.js.map

/***/ }),

/***/ 39079:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WidgetTime = void 0;
/**
 * Time setting for the widget.
 */
class WidgetTime {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return WidgetTime.attributeTypeMap;
    }
}
exports.WidgetTime = WidgetTime;
/**
 * @ignore
 */
WidgetTime.attributeTypeMap = {
    liveSpan: {
        baseName: "live_span",
        type: "WidgetLiveSpan",
    },
};
//# sourceMappingURL=WidgetTime.js.map

/***/ }),

/***/ 65768:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuditApi = exports.AuditApiResponseProcessor = exports.AuditApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
const AuditLogsQueryPageOptions_1 = __webpack_require__(46706);
const AuditLogsSearchEventsRequest_1 = __webpack_require__(52614);
class AuditApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    listAuditLogs(filterQuery, filterFrom, filterTo, sort, pageCursor, pageLimit, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/audit/events";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.AuditApi.listAuditLogs").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (filterQuery !== undefined) {
                requestContext.setQueryParam("filter[query]", ObjectSerializer_1.ObjectSerializer.serialize(filterQuery, "string", ""));
            }
            if (filterFrom !== undefined) {
                requestContext.setQueryParam("filter[from]", ObjectSerializer_1.ObjectSerializer.serialize(filterFrom, "Date", "date-time"));
            }
            if (filterTo !== undefined) {
                requestContext.setQueryParam("filter[to]", ObjectSerializer_1.ObjectSerializer.serialize(filterTo, "Date", "date-time"));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "AuditLogsSort", ""));
            }
            if (pageCursor !== undefined) {
                requestContext.setQueryParam("page[cursor]", ObjectSerializer_1.ObjectSerializer.serialize(pageCursor, "string", ""));
            }
            if (pageLimit !== undefined) {
                requestContext.setQueryParam("page[limit]", ObjectSerializer_1.ObjectSerializer.serialize(pageLimit, "number", "int32"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    searchAuditLogs(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/audit/events/search";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.AuditApi.searchAuditLogs").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "AuditLogsSearchEventsRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.AuditApiRequestFactory = AuditApiRequestFactory;
class AuditApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listAuditLogs
     * @throws ApiException if the response code was not in [200, 299]
     */
    listAuditLogs(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AuditLogsEventsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AuditLogsEventsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to searchAuditLogs
     * @throws ApiException if the response code was not in [200, 299]
     */
    searchAuditLogs(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AuditLogsEventsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AuditLogsEventsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.AuditApiResponseProcessor = AuditApiResponseProcessor;
class AuditApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new AuditApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new AuditApiResponseProcessor();
    }
    /**
     * List endpoint returns events that match a Audit Logs search query.
     * [Results are paginated][1].
     *
     * Use this endpoint to see your latest Audit Logs events.
     *
     * [1]: https://docs.datadoghq.com/logs/guide/collect-multiple-logs-with-pagination
     * @param param The request object
     */
    listAuditLogs(param = {}, options) {
        const requestContextPromise = this.requestFactory.listAuditLogs(param.filterQuery, param.filterFrom, param.filterTo, param.sort, param.pageCursor, param.pageLimit, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listAuditLogs(responseContext);
            });
        });
    }
    /**
     * Provide a paginated version of listAuditLogs returning a generator with all the items.
     */
    listAuditLogsWithPagination(param = {}, options) {
        return __asyncGenerator(this, arguments, function* listAuditLogsWithPagination_1() {
            let pageSize = 10;
            if (param.pageLimit !== undefined) {
                pageSize = param.pageLimit;
            }
            param.pageLimit = pageSize;
            while (true) {
                const requestContext = yield __await(this.requestFactory.listAuditLogs(param.filterQuery, param.filterFrom, param.filterTo, param.sort, param.pageCursor, param.pageLimit, options));
                const responseContext = yield __await(this.configuration.httpApi.send(requestContext));
                const response = yield __await(this.responseProcessor.listAuditLogs(responseContext));
                const responseData = response.data;
                if (responseData === undefined) {
                    break;
                }
                const results = responseData;
                for (const item of results) {
                    yield yield __await(item);
                }
                if (results.length < pageSize) {
                    break;
                }
                const cursorMeta = response.meta;
                if (cursorMeta === undefined) {
                    break;
                }
                const cursorMetaPage = cursorMeta.page;
                if (cursorMetaPage === undefined) {
                    break;
                }
                const cursorMetaPageAfter = cursorMetaPage.after;
                if (cursorMetaPageAfter === undefined) {
                    break;
                }
                param.pageCursor = cursorMetaPageAfter;
            }
        });
    }
    /**
     * List endpoint returns Audit Logs events that match an Audit search query.
     * [Results are paginated][1].
     *
     * Use this endpoint to build complex Audit Logs events filtering and search.
     *
     * [1]: https://docs.datadoghq.com/logs/guide/collect-multiple-logs-with-pagination
     * @param param The request object
     */
    searchAuditLogs(param = {}, options) {
        const requestContextPromise = this.requestFactory.searchAuditLogs(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.searchAuditLogs(responseContext);
            });
        });
    }
    /**
     * Provide a paginated version of searchAuditLogs returning a generator with all the items.
     */
    searchAuditLogsWithPagination(param = {}, options) {
        return __asyncGenerator(this, arguments, function* searchAuditLogsWithPagination_1() {
            let pageSize = 10;
            if (param.body === undefined) {
                param.body = new AuditLogsSearchEventsRequest_1.AuditLogsSearchEventsRequest();
            }
            if (param.body.page === undefined) {
                param.body.page = new AuditLogsQueryPageOptions_1.AuditLogsQueryPageOptions();
            }
            if (param.body.page.limit !== undefined) {
                pageSize = param.body.page.limit;
            }
            param.body.page.limit = pageSize;
            while (true) {
                const requestContext = yield __await(this.requestFactory.searchAuditLogs(param.body, options));
                const responseContext = yield __await(this.configuration.httpApi.send(requestContext));
                const response = yield __await(this.responseProcessor.searchAuditLogs(responseContext));
                const responseData = response.data;
                if (responseData === undefined) {
                    break;
                }
                const results = responseData;
                for (const item of results) {
                    yield yield __await(item);
                }
                if (results.length < pageSize) {
                    break;
                }
                const cursorMeta = response.meta;
                if (cursorMeta === undefined) {
                    break;
                }
                const cursorMetaPage = cursorMeta.page;
                if (cursorMetaPage === undefined) {
                    break;
                }
                const cursorMetaPageAfter = cursorMetaPage.after;
                if (cursorMetaPageAfter === undefined) {
                    break;
                }
                param.body.page.cursor = cursorMetaPageAfter;
            }
        });
    }
}
exports.AuditApi = AuditApi;
//# sourceMappingURL=AuditApi.js.map

/***/ }),

/***/ 36121:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthNMappingsApi = exports.AuthNMappingsApiResponseProcessor = exports.AuthNMappingsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class AuthNMappingsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createAuthNMapping(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createAuthNMapping");
            }
            // Path Params
            const localVarPath = "/api/v2/authn_mappings";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.AuthNMappingsApi.createAuthNMapping").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "AuthNMappingCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteAuthNMapping(authnMappingId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'authnMappingId' is not null or undefined
            if (authnMappingId === null || authnMappingId === undefined) {
                throw new baseapi_1.RequiredError("authnMappingId", "deleteAuthNMapping");
            }
            // Path Params
            const localVarPath = "/api/v2/authn_mappings/{authn_mapping_id}".replace("{authn_mapping_id}", encodeURIComponent(String(authnMappingId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.AuthNMappingsApi.deleteAuthNMapping").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getAuthNMapping(authnMappingId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'authnMappingId' is not null or undefined
            if (authnMappingId === null || authnMappingId === undefined) {
                throw new baseapi_1.RequiredError("authnMappingId", "getAuthNMapping");
            }
            // Path Params
            const localVarPath = "/api/v2/authn_mappings/{authn_mapping_id}".replace("{authn_mapping_id}", encodeURIComponent(String(authnMappingId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.AuthNMappingsApi.getAuthNMapping").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listAuthNMappings(pageSize, pageNumber, sort, filter, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/authn_mappings";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.AuthNMappingsApi.listAuthNMappings").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page[size]", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "number", "int64"));
            }
            if (pageNumber !== undefined) {
                requestContext.setQueryParam("page[number]", ObjectSerializer_1.ObjectSerializer.serialize(pageNumber, "number", "int64"));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "AuthNMappingsSort", ""));
            }
            if (filter !== undefined) {
                requestContext.setQueryParam("filter", ObjectSerializer_1.ObjectSerializer.serialize(filter, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateAuthNMapping(authnMappingId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'authnMappingId' is not null or undefined
            if (authnMappingId === null || authnMappingId === undefined) {
                throw new baseapi_1.RequiredError("authnMappingId", "updateAuthNMapping");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateAuthNMapping");
            }
            // Path Params
            const localVarPath = "/api/v2/authn_mappings/{authn_mapping_id}".replace("{authn_mapping_id}", encodeURIComponent(String(authnMappingId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.AuthNMappingsApi.updateAuthNMapping").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "AuthNMappingUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.AuthNMappingsApiRequestFactory = AuthNMappingsApiRequestFactory;
class AuthNMappingsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createAuthNMapping
     * @throws ApiException if the response code was not in [200, 299]
     */
    createAuthNMapping(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AuthNMappingResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AuthNMappingResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteAuthNMapping
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteAuthNMapping(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAuthNMapping
     * @throws ApiException if the response code was not in [200, 299]
     */
    getAuthNMapping(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AuthNMappingResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AuthNMappingResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listAuthNMappings
     * @throws ApiException if the response code was not in [200, 299]
     */
    listAuthNMappings(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AuthNMappingsResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AuthNMappingsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateAuthNMapping
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateAuthNMapping(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AuthNMappingResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 409 ||
                response.httpStatusCode == 422 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "AuthNMappingResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.AuthNMappingsApiResponseProcessor = AuthNMappingsApiResponseProcessor;
class AuthNMappingsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new AuthNMappingsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new AuthNMappingsApiResponseProcessor();
    }
    /**
     * Create an AuthN Mapping.
     * @param param The request object
     */
    createAuthNMapping(param, options) {
        const requestContextPromise = this.requestFactory.createAuthNMapping(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createAuthNMapping(responseContext);
            });
        });
    }
    /**
     * Delete an AuthN Mapping specified by AuthN Mapping UUID.
     * @param param The request object
     */
    deleteAuthNMapping(param, options) {
        const requestContextPromise = this.requestFactory.deleteAuthNMapping(param.authnMappingId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteAuthNMapping(responseContext);
            });
        });
    }
    /**
     * Get an AuthN Mapping specified by the AuthN Mapping UUID.
     * @param param The request object
     */
    getAuthNMapping(param, options) {
        const requestContextPromise = this.requestFactory.getAuthNMapping(param.authnMappingId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getAuthNMapping(responseContext);
            });
        });
    }
    /**
     * List all AuthN Mappings in the org.
     * @param param The request object
     */
    listAuthNMappings(param = {}, options) {
        const requestContextPromise = this.requestFactory.listAuthNMappings(param.pageSize, param.pageNumber, param.sort, param.filter, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listAuthNMappings(responseContext);
            });
        });
    }
    /**
     * Edit an AuthN Mapping.
     * @param param The request object
     */
    updateAuthNMapping(param, options) {
        const requestContextPromise = this.requestFactory.updateAuthNMapping(param.authnMappingId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateAuthNMapping(responseContext);
            });
        });
    }
}
exports.AuthNMappingsApi = AuthNMappingsApi;
//# sourceMappingURL=AuthNMappingsApi.js.map

/***/ }),

/***/ 8704:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIVisibilityPipelinesApi = exports.CIVisibilityPipelinesApiResponseProcessor = exports.CIVisibilityPipelinesApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
const CIAppPipelineEventsRequest_1 = __webpack_require__(7634);
const CIAppQueryPageOptions_1 = __webpack_require__(89457);
class CIVisibilityPipelinesApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    aggregateCIAppPipelineEvents(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "aggregateCIAppPipelineEvents");
            }
            // Path Params
            const localVarPath = "/api/v2/ci/pipelines/analytics/aggregate";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.CIVisibilityPipelinesApi.aggregateCIAppPipelineEvents").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "CIAppPipelinesAggregateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listCIAppPipelineEvents(filterQuery, filterFrom, filterTo, sort, pageCursor, pageLimit, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/ci/pipelines/events";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.CIVisibilityPipelinesApi.listCIAppPipelineEvents").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (filterQuery !== undefined) {
                requestContext.setQueryParam("filter[query]", ObjectSerializer_1.ObjectSerializer.serialize(filterQuery, "string", ""));
            }
            if (filterFrom !== undefined) {
                requestContext.setQueryParam("filter[from]", ObjectSerializer_1.ObjectSerializer.serialize(filterFrom, "Date", "date-time"));
            }
            if (filterTo !== undefined) {
                requestContext.setQueryParam("filter[to]", ObjectSerializer_1.ObjectSerializer.serialize(filterTo, "Date", "date-time"));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "CIAppSort", ""));
            }
            if (pageCursor !== undefined) {
                requestContext.setQueryParam("page[cursor]", ObjectSerializer_1.ObjectSerializer.serialize(pageCursor, "string", ""));
            }
            if (pageLimit !== undefined) {
                requestContext.setQueryParam("page[limit]", ObjectSerializer_1.ObjectSerializer.serialize(pageLimit, "number", "int32"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    searchCIAppPipelineEvents(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/ci/pipelines/events/search";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.CIVisibilityPipelinesApi.searchCIAppPipelineEvents").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "CIAppPipelineEventsRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.CIVisibilityPipelinesApiRequestFactory = CIVisibilityPipelinesApiRequestFactory;
class CIVisibilityPipelinesApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to aggregateCIAppPipelineEvents
     * @throws ApiException if the response code was not in [200, 299]
     */
    aggregateCIAppPipelineEvents(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CIAppPipelinesAnalyticsAggregateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CIAppPipelinesAnalyticsAggregateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listCIAppPipelineEvents
     * @throws ApiException if the response code was not in [200, 299]
     */
    listCIAppPipelineEvents(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CIAppPipelineEventsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CIAppPipelineEventsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to searchCIAppPipelineEvents
     * @throws ApiException if the response code was not in [200, 299]
     */
    searchCIAppPipelineEvents(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CIAppPipelineEventsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CIAppPipelineEventsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.CIVisibilityPipelinesApiResponseProcessor = CIVisibilityPipelinesApiResponseProcessor;
class CIVisibilityPipelinesApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory ||
                new CIVisibilityPipelinesApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new CIVisibilityPipelinesApiResponseProcessor();
    }
    /**
     * The API endpoint to aggregate CI Visibility pipeline events into buckets of computed metrics and timeseries.
     * @param param The request object
     */
    aggregateCIAppPipelineEvents(param, options) {
        const requestContextPromise = this.requestFactory.aggregateCIAppPipelineEvents(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.aggregateCIAppPipelineEvents(responseContext);
            });
        });
    }
    /**
     * List endpoint returns CI Visibility pipeline events that match a log search query.
     * [Results are paginated similarly to logs](https://docs.datadoghq.com/logs/guide/collect-multiple-logs-with-pagination).
     *
     * Use this endpoint to see your latest pipeline events.
     * @param param The request object
     */
    listCIAppPipelineEvents(param = {}, options) {
        const requestContextPromise = this.requestFactory.listCIAppPipelineEvents(param.filterQuery, param.filterFrom, param.filterTo, param.sort, param.pageCursor, param.pageLimit, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listCIAppPipelineEvents(responseContext);
            });
        });
    }
    /**
     * Provide a paginated version of listCIAppPipelineEvents returning a generator with all the items.
     */
    listCIAppPipelineEventsWithPagination(param = {}, options) {
        return __asyncGenerator(this, arguments, function* listCIAppPipelineEventsWithPagination_1() {
            let pageSize = 10;
            if (param.pageLimit !== undefined) {
                pageSize = param.pageLimit;
            }
            param.pageLimit = pageSize;
            while (true) {
                const requestContext = yield __await(this.requestFactory.listCIAppPipelineEvents(param.filterQuery, param.filterFrom, param.filterTo, param.sort, param.pageCursor, param.pageLimit, options));
                const responseContext = yield __await(this.configuration.httpApi.send(requestContext));
                const response = yield __await(this.responseProcessor.listCIAppPipelineEvents(responseContext));
                const responseData = response.data;
                if (responseData === undefined) {
                    break;
                }
                const results = responseData;
                for (const item of results) {
                    yield yield __await(item);
                }
                if (results.length < pageSize) {
                    break;
                }
                const cursorMeta = response.meta;
                if (cursorMeta === undefined) {
                    break;
                }
                const cursorMetaPage = cursorMeta.page;
                if (cursorMetaPage === undefined) {
                    break;
                }
                const cursorMetaPageAfter = cursorMetaPage.after;
                if (cursorMetaPageAfter === undefined) {
                    break;
                }
                param.pageCursor = cursorMetaPageAfter;
            }
        });
    }
    /**
     * List endpoint returns CI Visibility pipeline events that match a log search query.
     * [Results are paginated similarly to logs](https://docs.datadoghq.com/logs/guide/collect-multiple-logs-with-pagination).
     *
     * Use this endpoint to build complex events filtering and search.
     * @param param The request object
     */
    searchCIAppPipelineEvents(param = {}, options) {
        const requestContextPromise = this.requestFactory.searchCIAppPipelineEvents(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.searchCIAppPipelineEvents(responseContext);
            });
        });
    }
    /**
     * Provide a paginated version of searchCIAppPipelineEvents returning a generator with all the items.
     */
    searchCIAppPipelineEventsWithPagination(param = {}, options) {
        return __asyncGenerator(this, arguments, function* searchCIAppPipelineEventsWithPagination_1() {
            let pageSize = 10;
            if (param.body === undefined) {
                param.body = new CIAppPipelineEventsRequest_1.CIAppPipelineEventsRequest();
            }
            if (param.body.page === undefined) {
                param.body.page = new CIAppQueryPageOptions_1.CIAppQueryPageOptions();
            }
            if (param.body.page.limit !== undefined) {
                pageSize = param.body.page.limit;
            }
            param.body.page.limit = pageSize;
            while (true) {
                const requestContext = yield __await(this.requestFactory.searchCIAppPipelineEvents(param.body, options));
                const responseContext = yield __await(this.configuration.httpApi.send(requestContext));
                const response = yield __await(this.responseProcessor.searchCIAppPipelineEvents(responseContext));
                const responseData = response.data;
                if (responseData === undefined) {
                    break;
                }
                const results = responseData;
                for (const item of results) {
                    yield yield __await(item);
                }
                if (results.length < pageSize) {
                    break;
                }
                const cursorMeta = response.meta;
                if (cursorMeta === undefined) {
                    break;
                }
                const cursorMetaPage = cursorMeta.page;
                if (cursorMetaPage === undefined) {
                    break;
                }
                const cursorMetaPageAfter = cursorMetaPage.after;
                if (cursorMetaPageAfter === undefined) {
                    break;
                }
                param.body.page.cursor = cursorMetaPageAfter;
            }
        });
    }
}
exports.CIVisibilityPipelinesApi = CIVisibilityPipelinesApi;
//# sourceMappingURL=CIVisibilityPipelinesApi.js.map

/***/ }),

/***/ 56061:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIVisibilityTestsApi = exports.CIVisibilityTestsApiResponseProcessor = exports.CIVisibilityTestsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
const CIAppQueryPageOptions_1 = __webpack_require__(89457);
const CIAppTestEventsRequest_1 = __webpack_require__(94731);
class CIVisibilityTestsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    aggregateCIAppTestEvents(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "aggregateCIAppTestEvents");
            }
            // Path Params
            const localVarPath = "/api/v2/ci/tests/analytics/aggregate";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.CIVisibilityTestsApi.aggregateCIAppTestEvents").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "CIAppTestsAggregateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listCIAppTestEvents(filterQuery, filterFrom, filterTo, sort, pageCursor, pageLimit, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/ci/tests/events";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.CIVisibilityTestsApi.listCIAppTestEvents").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (filterQuery !== undefined) {
                requestContext.setQueryParam("filter[query]", ObjectSerializer_1.ObjectSerializer.serialize(filterQuery, "string", ""));
            }
            if (filterFrom !== undefined) {
                requestContext.setQueryParam("filter[from]", ObjectSerializer_1.ObjectSerializer.serialize(filterFrom, "Date", "date-time"));
            }
            if (filterTo !== undefined) {
                requestContext.setQueryParam("filter[to]", ObjectSerializer_1.ObjectSerializer.serialize(filterTo, "Date", "date-time"));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "CIAppSort", ""));
            }
            if (pageCursor !== undefined) {
                requestContext.setQueryParam("page[cursor]", ObjectSerializer_1.ObjectSerializer.serialize(pageCursor, "string", ""));
            }
            if (pageLimit !== undefined) {
                requestContext.setQueryParam("page[limit]", ObjectSerializer_1.ObjectSerializer.serialize(pageLimit, "number", "int32"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    searchCIAppTestEvents(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/ci/tests/events/search";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.CIVisibilityTestsApi.searchCIAppTestEvents").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "CIAppTestEventsRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.CIVisibilityTestsApiRequestFactory = CIVisibilityTestsApiRequestFactory;
class CIVisibilityTestsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to aggregateCIAppTestEvents
     * @throws ApiException if the response code was not in [200, 299]
     */
    aggregateCIAppTestEvents(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CIAppTestsAnalyticsAggregateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CIAppTestsAnalyticsAggregateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listCIAppTestEvents
     * @throws ApiException if the response code was not in [200, 299]
     */
    listCIAppTestEvents(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CIAppTestEventsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CIAppTestEventsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to searchCIAppTestEvents
     * @throws ApiException if the response code was not in [200, 299]
     */
    searchCIAppTestEvents(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CIAppTestEventsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CIAppTestEventsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.CIVisibilityTestsApiResponseProcessor = CIVisibilityTestsApiResponseProcessor;
class CIVisibilityTestsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new CIVisibilityTestsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new CIVisibilityTestsApiResponseProcessor();
    }
    /**
     * The API endpoint to aggregate CI Visibility test events into buckets of computed metrics and timeseries.
     * @param param The request object
     */
    aggregateCIAppTestEvents(param, options) {
        const requestContextPromise = this.requestFactory.aggregateCIAppTestEvents(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.aggregateCIAppTestEvents(responseContext);
            });
        });
    }
    /**
     * List endpoint returns CI Visibility test events that match a log search query.
     * [Results are paginated similarly to logs](https://docs.datadoghq.com/logs/guide/collect-multiple-logs-with-pagination).
     *
     * Use this endpoint to see your latest test events.
     * @param param The request object
     */
    listCIAppTestEvents(param = {}, options) {
        const requestContextPromise = this.requestFactory.listCIAppTestEvents(param.filterQuery, param.filterFrom, param.filterTo, param.sort, param.pageCursor, param.pageLimit, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listCIAppTestEvents(responseContext);
            });
        });
    }
    /**
     * Provide a paginated version of listCIAppTestEvents returning a generator with all the items.
     */
    listCIAppTestEventsWithPagination(param = {}, options) {
        return __asyncGenerator(this, arguments, function* listCIAppTestEventsWithPagination_1() {
            let pageSize = 10;
            if (param.pageLimit !== undefined) {
                pageSize = param.pageLimit;
            }
            param.pageLimit = pageSize;
            while (true) {
                const requestContext = yield __await(this.requestFactory.listCIAppTestEvents(param.filterQuery, param.filterFrom, param.filterTo, param.sort, param.pageCursor, param.pageLimit, options));
                const responseContext = yield __await(this.configuration.httpApi.send(requestContext));
                const response = yield __await(this.responseProcessor.listCIAppTestEvents(responseContext));
                const responseData = response.data;
                if (responseData === undefined) {
                    break;
                }
                const results = responseData;
                for (const item of results) {
                    yield yield __await(item);
                }
                if (results.length < pageSize) {
                    break;
                }
                const cursorMeta = response.meta;
                if (cursorMeta === undefined) {
                    break;
                }
                const cursorMetaPage = cursorMeta.page;
                if (cursorMetaPage === undefined) {
                    break;
                }
                const cursorMetaPageAfter = cursorMetaPage.after;
                if (cursorMetaPageAfter === undefined) {
                    break;
                }
                param.pageCursor = cursorMetaPageAfter;
            }
        });
    }
    /**
     * List endpoint returns CI Visibility test events that match a log search query.
     * [Results are paginated similarly to logs](https://docs.datadoghq.com/logs/guide/collect-multiple-logs-with-pagination).
     *
     * Use this endpoint to build complex events filtering and search.
     * @param param The request object
     */
    searchCIAppTestEvents(param = {}, options) {
        const requestContextPromise = this.requestFactory.searchCIAppTestEvents(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.searchCIAppTestEvents(responseContext);
            });
        });
    }
    /**
     * Provide a paginated version of searchCIAppTestEvents returning a generator with all the items.
     */
    searchCIAppTestEventsWithPagination(param = {}, options) {
        return __asyncGenerator(this, arguments, function* searchCIAppTestEventsWithPagination_1() {
            let pageSize = 10;
            if (param.body === undefined) {
                param.body = new CIAppTestEventsRequest_1.CIAppTestEventsRequest();
            }
            if (param.body.page === undefined) {
                param.body.page = new CIAppQueryPageOptions_1.CIAppQueryPageOptions();
            }
            if (param.body.page.limit !== undefined) {
                pageSize = param.body.page.limit;
            }
            param.body.page.limit = pageSize;
            while (true) {
                const requestContext = yield __await(this.requestFactory.searchCIAppTestEvents(param.body, options));
                const responseContext = yield __await(this.configuration.httpApi.send(requestContext));
                const response = yield __await(this.responseProcessor.searchCIAppTestEvents(responseContext));
                const responseData = response.data;
                if (responseData === undefined) {
                    break;
                }
                const results = responseData;
                for (const item of results) {
                    yield yield __await(item);
                }
                if (results.length < pageSize) {
                    break;
                }
                const cursorMeta = response.meta;
                if (cursorMeta === undefined) {
                    break;
                }
                const cursorMetaPage = cursorMeta.page;
                if (cursorMetaPage === undefined) {
                    break;
                }
                const cursorMetaPageAfter = cursorMetaPage.after;
                if (cursorMetaPageAfter === undefined) {
                    break;
                }
                param.body.page.cursor = cursorMetaPageAfter;
            }
        });
    }
}
exports.CIVisibilityTestsApi = CIVisibilityTestsApi;
//# sourceMappingURL=CIVisibilityTestsApi.js.map

/***/ }),

/***/ 42023:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudWorkloadSecurityApi = exports.CloudWorkloadSecurityApiResponseProcessor = exports.CloudWorkloadSecurityApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class CloudWorkloadSecurityApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createCloudWorkloadSecurityAgentRule(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createCloudWorkloadSecurityAgentRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/cloud_workload_security/agent_rules";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.CloudWorkloadSecurityApi.createCloudWorkloadSecurityAgentRule").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "CloudWorkloadSecurityAgentRuleCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteCloudWorkloadSecurityAgentRule(agentRuleId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'agentRuleId' is not null or undefined
            if (agentRuleId === null || agentRuleId === undefined) {
                throw new baseapi_1.RequiredError("agentRuleId", "deleteCloudWorkloadSecurityAgentRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/cloud_workload_security/agent_rules/{agent_rule_id}".replace("{agent_rule_id}", encodeURIComponent(String(agentRuleId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.CloudWorkloadSecurityApi.deleteCloudWorkloadSecurityAgentRule").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    downloadCloudWorkloadPolicyFile(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/security/cloud_workload/policy/download";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.CloudWorkloadSecurityApi.downloadCloudWorkloadPolicyFile").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/yaml, application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getCloudWorkloadSecurityAgentRule(agentRuleId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'agentRuleId' is not null or undefined
            if (agentRuleId === null || agentRuleId === undefined) {
                throw new baseapi_1.RequiredError("agentRuleId", "getCloudWorkloadSecurityAgentRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/cloud_workload_security/agent_rules/{agent_rule_id}".replace("{agent_rule_id}", encodeURIComponent(String(agentRuleId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.CloudWorkloadSecurityApi.getCloudWorkloadSecurityAgentRule").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listCloudWorkloadSecurityAgentRules(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/cloud_workload_security/agent_rules";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.CloudWorkloadSecurityApi.listCloudWorkloadSecurityAgentRules").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateCloudWorkloadSecurityAgentRule(agentRuleId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'agentRuleId' is not null or undefined
            if (agentRuleId === null || agentRuleId === undefined) {
                throw new baseapi_1.RequiredError("agentRuleId", "updateCloudWorkloadSecurityAgentRule");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateCloudWorkloadSecurityAgentRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/cloud_workload_security/agent_rules/{agent_rule_id}".replace("{agent_rule_id}", encodeURIComponent(String(agentRuleId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.CloudWorkloadSecurityApi.updateCloudWorkloadSecurityAgentRule").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "CloudWorkloadSecurityAgentRuleUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.CloudWorkloadSecurityApiRequestFactory = CloudWorkloadSecurityApiRequestFactory;
class CloudWorkloadSecurityApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createCloudWorkloadSecurityAgentRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    createCloudWorkloadSecurityAgentRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CloudWorkloadSecurityAgentRuleResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 409 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CloudWorkloadSecurityAgentRuleResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteCloudWorkloadSecurityAgentRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteCloudWorkloadSecurityAgentRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to downloadCloudWorkloadPolicyFile
     * @throws ApiException if the response code was not in [200, 299]
     */
    downloadCloudWorkloadPolicyFile(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = (yield response.getBodyAsFile());
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = (yield response.getBodyAsFile());
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getCloudWorkloadSecurityAgentRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    getCloudWorkloadSecurityAgentRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CloudWorkloadSecurityAgentRuleResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CloudWorkloadSecurityAgentRuleResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listCloudWorkloadSecurityAgentRules
     * @throws ApiException if the response code was not in [200, 299]
     */
    listCloudWorkloadSecurityAgentRules(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CloudWorkloadSecurityAgentRulesListResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CloudWorkloadSecurityAgentRulesListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateCloudWorkloadSecurityAgentRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateCloudWorkloadSecurityAgentRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CloudWorkloadSecurityAgentRuleResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 409 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CloudWorkloadSecurityAgentRuleResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.CloudWorkloadSecurityApiResponseProcessor = CloudWorkloadSecurityApiResponseProcessor;
class CloudWorkloadSecurityApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory ||
                new CloudWorkloadSecurityApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new CloudWorkloadSecurityApiResponseProcessor();
    }
    /**
     * Create a new Agent rule with the given parameters.
     * @param param The request object
     */
    createCloudWorkloadSecurityAgentRule(param, options) {
        const requestContextPromise = this.requestFactory.createCloudWorkloadSecurityAgentRule(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createCloudWorkloadSecurityAgentRule(responseContext);
            });
        });
    }
    /**
     * Delete a specific Agent rule.
     * @param param The request object
     */
    deleteCloudWorkloadSecurityAgentRule(param, options) {
        const requestContextPromise = this.requestFactory.deleteCloudWorkloadSecurityAgentRule(param.agentRuleId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteCloudWorkloadSecurityAgentRule(responseContext);
            });
        });
    }
    /**
     * The download endpoint generates a Cloud Workload Security policy file from your currently active
     * Cloud Workload Security rules, and downloads them as a .policy file. This file can then be deployed to
     * your Agents to update the policy running in your environment.
     * @param param The request object
     */
    downloadCloudWorkloadPolicyFile(options) {
        const requestContextPromise = this.requestFactory.downloadCloudWorkloadPolicyFile(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.downloadCloudWorkloadPolicyFile(responseContext);
            });
        });
    }
    /**
     * Get the details of a specific Agent rule.
     * @param param The request object
     */
    getCloudWorkloadSecurityAgentRule(param, options) {
        const requestContextPromise = this.requestFactory.getCloudWorkloadSecurityAgentRule(param.agentRuleId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getCloudWorkloadSecurityAgentRule(responseContext);
            });
        });
    }
    /**
     * Get the list of Agent rules.
     * @param param The request object
     */
    listCloudWorkloadSecurityAgentRules(options) {
        const requestContextPromise = this.requestFactory.listCloudWorkloadSecurityAgentRules(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listCloudWorkloadSecurityAgentRules(responseContext);
            });
        });
    }
    /**
     * Update a specific Agent rule.
     * Returns the Agent rule object when the request is successful.
     * @param param The request object
     */
    updateCloudWorkloadSecurityAgentRule(param, options) {
        const requestContextPromise = this.requestFactory.updateCloudWorkloadSecurityAgentRule(param.agentRuleId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateCloudWorkloadSecurityAgentRule(responseContext);
            });
        });
    }
}
exports.CloudWorkloadSecurityApi = CloudWorkloadSecurityApi;
//# sourceMappingURL=CloudWorkloadSecurityApi.js.map

/***/ }),

/***/ 22819:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudflareIntegrationApi = exports.CloudflareIntegrationApiResponseProcessor = exports.CloudflareIntegrationApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class CloudflareIntegrationApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createCloudflareAccount(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createCloudflareAccount");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/cloudflare/accounts";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.CloudflareIntegrationApi.createCloudflareAccount").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "CloudflareAccountCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteCloudflareAccount(accountId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new baseapi_1.RequiredError("accountId", "deleteCloudflareAccount");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/cloudflare/accounts/{account_id}".replace("{account_id}", encodeURIComponent(String(accountId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.CloudflareIntegrationApi.deleteCloudflareAccount").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getCloudflareAccount(accountId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new baseapi_1.RequiredError("accountId", "getCloudflareAccount");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/cloudflare/accounts/{account_id}".replace("{account_id}", encodeURIComponent(String(accountId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.CloudflareIntegrationApi.getCloudflareAccount").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listCloudflareAccounts(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/integrations/cloudflare/accounts";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.CloudflareIntegrationApi.listCloudflareAccounts").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateCloudflareAccount(accountId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new baseapi_1.RequiredError("accountId", "updateCloudflareAccount");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateCloudflareAccount");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/cloudflare/accounts/{account_id}".replace("{account_id}", encodeURIComponent(String(accountId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.CloudflareIntegrationApi.updateCloudflareAccount").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "CloudflareAccountUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.CloudflareIntegrationApiRequestFactory = CloudflareIntegrationApiRequestFactory;
class CloudflareIntegrationApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createCloudflareAccount
     * @throws ApiException if the response code was not in [200, 299]
     */
    createCloudflareAccount(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CloudflareAccountResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CloudflareAccountResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteCloudflareAccount
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteCloudflareAccount(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getCloudflareAccount
     * @throws ApiException if the response code was not in [200, 299]
     */
    getCloudflareAccount(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CloudflareAccountResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CloudflareAccountResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listCloudflareAccounts
     * @throws ApiException if the response code was not in [200, 299]
     */
    listCloudflareAccounts(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CloudflareAccountsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CloudflareAccountsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateCloudflareAccount
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateCloudflareAccount(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CloudflareAccountResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CloudflareAccountResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.CloudflareIntegrationApiResponseProcessor = CloudflareIntegrationApiResponseProcessor;
class CloudflareIntegrationApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory ||
                new CloudflareIntegrationApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new CloudflareIntegrationApiResponseProcessor();
    }
    /**
     * Create a Cloudflare account.
     * @param param The request object
     */
    createCloudflareAccount(param, options) {
        const requestContextPromise = this.requestFactory.createCloudflareAccount(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createCloudflareAccount(responseContext);
            });
        });
    }
    /**
     * Delete a Cloudflare account.
     * @param param The request object
     */
    deleteCloudflareAccount(param, options) {
        const requestContextPromise = this.requestFactory.deleteCloudflareAccount(param.accountId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteCloudflareAccount(responseContext);
            });
        });
    }
    /**
     * Get a Cloudflare account.
     * @param param The request object
     */
    getCloudflareAccount(param, options) {
        const requestContextPromise = this.requestFactory.getCloudflareAccount(param.accountId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getCloudflareAccount(responseContext);
            });
        });
    }
    /**
     * List Cloudflare accounts.
     * @param param The request object
     */
    listCloudflareAccounts(options) {
        const requestContextPromise = this.requestFactory.listCloudflareAccounts(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listCloudflareAccounts(responseContext);
            });
        });
    }
    /**
     * Update a Cloudflare account.
     * @param param The request object
     */
    updateCloudflareAccount(param, options) {
        const requestContextPromise = this.requestFactory.updateCloudflareAccount(param.accountId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateCloudflareAccount(responseContext);
            });
        });
    }
}
exports.CloudflareIntegrationApi = CloudflareIntegrationApi;
//# sourceMappingURL=CloudflareIntegrationApi.js.map

/***/ }),

/***/ 85828:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfluentCloudApi = exports.ConfluentCloudApiResponseProcessor = exports.ConfluentCloudApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class ConfluentCloudApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createConfluentAccount(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createConfluentAccount");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/confluent-cloud/accounts";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ConfluentCloudApi.createConfluentAccount").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "ConfluentAccountCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createConfluentResource(accountId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new baseapi_1.RequiredError("accountId", "createConfluentResource");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createConfluentResource");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/confluent-cloud/accounts/{account_id}/resources".replace("{account_id}", encodeURIComponent(String(accountId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ConfluentCloudApi.createConfluentResource").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "ConfluentResourceRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteConfluentAccount(accountId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new baseapi_1.RequiredError("accountId", "deleteConfluentAccount");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/confluent-cloud/accounts/{account_id}".replace("{account_id}", encodeURIComponent(String(accountId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ConfluentCloudApi.deleteConfluentAccount").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteConfluentResource(accountId, resourceId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new baseapi_1.RequiredError("accountId", "deleteConfluentResource");
            }
            // verify required parameter 'resourceId' is not null or undefined
            if (resourceId === null || resourceId === undefined) {
                throw new baseapi_1.RequiredError("resourceId", "deleteConfluentResource");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/confluent-cloud/accounts/{account_id}/resources/{resource_id}"
                .replace("{account_id}", encodeURIComponent(String(accountId)))
                .replace("{resource_id}", encodeURIComponent(String(resourceId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ConfluentCloudApi.deleteConfluentResource").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getConfluentAccount(accountId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new baseapi_1.RequiredError("accountId", "getConfluentAccount");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/confluent-cloud/accounts/{account_id}".replace("{account_id}", encodeURIComponent(String(accountId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ConfluentCloudApi.getConfluentAccount").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getConfluentResource(accountId, resourceId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new baseapi_1.RequiredError("accountId", "getConfluentResource");
            }
            // verify required parameter 'resourceId' is not null or undefined
            if (resourceId === null || resourceId === undefined) {
                throw new baseapi_1.RequiredError("resourceId", "getConfluentResource");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/confluent-cloud/accounts/{account_id}/resources/{resource_id}"
                .replace("{account_id}", encodeURIComponent(String(accountId)))
                .replace("{resource_id}", encodeURIComponent(String(resourceId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ConfluentCloudApi.getConfluentResource").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listConfluentAccount(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/integrations/confluent-cloud/accounts";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ConfluentCloudApi.listConfluentAccount").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listConfluentResource(accountId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new baseapi_1.RequiredError("accountId", "listConfluentResource");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/confluent-cloud/accounts/{account_id}/resources".replace("{account_id}", encodeURIComponent(String(accountId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ConfluentCloudApi.listConfluentResource").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateConfluentAccount(accountId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new baseapi_1.RequiredError("accountId", "updateConfluentAccount");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateConfluentAccount");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/confluent-cloud/accounts/{account_id}".replace("{account_id}", encodeURIComponent(String(accountId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ConfluentCloudApi.updateConfluentAccount").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "ConfluentAccountUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateConfluentResource(accountId, resourceId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new baseapi_1.RequiredError("accountId", "updateConfluentResource");
            }
            // verify required parameter 'resourceId' is not null or undefined
            if (resourceId === null || resourceId === undefined) {
                throw new baseapi_1.RequiredError("resourceId", "updateConfluentResource");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateConfluentResource");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/confluent-cloud/accounts/{account_id}/resources/{resource_id}"
                .replace("{account_id}", encodeURIComponent(String(accountId)))
                .replace("{resource_id}", encodeURIComponent(String(resourceId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ConfluentCloudApi.updateConfluentResource").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "ConfluentResourceRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.ConfluentCloudApiRequestFactory = ConfluentCloudApiRequestFactory;
class ConfluentCloudApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createConfluentAccount
     * @throws ApiException if the response code was not in [200, 299]
     */
    createConfluentAccount(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ConfluentAccountResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ConfluentAccountResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createConfluentResource
     * @throws ApiException if the response code was not in [200, 299]
     */
    createConfluentResource(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ConfluentResourceResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ConfluentResourceResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteConfluentAccount
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteConfluentAccount(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteConfluentResource
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteConfluentResource(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getConfluentAccount
     * @throws ApiException if the response code was not in [200, 299]
     */
    getConfluentAccount(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ConfluentAccountResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ConfluentAccountResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getConfluentResource
     * @throws ApiException if the response code was not in [200, 299]
     */
    getConfluentResource(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ConfluentResourceResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ConfluentResourceResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listConfluentAccount
     * @throws ApiException if the response code was not in [200, 299]
     */
    listConfluentAccount(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ConfluentAccountsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ConfluentAccountsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listConfluentResource
     * @throws ApiException if the response code was not in [200, 299]
     */
    listConfluentResource(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ConfluentResourcesResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ConfluentResourcesResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateConfluentAccount
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateConfluentAccount(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ConfluentAccountResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ConfluentAccountResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateConfluentResource
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateConfluentResource(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ConfluentResourceResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ConfluentResourceResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.ConfluentCloudApiResponseProcessor = ConfluentCloudApiResponseProcessor;
class ConfluentCloudApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new ConfluentCloudApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new ConfluentCloudApiResponseProcessor();
    }
    /**
     * Create a Confluent account.
     * @param param The request object
     */
    createConfluentAccount(param, options) {
        const requestContextPromise = this.requestFactory.createConfluentAccount(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createConfluentAccount(responseContext);
            });
        });
    }
    /**
     * Create a Confluent resource for the account associated with the provided ID.
     * @param param The request object
     */
    createConfluentResource(param, options) {
        const requestContextPromise = this.requestFactory.createConfluentResource(param.accountId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createConfluentResource(responseContext);
            });
        });
    }
    /**
     * Delete a Confluent account with the provided account ID.
     * @param param The request object
     */
    deleteConfluentAccount(param, options) {
        const requestContextPromise = this.requestFactory.deleteConfluentAccount(param.accountId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteConfluentAccount(responseContext);
            });
        });
    }
    /**
     * Delete a Confluent resource with the provided resource id for the account associated with the provided account ID.
     * @param param The request object
     */
    deleteConfluentResource(param, options) {
        const requestContextPromise = this.requestFactory.deleteConfluentResource(param.accountId, param.resourceId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteConfluentResource(responseContext);
            });
        });
    }
    /**
     * Get the Confluent account with the provided account ID.
     * @param param The request object
     */
    getConfluentAccount(param, options) {
        const requestContextPromise = this.requestFactory.getConfluentAccount(param.accountId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getConfluentAccount(responseContext);
            });
        });
    }
    /**
     * Get a Confluent resource with the provided resource id for the account associated with the provided account ID.
     * @param param The request object
     */
    getConfluentResource(param, options) {
        const requestContextPromise = this.requestFactory.getConfluentResource(param.accountId, param.resourceId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getConfluentResource(responseContext);
            });
        });
    }
    /**
     * List Confluent accounts.
     * @param param The request object
     */
    listConfluentAccount(options) {
        const requestContextPromise = this.requestFactory.listConfluentAccount(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listConfluentAccount(responseContext);
            });
        });
    }
    /**
     * Get a Confluent resource for the account associated with the provided ID.
     * @param param The request object
     */
    listConfluentResource(param, options) {
        const requestContextPromise = this.requestFactory.listConfluentResource(param.accountId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listConfluentResource(responseContext);
            });
        });
    }
    /**
     * Update the Confluent account with the provided account ID.
     * @param param The request object
     */
    updateConfluentAccount(param, options) {
        const requestContextPromise = this.requestFactory.updateConfluentAccount(param.accountId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateConfluentAccount(responseContext);
            });
        });
    }
    /**
     * Update a Confluent resource with the provided resource id for the account associated with the provided account ID.
     * @param param The request object
     */
    updateConfluentResource(param, options) {
        const requestContextPromise = this.requestFactory.updateConfluentResource(param.accountId, param.resourceId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateConfluentResource(responseContext);
            });
        });
    }
}
exports.ConfluentCloudApi = ConfluentCloudApi;
//# sourceMappingURL=ConfluentCloudApi.js.map

/***/ }),

/***/ 50063:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardListsApi = exports.DashboardListsApiResponseProcessor = exports.DashboardListsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class DashboardListsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createDashboardListItems(dashboardListId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'dashboardListId' is not null or undefined
            if (dashboardListId === null || dashboardListId === undefined) {
                throw new baseapi_1.RequiredError("dashboardListId", "createDashboardListItems");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createDashboardListItems");
            }
            // Path Params
            const localVarPath = "/api/v2/dashboard/lists/manual/{dashboard_list_id}/dashboards".replace("{dashboard_list_id}", encodeURIComponent(String(dashboardListId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.DashboardListsApi.createDashboardListItems").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "DashboardListAddItemsRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteDashboardListItems(dashboardListId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'dashboardListId' is not null or undefined
            if (dashboardListId === null || dashboardListId === undefined) {
                throw new baseapi_1.RequiredError("dashboardListId", "deleteDashboardListItems");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "deleteDashboardListItems");
            }
            // Path Params
            const localVarPath = "/api/v2/dashboard/lists/manual/{dashboard_list_id}/dashboards".replace("{dashboard_list_id}", encodeURIComponent(String(dashboardListId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.DashboardListsApi.deleteDashboardListItems").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "DashboardListDeleteItemsRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getDashboardListItems(dashboardListId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'dashboardListId' is not null or undefined
            if (dashboardListId === null || dashboardListId === undefined) {
                throw new baseapi_1.RequiredError("dashboardListId", "getDashboardListItems");
            }
            // Path Params
            const localVarPath = "/api/v2/dashboard/lists/manual/{dashboard_list_id}/dashboards".replace("{dashboard_list_id}", encodeURIComponent(String(dashboardListId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.DashboardListsApi.getDashboardListItems").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateDashboardListItems(dashboardListId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'dashboardListId' is not null or undefined
            if (dashboardListId === null || dashboardListId === undefined) {
                throw new baseapi_1.RequiredError("dashboardListId", "updateDashboardListItems");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateDashboardListItems");
            }
            // Path Params
            const localVarPath = "/api/v2/dashboard/lists/manual/{dashboard_list_id}/dashboards".replace("{dashboard_list_id}", encodeURIComponent(String(dashboardListId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.DashboardListsApi.updateDashboardListItems").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "DashboardListUpdateItemsRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.DashboardListsApiRequestFactory = DashboardListsApiRequestFactory;
class DashboardListsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createDashboardListItems
     * @throws ApiException if the response code was not in [200, 299]
     */
    createDashboardListItems(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardListAddItemsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardListAddItemsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteDashboardListItems
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteDashboardListItems(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardListDeleteItemsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardListDeleteItemsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getDashboardListItems
     * @throws ApiException if the response code was not in [200, 299]
     */
    getDashboardListItems(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardListItems");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardListItems", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateDashboardListItems
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateDashboardListItems(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardListUpdateItemsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "DashboardListUpdateItemsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.DashboardListsApiResponseProcessor = DashboardListsApiResponseProcessor;
class DashboardListsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new DashboardListsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new DashboardListsApiResponseProcessor();
    }
    /**
     * Add dashboards to an existing dashboard list.
     * @param param The request object
     */
    createDashboardListItems(param, options) {
        const requestContextPromise = this.requestFactory.createDashboardListItems(param.dashboardListId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createDashboardListItems(responseContext);
            });
        });
    }
    /**
     * Delete dashboards from an existing dashboard list.
     * @param param The request object
     */
    deleteDashboardListItems(param, options) {
        const requestContextPromise = this.requestFactory.deleteDashboardListItems(param.dashboardListId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteDashboardListItems(responseContext);
            });
        });
    }
    /**
     * Fetch the dashboard lists dashboard definitions.
     * @param param The request object
     */
    getDashboardListItems(param, options) {
        const requestContextPromise = this.requestFactory.getDashboardListItems(param.dashboardListId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getDashboardListItems(responseContext);
            });
        });
    }
    /**
     * Update dashboards of an existing dashboard list.
     * @param param The request object
     */
    updateDashboardListItems(param, options) {
        const requestContextPromise = this.requestFactory.updateDashboardListItems(param.dashboardListId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateDashboardListItems(responseContext);
            });
        });
    }
}
exports.DashboardListsApi = DashboardListsApi;
//# sourceMappingURL=DashboardListsApi.js.map

/***/ }),

/***/ 8300:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventsApi = exports.EventsApiResponseProcessor = exports.EventsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
const EventsListRequest_1 = __webpack_require__(23754);
const EventsRequestPage_1 = __webpack_require__(57858);
class EventsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    listEvents(filterQuery, filterFrom, filterTo, sort, pageCursor, pageLimit, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'listEvents'");
            if (!_config.unstableOperations["v2.listEvents"]) {
                throw new Error("Unstable operation 'listEvents' is disabled");
            }
            // Path Params
            const localVarPath = "/api/v2/events";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.EventsApi.listEvents").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (filterQuery !== undefined) {
                requestContext.setQueryParam("filter[query]", ObjectSerializer_1.ObjectSerializer.serialize(filterQuery, "string", ""));
            }
            if (filterFrom !== undefined) {
                requestContext.setQueryParam("filter[from]", ObjectSerializer_1.ObjectSerializer.serialize(filterFrom, "string", ""));
            }
            if (filterTo !== undefined) {
                requestContext.setQueryParam("filter[to]", ObjectSerializer_1.ObjectSerializer.serialize(filterTo, "string", ""));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "EventsSort", ""));
            }
            if (pageCursor !== undefined) {
                requestContext.setQueryParam("page[cursor]", ObjectSerializer_1.ObjectSerializer.serialize(pageCursor, "string", ""));
            }
            if (pageLimit !== undefined) {
                requestContext.setQueryParam("page[limit]", ObjectSerializer_1.ObjectSerializer.serialize(pageLimit, "number", "int32"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    searchEvents(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'searchEvents'");
            if (!_config.unstableOperations["v2.searchEvents"]) {
                throw new Error("Unstable operation 'searchEvents' is disabled");
            }
            // Path Params
            const localVarPath = "/api/v2/events/search";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.EventsApi.searchEvents").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "EventsListRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.EventsApiRequestFactory = EventsApiRequestFactory;
class EventsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listEvents
     * @throws ApiException if the response code was not in [200, 299]
     */
    listEvents(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "EventsListResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "EventsListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to searchEvents
     * @throws ApiException if the response code was not in [200, 299]
     */
    searchEvents(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "EventsListResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "EventsListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.EventsApiResponseProcessor = EventsApiResponseProcessor;
class EventsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new EventsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new EventsApiResponseProcessor();
    }
    /**
     * List endpoint returns events that match an events search query.
     * [Results are paginated similarly to logs](https://docs.datadoghq.com/logs/guide/collect-multiple-logs-with-pagination).
     *
     * Use this endpoint to see your latest events.
     * @param param The request object
     */
    listEvents(param = {}, options) {
        const requestContextPromise = this.requestFactory.listEvents(param.filterQuery, param.filterFrom, param.filterTo, param.sort, param.pageCursor, param.pageLimit, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listEvents(responseContext);
            });
        });
    }
    /**
     * Provide a paginated version of listEvents returning a generator with all the items.
     */
    listEventsWithPagination(param = {}, options) {
        return __asyncGenerator(this, arguments, function* listEventsWithPagination_1() {
            let pageSize = 10;
            if (param.pageLimit !== undefined) {
                pageSize = param.pageLimit;
            }
            param.pageLimit = pageSize;
            while (true) {
                const requestContext = yield __await(this.requestFactory.listEvents(param.filterQuery, param.filterFrom, param.filterTo, param.sort, param.pageCursor, param.pageLimit, options));
                const responseContext = yield __await(this.configuration.httpApi.send(requestContext));
                const response = yield __await(this.responseProcessor.listEvents(responseContext));
                const responseData = response.data;
                if (responseData === undefined) {
                    break;
                }
                const results = responseData;
                for (const item of results) {
                    yield yield __await(item);
                }
                if (results.length < pageSize) {
                    break;
                }
                const cursorMeta = response.meta;
                if (cursorMeta === undefined) {
                    break;
                }
                const cursorMetaPage = cursorMeta.page;
                if (cursorMetaPage === undefined) {
                    break;
                }
                const cursorMetaPageAfter = cursorMetaPage.after;
                if (cursorMetaPageAfter === undefined) {
                    break;
                }
                param.pageCursor = cursorMetaPageAfter;
            }
        });
    }
    /**
     * List endpoint returns events that match an events search query.
     * [Results are paginated similarly to logs](https://docs.datadoghq.com/logs/guide/collect-multiple-logs-with-pagination).
     *
     * Use this endpoint to build complex events filtering and search.
     * @param param The request object
     */
    searchEvents(param = {}, options) {
        const requestContextPromise = this.requestFactory.searchEvents(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.searchEvents(responseContext);
            });
        });
    }
    /**
     * Provide a paginated version of searchEvents returning a generator with all the items.
     */
    searchEventsWithPagination(param = {}, options) {
        return __asyncGenerator(this, arguments, function* searchEventsWithPagination_1() {
            let pageSize = 10;
            if (param.body === undefined) {
                param.body = new EventsListRequest_1.EventsListRequest();
            }
            if (param.body.page === undefined) {
                param.body.page = new EventsRequestPage_1.EventsRequestPage();
            }
            if (param.body.page.limit !== undefined) {
                pageSize = param.body.page.limit;
            }
            param.body.page.limit = pageSize;
            while (true) {
                const requestContext = yield __await(this.requestFactory.searchEvents(param.body, options));
                const responseContext = yield __await(this.configuration.httpApi.send(requestContext));
                const response = yield __await(this.responseProcessor.searchEvents(responseContext));
                const responseData = response.data;
                if (responseData === undefined) {
                    break;
                }
                const results = responseData;
                for (const item of results) {
                    yield yield __await(item);
                }
                if (results.length < pageSize) {
                    break;
                }
                const cursorMeta = response.meta;
                if (cursorMeta === undefined) {
                    break;
                }
                const cursorMetaPage = cursorMeta.page;
                if (cursorMetaPage === undefined) {
                    break;
                }
                const cursorMetaPageAfter = cursorMetaPage.after;
                if (cursorMetaPageAfter === undefined) {
                    break;
                }
                param.body.page.cursor = cursorMetaPageAfter;
            }
        });
    }
}
exports.EventsApi = EventsApi;
//# sourceMappingURL=EventsApi.js.map

/***/ }),

/***/ 7349:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FastlyIntegrationApi = exports.FastlyIntegrationApiResponseProcessor = exports.FastlyIntegrationApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class FastlyIntegrationApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createFastlyAccount(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createFastlyAccount");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/fastly/accounts";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.FastlyIntegrationApi.createFastlyAccount").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "FastlyAccountCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createFastlyService(accountId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new baseapi_1.RequiredError("accountId", "createFastlyService");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createFastlyService");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/fastly/accounts/{account_id}/services".replace("{account_id}", encodeURIComponent(String(accountId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.FastlyIntegrationApi.createFastlyService").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "FastlyServiceRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteFastlyAccount(accountId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new baseapi_1.RequiredError("accountId", "deleteFastlyAccount");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/fastly/accounts/{account_id}".replace("{account_id}", encodeURIComponent(String(accountId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.FastlyIntegrationApi.deleteFastlyAccount").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteFastlyService(accountId, serviceId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new baseapi_1.RequiredError("accountId", "deleteFastlyService");
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new baseapi_1.RequiredError("serviceId", "deleteFastlyService");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/fastly/accounts/{account_id}/services/{service_id}"
                .replace("{account_id}", encodeURIComponent(String(accountId)))
                .replace("{service_id}", encodeURIComponent(String(serviceId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.FastlyIntegrationApi.deleteFastlyService").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getFastlyAccount(accountId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new baseapi_1.RequiredError("accountId", "getFastlyAccount");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/fastly/accounts/{account_id}".replace("{account_id}", encodeURIComponent(String(accountId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.FastlyIntegrationApi.getFastlyAccount").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getFastlyService(accountId, serviceId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new baseapi_1.RequiredError("accountId", "getFastlyService");
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new baseapi_1.RequiredError("serviceId", "getFastlyService");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/fastly/accounts/{account_id}/services/{service_id}"
                .replace("{account_id}", encodeURIComponent(String(accountId)))
                .replace("{service_id}", encodeURIComponent(String(serviceId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.FastlyIntegrationApi.getFastlyService").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listFastlyAccounts(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/integrations/fastly/accounts";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.FastlyIntegrationApi.listFastlyAccounts").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listFastlyServices(accountId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new baseapi_1.RequiredError("accountId", "listFastlyServices");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/fastly/accounts/{account_id}/services".replace("{account_id}", encodeURIComponent(String(accountId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.FastlyIntegrationApi.listFastlyServices").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateFastlyAccount(accountId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new baseapi_1.RequiredError("accountId", "updateFastlyAccount");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateFastlyAccount");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/fastly/accounts/{account_id}".replace("{account_id}", encodeURIComponent(String(accountId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.FastlyIntegrationApi.updateFastlyAccount").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "FastlyAccountUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateFastlyService(accountId, serviceId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new baseapi_1.RequiredError("accountId", "updateFastlyService");
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new baseapi_1.RequiredError("serviceId", "updateFastlyService");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateFastlyService");
            }
            // Path Params
            const localVarPath = "/api/v2/integrations/fastly/accounts/{account_id}/services/{service_id}"
                .replace("{account_id}", encodeURIComponent(String(accountId)))
                .replace("{service_id}", encodeURIComponent(String(serviceId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.FastlyIntegrationApi.updateFastlyService").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "FastlyServiceRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.FastlyIntegrationApiRequestFactory = FastlyIntegrationApiRequestFactory;
class FastlyIntegrationApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createFastlyAccount
     * @throws ApiException if the response code was not in [200, 299]
     */
    createFastlyAccount(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "FastlyAccountResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "FastlyAccountResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createFastlyService
     * @throws ApiException if the response code was not in [200, 299]
     */
    createFastlyService(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "FastlyServiceResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "FastlyServiceResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteFastlyAccount
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteFastlyAccount(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteFastlyService
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteFastlyService(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getFastlyAccount
     * @throws ApiException if the response code was not in [200, 299]
     */
    getFastlyAccount(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "FastlyAccountResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "FastlyAccountResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getFastlyService
     * @throws ApiException if the response code was not in [200, 299]
     */
    getFastlyService(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "FastlyServiceResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "FastlyServiceResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listFastlyAccounts
     * @throws ApiException if the response code was not in [200, 299]
     */
    listFastlyAccounts(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "FastlyAccountsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "FastlyAccountsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listFastlyServices
     * @throws ApiException if the response code was not in [200, 299]
     */
    listFastlyServices(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "FastlyServicesResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "FastlyServicesResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateFastlyAccount
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateFastlyAccount(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "FastlyAccountResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "FastlyAccountResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateFastlyService
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateFastlyService(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "FastlyServiceResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "FastlyServiceResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.FastlyIntegrationApiResponseProcessor = FastlyIntegrationApiResponseProcessor;
class FastlyIntegrationApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new FastlyIntegrationApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new FastlyIntegrationApiResponseProcessor();
    }
    /**
     * Create a Fastly account.
     * @param param The request object
     */
    createFastlyAccount(param, options) {
        const requestContextPromise = this.requestFactory.createFastlyAccount(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createFastlyAccount(responseContext);
            });
        });
    }
    /**
     * Create a Fastly service for an account.
     * @param param The request object
     */
    createFastlyService(param, options) {
        const requestContextPromise = this.requestFactory.createFastlyService(param.accountId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createFastlyService(responseContext);
            });
        });
    }
    /**
     * Delete a Fastly account.
     * @param param The request object
     */
    deleteFastlyAccount(param, options) {
        const requestContextPromise = this.requestFactory.deleteFastlyAccount(param.accountId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteFastlyAccount(responseContext);
            });
        });
    }
    /**
     * Delete a Fastly service for an account.
     * @param param The request object
     */
    deleteFastlyService(param, options) {
        const requestContextPromise = this.requestFactory.deleteFastlyService(param.accountId, param.serviceId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteFastlyService(responseContext);
            });
        });
    }
    /**
     * Get a Fastly account.
     * @param param The request object
     */
    getFastlyAccount(param, options) {
        const requestContextPromise = this.requestFactory.getFastlyAccount(param.accountId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getFastlyAccount(responseContext);
            });
        });
    }
    /**
     * Get a Fastly service for an account.
     * @param param The request object
     */
    getFastlyService(param, options) {
        const requestContextPromise = this.requestFactory.getFastlyService(param.accountId, param.serviceId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getFastlyService(responseContext);
            });
        });
    }
    /**
     * List Fastly accounts.
     * @param param The request object
     */
    listFastlyAccounts(options) {
        const requestContextPromise = this.requestFactory.listFastlyAccounts(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listFastlyAccounts(responseContext);
            });
        });
    }
    /**
     * List Fastly services for an account.
     * @param param The request object
     */
    listFastlyServices(param, options) {
        const requestContextPromise = this.requestFactory.listFastlyServices(param.accountId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listFastlyServices(responseContext);
            });
        });
    }
    /**
     * Update a Fastly account.
     * @param param The request object
     */
    updateFastlyAccount(param, options) {
        const requestContextPromise = this.requestFactory.updateFastlyAccount(param.accountId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateFastlyAccount(responseContext);
            });
        });
    }
    /**
     * Update a Fastly service for an account.
     * @param param The request object
     */
    updateFastlyService(param, options) {
        const requestContextPromise = this.requestFactory.updateFastlyService(param.accountId, param.serviceId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateFastlyService(responseContext);
            });
        });
    }
}
exports.FastlyIntegrationApi = FastlyIntegrationApi;
//# sourceMappingURL=FastlyIntegrationApi.js.map

/***/ }),

/***/ 6990:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentServicesApi = exports.IncidentServicesApiResponseProcessor = exports.IncidentServicesApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class IncidentServicesApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createIncidentService(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'createIncidentService'");
            if (!_config.unstableOperations["v2.createIncidentService"]) {
                throw new Error("Unstable operation 'createIncidentService' is disabled");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createIncidentService");
            }
            // Path Params
            const localVarPath = "/api/v2/services";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentServicesApi.createIncidentService").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "IncidentServiceCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteIncidentService(serviceId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'deleteIncidentService'");
            if (!_config.unstableOperations["v2.deleteIncidentService"]) {
                throw new Error("Unstable operation 'deleteIncidentService' is disabled");
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new baseapi_1.RequiredError("serviceId", "deleteIncidentService");
            }
            // Path Params
            const localVarPath = "/api/v2/services/{service_id}".replace("{service_id}", encodeURIComponent(String(serviceId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentServicesApi.deleteIncidentService").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getIncidentService(serviceId, include, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'getIncidentService'");
            if (!_config.unstableOperations["v2.getIncidentService"]) {
                throw new Error("Unstable operation 'getIncidentService' is disabled");
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new baseapi_1.RequiredError("serviceId", "getIncidentService");
            }
            // Path Params
            const localVarPath = "/api/v2/services/{service_id}".replace("{service_id}", encodeURIComponent(String(serviceId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentServicesApi.getIncidentService").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (include !== undefined) {
                requestContext.setQueryParam("include", ObjectSerializer_1.ObjectSerializer.serialize(include, "IncidentRelatedObject", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listIncidentServices(include, pageSize, pageOffset, filter, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'listIncidentServices'");
            if (!_config.unstableOperations["v2.listIncidentServices"]) {
                throw new Error("Unstable operation 'listIncidentServices' is disabled");
            }
            // Path Params
            const localVarPath = "/api/v2/services";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentServicesApi.listIncidentServices").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (include !== undefined) {
                requestContext.setQueryParam("include", ObjectSerializer_1.ObjectSerializer.serialize(include, "IncidentRelatedObject", ""));
            }
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page[size]", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "number", "int64"));
            }
            if (pageOffset !== undefined) {
                requestContext.setQueryParam("page[offset]", ObjectSerializer_1.ObjectSerializer.serialize(pageOffset, "number", "int64"));
            }
            if (filter !== undefined) {
                requestContext.setQueryParam("filter", ObjectSerializer_1.ObjectSerializer.serialize(filter, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateIncidentService(serviceId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'updateIncidentService'");
            if (!_config.unstableOperations["v2.updateIncidentService"]) {
                throw new Error("Unstable operation 'updateIncidentService' is disabled");
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new baseapi_1.RequiredError("serviceId", "updateIncidentService");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateIncidentService");
            }
            // Path Params
            const localVarPath = "/api/v2/services/{service_id}".replace("{service_id}", encodeURIComponent(String(serviceId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentServicesApi.updateIncidentService").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "IncidentServiceUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.IncidentServicesApiRequestFactory = IncidentServicesApiRequestFactory;
class IncidentServicesApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createIncidentService
     * @throws ApiException if the response code was not in [200, 299]
     */
    createIncidentService(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentServiceResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentServiceResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteIncidentService
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteIncidentService(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getIncidentService
     * @throws ApiException if the response code was not in [200, 299]
     */
    getIncidentService(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentServiceResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentServiceResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listIncidentServices
     * @throws ApiException if the response code was not in [200, 299]
     */
    listIncidentServices(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentServicesResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentServicesResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateIncidentService
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateIncidentService(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentServiceResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentServiceResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.IncidentServicesApiResponseProcessor = IncidentServicesApiResponseProcessor;
class IncidentServicesApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new IncidentServicesApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new IncidentServicesApiResponseProcessor();
    }
    /**
     * Creates a new incident service.
     * @param param The request object
     */
    createIncidentService(param, options) {
        const requestContextPromise = this.requestFactory.createIncidentService(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createIncidentService(responseContext);
            });
        });
    }
    /**
     * Deletes an existing incident service.
     * @param param The request object
     */
    deleteIncidentService(param, options) {
        const requestContextPromise = this.requestFactory.deleteIncidentService(param.serviceId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteIncidentService(responseContext);
            });
        });
    }
    /**
     * Get details of an incident service. If the `include[users]` query parameter is provided,
     * the included attribute will contain the users related to these incident services.
     * @param param The request object
     */
    getIncidentService(param, options) {
        const requestContextPromise = this.requestFactory.getIncidentService(param.serviceId, param.include, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getIncidentService(responseContext);
            });
        });
    }
    /**
     * Get all incident services uploaded for the requesting user's organization. If the `include[users]` query parameter is provided, the included attribute will contain the users related to these incident services.
     * @param param The request object
     */
    listIncidentServices(param = {}, options) {
        const requestContextPromise = this.requestFactory.listIncidentServices(param.include, param.pageSize, param.pageOffset, param.filter, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listIncidentServices(responseContext);
            });
        });
    }
    /**
     * Updates an existing incident service. Only provide the attributes which should be updated as this request is a partial update.
     * @param param The request object
     */
    updateIncidentService(param, options) {
        const requestContextPromise = this.requestFactory.updateIncidentService(param.serviceId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateIncidentService(responseContext);
            });
        });
    }
}
exports.IncidentServicesApi = IncidentServicesApi;
//# sourceMappingURL=IncidentServicesApi.js.map

/***/ }),

/***/ 97201:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentTeamsApi = exports.IncidentTeamsApiResponseProcessor = exports.IncidentTeamsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class IncidentTeamsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createIncidentTeam(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'createIncidentTeam'");
            if (!_config.unstableOperations["v2.createIncidentTeam"]) {
                throw new Error("Unstable operation 'createIncidentTeam' is disabled");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createIncidentTeam");
            }
            // Path Params
            const localVarPath = "/api/v2/teams";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentTeamsApi.createIncidentTeam").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "IncidentTeamCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteIncidentTeam(teamId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'deleteIncidentTeam'");
            if (!_config.unstableOperations["v2.deleteIncidentTeam"]) {
                throw new Error("Unstable operation 'deleteIncidentTeam' is disabled");
            }
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new baseapi_1.RequiredError("teamId", "deleteIncidentTeam");
            }
            // Path Params
            const localVarPath = "/api/v2/teams/{team_id}".replace("{team_id}", encodeURIComponent(String(teamId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentTeamsApi.deleteIncidentTeam").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getIncidentTeam(teamId, include, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'getIncidentTeam'");
            if (!_config.unstableOperations["v2.getIncidentTeam"]) {
                throw new Error("Unstable operation 'getIncidentTeam' is disabled");
            }
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new baseapi_1.RequiredError("teamId", "getIncidentTeam");
            }
            // Path Params
            const localVarPath = "/api/v2/teams/{team_id}".replace("{team_id}", encodeURIComponent(String(teamId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentTeamsApi.getIncidentTeam").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (include !== undefined) {
                requestContext.setQueryParam("include", ObjectSerializer_1.ObjectSerializer.serialize(include, "IncidentRelatedObject", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listIncidentTeams(include, pageSize, pageOffset, filter, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'listIncidentTeams'");
            if (!_config.unstableOperations["v2.listIncidentTeams"]) {
                throw new Error("Unstable operation 'listIncidentTeams' is disabled");
            }
            // Path Params
            const localVarPath = "/api/v2/teams";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentTeamsApi.listIncidentTeams").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (include !== undefined) {
                requestContext.setQueryParam("include", ObjectSerializer_1.ObjectSerializer.serialize(include, "IncidentRelatedObject", ""));
            }
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page[size]", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "number", "int64"));
            }
            if (pageOffset !== undefined) {
                requestContext.setQueryParam("page[offset]", ObjectSerializer_1.ObjectSerializer.serialize(pageOffset, "number", "int64"));
            }
            if (filter !== undefined) {
                requestContext.setQueryParam("filter", ObjectSerializer_1.ObjectSerializer.serialize(filter, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateIncidentTeam(teamId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'updateIncidentTeam'");
            if (!_config.unstableOperations["v2.updateIncidentTeam"]) {
                throw new Error("Unstable operation 'updateIncidentTeam' is disabled");
            }
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new baseapi_1.RequiredError("teamId", "updateIncidentTeam");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateIncidentTeam");
            }
            // Path Params
            const localVarPath = "/api/v2/teams/{team_id}".replace("{team_id}", encodeURIComponent(String(teamId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentTeamsApi.updateIncidentTeam").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "IncidentTeamUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.IncidentTeamsApiRequestFactory = IncidentTeamsApiRequestFactory;
class IncidentTeamsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createIncidentTeam
     * @throws ApiException if the response code was not in [200, 299]
     */
    createIncidentTeam(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentTeamResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentTeamResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteIncidentTeam
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteIncidentTeam(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getIncidentTeam
     * @throws ApiException if the response code was not in [200, 299]
     */
    getIncidentTeam(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentTeamResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentTeamResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listIncidentTeams
     * @throws ApiException if the response code was not in [200, 299]
     */
    listIncidentTeams(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentTeamsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentTeamsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateIncidentTeam
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateIncidentTeam(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentTeamResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentTeamResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.IncidentTeamsApiResponseProcessor = IncidentTeamsApiResponseProcessor;
class IncidentTeamsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new IncidentTeamsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new IncidentTeamsApiResponseProcessor();
    }
    /**
     * Creates a new incident team.
     * @param param The request object
     */
    createIncidentTeam(param, options) {
        const requestContextPromise = this.requestFactory.createIncidentTeam(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createIncidentTeam(responseContext);
            });
        });
    }
    /**
     * Deletes an existing incident team.
     * @param param The request object
     */
    deleteIncidentTeam(param, options) {
        const requestContextPromise = this.requestFactory.deleteIncidentTeam(param.teamId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteIncidentTeam(responseContext);
            });
        });
    }
    /**
     * Get details of an incident team. If the `include[users]` query parameter is provided,
     * the included attribute will contain the users related to these incident teams.
     * @param param The request object
     */
    getIncidentTeam(param, options) {
        const requestContextPromise = this.requestFactory.getIncidentTeam(param.teamId, param.include, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getIncidentTeam(responseContext);
            });
        });
    }
    /**
     * Get all incident teams for the requesting user's organization. If the `include[users]` query parameter is provided, the included attribute will contain the users related to these incident teams.
     * @param param The request object
     */
    listIncidentTeams(param = {}, options) {
        const requestContextPromise = this.requestFactory.listIncidentTeams(param.include, param.pageSize, param.pageOffset, param.filter, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listIncidentTeams(responseContext);
            });
        });
    }
    /**
     * Updates an existing incident team. Only provide the attributes which should be updated as this request is a partial update.
     * @param param The request object
     */
    updateIncidentTeam(param, options) {
        const requestContextPromise = this.requestFactory.updateIncidentTeam(param.teamId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateIncidentTeam(responseContext);
            });
        });
    }
}
exports.IncidentTeamsApi = IncidentTeamsApi;
//# sourceMappingURL=IncidentTeamsApi.js.map

/***/ }),

/***/ 9580:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentsApi = exports.IncidentsApiResponseProcessor = exports.IncidentsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class IncidentsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createIncident(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'createIncident'");
            if (!_config.unstableOperations["v2.createIncident"]) {
                throw new Error("Unstable operation 'createIncident' is disabled");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createIncident");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.createIncident").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "IncidentCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteIncident(incidentId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'deleteIncident'");
            if (!_config.unstableOperations["v2.deleteIncident"]) {
                throw new Error("Unstable operation 'deleteIncident' is disabled");
            }
            // verify required parameter 'incidentId' is not null or undefined
            if (incidentId === null || incidentId === undefined) {
                throw new baseapi_1.RequiredError("incidentId", "deleteIncident");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents/{incident_id}".replace("{incident_id}", encodeURIComponent(String(incidentId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.deleteIncident").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getIncident(incidentId, include, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'getIncident'");
            if (!_config.unstableOperations["v2.getIncident"]) {
                throw new Error("Unstable operation 'getIncident' is disabled");
            }
            // verify required parameter 'incidentId' is not null or undefined
            if (incidentId === null || incidentId === undefined) {
                throw new baseapi_1.RequiredError("incidentId", "getIncident");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents/{incident_id}".replace("{incident_id}", encodeURIComponent(String(incidentId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.getIncident").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (include !== undefined) {
                requestContext.setQueryParam("include", ObjectSerializer_1.ObjectSerializer.serialize(include, "Array<IncidentRelatedObject>", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listIncidentAttachments(incidentId, include, filterAttachmentType, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'listIncidentAttachments'");
            if (!_config.unstableOperations["v2.listIncidentAttachments"]) {
                throw new Error("Unstable operation 'listIncidentAttachments' is disabled");
            }
            // verify required parameter 'incidentId' is not null or undefined
            if (incidentId === null || incidentId === undefined) {
                throw new baseapi_1.RequiredError("incidentId", "listIncidentAttachments");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents/{incident_id}/attachments".replace("{incident_id}", encodeURIComponent(String(incidentId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.listIncidentAttachments").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (include !== undefined) {
                requestContext.setQueryParam("include", ObjectSerializer_1.ObjectSerializer.serialize(include, "Array<IncidentAttachmentRelatedObject>", ""));
            }
            if (filterAttachmentType !== undefined) {
                requestContext.setQueryParam("filter[attachment_type]", ObjectSerializer_1.ObjectSerializer.serialize(filterAttachmentType, "Array<IncidentAttachmentAttachmentType>", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listIncidents(include, pageSize, pageOffset, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'listIncidents'");
            if (!_config.unstableOperations["v2.listIncidents"]) {
                throw new Error("Unstable operation 'listIncidents' is disabled");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.listIncidents").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (include !== undefined) {
                requestContext.setQueryParam("include", ObjectSerializer_1.ObjectSerializer.serialize(include, "Array<IncidentRelatedObject>", ""));
            }
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page[size]", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "number", "int64"));
            }
            if (pageOffset !== undefined) {
                requestContext.setQueryParam("page[offset]", ObjectSerializer_1.ObjectSerializer.serialize(pageOffset, "number", "int64"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    searchIncidents(query, include, sort, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'searchIncidents'");
            if (!_config.unstableOperations["v2.searchIncidents"]) {
                throw new Error("Unstable operation 'searchIncidents' is disabled");
            }
            // verify required parameter 'query' is not null or undefined
            if (query === null || query === undefined) {
                throw new baseapi_1.RequiredError("query", "searchIncidents");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents/search";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.searchIncidents").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (include !== undefined) {
                requestContext.setQueryParam("include", ObjectSerializer_1.ObjectSerializer.serialize(include, "IncidentRelatedObject", ""));
            }
            if (query !== undefined) {
                requestContext.setQueryParam("query", ObjectSerializer_1.ObjectSerializer.serialize(query, "string", ""));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "IncidentSearchSortOrder", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateIncident(incidentId, body, include, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'updateIncident'");
            if (!_config.unstableOperations["v2.updateIncident"]) {
                throw new Error("Unstable operation 'updateIncident' is disabled");
            }
            // verify required parameter 'incidentId' is not null or undefined
            if (incidentId === null || incidentId === undefined) {
                throw new baseapi_1.RequiredError("incidentId", "updateIncident");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateIncident");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents/{incident_id}".replace("{incident_id}", encodeURIComponent(String(incidentId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.updateIncident").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (include !== undefined) {
                requestContext.setQueryParam("include", ObjectSerializer_1.ObjectSerializer.serialize(include, "Array<IncidentRelatedObject>", ""));
            }
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "IncidentUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateIncidentAttachments(incidentId, body, include, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'updateIncidentAttachments'");
            if (!_config.unstableOperations["v2.updateIncidentAttachments"]) {
                throw new Error("Unstable operation 'updateIncidentAttachments' is disabled");
            }
            // verify required parameter 'incidentId' is not null or undefined
            if (incidentId === null || incidentId === undefined) {
                throw new baseapi_1.RequiredError("incidentId", "updateIncidentAttachments");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateIncidentAttachments");
            }
            // Path Params
            const localVarPath = "/api/v2/incidents/{incident_id}/attachments".replace("{incident_id}", encodeURIComponent(String(incidentId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.IncidentsApi.updateIncidentAttachments").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (include !== undefined) {
                requestContext.setQueryParam("include", ObjectSerializer_1.ObjectSerializer.serialize(include, "Array<IncidentAttachmentRelatedObject>", ""));
            }
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "IncidentAttachmentUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.IncidentsApiRequestFactory = IncidentsApiRequestFactory;
class IncidentsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createIncident
     * @throws ApiException if the response code was not in [200, 299]
     */
    createIncident(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteIncident
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteIncident(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getIncident
     * @throws ApiException if the response code was not in [200, 299]
     */
    getIncident(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listIncidentAttachments
     * @throws ApiException if the response code was not in [200, 299]
     */
    listIncidentAttachments(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentAttachmentsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentAttachmentsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listIncidents
     * @throws ApiException if the response code was not in [200, 299]
     */
    listIncidents(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to searchIncidents
     * @throws ApiException if the response code was not in [200, 299]
     */
    searchIncidents(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentSearchResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentSearchResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateIncident
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateIncident(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateIncidentAttachments
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateIncidentAttachments(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentAttachmentUpdateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IncidentAttachmentUpdateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.IncidentsApiResponseProcessor = IncidentsApiResponseProcessor;
class IncidentsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new IncidentsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new IncidentsApiResponseProcessor();
    }
    /**
     * Create an incident.
     * @param param The request object
     */
    createIncident(param, options) {
        const requestContextPromise = this.requestFactory.createIncident(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createIncident(responseContext);
            });
        });
    }
    /**
     * Deletes an existing incident from the users organization.
     * @param param The request object
     */
    deleteIncident(param, options) {
        const requestContextPromise = this.requestFactory.deleteIncident(param.incidentId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteIncident(responseContext);
            });
        });
    }
    /**
     * Get the details of an incident by `incident_id`.
     * @param param The request object
     */
    getIncident(param, options) {
        const requestContextPromise = this.requestFactory.getIncident(param.incidentId, param.include, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getIncident(responseContext);
            });
        });
    }
    /**
     * Get all attachments for a given incident.
     * @param param The request object
     */
    listIncidentAttachments(param, options) {
        const requestContextPromise = this.requestFactory.listIncidentAttachments(param.incidentId, param.include, param.filterAttachmentType, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listIncidentAttachments(responseContext);
            });
        });
    }
    /**
     * Get all incidents for the user's organization.
     * @param param The request object
     */
    listIncidents(param = {}, options) {
        const requestContextPromise = this.requestFactory.listIncidents(param.include, param.pageSize, param.pageOffset, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listIncidents(responseContext);
            });
        });
    }
    /**
     * Provide a paginated version of listIncidents returning a generator with all the items.
     */
    listIncidentsWithPagination(param = {}, options) {
        return __asyncGenerator(this, arguments, function* listIncidentsWithPagination_1() {
            let pageSize = 10;
            if (param.pageSize !== undefined) {
                pageSize = param.pageSize;
            }
            param.pageSize = pageSize;
            while (true) {
                const requestContext = yield __await(this.requestFactory.listIncidents(param.include, param.pageSize, param.pageOffset, options));
                const responseContext = yield __await(this.configuration.httpApi.send(requestContext));
                const response = yield __await(this.responseProcessor.listIncidents(responseContext));
                const responseData = response.data;
                if (responseData === undefined) {
                    break;
                }
                const results = responseData;
                for (const item of results) {
                    yield yield __await(item);
                }
                if (results.length < pageSize) {
                    break;
                }
                if (param.pageOffset === undefined) {
                    param.pageOffset = pageSize;
                }
                else {
                    param.pageOffset = param.pageOffset + pageSize;
                }
            }
        });
    }
    /**
     * Search for incidents matching a certain query.
     * @param param The request object
     */
    searchIncidents(param, options) {
        const requestContextPromise = this.requestFactory.searchIncidents(param.query, param.include, param.sort, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.searchIncidents(responseContext);
            });
        });
    }
    /**
     * Updates an incident. Provide only the attributes that should be updated as this request is a partial update.
     * @param param The request object
     */
    updateIncident(param, options) {
        const requestContextPromise = this.requestFactory.updateIncident(param.incidentId, param.body, param.include, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateIncident(responseContext);
            });
        });
    }
    /**
     * The bulk update endpoint for creating, updating, and deleting attachments for a given incident.
     * @param param The request object
     */
    updateIncidentAttachments(param, options) {
        const requestContextPromise = this.requestFactory.updateIncidentAttachments(param.incidentId, param.body, param.include, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateIncidentAttachments(responseContext);
            });
        });
    }
}
exports.IncidentsApi = IncidentsApi;
//# sourceMappingURL=IncidentsApi.js.map

/***/ }),

/***/ 95951:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeyManagementApi = exports.KeyManagementApiResponseProcessor = exports.KeyManagementApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class KeyManagementApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createAPIKey(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createAPIKey");
            }
            // Path Params
            const localVarPath = "/api/v2/api_keys";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.KeyManagementApi.createAPIKey").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "APIKeyCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createCurrentUserApplicationKey(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createCurrentUserApplicationKey");
            }
            // Path Params
            const localVarPath = "/api/v2/current_user/application_keys";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.KeyManagementApi.createCurrentUserApplicationKey").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "ApplicationKeyCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteAPIKey(apiKeyId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'apiKeyId' is not null or undefined
            if (apiKeyId === null || apiKeyId === undefined) {
                throw new baseapi_1.RequiredError("apiKeyId", "deleteAPIKey");
            }
            // Path Params
            const localVarPath = "/api/v2/api_keys/{api_key_id}".replace("{api_key_id}", encodeURIComponent(String(apiKeyId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.KeyManagementApi.deleteAPIKey").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteApplicationKey(appKeyId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'appKeyId' is not null or undefined
            if (appKeyId === null || appKeyId === undefined) {
                throw new baseapi_1.RequiredError("appKeyId", "deleteApplicationKey");
            }
            // Path Params
            const localVarPath = "/api/v2/application_keys/{app_key_id}".replace("{app_key_id}", encodeURIComponent(String(appKeyId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.KeyManagementApi.deleteApplicationKey").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteCurrentUserApplicationKey(appKeyId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'appKeyId' is not null or undefined
            if (appKeyId === null || appKeyId === undefined) {
                throw new baseapi_1.RequiredError("appKeyId", "deleteCurrentUserApplicationKey");
            }
            // Path Params
            const localVarPath = "/api/v2/current_user/application_keys/{app_key_id}".replace("{app_key_id}", encodeURIComponent(String(appKeyId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.KeyManagementApi.deleteCurrentUserApplicationKey").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getAPIKey(apiKeyId, include, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'apiKeyId' is not null or undefined
            if (apiKeyId === null || apiKeyId === undefined) {
                throw new baseapi_1.RequiredError("apiKeyId", "getAPIKey");
            }
            // Path Params
            const localVarPath = "/api/v2/api_keys/{api_key_id}".replace("{api_key_id}", encodeURIComponent(String(apiKeyId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.KeyManagementApi.getAPIKey").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (include !== undefined) {
                requestContext.setQueryParam("include", ObjectSerializer_1.ObjectSerializer.serialize(include, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getApplicationKey(appKeyId, include, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'appKeyId' is not null or undefined
            if (appKeyId === null || appKeyId === undefined) {
                throw new baseapi_1.RequiredError("appKeyId", "getApplicationKey");
            }
            // Path Params
            const localVarPath = "/api/v2/application_keys/{app_key_id}".replace("{app_key_id}", encodeURIComponent(String(appKeyId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.KeyManagementApi.getApplicationKey").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (include !== undefined) {
                requestContext.setQueryParam("include", ObjectSerializer_1.ObjectSerializer.serialize(include, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getCurrentUserApplicationKey(appKeyId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'appKeyId' is not null or undefined
            if (appKeyId === null || appKeyId === undefined) {
                throw new baseapi_1.RequiredError("appKeyId", "getCurrentUserApplicationKey");
            }
            // Path Params
            const localVarPath = "/api/v2/current_user/application_keys/{app_key_id}".replace("{app_key_id}", encodeURIComponent(String(appKeyId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.KeyManagementApi.getCurrentUserApplicationKey").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listAPIKeys(pageSize, pageNumber, sort, filter, filterCreatedAtStart, filterCreatedAtEnd, filterModifiedAtStart, filterModifiedAtEnd, include, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/api_keys";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.KeyManagementApi.listAPIKeys").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page[size]", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "number", "int64"));
            }
            if (pageNumber !== undefined) {
                requestContext.setQueryParam("page[number]", ObjectSerializer_1.ObjectSerializer.serialize(pageNumber, "number", "int64"));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "APIKeysSort", ""));
            }
            if (filter !== undefined) {
                requestContext.setQueryParam("filter", ObjectSerializer_1.ObjectSerializer.serialize(filter, "string", ""));
            }
            if (filterCreatedAtStart !== undefined) {
                requestContext.setQueryParam("filter[created_at][start]", ObjectSerializer_1.ObjectSerializer.serialize(filterCreatedAtStart, "string", ""));
            }
            if (filterCreatedAtEnd !== undefined) {
                requestContext.setQueryParam("filter[created_at][end]", ObjectSerializer_1.ObjectSerializer.serialize(filterCreatedAtEnd, "string", ""));
            }
            if (filterModifiedAtStart !== undefined) {
                requestContext.setQueryParam("filter[modified_at][start]", ObjectSerializer_1.ObjectSerializer.serialize(filterModifiedAtStart, "string", ""));
            }
            if (filterModifiedAtEnd !== undefined) {
                requestContext.setQueryParam("filter[modified_at][end]", ObjectSerializer_1.ObjectSerializer.serialize(filterModifiedAtEnd, "string", ""));
            }
            if (include !== undefined) {
                requestContext.setQueryParam("include", ObjectSerializer_1.ObjectSerializer.serialize(include, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listApplicationKeys(pageSize, pageNumber, sort, filter, filterCreatedAtStart, filterCreatedAtEnd, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/application_keys";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.KeyManagementApi.listApplicationKeys").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page[size]", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "number", "int64"));
            }
            if (pageNumber !== undefined) {
                requestContext.setQueryParam("page[number]", ObjectSerializer_1.ObjectSerializer.serialize(pageNumber, "number", "int64"));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "ApplicationKeysSort", ""));
            }
            if (filter !== undefined) {
                requestContext.setQueryParam("filter", ObjectSerializer_1.ObjectSerializer.serialize(filter, "string", ""));
            }
            if (filterCreatedAtStart !== undefined) {
                requestContext.setQueryParam("filter[created_at][start]", ObjectSerializer_1.ObjectSerializer.serialize(filterCreatedAtStart, "string", ""));
            }
            if (filterCreatedAtEnd !== undefined) {
                requestContext.setQueryParam("filter[created_at][end]", ObjectSerializer_1.ObjectSerializer.serialize(filterCreatedAtEnd, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listCurrentUserApplicationKeys(pageSize, pageNumber, sort, filter, filterCreatedAtStart, filterCreatedAtEnd, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/current_user/application_keys";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.KeyManagementApi.listCurrentUserApplicationKeys").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page[size]", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "number", "int64"));
            }
            if (pageNumber !== undefined) {
                requestContext.setQueryParam("page[number]", ObjectSerializer_1.ObjectSerializer.serialize(pageNumber, "number", "int64"));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "ApplicationKeysSort", ""));
            }
            if (filter !== undefined) {
                requestContext.setQueryParam("filter", ObjectSerializer_1.ObjectSerializer.serialize(filter, "string", ""));
            }
            if (filterCreatedAtStart !== undefined) {
                requestContext.setQueryParam("filter[created_at][start]", ObjectSerializer_1.ObjectSerializer.serialize(filterCreatedAtStart, "string", ""));
            }
            if (filterCreatedAtEnd !== undefined) {
                requestContext.setQueryParam("filter[created_at][end]", ObjectSerializer_1.ObjectSerializer.serialize(filterCreatedAtEnd, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateAPIKey(apiKeyId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'apiKeyId' is not null or undefined
            if (apiKeyId === null || apiKeyId === undefined) {
                throw new baseapi_1.RequiredError("apiKeyId", "updateAPIKey");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateAPIKey");
            }
            // Path Params
            const localVarPath = "/api/v2/api_keys/{api_key_id}".replace("{api_key_id}", encodeURIComponent(String(apiKeyId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.KeyManagementApi.updateAPIKey").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "APIKeyUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateApplicationKey(appKeyId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'appKeyId' is not null or undefined
            if (appKeyId === null || appKeyId === undefined) {
                throw new baseapi_1.RequiredError("appKeyId", "updateApplicationKey");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateApplicationKey");
            }
            // Path Params
            const localVarPath = "/api/v2/application_keys/{app_key_id}".replace("{app_key_id}", encodeURIComponent(String(appKeyId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.KeyManagementApi.updateApplicationKey").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "ApplicationKeyUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateCurrentUserApplicationKey(appKeyId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'appKeyId' is not null or undefined
            if (appKeyId === null || appKeyId === undefined) {
                throw new baseapi_1.RequiredError("appKeyId", "updateCurrentUserApplicationKey");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateCurrentUserApplicationKey");
            }
            // Path Params
            const localVarPath = "/api/v2/current_user/application_keys/{app_key_id}".replace("{app_key_id}", encodeURIComponent(String(appKeyId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.KeyManagementApi.updateCurrentUserApplicationKey").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "ApplicationKeyUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.KeyManagementApiRequestFactory = KeyManagementApiRequestFactory;
class KeyManagementApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createAPIKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    createAPIKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "APIKeyResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "APIKeyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createCurrentUserApplicationKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    createCurrentUserApplicationKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteAPIKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteAPIKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteApplicationKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteApplicationKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteCurrentUserApplicationKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteCurrentUserApplicationKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAPIKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    getAPIKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "APIKeyResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "APIKeyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getApplicationKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    getApplicationKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getCurrentUserApplicationKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    getCurrentUserApplicationKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listAPIKeys
     * @throws ApiException if the response code was not in [200, 299]
     */
    listAPIKeys(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "APIKeysResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "APIKeysResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listApplicationKeys
     * @throws ApiException if the response code was not in [200, 299]
     */
    listApplicationKeys(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ListApplicationKeysResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ListApplicationKeysResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listCurrentUserApplicationKeys
     * @throws ApiException if the response code was not in [200, 299]
     */
    listCurrentUserApplicationKeys(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ListApplicationKeysResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ListApplicationKeysResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateAPIKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateAPIKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "APIKeyResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "APIKeyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateApplicationKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateApplicationKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateCurrentUserApplicationKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateCurrentUserApplicationKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.KeyManagementApiResponseProcessor = KeyManagementApiResponseProcessor;
class KeyManagementApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new KeyManagementApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new KeyManagementApiResponseProcessor();
    }
    /**
     * Create an API key.
     * @param param The request object
     */
    createAPIKey(param, options) {
        const requestContextPromise = this.requestFactory.createAPIKey(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createAPIKey(responseContext);
            });
        });
    }
    /**
     * Create an application key for current user
     * @param param The request object
     */
    createCurrentUserApplicationKey(param, options) {
        const requestContextPromise = this.requestFactory.createCurrentUserApplicationKey(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createCurrentUserApplicationKey(responseContext);
            });
        });
    }
    /**
     * Delete an API key.
     * @param param The request object
     */
    deleteAPIKey(param, options) {
        const requestContextPromise = this.requestFactory.deleteAPIKey(param.apiKeyId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteAPIKey(responseContext);
            });
        });
    }
    /**
     * Delete an application key
     * @param param The request object
     */
    deleteApplicationKey(param, options) {
        const requestContextPromise = this.requestFactory.deleteApplicationKey(param.appKeyId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteApplicationKey(responseContext);
            });
        });
    }
    /**
     * Delete an application key owned by current user
     * @param param The request object
     */
    deleteCurrentUserApplicationKey(param, options) {
        const requestContextPromise = this.requestFactory.deleteCurrentUserApplicationKey(param.appKeyId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteCurrentUserApplicationKey(responseContext);
            });
        });
    }
    /**
     * Get an API key.
     * @param param The request object
     */
    getAPIKey(param, options) {
        const requestContextPromise = this.requestFactory.getAPIKey(param.apiKeyId, param.include, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getAPIKey(responseContext);
            });
        });
    }
    /**
     * Get an application key for your org.
     * @param param The request object
     */
    getApplicationKey(param, options) {
        const requestContextPromise = this.requestFactory.getApplicationKey(param.appKeyId, param.include, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getApplicationKey(responseContext);
            });
        });
    }
    /**
     * Get an application key owned by current user
     * @param param The request object
     */
    getCurrentUserApplicationKey(param, options) {
        const requestContextPromise = this.requestFactory.getCurrentUserApplicationKey(param.appKeyId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getCurrentUserApplicationKey(responseContext);
            });
        });
    }
    /**
     * List all API keys available for your account.
     * @param param The request object
     */
    listAPIKeys(param = {}, options) {
        const requestContextPromise = this.requestFactory.listAPIKeys(param.pageSize, param.pageNumber, param.sort, param.filter, param.filterCreatedAtStart, param.filterCreatedAtEnd, param.filterModifiedAtStart, param.filterModifiedAtEnd, param.include, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listAPIKeys(responseContext);
            });
        });
    }
    /**
     * List all application keys available for your org
     * @param param The request object
     */
    listApplicationKeys(param = {}, options) {
        const requestContextPromise = this.requestFactory.listApplicationKeys(param.pageSize, param.pageNumber, param.sort, param.filter, param.filterCreatedAtStart, param.filterCreatedAtEnd, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listApplicationKeys(responseContext);
            });
        });
    }
    /**
     * List all application keys available for current user
     * @param param The request object
     */
    listCurrentUserApplicationKeys(param = {}, options) {
        const requestContextPromise = this.requestFactory.listCurrentUserApplicationKeys(param.pageSize, param.pageNumber, param.sort, param.filter, param.filterCreatedAtStart, param.filterCreatedAtEnd, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listCurrentUserApplicationKeys(responseContext);
            });
        });
    }
    /**
     * Update an API key.
     * @param param The request object
     */
    updateAPIKey(param, options) {
        const requestContextPromise = this.requestFactory.updateAPIKey(param.apiKeyId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateAPIKey(responseContext);
            });
        });
    }
    /**
     * Edit an application key
     * @param param The request object
     */
    updateApplicationKey(param, options) {
        const requestContextPromise = this.requestFactory.updateApplicationKey(param.appKeyId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateApplicationKey(responseContext);
            });
        });
    }
    /**
     * Edit an application key owned by current user
     * @param param The request object
     */
    updateCurrentUserApplicationKey(param, options) {
        const requestContextPromise = this.requestFactory.updateCurrentUserApplicationKey(param.appKeyId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateCurrentUserApplicationKey(responseContext);
            });
        });
    }
}
exports.KeyManagementApi = KeyManagementApi;
//# sourceMappingURL=KeyManagementApi.js.map

/***/ }),

/***/ 94716:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsApi = exports.LogsApiResponseProcessor = exports.LogsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
const LogsListRequest_1 = __webpack_require__(46975);
const LogsListRequestPage_1 = __webpack_require__(92486);
class LogsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    aggregateLogs(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "aggregateLogs");
            }
            // Path Params
            const localVarPath = "/api/v2/logs/analytics/aggregate";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.LogsApi.aggregateLogs").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "LogsAggregateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listLogs(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/logs/events/search";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.LogsApi.listLogs").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "LogsListRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listLogsGet(filterQuery, filterIndex, filterFrom, filterTo, filterStorageTier, sort, pageCursor, pageLimit, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/logs/events";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.LogsApi.listLogsGet").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (filterQuery !== undefined) {
                requestContext.setQueryParam("filter[query]", ObjectSerializer_1.ObjectSerializer.serialize(filterQuery, "string", ""));
            }
            if (filterIndex !== undefined) {
                requestContext.setQueryParam("filter[index]", ObjectSerializer_1.ObjectSerializer.serialize(filterIndex, "string", ""));
            }
            if (filterFrom !== undefined) {
                requestContext.setQueryParam("filter[from]", ObjectSerializer_1.ObjectSerializer.serialize(filterFrom, "Date", "date-time"));
            }
            if (filterTo !== undefined) {
                requestContext.setQueryParam("filter[to]", ObjectSerializer_1.ObjectSerializer.serialize(filterTo, "Date", "date-time"));
            }
            if (filterStorageTier !== undefined) {
                requestContext.setQueryParam("filter[storage_tier]", ObjectSerializer_1.ObjectSerializer.serialize(filterStorageTier, "LogsStorageTier", ""));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "LogsSort", ""));
            }
            if (pageCursor !== undefined) {
                requestContext.setQueryParam("page[cursor]", ObjectSerializer_1.ObjectSerializer.serialize(pageCursor, "string", ""));
            }
            if (pageLimit !== undefined) {
                requestContext.setQueryParam("page[limit]", ObjectSerializer_1.ObjectSerializer.serialize(pageLimit, "number", "int32"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    submitLog(body, contentEncoding, ddtags, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "submitLog");
            }
            // Path Params
            const localVarPath = "/api/v2/logs";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.LogsApi.submitLog").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (ddtags !== undefined) {
                requestContext.setQueryParam("ddtags", ObjectSerializer_1.ObjectSerializer.serialize(ddtags, "string", ""));
            }
            // Header Params
            if (contentEncoding !== undefined) {
                requestContext.setHeaderParam("Content-Encoding", ObjectSerializer_1.ObjectSerializer.serialize(contentEncoding, "ContentEncoding", ""));
            }
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
                "application/logplex-1",
                "text/plain",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "Array<HTTPLogItem>", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, ["apiKeyAuth"]);
            return requestContext;
        });
    }
}
exports.LogsApiRequestFactory = LogsApiRequestFactory;
class LogsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to aggregateLogs
     * @throws ApiException if the response code was not in [200, 299]
     */
    aggregateLogs(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsAggregateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsAggregateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listLogs
     * @throws ApiException if the response code was not in [200, 299]
     */
    listLogs(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsListResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listLogsGet
     * @throws ApiException if the response code was not in [200, 299]
     */
    listLogsGet(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsListResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to submitLog
     * @throws ApiException if the response code was not in [200, 299]
     */
    submitLog(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 202) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 408 ||
                response.httpStatusCode == 413 ||
                response.httpStatusCode == 429 ||
                response.httpStatusCode == 500 ||
                response.httpStatusCode == 503) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "HTTPLogErrors");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "any", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.LogsApiResponseProcessor = LogsApiResponseProcessor;
class LogsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new LogsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new LogsApiResponseProcessor();
    }
    /**
     * The API endpoint to aggregate events into buckets and compute metrics and timeseries.
     * @param param The request object
     */
    aggregateLogs(param, options) {
        const requestContextPromise = this.requestFactory.aggregateLogs(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.aggregateLogs(responseContext);
            });
        });
    }
    /**
     * List endpoint returns logs that match a log search query.
     * [Results are paginated][1].
     *
     * Use this endpoint to build complex logs filtering and search.
     *
     * **If you are considering archiving logs for your organization,
     * consider use of the Datadog archive capabilities instead of the log list API.
     * See [Datadog Logs Archive documentation][2].**
     *
     * [1]: /logs/guide/collect-multiple-logs-with-pagination
     * [2]: https://docs.datadoghq.com/logs/archives
     * @param param The request object
     */
    listLogs(param = {}, options) {
        const requestContextPromise = this.requestFactory.listLogs(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listLogs(responseContext);
            });
        });
    }
    /**
     * Provide a paginated version of listLogs returning a generator with all the items.
     */
    listLogsWithPagination(param = {}, options) {
        return __asyncGenerator(this, arguments, function* listLogsWithPagination_1() {
            let pageSize = 10;
            if (param.body === undefined) {
                param.body = new LogsListRequest_1.LogsListRequest();
            }
            if (param.body.page === undefined) {
                param.body.page = new LogsListRequestPage_1.LogsListRequestPage();
            }
            if (param.body.page.limit !== undefined) {
                pageSize = param.body.page.limit;
            }
            param.body.page.limit = pageSize;
            while (true) {
                const requestContext = yield __await(this.requestFactory.listLogs(param.body, options));
                const responseContext = yield __await(this.configuration.httpApi.send(requestContext));
                const response = yield __await(this.responseProcessor.listLogs(responseContext));
                const responseData = response.data;
                if (responseData === undefined) {
                    break;
                }
                const results = responseData;
                for (const item of results) {
                    yield yield __await(item);
                }
                if (results.length < pageSize) {
                    break;
                }
                const cursorMeta = response.meta;
                if (cursorMeta === undefined) {
                    break;
                }
                const cursorMetaPage = cursorMeta.page;
                if (cursorMetaPage === undefined) {
                    break;
                }
                const cursorMetaPageAfter = cursorMetaPage.after;
                if (cursorMetaPageAfter === undefined) {
                    break;
                }
                param.body.page.cursor = cursorMetaPageAfter;
            }
        });
    }
    /**
     * List endpoint returns logs that match a log search query.
     * [Results are paginated][1].
     *
     * Use this endpoint to see your latest logs.
     *
     * **If you are considering archiving logs for your organization,
     * consider use of the Datadog archive capabilities instead of the log list API.
     * See [Datadog Logs Archive documentation][2].**
     *
     * [1]: /logs/guide/collect-multiple-logs-with-pagination
     * [2]: https://docs.datadoghq.com/logs/archives
     * @param param The request object
     */
    listLogsGet(param = {}, options) {
        const requestContextPromise = this.requestFactory.listLogsGet(param.filterQuery, param.filterIndex, param.filterFrom, param.filterTo, param.filterStorageTier, param.sort, param.pageCursor, param.pageLimit, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listLogsGet(responseContext);
            });
        });
    }
    /**
     * Provide a paginated version of listLogsGet returning a generator with all the items.
     */
    listLogsGetWithPagination(param = {}, options) {
        return __asyncGenerator(this, arguments, function* listLogsGetWithPagination_1() {
            let pageSize = 10;
            if (param.pageLimit !== undefined) {
                pageSize = param.pageLimit;
            }
            param.pageLimit = pageSize;
            while (true) {
                const requestContext = yield __await(this.requestFactory.listLogsGet(param.filterQuery, param.filterIndex, param.filterFrom, param.filterTo, param.filterStorageTier, param.sort, param.pageCursor, param.pageLimit, options));
                const responseContext = yield __await(this.configuration.httpApi.send(requestContext));
                const response = yield __await(this.responseProcessor.listLogsGet(responseContext));
                const responseData = response.data;
                if (responseData === undefined) {
                    break;
                }
                const results = responseData;
                for (const item of results) {
                    yield yield __await(item);
                }
                if (results.length < pageSize) {
                    break;
                }
                const cursorMeta = response.meta;
                if (cursorMeta === undefined) {
                    break;
                }
                const cursorMetaPage = cursorMeta.page;
                if (cursorMetaPage === undefined) {
                    break;
                }
                const cursorMetaPageAfter = cursorMetaPage.after;
                if (cursorMetaPageAfter === undefined) {
                    break;
                }
                param.pageCursor = cursorMetaPageAfter;
            }
        });
    }
    /**
     * Send your logs to your Datadog platform over HTTP. Limits per HTTP request are:
     *
     * - Maximum content size per payload (uncompressed): 5MB
     * - Maximum size for a single log: 1MB
     * - Maximum array size if sending multiple logs in an array: 1000 entries
     *
     * Any log exceeding 1MB is accepted and truncated by Datadog:
     * - For a single log request, the API truncates the log at 1MB and returns a 2xx.
     * - For a multi-logs request, the API processes all logs, truncates only logs larger than 1MB, and returns a 2xx.
     *
     * Datadog recommends sending your logs compressed.
     * Add the `Content-Encoding: gzip` header to the request when sending compressed logs.
     *
     * The status codes answered by the HTTP API are:
     * - 202: Accepted: the request has been accepted for processing
     * - 400: Bad request (likely an issue in the payload formatting)
     * - 401: Unauthorized (likely a missing API Key)
     * - 403: Permission issue (likely using an invalid API Key)
     * - 408: Request Timeout, request should be retried after some time
     * - 413: Payload too large (batch is above 5MB uncompressed)
     * - 429: Too Many Requests, request should be retried after some time
     * - 500: Internal Server Error, the server encountered an unexpected condition that prevented it from fulfilling the request, request should be retried after some time
     * - 503: Service Unavailable, the server is not ready to handle the request probably because it is overloaded, request should be retried after some time
     * @param param The request object
     */
    submitLog(param, options) {
        const requestContextPromise = this.requestFactory.submitLog(param.body, param.contentEncoding, param.ddtags, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.submitLog(responseContext);
            });
        });
    }
}
exports.LogsApi = LogsApi;
//# sourceMappingURL=LogsApi.js.map

/***/ }),

/***/ 73593:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsArchivesApi = exports.LogsArchivesApiResponseProcessor = exports.LogsArchivesApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class LogsArchivesApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    addReadRoleToArchive(archiveId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'archiveId' is not null or undefined
            if (archiveId === null || archiveId === undefined) {
                throw new baseapi_1.RequiredError("archiveId", "addReadRoleToArchive");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "addReadRoleToArchive");
            }
            // Path Params
            const localVarPath = "/api/v2/logs/config/archives/{archive_id}/readers".replace("{archive_id}", encodeURIComponent(String(archiveId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.LogsArchivesApi.addReadRoleToArchive").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "RelationshipToRole", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createLogsArchive(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createLogsArchive");
            }
            // Path Params
            const localVarPath = "/api/v2/logs/config/archives";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.LogsArchivesApi.createLogsArchive").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "LogsArchiveCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteLogsArchive(archiveId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'archiveId' is not null or undefined
            if (archiveId === null || archiveId === undefined) {
                throw new baseapi_1.RequiredError("archiveId", "deleteLogsArchive");
            }
            // Path Params
            const localVarPath = "/api/v2/logs/config/archives/{archive_id}".replace("{archive_id}", encodeURIComponent(String(archiveId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.LogsArchivesApi.deleteLogsArchive").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getLogsArchive(archiveId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'archiveId' is not null or undefined
            if (archiveId === null || archiveId === undefined) {
                throw new baseapi_1.RequiredError("archiveId", "getLogsArchive");
            }
            // Path Params
            const localVarPath = "/api/v2/logs/config/archives/{archive_id}".replace("{archive_id}", encodeURIComponent(String(archiveId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.LogsArchivesApi.getLogsArchive").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getLogsArchiveOrder(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/logs/config/archive-order";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.LogsArchivesApi.getLogsArchiveOrder").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listArchiveReadRoles(archiveId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'archiveId' is not null or undefined
            if (archiveId === null || archiveId === undefined) {
                throw new baseapi_1.RequiredError("archiveId", "listArchiveReadRoles");
            }
            // Path Params
            const localVarPath = "/api/v2/logs/config/archives/{archive_id}/readers".replace("{archive_id}", encodeURIComponent(String(archiveId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.LogsArchivesApi.listArchiveReadRoles").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listLogsArchives(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/logs/config/archives";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.LogsArchivesApi.listLogsArchives").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    removeRoleFromArchive(archiveId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'archiveId' is not null or undefined
            if (archiveId === null || archiveId === undefined) {
                throw new baseapi_1.RequiredError("archiveId", "removeRoleFromArchive");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "removeRoleFromArchive");
            }
            // Path Params
            const localVarPath = "/api/v2/logs/config/archives/{archive_id}/readers".replace("{archive_id}", encodeURIComponent(String(archiveId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.LogsArchivesApi.removeRoleFromArchive").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "RelationshipToRole", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateLogsArchive(archiveId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'archiveId' is not null or undefined
            if (archiveId === null || archiveId === undefined) {
                throw new baseapi_1.RequiredError("archiveId", "updateLogsArchive");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateLogsArchive");
            }
            // Path Params
            const localVarPath = "/api/v2/logs/config/archives/{archive_id}".replace("{archive_id}", encodeURIComponent(String(archiveId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.LogsArchivesApi.updateLogsArchive").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "LogsArchiveCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateLogsArchiveOrder(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateLogsArchiveOrder");
            }
            // Path Params
            const localVarPath = "/api/v2/logs/config/archive-order";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.LogsArchivesApi.updateLogsArchiveOrder").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "LogsArchiveOrder", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.LogsArchivesApiRequestFactory = LogsArchivesApiRequestFactory;
class LogsArchivesApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to addReadRoleToArchive
     * @throws ApiException if the response code was not in [200, 299]
     */
    addReadRoleToArchive(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createLogsArchive
     * @throws ApiException if the response code was not in [200, 299]
     */
    createLogsArchive(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsArchive");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsArchive", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteLogsArchive
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteLogsArchive(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getLogsArchive
     * @throws ApiException if the response code was not in [200, 299]
     */
    getLogsArchive(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsArchive");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsArchive", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getLogsArchiveOrder
     * @throws ApiException if the response code was not in [200, 299]
     */
    getLogsArchiveOrder(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsArchiveOrder");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsArchiveOrder", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listArchiveReadRoles
     * @throws ApiException if the response code was not in [200, 299]
     */
    listArchiveReadRoles(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RolesResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RolesResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listLogsArchives
     * @throws ApiException if the response code was not in [200, 299]
     */
    listLogsArchives(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsArchives");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsArchives", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to removeRoleFromArchive
     * @throws ApiException if the response code was not in [200, 299]
     */
    removeRoleFromArchive(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateLogsArchive
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateLogsArchive(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsArchive");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsArchive", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateLogsArchiveOrder
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateLogsArchiveOrder(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsArchiveOrder");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 422 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsArchiveOrder", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.LogsArchivesApiResponseProcessor = LogsArchivesApiResponseProcessor;
class LogsArchivesApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new LogsArchivesApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new LogsArchivesApiResponseProcessor();
    }
    /**
     * Adds a read role to an archive. ([Roles API](https://docs.datadoghq.com/api/v2/roles/))
     * @param param The request object
     */
    addReadRoleToArchive(param, options) {
        const requestContextPromise = this.requestFactory.addReadRoleToArchive(param.archiveId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.addReadRoleToArchive(responseContext);
            });
        });
    }
    /**
     * Create an archive in your organization.
     * @param param The request object
     */
    createLogsArchive(param, options) {
        const requestContextPromise = this.requestFactory.createLogsArchive(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createLogsArchive(responseContext);
            });
        });
    }
    /**
     * Delete a given archive from your organization.
     * @param param The request object
     */
    deleteLogsArchive(param, options) {
        const requestContextPromise = this.requestFactory.deleteLogsArchive(param.archiveId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteLogsArchive(responseContext);
            });
        });
    }
    /**
     * Get a specific archive from your organization.
     * @param param The request object
     */
    getLogsArchive(param, options) {
        const requestContextPromise = this.requestFactory.getLogsArchive(param.archiveId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getLogsArchive(responseContext);
            });
        });
    }
    /**
     * Get the current order of your archives.
     * This endpoint takes no JSON arguments.
     * @param param The request object
     */
    getLogsArchiveOrder(options) {
        const requestContextPromise = this.requestFactory.getLogsArchiveOrder(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getLogsArchiveOrder(responseContext);
            });
        });
    }
    /**
     * Returns all read roles a given archive is restricted to.
     * @param param The request object
     */
    listArchiveReadRoles(param, options) {
        const requestContextPromise = this.requestFactory.listArchiveReadRoles(param.archiveId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listArchiveReadRoles(responseContext);
            });
        });
    }
    /**
     * Get the list of configured logs archives with their definitions.
     * @param param The request object
     */
    listLogsArchives(options) {
        const requestContextPromise = this.requestFactory.listLogsArchives(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listLogsArchives(responseContext);
            });
        });
    }
    /**
     * Removes a role from an archive. ([Roles API](https://docs.datadoghq.com/api/v2/roles/))
     * @param param The request object
     */
    removeRoleFromArchive(param, options) {
        const requestContextPromise = this.requestFactory.removeRoleFromArchive(param.archiveId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.removeRoleFromArchive(responseContext);
            });
        });
    }
    /**
     * Update a given archive configuration.
     *
     * **Note**: Using this method updates your archive configuration by **replacing**
     * your current configuration with the new one sent to your Datadog organization.
     * @param param The request object
     */
    updateLogsArchive(param, options) {
        const requestContextPromise = this.requestFactory.updateLogsArchive(param.archiveId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateLogsArchive(responseContext);
            });
        });
    }
    /**
     * Update the order of your archives. Since logs are processed sequentially, reordering an archive may change
     * the structure and content of the data processed by other archives.
     *
     * **Note**: Using the `PUT` method updates your archive's order by replacing the current order
     * with the new one.
     * @param param The request object
     */
    updateLogsArchiveOrder(param, options) {
        const requestContextPromise = this.requestFactory.updateLogsArchiveOrder(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateLogsArchiveOrder(responseContext);
            });
        });
    }
}
exports.LogsArchivesApi = LogsArchivesApi;
//# sourceMappingURL=LogsArchivesApi.js.map

/***/ }),

/***/ 12943:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsMetricsApi = exports.LogsMetricsApiResponseProcessor = exports.LogsMetricsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class LogsMetricsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createLogsMetric(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createLogsMetric");
            }
            // Path Params
            const localVarPath = "/api/v2/logs/config/metrics";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.LogsMetricsApi.createLogsMetric").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "LogsMetricCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteLogsMetric(metricId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new baseapi_1.RequiredError("metricId", "deleteLogsMetric");
            }
            // Path Params
            const localVarPath = "/api/v2/logs/config/metrics/{metric_id}".replace("{metric_id}", encodeURIComponent(String(metricId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.LogsMetricsApi.deleteLogsMetric").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getLogsMetric(metricId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new baseapi_1.RequiredError("metricId", "getLogsMetric");
            }
            // Path Params
            const localVarPath = "/api/v2/logs/config/metrics/{metric_id}".replace("{metric_id}", encodeURIComponent(String(metricId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.LogsMetricsApi.getLogsMetric").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listLogsMetrics(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/logs/config/metrics";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.LogsMetricsApi.listLogsMetrics").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateLogsMetric(metricId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new baseapi_1.RequiredError("metricId", "updateLogsMetric");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateLogsMetric");
            }
            // Path Params
            const localVarPath = "/api/v2/logs/config/metrics/{metric_id}".replace("{metric_id}", encodeURIComponent(String(metricId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.LogsMetricsApi.updateLogsMetric").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "LogsMetricUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.LogsMetricsApiRequestFactory = LogsMetricsApiRequestFactory;
class LogsMetricsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createLogsMetric
     * @throws ApiException if the response code was not in [200, 299]
     */
    createLogsMetric(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsMetricResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 409 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsMetricResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteLogsMetric
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteLogsMetric(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                return;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getLogsMetric
     * @throws ApiException if the response code was not in [200, 299]
     */
    getLogsMetric(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsMetricResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsMetricResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listLogsMetrics
     * @throws ApiException if the response code was not in [200, 299]
     */
    listLogsMetrics(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsMetricsResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsMetricsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateLogsMetric
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateLogsMetric(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsMetricResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "LogsMetricResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.LogsMetricsApiResponseProcessor = LogsMetricsApiResponseProcessor;
class LogsMetricsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new LogsMetricsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new LogsMetricsApiResponseProcessor();
    }
    /**
     * Create a metric based on your ingested logs in your organization.
     * Returns the log-based metric object from the request body when the request is successful.
     * @param param The request object
     */
    createLogsMetric(param, options) {
        const requestContextPromise = this.requestFactory.createLogsMetric(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createLogsMetric(responseContext);
            });
        });
    }
    /**
     * Delete a specific log-based metric from your organization.
     * @param param The request object
     */
    deleteLogsMetric(param, options) {
        const requestContextPromise = this.requestFactory.deleteLogsMetric(param.metricId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteLogsMetric(responseContext);
            });
        });
    }
    /**
     * Get a specific log-based metric from your organization.
     * @param param The request object
     */
    getLogsMetric(param, options) {
        const requestContextPromise = this.requestFactory.getLogsMetric(param.metricId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getLogsMetric(responseContext);
            });
        });
    }
    /**
     * Get the list of configured log-based metrics with their definitions.
     * @param param The request object
     */
    listLogsMetrics(options) {
        const requestContextPromise = this.requestFactory.listLogsMetrics(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listLogsMetrics(responseContext);
            });
        });
    }
    /**
     * Update a specific log-based metric from your organization.
     * Returns the log-based metric object from the request body when the request is successful.
     * @param param The request object
     */
    updateLogsMetric(param, options) {
        const requestContextPromise = this.requestFactory.updateLogsMetric(param.metricId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateLogsMetric(responseContext);
            });
        });
    }
}
exports.LogsMetricsApi = LogsMetricsApi;
//# sourceMappingURL=LogsMetricsApi.js.map

/***/ }),

/***/ 47719:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricsApi = exports.MetricsApiResponseProcessor = exports.MetricsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class MetricsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createBulkTagsMetricsConfiguration(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createBulkTagsMetricsConfiguration");
            }
            // Path Params
            const localVarPath = "/api/v2/metrics/config/bulk-tags";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.MetricsApi.createBulkTagsMetricsConfiguration").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "MetricBulkTagConfigCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createTagConfiguration(metricName, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'metricName' is not null or undefined
            if (metricName === null || metricName === undefined) {
                throw new baseapi_1.RequiredError("metricName", "createTagConfiguration");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createTagConfiguration");
            }
            // Path Params
            const localVarPath = "/api/v2/metrics/{metric_name}/tags".replace("{metric_name}", encodeURIComponent(String(metricName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.MetricsApi.createTagConfiguration").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "MetricTagConfigurationCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteBulkTagsMetricsConfiguration(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "deleteBulkTagsMetricsConfiguration");
            }
            // Path Params
            const localVarPath = "/api/v2/metrics/config/bulk-tags";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.MetricsApi.deleteBulkTagsMetricsConfiguration").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "MetricBulkTagConfigDeleteRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteTagConfiguration(metricName, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'metricName' is not null or undefined
            if (metricName === null || metricName === undefined) {
                throw new baseapi_1.RequiredError("metricName", "deleteTagConfiguration");
            }
            // Path Params
            const localVarPath = "/api/v2/metrics/{metric_name}/tags".replace("{metric_name}", encodeURIComponent(String(metricName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.MetricsApi.deleteTagConfiguration").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    estimateMetricsOutputSeries(metricName, filterGroups, filterHoursAgo, filterNumAggregations, filterPct, filterTimespanH, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'metricName' is not null or undefined
            if (metricName === null || metricName === undefined) {
                throw new baseapi_1.RequiredError("metricName", "estimateMetricsOutputSeries");
            }
            // Path Params
            const localVarPath = "/api/v2/metrics/{metric_name}/estimate".replace("{metric_name}", encodeURIComponent(String(metricName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.MetricsApi.estimateMetricsOutputSeries").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (filterGroups !== undefined) {
                requestContext.setQueryParam("filter[groups]", ObjectSerializer_1.ObjectSerializer.serialize(filterGroups, "string", ""));
            }
            if (filterHoursAgo !== undefined) {
                requestContext.setQueryParam("filter[hours_ago]", ObjectSerializer_1.ObjectSerializer.serialize(filterHoursAgo, "number", "int32"));
            }
            if (filterNumAggregations !== undefined) {
                requestContext.setQueryParam("filter[num_aggregations]", ObjectSerializer_1.ObjectSerializer.serialize(filterNumAggregations, "number", "int32"));
            }
            if (filterPct !== undefined) {
                requestContext.setQueryParam("filter[pct]", ObjectSerializer_1.ObjectSerializer.serialize(filterPct, "boolean", ""));
            }
            if (filterTimespanH !== undefined) {
                requestContext.setQueryParam("filter[timespan_h]", ObjectSerializer_1.ObjectSerializer.serialize(filterTimespanH, "number", "int32"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listActiveMetricConfigurations(metricName, windowSeconds, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'metricName' is not null or undefined
            if (metricName === null || metricName === undefined) {
                throw new baseapi_1.RequiredError("metricName", "listActiveMetricConfigurations");
            }
            // Path Params
            const localVarPath = "/api/v2/metrics/{metric_name}/active-configurations".replace("{metric_name}", encodeURIComponent(String(metricName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.MetricsApi.listActiveMetricConfigurations").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (windowSeconds !== undefined) {
                requestContext.setQueryParam("window[seconds]", ObjectSerializer_1.ObjectSerializer.serialize(windowSeconds, "number", "int64"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listTagConfigurationByName(metricName, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'metricName' is not null or undefined
            if (metricName === null || metricName === undefined) {
                throw new baseapi_1.RequiredError("metricName", "listTagConfigurationByName");
            }
            // Path Params
            const localVarPath = "/api/v2/metrics/{metric_name}/tags".replace("{metric_name}", encodeURIComponent(String(metricName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.MetricsApi.listTagConfigurationByName").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listTagConfigurations(filterConfigured, filterTagsConfigured, filterMetricType, filterIncludePercentiles, filterQueried, filterTags, windowSeconds, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/metrics";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.MetricsApi.listTagConfigurations").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (filterConfigured !== undefined) {
                requestContext.setQueryParam("filter[configured]", ObjectSerializer_1.ObjectSerializer.serialize(filterConfigured, "boolean", ""));
            }
            if (filterTagsConfigured !== undefined) {
                requestContext.setQueryParam("filter[tags_configured]", ObjectSerializer_1.ObjectSerializer.serialize(filterTagsConfigured, "string", ""));
            }
            if (filterMetricType !== undefined) {
                requestContext.setQueryParam("filter[metric_type]", ObjectSerializer_1.ObjectSerializer.serialize(filterMetricType, "MetricTagConfigurationMetricTypes", ""));
            }
            if (filterIncludePercentiles !== undefined) {
                requestContext.setQueryParam("filter[include_percentiles]", ObjectSerializer_1.ObjectSerializer.serialize(filterIncludePercentiles, "boolean", ""));
            }
            if (filterQueried !== undefined) {
                requestContext.setQueryParam("filter[queried]", ObjectSerializer_1.ObjectSerializer.serialize(filterQueried, "boolean", ""));
            }
            if (filterTags !== undefined) {
                requestContext.setQueryParam("filter[tags]", ObjectSerializer_1.ObjectSerializer.serialize(filterTags, "string", ""));
            }
            if (windowSeconds !== undefined) {
                requestContext.setQueryParam("window[seconds]", ObjectSerializer_1.ObjectSerializer.serialize(windowSeconds, "number", "int64"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listTagsByMetricName(metricName, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'metricName' is not null or undefined
            if (metricName === null || metricName === undefined) {
                throw new baseapi_1.RequiredError("metricName", "listTagsByMetricName");
            }
            // Path Params
            const localVarPath = "/api/v2/metrics/{metric_name}/all-tags".replace("{metric_name}", encodeURIComponent(String(metricName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.MetricsApi.listTagsByMetricName").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listVolumesByMetricName(metricName, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'metricName' is not null or undefined
            if (metricName === null || metricName === undefined) {
                throw new baseapi_1.RequiredError("metricName", "listVolumesByMetricName");
            }
            // Path Params
            const localVarPath = "/api/v2/metrics/{metric_name}/volumes".replace("{metric_name}", encodeURIComponent(String(metricName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.MetricsApi.listVolumesByMetricName").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    queryScalarData(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'queryScalarData'");
            if (!_config.unstableOperations["v2.queryScalarData"]) {
                throw new Error("Unstable operation 'queryScalarData' is disabled");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "queryScalarData");
            }
            // Path Params
            const localVarPath = "/api/v2/query/scalar";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.MetricsApi.queryScalarData").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "ScalarFormulaQueryRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    queryTimeseriesData(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            logger_1.logger.warn("Using unstable operation 'queryTimeseriesData'");
            if (!_config.unstableOperations["v2.queryTimeseriesData"]) {
                throw new Error("Unstable operation 'queryTimeseriesData' is disabled");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "queryTimeseriesData");
            }
            // Path Params
            const localVarPath = "/api/v2/query/timeseries";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.MetricsApi.queryTimeseriesData").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "TimeseriesFormulaQueryRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    submitMetrics(body, contentEncoding, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "submitMetrics");
            }
            // Path Params
            const localVarPath = "/api/v2/series";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.MetricsApi.submitMetrics").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Header Params
            if (contentEncoding !== undefined) {
                requestContext.setHeaderParam("Content-Encoding", ObjectSerializer_1.ObjectSerializer.serialize(contentEncoding, "MetricContentEncoding", ""));
            }
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "MetricPayload", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, ["apiKeyAuth"]);
            return requestContext;
        });
    }
    updateTagConfiguration(metricName, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'metricName' is not null or undefined
            if (metricName === null || metricName === undefined) {
                throw new baseapi_1.RequiredError("metricName", "updateTagConfiguration");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateTagConfiguration");
            }
            // Path Params
            const localVarPath = "/api/v2/metrics/{metric_name}/tags".replace("{metric_name}", encodeURIComponent(String(metricName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.MetricsApi.updateTagConfiguration").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "MetricTagConfigurationUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.MetricsApiRequestFactory = MetricsApiRequestFactory;
class MetricsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createBulkTagsMetricsConfiguration
     * @throws ApiException if the response code was not in [200, 299]
     */
    createBulkTagsMetricsConfiguration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 202) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricBulkTagConfigResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricBulkTagConfigResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createTagConfiguration
     * @throws ApiException if the response code was not in [200, 299]
     */
    createTagConfiguration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricTagConfigurationResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 409 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricTagConfigurationResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteBulkTagsMetricsConfiguration
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteBulkTagsMetricsConfiguration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 202) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricBulkTagConfigResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricBulkTagConfigResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteTagConfiguration
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteTagConfiguration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to estimateMetricsOutputSeries
     * @throws ApiException if the response code was not in [200, 299]
     */
    estimateMetricsOutputSeries(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricEstimateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricEstimateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listActiveMetricConfigurations
     * @throws ApiException if the response code was not in [200, 299]
     */
    listActiveMetricConfigurations(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricSuggestedTagsAndAggregationsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricSuggestedTagsAndAggregationsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listTagConfigurationByName
     * @throws ApiException if the response code was not in [200, 299]
     */
    listTagConfigurationByName(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricTagConfigurationResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricTagConfigurationResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listTagConfigurations
     * @throws ApiException if the response code was not in [200, 299]
     */
    listTagConfigurations(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricsAndMetricTagConfigurationsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricsAndMetricTagConfigurationsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listTagsByMetricName
     * @throws ApiException if the response code was not in [200, 299]
     */
    listTagsByMetricName(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricAllTagsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricAllTagsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listVolumesByMetricName
     * @throws ApiException if the response code was not in [200, 299]
     */
    listVolumesByMetricName(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricVolumesResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricVolumesResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to queryScalarData
     * @throws ApiException if the response code was not in [200, 299]
     */
    queryScalarData(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ScalarFormulaQueryResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ScalarFormulaQueryResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to queryTimeseriesData
     * @throws ApiException if the response code was not in [200, 299]
     */
    queryTimeseriesData(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "TimeseriesFormulaQueryResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "TimeseriesFormulaQueryResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to submitMetrics
     * @throws ApiException if the response code was not in [200, 299]
     */
    submitMetrics(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 202) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IntakePayloadAccepted");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 408 ||
                response.httpStatusCode == 413 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "IntakePayloadAccepted", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateTagConfiguration
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateTagConfiguration(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricTagConfigurationResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 422 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MetricTagConfigurationResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.MetricsApiResponseProcessor = MetricsApiResponseProcessor;
class MetricsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new MetricsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new MetricsApiResponseProcessor();
    }
    /**
     * Create and define a list of queryable tag keys for a set of existing count, gauge, rate, and distribution metrics.
     * Metrics are selected by passing a metric name prefix. Use the Delete method of this API path to remove tag configurations.
     * Results can be sent to a set of account email addresses, just like the same operation in the Datadog web app.
     * If multiple calls include the same metric, the last configuration applied (not by submit order) is used, do not
     * expect deterministic ordering of concurrent calls.
     * Can only be used with application keys of users with the `Manage Tags for Metrics` permission.
     * @param param The request object
     */
    createBulkTagsMetricsConfiguration(param, options) {
        const requestContextPromise = this.requestFactory.createBulkTagsMetricsConfiguration(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createBulkTagsMetricsConfiguration(responseContext);
            });
        });
    }
    /**
     * Create and define a list of queryable tag keys for an existing count/gauge/rate/distribution metric.
     * Optionally, include percentile aggregations on any distribution metric or configure custom aggregations
     * on any count, rate, or gauge metric.
     * Can only be used with application keys of users with the `Manage Tags for Metrics` permission.
     * @param param The request object
     */
    createTagConfiguration(param, options) {
        const requestContextPromise = this.requestFactory.createTagConfiguration(param.metricName, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createTagConfiguration(responseContext);
            });
        });
    }
    /**
     * Delete all custom lists of queryable tag keys for a set of existing count, gauge, rate, and distribution metrics.
     * Metrics are selected by passing a metric name prefix.
     * Results can be sent to a set of account email addresses, just like the same operation in the Datadog web app.
     * Can only be used with application keys of users with the `Manage Tags for Metrics` permission.
     * @param param The request object
     */
    deleteBulkTagsMetricsConfiguration(param, options) {
        const requestContextPromise = this.requestFactory.deleteBulkTagsMetricsConfiguration(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteBulkTagsMetricsConfiguration(responseContext);
            });
        });
    }
    /**
     * Deletes a metric's tag configuration. Can only be used with application
     * keys from users with the `Manage Tags for Metrics` permission.
     * @param param The request object
     */
    deleteTagConfiguration(param, options) {
        const requestContextPromise = this.requestFactory.deleteTagConfiguration(param.metricName, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteTagConfiguration(responseContext);
            });
        });
    }
    /**
     * Returns the estimated cardinality for a metric with a given tag, percentile and number of aggregations configuration using Metrics without Limits&trade;.
     * @param param The request object
     */
    estimateMetricsOutputSeries(param, options) {
        const requestContextPromise = this.requestFactory.estimateMetricsOutputSeries(param.metricName, param.filterGroups, param.filterHoursAgo, param.filterNumAggregations, param.filterPct, param.filterTimespanH, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.estimateMetricsOutputSeries(responseContext);
            });
        });
    }
    /**
     * List tags and aggregations that are actively queried on dashboards and monitors for a given metric name.
     * @param param The request object
     */
    listActiveMetricConfigurations(param, options) {
        const requestContextPromise = this.requestFactory.listActiveMetricConfigurations(param.metricName, param.windowSeconds, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listActiveMetricConfigurations(responseContext);
            });
        });
    }
    /**
     * Returns the tag configuration for the given metric name.
     * @param param The request object
     */
    listTagConfigurationByName(param, options) {
        const requestContextPromise = this.requestFactory.listTagConfigurationByName(param.metricName, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listTagConfigurationByName(responseContext);
            });
        });
    }
    /**
     * Returns all metrics that can be configured in the Metrics Summary page or with Metrics without Limits (matching additional filters if specified).
     * @param param The request object
     */
    listTagConfigurations(param = {}, options) {
        const requestContextPromise = this.requestFactory.listTagConfigurations(param.filterConfigured, param.filterTagsConfigured, param.filterMetricType, param.filterIncludePercentiles, param.filterQueried, param.filterTags, param.windowSeconds, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listTagConfigurations(responseContext);
            });
        });
    }
    /**
     * View indexed tag key-value pairs for a given metric name.
     * @param param The request object
     */
    listTagsByMetricName(param, options) {
        const requestContextPromise = this.requestFactory.listTagsByMetricName(param.metricName, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listTagsByMetricName(responseContext);
            });
        });
    }
    /**
     * View distinct metrics volumes for the given metric name.
     *
     * Custom metrics generated in-app from other products will return `null` for ingested volumes.
     * @param param The request object
     */
    listVolumesByMetricName(param, options) {
        const requestContextPromise = this.requestFactory.listVolumesByMetricName(param.metricName, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listVolumesByMetricName(responseContext);
            });
        });
    }
    /**
     * Query scalar values (as seen on Query Value, Table and Toplist widgets).
     * Multiple data sources are supported with the ability to
     * process the data using formulas and functions.
     * @param param The request object
     */
    queryScalarData(param, options) {
        const requestContextPromise = this.requestFactory.queryScalarData(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.queryScalarData(responseContext);
            });
        });
    }
    /**
     * Query timeseries data across various data sources and
     * process the data by applying formulas and functions.
     * @param param The request object
     */
    queryTimeseriesData(param, options) {
        const requestContextPromise = this.requestFactory.queryTimeseriesData(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.queryTimeseriesData(responseContext);
            });
        });
    }
    /**
     * The metrics end-point allows you to post time-series data that can be graphed on Datadogs dashboards.
     * The maximum payload size is 500 kilobytes (512000 bytes). Compressed payloads must have a decompressed size of less than 5 megabytes (5242880 bytes).
     *
     * If youre submitting metrics directly to the Datadog API without using DogStatsD, expect:
     *
     * - 64 bits for the timestamp
     * - 64 bits for the value
     * - 20 bytes for the metric names
     * - 50 bytes for the timeseries
     * - The full payload is approximately 100 bytes.
     *
     * Host name is one of the resources in the Resources field.
     * @param param The request object
     */
    submitMetrics(param, options) {
        const requestContextPromise = this.requestFactory.submitMetrics(param.body, param.contentEncoding, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.submitMetrics(responseContext);
            });
        });
    }
    /**
     * Update the tag configuration of a metric or percentile aggregations of a distribution metric or custom aggregations
     * of a count, rate, or gauge metric.
     * Can only be used with application keys from users with the `Manage Tags for Metrics` permission.
     * @param param The request object
     */
    updateTagConfiguration(param, options) {
        const requestContextPromise = this.requestFactory.updateTagConfiguration(param.metricName, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateTagConfiguration(responseContext);
            });
        });
    }
}
exports.MetricsApi = MetricsApi;
//# sourceMappingURL=MetricsApi.js.map

/***/ }),

/***/ 83263:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorsApi = exports.MonitorsApiResponseProcessor = exports.MonitorsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class MonitorsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createMonitorConfigPolicy(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createMonitorConfigPolicy");
            }
            // Path Params
            const localVarPath = "/api/v2/monitor/policy";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.MonitorsApi.createMonitorConfigPolicy").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "MonitorConfigPolicyCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteMonitorConfigPolicy(policyId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new baseapi_1.RequiredError("policyId", "deleteMonitorConfigPolicy");
            }
            // Path Params
            const localVarPath = "/api/v2/monitor/policy/{policy_id}".replace("{policy_id}", encodeURIComponent(String(policyId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.MonitorsApi.deleteMonitorConfigPolicy").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getMonitorConfigPolicy(policyId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new baseapi_1.RequiredError("policyId", "getMonitorConfigPolicy");
            }
            // Path Params
            const localVarPath = "/api/v2/monitor/policy/{policy_id}".replace("{policy_id}", encodeURIComponent(String(policyId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.MonitorsApi.getMonitorConfigPolicy").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listMonitorConfigPolicies(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/monitor/policy";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.MonitorsApi.listMonitorConfigPolicies").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateMonitorConfigPolicy(policyId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new baseapi_1.RequiredError("policyId", "updateMonitorConfigPolicy");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateMonitorConfigPolicy");
            }
            // Path Params
            const localVarPath = "/api/v2/monitor/policy/{policy_id}".replace("{policy_id}", encodeURIComponent(String(policyId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.MonitorsApi.updateMonitorConfigPolicy").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "MonitorConfigPolicyEditRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.MonitorsApiRequestFactory = MonitorsApiRequestFactory;
class MonitorsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createMonitorConfigPolicy
     * @throws ApiException if the response code was not in [200, 299]
     */
    createMonitorConfigPolicy(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MonitorConfigPolicyResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MonitorConfigPolicyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteMonitorConfigPolicy
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteMonitorConfigPolicy(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getMonitorConfigPolicy
     * @throws ApiException if the response code was not in [200, 299]
     */
    getMonitorConfigPolicy(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MonitorConfigPolicyResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MonitorConfigPolicyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listMonitorConfigPolicies
     * @throws ApiException if the response code was not in [200, 299]
     */
    listMonitorConfigPolicies(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MonitorConfigPolicyListResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MonitorConfigPolicyListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateMonitorConfigPolicy
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateMonitorConfigPolicy(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MonitorConfigPolicyResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 422 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "MonitorConfigPolicyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.MonitorsApiResponseProcessor = MonitorsApiResponseProcessor;
class MonitorsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new MonitorsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new MonitorsApiResponseProcessor();
    }
    /**
     * Create a monitor configuration policy.
     * @param param The request object
     */
    createMonitorConfigPolicy(param, options) {
        const requestContextPromise = this.requestFactory.createMonitorConfigPolicy(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createMonitorConfigPolicy(responseContext);
            });
        });
    }
    /**
     * Delete a monitor configuration policy.
     * @param param The request object
     */
    deleteMonitorConfigPolicy(param, options) {
        const requestContextPromise = this.requestFactory.deleteMonitorConfigPolicy(param.policyId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteMonitorConfigPolicy(responseContext);
            });
        });
    }
    /**
     * Get a monitor configuration policy by `policy_id`.
     * @param param The request object
     */
    getMonitorConfigPolicy(param, options) {
        const requestContextPromise = this.requestFactory.getMonitorConfigPolicy(param.policyId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getMonitorConfigPolicy(responseContext);
            });
        });
    }
    /**
     * Get all monitor configuration policies.
     * @param param The request object
     */
    listMonitorConfigPolicies(options) {
        const requestContextPromise = this.requestFactory.listMonitorConfigPolicies(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listMonitorConfigPolicies(responseContext);
            });
        });
    }
    /**
     * Edit a monitor configuration policy.
     * @param param The request object
     */
    updateMonitorConfigPolicy(param, options) {
        const requestContextPromise = this.requestFactory.updateMonitorConfigPolicy(param.policyId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateMonitorConfigPolicy(responseContext);
            });
        });
    }
}
exports.MonitorsApi = MonitorsApi;
//# sourceMappingURL=MonitorsApi.js.map

/***/ }),

/***/ 44111:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OpsgenieIntegrationApi = exports.OpsgenieIntegrationApiResponseProcessor = exports.OpsgenieIntegrationApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class OpsgenieIntegrationApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createOpsgenieService(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createOpsgenieService");
            }
            // Path Params
            const localVarPath = "/api/v2/integration/opsgenie/services";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.OpsgenieIntegrationApi.createOpsgenieService").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "OpsgenieServiceCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteOpsgenieService(integrationServiceId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'integrationServiceId' is not null or undefined
            if (integrationServiceId === null || integrationServiceId === undefined) {
                throw new baseapi_1.RequiredError("integrationServiceId", "deleteOpsgenieService");
            }
            // Path Params
            const localVarPath = "/api/v2/integration/opsgenie/services/{integration_service_id}".replace("{integration_service_id}", encodeURIComponent(String(integrationServiceId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.OpsgenieIntegrationApi.deleteOpsgenieService").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getOpsgenieService(integrationServiceId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'integrationServiceId' is not null or undefined
            if (integrationServiceId === null || integrationServiceId === undefined) {
                throw new baseapi_1.RequiredError("integrationServiceId", "getOpsgenieService");
            }
            // Path Params
            const localVarPath = "/api/v2/integration/opsgenie/services/{integration_service_id}".replace("{integration_service_id}", encodeURIComponent(String(integrationServiceId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.OpsgenieIntegrationApi.getOpsgenieService").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listOpsgenieServices(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/integration/opsgenie/services";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.OpsgenieIntegrationApi.listOpsgenieServices").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateOpsgenieService(integrationServiceId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'integrationServiceId' is not null or undefined
            if (integrationServiceId === null || integrationServiceId === undefined) {
                throw new baseapi_1.RequiredError("integrationServiceId", "updateOpsgenieService");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateOpsgenieService");
            }
            // Path Params
            const localVarPath = "/api/v2/integration/opsgenie/services/{integration_service_id}".replace("{integration_service_id}", encodeURIComponent(String(integrationServiceId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.OpsgenieIntegrationApi.updateOpsgenieService").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "OpsgenieServiceUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.OpsgenieIntegrationApiRequestFactory = OpsgenieIntegrationApiRequestFactory;
class OpsgenieIntegrationApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createOpsgenieService
     * @throws ApiException if the response code was not in [200, 299]
     */
    createOpsgenieService(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "OpsgenieServiceResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 409 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "OpsgenieServiceResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteOpsgenieService
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteOpsgenieService(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getOpsgenieService
     * @throws ApiException if the response code was not in [200, 299]
     */
    getOpsgenieService(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "OpsgenieServiceResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 409 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "OpsgenieServiceResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listOpsgenieServices
     * @throws ApiException if the response code was not in [200, 299]
     */
    listOpsgenieServices(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "OpsgenieServicesResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "OpsgenieServicesResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateOpsgenieService
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateOpsgenieService(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "OpsgenieServiceResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 409 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "OpsgenieServiceResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.OpsgenieIntegrationApiResponseProcessor = OpsgenieIntegrationApiResponseProcessor;
class OpsgenieIntegrationApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new OpsgenieIntegrationApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new OpsgenieIntegrationApiResponseProcessor();
    }
    /**
     * Create a new service object in the Opsgenie integration.
     * @param param The request object
     */
    createOpsgenieService(param, options) {
        const requestContextPromise = this.requestFactory.createOpsgenieService(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createOpsgenieService(responseContext);
            });
        });
    }
    /**
     * Delete a single service object in the Datadog Opsgenie integration.
     * @param param The request object
     */
    deleteOpsgenieService(param, options) {
        const requestContextPromise = this.requestFactory.deleteOpsgenieService(param.integrationServiceId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteOpsgenieService(responseContext);
            });
        });
    }
    /**
     * Get a single service from the Datadog Opsgenie integration.
     * @param param The request object
     */
    getOpsgenieService(param, options) {
        const requestContextPromise = this.requestFactory.getOpsgenieService(param.integrationServiceId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getOpsgenieService(responseContext);
            });
        });
    }
    /**
     * Get a list of all services from the Datadog Opsgenie integration.
     * @param param The request object
     */
    listOpsgenieServices(options) {
        const requestContextPromise = this.requestFactory.listOpsgenieServices(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listOpsgenieServices(responseContext);
            });
        });
    }
    /**
     * Update a single service object in the Datadog Opsgenie integration.
     * @param param The request object
     */
    updateOpsgenieService(param, options) {
        const requestContextPromise = this.requestFactory.updateOpsgenieService(param.integrationServiceId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateOpsgenieService(responseContext);
            });
        });
    }
}
exports.OpsgenieIntegrationApi = OpsgenieIntegrationApi;
//# sourceMappingURL=OpsgenieIntegrationApi.js.map

/***/ }),

/***/ 49292:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrganizationsApi = exports.OrganizationsApiResponseProcessor = exports.OrganizationsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const form_data_1 = __importDefault(__webpack_require__(64334));
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class OrganizationsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    uploadIdPMetadata(idpFile, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/saml_configurations/idp_metadata";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.OrganizationsApi.uploadIdPMetadata").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Form Params
            const localVarFormParams = new form_data_1.default();
            if (idpFile !== undefined) {
                // TODO: replace .append with .set
                localVarFormParams.append("idp_file", idpFile.data, idpFile.name);
            }
            requestContext.setBody(localVarFormParams);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.OrganizationsApiRequestFactory = OrganizationsApiRequestFactory;
class OrganizationsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to uploadIdPMetadata
     * @throws ApiException if the response code was not in [200, 299]
     */
    uploadIdPMetadata(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.OrganizationsApiResponseProcessor = OrganizationsApiResponseProcessor;
class OrganizationsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new OrganizationsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new OrganizationsApiResponseProcessor();
    }
    /**
     * Endpoint for uploading IdP metadata for SAML setup.
     *
     * Use this endpoint to upload or replace IdP metadata for SAML login configuration.
     * @param param The request object
     */
    uploadIdPMetadata(param = {}, options) {
        const requestContextPromise = this.requestFactory.uploadIdPMetadata(param.idpFile, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.uploadIdPMetadata(responseContext);
            });
        });
    }
}
exports.OrganizationsApi = OrganizationsApi;
//# sourceMappingURL=OrganizationsApi.js.map

/***/ }),

/***/ 2718:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProcessesApi = exports.ProcessesApiResponseProcessor = exports.ProcessesApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class ProcessesApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    listProcesses(search, tags, from, to, pageLimit, pageCursor, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/processes";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ProcessesApi.listProcesses").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (search !== undefined) {
                requestContext.setQueryParam("search", ObjectSerializer_1.ObjectSerializer.serialize(search, "string", ""));
            }
            if (tags !== undefined) {
                requestContext.setQueryParam("tags", ObjectSerializer_1.ObjectSerializer.serialize(tags, "string", ""));
            }
            if (from !== undefined) {
                requestContext.setQueryParam("from", ObjectSerializer_1.ObjectSerializer.serialize(from, "number", "int64"));
            }
            if (to !== undefined) {
                requestContext.setQueryParam("to", ObjectSerializer_1.ObjectSerializer.serialize(to, "number", "int64"));
            }
            if (pageLimit !== undefined) {
                requestContext.setQueryParam("page[limit]", ObjectSerializer_1.ObjectSerializer.serialize(pageLimit, "number", "int32"));
            }
            if (pageCursor !== undefined) {
                requestContext.setQueryParam("page[cursor]", ObjectSerializer_1.ObjectSerializer.serialize(pageCursor, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.ProcessesApiRequestFactory = ProcessesApiRequestFactory;
class ProcessesApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listProcesses
     * @throws ApiException if the response code was not in [200, 299]
     */
    listProcesses(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ProcessSummariesResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ProcessSummariesResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.ProcessesApiResponseProcessor = ProcessesApiResponseProcessor;
class ProcessesApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new ProcessesApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new ProcessesApiResponseProcessor();
    }
    /**
     * Get all processes for your organization.
     * @param param The request object
     */
    listProcesses(param = {}, options) {
        const requestContextPromise = this.requestFactory.listProcesses(param.search, param.tags, param.from, param.to, param.pageLimit, param.pageCursor, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listProcesses(responseContext);
            });
        });
    }
    /**
     * Provide a paginated version of listProcesses returning a generator with all the items.
     */
    listProcessesWithPagination(param = {}, options) {
        return __asyncGenerator(this, arguments, function* listProcessesWithPagination_1() {
            let pageSize = 1000;
            if (param.pageLimit !== undefined) {
                pageSize = param.pageLimit;
            }
            param.pageLimit = pageSize;
            while (true) {
                const requestContext = yield __await(this.requestFactory.listProcesses(param.search, param.tags, param.from, param.to, param.pageLimit, param.pageCursor, options));
                const responseContext = yield __await(this.configuration.httpApi.send(requestContext));
                const response = yield __await(this.responseProcessor.listProcesses(responseContext));
                const responseData = response.data;
                if (responseData === undefined) {
                    break;
                }
                const results = responseData;
                for (const item of results) {
                    yield yield __await(item);
                }
                if (results.length < pageSize) {
                    break;
                }
                const cursorMeta = response.meta;
                if (cursorMeta === undefined) {
                    break;
                }
                const cursorMetaPage = cursorMeta.page;
                if (cursorMetaPage === undefined) {
                    break;
                }
                const cursorMetaPageAfter = cursorMetaPage.after;
                if (cursorMetaPageAfter === undefined) {
                    break;
                }
                param.pageCursor = cursorMetaPageAfter;
            }
        });
    }
}
exports.ProcessesApi = ProcessesApi;
//# sourceMappingURL=ProcessesApi.js.map

/***/ }),

/***/ 53106:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMApi = exports.RUMApiResponseProcessor = exports.RUMApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
const RUMQueryPageOptions_1 = __webpack_require__(89982);
class RUMApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    aggregateRUMEvents(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "aggregateRUMEvents");
            }
            // Path Params
            const localVarPath = "/api/v2/rum/analytics/aggregate";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RUMApi.aggregateRUMEvents").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "RUMAggregateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createRUMApplication(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createRUMApplication");
            }
            // Path Params
            const localVarPath = "/api/v2/rum/applications";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RUMApi.createRUMApplication").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "RUMApplicationCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteRUMApplication(id, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new baseapi_1.RequiredError("id", "deleteRUMApplication");
            }
            // Path Params
            const localVarPath = "/api/v2/rum/applications/{id}".replace("{id}", encodeURIComponent(String(id)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RUMApi.deleteRUMApplication").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getRUMApplication(id, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new baseapi_1.RequiredError("id", "getRUMApplication");
            }
            // Path Params
            const localVarPath = "/api/v2/rum/applications/{id}".replace("{id}", encodeURIComponent(String(id)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RUMApi.getRUMApplication").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getRUMApplications(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/rum/applications";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RUMApi.getRUMApplications").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listRUMEvents(filterQuery, filterFrom, filterTo, sort, pageCursor, pageLimit, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/rum/events";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RUMApi.listRUMEvents").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (filterQuery !== undefined) {
                requestContext.setQueryParam("filter[query]", ObjectSerializer_1.ObjectSerializer.serialize(filterQuery, "string", ""));
            }
            if (filterFrom !== undefined) {
                requestContext.setQueryParam("filter[from]", ObjectSerializer_1.ObjectSerializer.serialize(filterFrom, "Date", "date-time"));
            }
            if (filterTo !== undefined) {
                requestContext.setQueryParam("filter[to]", ObjectSerializer_1.ObjectSerializer.serialize(filterTo, "Date", "date-time"));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "RUMSort", ""));
            }
            if (pageCursor !== undefined) {
                requestContext.setQueryParam("page[cursor]", ObjectSerializer_1.ObjectSerializer.serialize(pageCursor, "string", ""));
            }
            if (pageLimit !== undefined) {
                requestContext.setQueryParam("page[limit]", ObjectSerializer_1.ObjectSerializer.serialize(pageLimit, "number", "int32"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    searchRUMEvents(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "searchRUMEvents");
            }
            // Path Params
            const localVarPath = "/api/v2/rum/events/search";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RUMApi.searchRUMEvents").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "RUMSearchEventsRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateRUMApplication(id, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new baseapi_1.RequiredError("id", "updateRUMApplication");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateRUMApplication");
            }
            // Path Params
            const localVarPath = "/api/v2/rum/applications/{id}".replace("{id}", encodeURIComponent(String(id)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RUMApi.updateRUMApplication").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "RUMApplicationUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.RUMApiRequestFactory = RUMApiRequestFactory;
class RUMApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to aggregateRUMEvents
     * @throws ApiException if the response code was not in [200, 299]
     */
    aggregateRUMEvents(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RUMAnalyticsAggregateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RUMAnalyticsAggregateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createRUMApplication
     * @throws ApiException if the response code was not in [200, 299]
     */
    createRUMApplication(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RUMApplicationResponse");
                return body;
            }
            if (response.httpStatusCode == 400 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RUMApplicationResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteRUMApplication
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteRUMApplication(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 404 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getRUMApplication
     * @throws ApiException if the response code was not in [200, 299]
     */
    getRUMApplication(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RUMApplicationResponse");
                return body;
            }
            if (response.httpStatusCode == 404 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RUMApplicationResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getRUMApplications
     * @throws ApiException if the response code was not in [200, 299]
     */
    getRUMApplications(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RUMApplicationsResponse");
                return body;
            }
            if (response.httpStatusCode == 404 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RUMApplicationsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listRUMEvents
     * @throws ApiException if the response code was not in [200, 299]
     */
    listRUMEvents(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RUMEventsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RUMEventsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to searchRUMEvents
     * @throws ApiException if the response code was not in [200, 299]
     */
    searchRUMEvents(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RUMEventsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RUMEventsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateRUMApplication
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateRUMApplication(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RUMApplicationResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 422 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RUMApplicationResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.RUMApiResponseProcessor = RUMApiResponseProcessor;
class RUMApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new RUMApiRequestFactory(configuration);
        this.responseProcessor = responseProcessor || new RUMApiResponseProcessor();
    }
    /**
     * The API endpoint to aggregate RUM events into buckets of computed metrics and timeseries.
     * @param param The request object
     */
    aggregateRUMEvents(param, options) {
        const requestContextPromise = this.requestFactory.aggregateRUMEvents(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.aggregateRUMEvents(responseContext);
            });
        });
    }
    /**
     * Create a new RUM application in your organization.
     * @param param The request object
     */
    createRUMApplication(param, options) {
        const requestContextPromise = this.requestFactory.createRUMApplication(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createRUMApplication(responseContext);
            });
        });
    }
    /**
     * Delete an existing RUM application in your organization.
     * @param param The request object
     */
    deleteRUMApplication(param, options) {
        const requestContextPromise = this.requestFactory.deleteRUMApplication(param.id, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteRUMApplication(responseContext);
            });
        });
    }
    /**
     * Get the RUM application with given ID in your organization.
     * @param param The request object
     */
    getRUMApplication(param, options) {
        const requestContextPromise = this.requestFactory.getRUMApplication(param.id, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getRUMApplication(responseContext);
            });
        });
    }
    /**
     * List all the RUM applications in your organization.
     * @param param The request object
     */
    getRUMApplications(options) {
        const requestContextPromise = this.requestFactory.getRUMApplications(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getRUMApplications(responseContext);
            });
        });
    }
    /**
     * List endpoint returns events that match a RUM search query.
     * [Results are paginated][1].
     *
     * Use this endpoint to see your latest RUM events.
     *
     * [1]: https://docs.datadoghq.com/logs/guide/collect-multiple-logs-with-pagination
     * @param param The request object
     */
    listRUMEvents(param = {}, options) {
        const requestContextPromise = this.requestFactory.listRUMEvents(param.filterQuery, param.filterFrom, param.filterTo, param.sort, param.pageCursor, param.pageLimit, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listRUMEvents(responseContext);
            });
        });
    }
    /**
     * Provide a paginated version of listRUMEvents returning a generator with all the items.
     */
    listRUMEventsWithPagination(param = {}, options) {
        return __asyncGenerator(this, arguments, function* listRUMEventsWithPagination_1() {
            let pageSize = 10;
            if (param.pageLimit !== undefined) {
                pageSize = param.pageLimit;
            }
            param.pageLimit = pageSize;
            while (true) {
                const requestContext = yield __await(this.requestFactory.listRUMEvents(param.filterQuery, param.filterFrom, param.filterTo, param.sort, param.pageCursor, param.pageLimit, options));
                const responseContext = yield __await(this.configuration.httpApi.send(requestContext));
                const response = yield __await(this.responseProcessor.listRUMEvents(responseContext));
                const responseData = response.data;
                if (responseData === undefined) {
                    break;
                }
                const results = responseData;
                for (const item of results) {
                    yield yield __await(item);
                }
                if (results.length < pageSize) {
                    break;
                }
                const cursorMeta = response.meta;
                if (cursorMeta === undefined) {
                    break;
                }
                const cursorMetaPage = cursorMeta.page;
                if (cursorMetaPage === undefined) {
                    break;
                }
                const cursorMetaPageAfter = cursorMetaPage.after;
                if (cursorMetaPageAfter === undefined) {
                    break;
                }
                param.pageCursor = cursorMetaPageAfter;
            }
        });
    }
    /**
     * List endpoint returns RUM events that match a RUM search query.
     * [Results are paginated][1].
     *
     * Use this endpoint to build complex RUM events filtering and search.
     *
     * [1]: https://docs.datadoghq.com/logs/guide/collect-multiple-logs-with-pagination
     * @param param The request object
     */
    searchRUMEvents(param, options) {
        const requestContextPromise = this.requestFactory.searchRUMEvents(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.searchRUMEvents(responseContext);
            });
        });
    }
    /**
     * Provide a paginated version of searchRUMEvents returning a generator with all the items.
     */
    searchRUMEventsWithPagination(param, options) {
        return __asyncGenerator(this, arguments, function* searchRUMEventsWithPagination_1() {
            let pageSize = 10;
            if (param.body.page === undefined) {
                param.body.page = new RUMQueryPageOptions_1.RUMQueryPageOptions();
            }
            if (param.body.page.limit === undefined) {
                param.body.page.limit = pageSize;
            }
            else {
                pageSize = param.body.page.limit;
            }
            while (true) {
                const requestContext = yield __await(this.requestFactory.searchRUMEvents(param.body, options));
                const responseContext = yield __await(this.configuration.httpApi.send(requestContext));
                const response = yield __await(this.responseProcessor.searchRUMEvents(responseContext));
                const responseData = response.data;
                if (responseData === undefined) {
                    break;
                }
                const results = responseData;
                for (const item of results) {
                    yield yield __await(item);
                }
                if (results.length < pageSize) {
                    break;
                }
                const cursorMeta = response.meta;
                if (cursorMeta === undefined) {
                    break;
                }
                const cursorMetaPage = cursorMeta.page;
                if (cursorMetaPage === undefined) {
                    break;
                }
                const cursorMetaPageAfter = cursorMetaPage.after;
                if (cursorMetaPageAfter === undefined) {
                    break;
                }
                param.body.page.cursor = cursorMetaPageAfter;
            }
        });
    }
    /**
     * Update the RUM application with given ID in your organization.
     * @param param The request object
     */
    updateRUMApplication(param, options) {
        const requestContextPromise = this.requestFactory.updateRUMApplication(param.id, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateRUMApplication(responseContext);
            });
        });
    }
}
exports.RUMApi = RUMApi;
//# sourceMappingURL=RUMApi.js.map

/***/ }),

/***/ 49755:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RolesApi = exports.RolesApiResponseProcessor = exports.RolesApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class RolesApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    addPermissionToRole(roleId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new baseapi_1.RequiredError("roleId", "addPermissionToRole");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "addPermissionToRole");
            }
            // Path Params
            const localVarPath = "/api/v2/roles/{role_id}/permissions".replace("{role_id}", encodeURIComponent(String(roleId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RolesApi.addPermissionToRole").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "RelationshipToPermission", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    addUserToRole(roleId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new baseapi_1.RequiredError("roleId", "addUserToRole");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "addUserToRole");
            }
            // Path Params
            const localVarPath = "/api/v2/roles/{role_id}/users".replace("{role_id}", encodeURIComponent(String(roleId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RolesApi.addUserToRole").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "RelationshipToUser", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    cloneRole(roleId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new baseapi_1.RequiredError("roleId", "cloneRole");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "cloneRole");
            }
            // Path Params
            const localVarPath = "/api/v2/roles/{role_id}/clone".replace("{role_id}", encodeURIComponent(String(roleId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RolesApi.cloneRole").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "RoleCloneRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createRole(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createRole");
            }
            // Path Params
            const localVarPath = "/api/v2/roles";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RolesApi.createRole").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "RoleCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteRole(roleId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new baseapi_1.RequiredError("roleId", "deleteRole");
            }
            // Path Params
            const localVarPath = "/api/v2/roles/{role_id}".replace("{role_id}", encodeURIComponent(String(roleId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RolesApi.deleteRole").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getRole(roleId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new baseapi_1.RequiredError("roleId", "getRole");
            }
            // Path Params
            const localVarPath = "/api/v2/roles/{role_id}".replace("{role_id}", encodeURIComponent(String(roleId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RolesApi.getRole").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listPermissions(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/permissions";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RolesApi.listPermissions").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listRolePermissions(roleId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new baseapi_1.RequiredError("roleId", "listRolePermissions");
            }
            // Path Params
            const localVarPath = "/api/v2/roles/{role_id}/permissions".replace("{role_id}", encodeURIComponent(String(roleId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RolesApi.listRolePermissions").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listRoles(pageSize, pageNumber, sort, filter, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/roles";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RolesApi.listRoles").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page[size]", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "number", "int64"));
            }
            if (pageNumber !== undefined) {
                requestContext.setQueryParam("page[number]", ObjectSerializer_1.ObjectSerializer.serialize(pageNumber, "number", "int64"));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "RolesSort", ""));
            }
            if (filter !== undefined) {
                requestContext.setQueryParam("filter", ObjectSerializer_1.ObjectSerializer.serialize(filter, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listRoleUsers(roleId, pageSize, pageNumber, sort, filter, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new baseapi_1.RequiredError("roleId", "listRoleUsers");
            }
            // Path Params
            const localVarPath = "/api/v2/roles/{role_id}/users".replace("{role_id}", encodeURIComponent(String(roleId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RolesApi.listRoleUsers").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page[size]", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "number", "int64"));
            }
            if (pageNumber !== undefined) {
                requestContext.setQueryParam("page[number]", ObjectSerializer_1.ObjectSerializer.serialize(pageNumber, "number", "int64"));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "string", ""));
            }
            if (filter !== undefined) {
                requestContext.setQueryParam("filter", ObjectSerializer_1.ObjectSerializer.serialize(filter, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    removePermissionFromRole(roleId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new baseapi_1.RequiredError("roleId", "removePermissionFromRole");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "removePermissionFromRole");
            }
            // Path Params
            const localVarPath = "/api/v2/roles/{role_id}/permissions".replace("{role_id}", encodeURIComponent(String(roleId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RolesApi.removePermissionFromRole").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "RelationshipToPermission", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    removeUserFromRole(roleId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new baseapi_1.RequiredError("roleId", "removeUserFromRole");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "removeUserFromRole");
            }
            // Path Params
            const localVarPath = "/api/v2/roles/{role_id}/users".replace("{role_id}", encodeURIComponent(String(roleId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RolesApi.removeUserFromRole").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "RelationshipToUser", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateRole(roleId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new baseapi_1.RequiredError("roleId", "updateRole");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateRole");
            }
            // Path Params
            const localVarPath = "/api/v2/roles/{role_id}".replace("{role_id}", encodeURIComponent(String(roleId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.RolesApi.updateRole").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "RoleUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.RolesApiRequestFactory = RolesApiRequestFactory;
class RolesApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to addPermissionToRole
     * @throws ApiException if the response code was not in [200, 299]
     */
    addPermissionToRole(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "PermissionsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "PermissionsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to addUserToRole
     * @throws ApiException if the response code was not in [200, 299]
     */
    addUserToRole(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsersResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsersResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to cloneRole
     * @throws ApiException if the response code was not in [200, 299]
     */
    cloneRole(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RoleResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 409 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RoleResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createRole
     * @throws ApiException if the response code was not in [200, 299]
     */
    createRole(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RoleCreateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RoleCreateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteRole
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteRole(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getRole
     * @throws ApiException if the response code was not in [200, 299]
     */
    getRole(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RoleResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RoleResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listPermissions
     * @throws ApiException if the response code was not in [200, 299]
     */
    listPermissions(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "PermissionsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "PermissionsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listRolePermissions
     * @throws ApiException if the response code was not in [200, 299]
     */
    listRolePermissions(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "PermissionsResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "PermissionsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listRoles
     * @throws ApiException if the response code was not in [200, 299]
     */
    listRoles(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RolesResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RolesResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listRoleUsers
     * @throws ApiException if the response code was not in [200, 299]
     */
    listRoleUsers(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsersResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsersResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to removePermissionFromRole
     * @throws ApiException if the response code was not in [200, 299]
     */
    removePermissionFromRole(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "PermissionsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "PermissionsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to removeUserFromRole
     * @throws ApiException if the response code was not in [200, 299]
     */
    removeUserFromRole(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsersResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsersResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateRole
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateRole(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RoleUpdateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 422 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "RoleUpdateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.RolesApiResponseProcessor = RolesApiResponseProcessor;
class RolesApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new RolesApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new RolesApiResponseProcessor();
    }
    /**
     * Adds a permission to a role.
     * @param param The request object
     */
    addPermissionToRole(param, options) {
        const requestContextPromise = this.requestFactory.addPermissionToRole(param.roleId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.addPermissionToRole(responseContext);
            });
        });
    }
    /**
     * Adds a user to a role.
     * @param param The request object
     */
    addUserToRole(param, options) {
        const requestContextPromise = this.requestFactory.addUserToRole(param.roleId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.addUserToRole(responseContext);
            });
        });
    }
    /**
     * Clone an existing role
     * @param param The request object
     */
    cloneRole(param, options) {
        const requestContextPromise = this.requestFactory.cloneRole(param.roleId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.cloneRole(responseContext);
            });
        });
    }
    /**
     * Create a new role for your organization.
     * @param param The request object
     */
    createRole(param, options) {
        const requestContextPromise = this.requestFactory.createRole(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createRole(responseContext);
            });
        });
    }
    /**
     * Disables a role.
     * @param param The request object
     */
    deleteRole(param, options) {
        const requestContextPromise = this.requestFactory.deleteRole(param.roleId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteRole(responseContext);
            });
        });
    }
    /**
     * Get a role in the organization specified by the roles `role_id`.
     * @param param The request object
     */
    getRole(param, options) {
        const requestContextPromise = this.requestFactory.getRole(param.roleId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getRole(responseContext);
            });
        });
    }
    /**
     * Returns a list of all permissions, including name, description, and ID.
     * @param param The request object
     */
    listPermissions(options) {
        const requestContextPromise = this.requestFactory.listPermissions(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listPermissions(responseContext);
            });
        });
    }
    /**
     * Returns a list of all permissions for a single role.
     * @param param The request object
     */
    listRolePermissions(param, options) {
        const requestContextPromise = this.requestFactory.listRolePermissions(param.roleId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listRolePermissions(responseContext);
            });
        });
    }
    /**
     * Returns all roles, including their names and their unique identifiers.
     * @param param The request object
     */
    listRoles(param = {}, options) {
        const requestContextPromise = this.requestFactory.listRoles(param.pageSize, param.pageNumber, param.sort, param.filter, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listRoles(responseContext);
            });
        });
    }
    /**
     * Gets all users of a role.
     * @param param The request object
     */
    listRoleUsers(param, options) {
        const requestContextPromise = this.requestFactory.listRoleUsers(param.roleId, param.pageSize, param.pageNumber, param.sort, param.filter, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listRoleUsers(responseContext);
            });
        });
    }
    /**
     * Removes a permission from a role.
     * @param param The request object
     */
    removePermissionFromRole(param, options) {
        const requestContextPromise = this.requestFactory.removePermissionFromRole(param.roleId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.removePermissionFromRole(responseContext);
            });
        });
    }
    /**
     * Removes a user from a role.
     * @param param The request object
     */
    removeUserFromRole(param, options) {
        const requestContextPromise = this.requestFactory.removeUserFromRole(param.roleId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.removeUserFromRole(responseContext);
            });
        });
    }
    /**
     * Edit a role. Can only be used with application keys belonging to administrators.
     * @param param The request object
     */
    updateRole(param, options) {
        const requestContextPromise = this.requestFactory.updateRole(param.roleId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateRole(responseContext);
            });
        });
    }
}
exports.RolesApi = RolesApi;
//# sourceMappingURL=RolesApi.js.map

/***/ }),

/***/ 94005:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringApi = exports.SecurityMonitoringApiResponseProcessor = exports.SecurityMonitoringApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
const SecurityMonitoringSignalListRequest_1 = __webpack_require__(13723);
const SecurityMonitoringSignalListRequestPage_1 = __webpack_require__(31123);
class SecurityMonitoringApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createSecurityFilter(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createSecurityFilter");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/configuration/security_filters";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SecurityMonitoringApi.createSecurityFilter").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityFilterCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createSecurityMonitoringRule(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createSecurityMonitoringRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/rules";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SecurityMonitoringApi.createSecurityMonitoringRule").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityMonitoringRuleCreatePayload", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteSecurityFilter(securityFilterId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'securityFilterId' is not null or undefined
            if (securityFilterId === null || securityFilterId === undefined) {
                throw new baseapi_1.RequiredError("securityFilterId", "deleteSecurityFilter");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/configuration/security_filters/{security_filter_id}".replace("{security_filter_id}", encodeURIComponent(String(securityFilterId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SecurityMonitoringApi.deleteSecurityFilter").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteSecurityMonitoringRule(ruleId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new baseapi_1.RequiredError("ruleId", "deleteSecurityMonitoringRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/rules/{rule_id}".replace("{rule_id}", encodeURIComponent(String(ruleId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SecurityMonitoringApi.deleteSecurityMonitoringRule").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    editSecurityMonitoringSignalAssignee(signalId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'signalId' is not null or undefined
            if (signalId === null || signalId === undefined) {
                throw new baseapi_1.RequiredError("signalId", "editSecurityMonitoringSignalAssignee");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "editSecurityMonitoringSignalAssignee");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/signals/{signal_id}/assignee".replace("{signal_id}", encodeURIComponent(String(signalId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SecurityMonitoringApi.editSecurityMonitoringSignalAssignee").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityMonitoringSignalAssigneeUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    editSecurityMonitoringSignalIncidents(signalId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'signalId' is not null or undefined
            if (signalId === null || signalId === undefined) {
                throw new baseapi_1.RequiredError("signalId", "editSecurityMonitoringSignalIncidents");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "editSecurityMonitoringSignalIncidents");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/signals/{signal_id}/incidents".replace("{signal_id}", encodeURIComponent(String(signalId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SecurityMonitoringApi.editSecurityMonitoringSignalIncidents").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityMonitoringSignalIncidentsUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    editSecurityMonitoringSignalState(signalId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'signalId' is not null or undefined
            if (signalId === null || signalId === undefined) {
                throw new baseapi_1.RequiredError("signalId", "editSecurityMonitoringSignalState");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "editSecurityMonitoringSignalState");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/signals/{signal_id}/state".replace("{signal_id}", encodeURIComponent(String(signalId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SecurityMonitoringApi.editSecurityMonitoringSignalState").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityMonitoringSignalStateUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getSecurityFilter(securityFilterId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'securityFilterId' is not null or undefined
            if (securityFilterId === null || securityFilterId === undefined) {
                throw new baseapi_1.RequiredError("securityFilterId", "getSecurityFilter");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/configuration/security_filters/{security_filter_id}".replace("{security_filter_id}", encodeURIComponent(String(securityFilterId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SecurityMonitoringApi.getSecurityFilter").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getSecurityMonitoringRule(ruleId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new baseapi_1.RequiredError("ruleId", "getSecurityMonitoringRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/rules/{rule_id}".replace("{rule_id}", encodeURIComponent(String(ruleId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SecurityMonitoringApi.getSecurityMonitoringRule").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getSecurityMonitoringSignal(signalId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'signalId' is not null or undefined
            if (signalId === null || signalId === undefined) {
                throw new baseapi_1.RequiredError("signalId", "getSecurityMonitoringSignal");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/signals/{signal_id}".replace("{signal_id}", encodeURIComponent(String(signalId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SecurityMonitoringApi.getSecurityMonitoringSignal").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listSecurityFilters(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/configuration/security_filters";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SecurityMonitoringApi.listSecurityFilters").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listSecurityMonitoringRules(pageSize, pageNumber, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/rules";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SecurityMonitoringApi.listSecurityMonitoringRules").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page[size]", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "number", "int64"));
            }
            if (pageNumber !== undefined) {
                requestContext.setQueryParam("page[number]", ObjectSerializer_1.ObjectSerializer.serialize(pageNumber, "number", "int64"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listSecurityMonitoringSignals(filterQuery, filterFrom, filterTo, sort, pageCursor, pageLimit, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/signals";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SecurityMonitoringApi.listSecurityMonitoringSignals").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (filterQuery !== undefined) {
                requestContext.setQueryParam("filter[query]", ObjectSerializer_1.ObjectSerializer.serialize(filterQuery, "string", ""));
            }
            if (filterFrom !== undefined) {
                requestContext.setQueryParam("filter[from]", ObjectSerializer_1.ObjectSerializer.serialize(filterFrom, "Date", "date-time"));
            }
            if (filterTo !== undefined) {
                requestContext.setQueryParam("filter[to]", ObjectSerializer_1.ObjectSerializer.serialize(filterTo, "Date", "date-time"));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "SecurityMonitoringSignalsSort", ""));
            }
            if (pageCursor !== undefined) {
                requestContext.setQueryParam("page[cursor]", ObjectSerializer_1.ObjectSerializer.serialize(pageCursor, "string", ""));
            }
            if (pageLimit !== undefined) {
                requestContext.setQueryParam("page[limit]", ObjectSerializer_1.ObjectSerializer.serialize(pageLimit, "number", "int32"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    searchSecurityMonitoringSignals(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/signals/search";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SecurityMonitoringApi.searchSecurityMonitoringSignals").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityMonitoringSignalListRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateSecurityFilter(securityFilterId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'securityFilterId' is not null or undefined
            if (securityFilterId === null || securityFilterId === undefined) {
                throw new baseapi_1.RequiredError("securityFilterId", "updateSecurityFilter");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateSecurityFilter");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/configuration/security_filters/{security_filter_id}".replace("{security_filter_id}", encodeURIComponent(String(securityFilterId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SecurityMonitoringApi.updateSecurityFilter").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityFilterUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateSecurityMonitoringRule(ruleId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new baseapi_1.RequiredError("ruleId", "updateSecurityMonitoringRule");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateSecurityMonitoringRule");
            }
            // Path Params
            const localVarPath = "/api/v2/security_monitoring/rules/{rule_id}".replace("{rule_id}", encodeURIComponent(String(ruleId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SecurityMonitoringApi.updateSecurityMonitoringRule").makeRequestContext(localVarPath, http_1.HttpMethod.PUT);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SecurityMonitoringRuleUpdatePayload", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.SecurityMonitoringApiRequestFactory = SecurityMonitoringApiRequestFactory;
class SecurityMonitoringApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createSecurityFilter
     * @throws ApiException if the response code was not in [200, 299]
     */
    createSecurityFilter(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityFilterResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 409 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityFilterResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createSecurityMonitoringRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    createSecurityMonitoringRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringRuleResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringRuleResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteSecurityFilter
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteSecurityFilter(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteSecurityMonitoringRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteSecurityMonitoringRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to editSecurityMonitoringSignalAssignee
     * @throws ApiException if the response code was not in [200, 299]
     */
    editSecurityMonitoringSignalAssignee(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalTriageUpdateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalTriageUpdateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to editSecurityMonitoringSignalIncidents
     * @throws ApiException if the response code was not in [200, 299]
     */
    editSecurityMonitoringSignalIncidents(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalTriageUpdateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalTriageUpdateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to editSecurityMonitoringSignalState
     * @throws ApiException if the response code was not in [200, 299]
     */
    editSecurityMonitoringSignalState(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalTriageUpdateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalTriageUpdateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getSecurityFilter
     * @throws ApiException if the response code was not in [200, 299]
     */
    getSecurityFilter(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityFilterResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityFilterResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getSecurityMonitoringRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    getSecurityMonitoringRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringRuleResponse");
                return body;
            }
            if (response.httpStatusCode == 404 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringRuleResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getSecurityMonitoringSignal
     * @throws ApiException if the response code was not in [200, 299]
     */
    getSecurityMonitoringSignal(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignal");
                return body;
            }
            if (response.httpStatusCode == 404 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignal", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listSecurityFilters
     * @throws ApiException if the response code was not in [200, 299]
     */
    listSecurityFilters(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityFiltersResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityFiltersResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listSecurityMonitoringRules
     * @throws ApiException if the response code was not in [200, 299]
     */
    listSecurityMonitoringRules(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringListRulesResponse");
                return body;
            }
            if (response.httpStatusCode == 400 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringListRulesResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listSecurityMonitoringSignals
     * @throws ApiException if the response code was not in [200, 299]
     */
    listSecurityMonitoringSignals(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalsListResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalsListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to searchSecurityMonitoringSignals
     * @throws ApiException if the response code was not in [200, 299]
     */
    searchSecurityMonitoringSignals(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalsListResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringSignalsListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateSecurityFilter
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateSecurityFilter(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityFilterResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 409 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityFilterResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateSecurityMonitoringRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateSecurityMonitoringRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringRuleResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 401 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SecurityMonitoringRuleResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.SecurityMonitoringApiResponseProcessor = SecurityMonitoringApiResponseProcessor;
class SecurityMonitoringApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new SecurityMonitoringApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new SecurityMonitoringApiResponseProcessor();
    }
    /**
     * Create a security filter.
     *
     * See the [security filter guide](https://docs.datadoghq.com/security_platform/guide/how-to-setup-security-filters-using-security-monitoring-api/)
     * for more examples.
     * @param param The request object
     */
    createSecurityFilter(param, options) {
        const requestContextPromise = this.requestFactory.createSecurityFilter(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createSecurityFilter(responseContext);
            });
        });
    }
    /**
     * Create a detection rule.
     * @param param The request object
     */
    createSecurityMonitoringRule(param, options) {
        const requestContextPromise = this.requestFactory.createSecurityMonitoringRule(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createSecurityMonitoringRule(responseContext);
            });
        });
    }
    /**
     * Delete a specific security filter.
     * @param param The request object
     */
    deleteSecurityFilter(param, options) {
        const requestContextPromise = this.requestFactory.deleteSecurityFilter(param.securityFilterId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteSecurityFilter(responseContext);
            });
        });
    }
    /**
     * Delete an existing rule. Default rules cannot be deleted.
     * @param param The request object
     */
    deleteSecurityMonitoringRule(param, options) {
        const requestContextPromise = this.requestFactory.deleteSecurityMonitoringRule(param.ruleId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteSecurityMonitoringRule(responseContext);
            });
        });
    }
    /**
     * Modify the triage assignee of a security signal.
     * @param param The request object
     */
    editSecurityMonitoringSignalAssignee(param, options) {
        const requestContextPromise = this.requestFactory.editSecurityMonitoringSignalAssignee(param.signalId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.editSecurityMonitoringSignalAssignee(responseContext);
            });
        });
    }
    /**
     * Change the related incidents for a security signal.
     * @param param The request object
     */
    editSecurityMonitoringSignalIncidents(param, options) {
        const requestContextPromise = this.requestFactory.editSecurityMonitoringSignalIncidents(param.signalId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.editSecurityMonitoringSignalIncidents(responseContext);
            });
        });
    }
    /**
     * Change the triage state of a security signal.
     * @param param The request object
     */
    editSecurityMonitoringSignalState(param, options) {
        const requestContextPromise = this.requestFactory.editSecurityMonitoringSignalState(param.signalId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.editSecurityMonitoringSignalState(responseContext);
            });
        });
    }
    /**
     * Get the details of a specific security filter.
     *
     * See the [security filter guide](https://docs.datadoghq.com/security_platform/guide/how-to-setup-security-filters-using-security-monitoring-api/)
     * for more examples.
     * @param param The request object
     */
    getSecurityFilter(param, options) {
        const requestContextPromise = this.requestFactory.getSecurityFilter(param.securityFilterId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getSecurityFilter(responseContext);
            });
        });
    }
    /**
     * Get a rule's details.
     * @param param The request object
     */
    getSecurityMonitoringRule(param, options) {
        const requestContextPromise = this.requestFactory.getSecurityMonitoringRule(param.ruleId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getSecurityMonitoringRule(responseContext);
            });
        });
    }
    /**
     * Get a signal's details.
     * @param param The request object
     */
    getSecurityMonitoringSignal(param, options) {
        const requestContextPromise = this.requestFactory.getSecurityMonitoringSignal(param.signalId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getSecurityMonitoringSignal(responseContext);
            });
        });
    }
    /**
     * Get the list of configured security filters with their definitions.
     * @param param The request object
     */
    listSecurityFilters(options) {
        const requestContextPromise = this.requestFactory.listSecurityFilters(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listSecurityFilters(responseContext);
            });
        });
    }
    /**
     * List rules.
     * @param param The request object
     */
    listSecurityMonitoringRules(param = {}, options) {
        const requestContextPromise = this.requestFactory.listSecurityMonitoringRules(param.pageSize, param.pageNumber, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listSecurityMonitoringRules(responseContext);
            });
        });
    }
    /**
     * The list endpoint returns security signals that match a search query.
     * Both this endpoint and the POST endpoint can be used interchangeably when listing
     * security signals.
     * @param param The request object
     */
    listSecurityMonitoringSignals(param = {}, options) {
        const requestContextPromise = this.requestFactory.listSecurityMonitoringSignals(param.filterQuery, param.filterFrom, param.filterTo, param.sort, param.pageCursor, param.pageLimit, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listSecurityMonitoringSignals(responseContext);
            });
        });
    }
    /**
     * Provide a paginated version of listSecurityMonitoringSignals returning a generator with all the items.
     */
    listSecurityMonitoringSignalsWithPagination(param = {}, options) {
        return __asyncGenerator(this, arguments, function* listSecurityMonitoringSignalsWithPagination_1() {
            let pageSize = 10;
            if (param.pageLimit !== undefined) {
                pageSize = param.pageLimit;
            }
            param.pageLimit = pageSize;
            while (true) {
                const requestContext = yield __await(this.requestFactory.listSecurityMonitoringSignals(param.filterQuery, param.filterFrom, param.filterTo, param.sort, param.pageCursor, param.pageLimit, options));
                const responseContext = yield __await(this.configuration.httpApi.send(requestContext));
                const response = yield __await(this.responseProcessor.listSecurityMonitoringSignals(responseContext));
                const responseData = response.data;
                if (responseData === undefined) {
                    break;
                }
                const results = responseData;
                for (const item of results) {
                    yield yield __await(item);
                }
                if (results.length < pageSize) {
                    break;
                }
                const cursorMeta = response.meta;
                if (cursorMeta === undefined) {
                    break;
                }
                const cursorMetaPage = cursorMeta.page;
                if (cursorMetaPage === undefined) {
                    break;
                }
                const cursorMetaPageAfter = cursorMetaPage.after;
                if (cursorMetaPageAfter === undefined) {
                    break;
                }
                param.pageCursor = cursorMetaPageAfter;
            }
        });
    }
    /**
     * Returns security signals that match a search query.
     * Both this endpoint and the GET endpoint can be used interchangeably for listing
     * security signals.
     * @param param The request object
     */
    searchSecurityMonitoringSignals(param = {}, options) {
        const requestContextPromise = this.requestFactory.searchSecurityMonitoringSignals(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.searchSecurityMonitoringSignals(responseContext);
            });
        });
    }
    /**
     * Provide a paginated version of searchSecurityMonitoringSignals returning a generator with all the items.
     */
    searchSecurityMonitoringSignalsWithPagination(param = {}, options) {
        return __asyncGenerator(this, arguments, function* searchSecurityMonitoringSignalsWithPagination_1() {
            let pageSize = 10;
            if (param.body === undefined) {
                param.body = new SecurityMonitoringSignalListRequest_1.SecurityMonitoringSignalListRequest();
            }
            if (param.body.page === undefined) {
                param.body.page = new SecurityMonitoringSignalListRequestPage_1.SecurityMonitoringSignalListRequestPage();
            }
            if (param.body.page.limit !== undefined) {
                pageSize = param.body.page.limit;
            }
            param.body.page.limit = pageSize;
            while (true) {
                const requestContext = yield __await(this.requestFactory.searchSecurityMonitoringSignals(param.body, options));
                const responseContext = yield __await(this.configuration.httpApi.send(requestContext));
                const response = yield __await(this.responseProcessor.searchSecurityMonitoringSignals(responseContext));
                const responseData = response.data;
                if (responseData === undefined) {
                    break;
                }
                const results = responseData;
                for (const item of results) {
                    yield yield __await(item);
                }
                if (results.length < pageSize) {
                    break;
                }
                const cursorMeta = response.meta;
                if (cursorMeta === undefined) {
                    break;
                }
                const cursorMetaPage = cursorMeta.page;
                if (cursorMetaPage === undefined) {
                    break;
                }
                const cursorMetaPageAfter = cursorMetaPage.after;
                if (cursorMetaPageAfter === undefined) {
                    break;
                }
                param.body.page.cursor = cursorMetaPageAfter;
            }
        });
    }
    /**
     * Update a specific security filter.
     * Returns the security filter object when the request is successful.
     * @param param The request object
     */
    updateSecurityFilter(param, options) {
        const requestContextPromise = this.requestFactory.updateSecurityFilter(param.securityFilterId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateSecurityFilter(responseContext);
            });
        });
    }
    /**
     * Update an existing rule. When updating `cases`, `queries` or `options`, the whole field
     * must be included. For example, when modifying a query all queries must be included.
     * Default rules can only be updated to be enabled and to change notifications.
     * @param param The request object
     */
    updateSecurityMonitoringRule(param, options) {
        const requestContextPromise = this.requestFactory.updateSecurityMonitoringRule(param.ruleId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateSecurityMonitoringRule(responseContext);
            });
        });
    }
}
exports.SecurityMonitoringApi = SecurityMonitoringApi;
//# sourceMappingURL=SecurityMonitoringApi.js.map

/***/ }),

/***/ 1235:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerApi = exports.SensitiveDataScannerApiResponseProcessor = exports.SensitiveDataScannerApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class SensitiveDataScannerApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createScanningGroup(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createScanningGroup");
            }
            // Path Params
            const localVarPath = "/api/v2/sensitive-data-scanner/config/groups";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SensitiveDataScannerApi.createScanningGroup").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SensitiveDataScannerGroupCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createScanningRule(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createScanningRule");
            }
            // Path Params
            const localVarPath = "/api/v2/sensitive-data-scanner/config/rules";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SensitiveDataScannerApi.createScanningRule").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SensitiveDataScannerRuleCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteScanningGroup(groupId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new baseapi_1.RequiredError("groupId", "deleteScanningGroup");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "deleteScanningGroup");
            }
            // Path Params
            const localVarPath = "/api/v2/sensitive-data-scanner/config/groups/{group_id}".replace("{group_id}", encodeURIComponent(String(groupId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SensitiveDataScannerApi.deleteScanningGroup").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SensitiveDataScannerGroupDeleteRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteScanningRule(ruleId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new baseapi_1.RequiredError("ruleId", "deleteScanningRule");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "deleteScanningRule");
            }
            // Path Params
            const localVarPath = "/api/v2/sensitive-data-scanner/config/rules/{rule_id}".replace("{rule_id}", encodeURIComponent(String(ruleId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SensitiveDataScannerApi.deleteScanningRule").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SensitiveDataScannerRuleDeleteRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listScanningGroups(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/sensitive-data-scanner/config";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SensitiveDataScannerApi.listScanningGroups").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listStandardPatterns(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/sensitive-data-scanner/config/standard-patterns";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SensitiveDataScannerApi.listStandardPatterns").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    reorderScanningGroups(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "reorderScanningGroups");
            }
            // Path Params
            const localVarPath = "/api/v2/sensitive-data-scanner/config";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SensitiveDataScannerApi.reorderScanningGroups").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SensitiveDataScannerConfigRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateScanningGroup(groupId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new baseapi_1.RequiredError("groupId", "updateScanningGroup");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateScanningGroup");
            }
            // Path Params
            const localVarPath = "/api/v2/sensitive-data-scanner/config/groups/{group_id}".replace("{group_id}", encodeURIComponent(String(groupId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SensitiveDataScannerApi.updateScanningGroup").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SensitiveDataScannerGroupUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateScanningRule(ruleId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new baseapi_1.RequiredError("ruleId", "updateScanningRule");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateScanningRule");
            }
            // Path Params
            const localVarPath = "/api/v2/sensitive-data-scanner/config/rules/{rule_id}".replace("{rule_id}", encodeURIComponent(String(ruleId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.SensitiveDataScannerApi.updateScanningRule").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "SensitiveDataScannerRuleUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.SensitiveDataScannerApiRequestFactory = SensitiveDataScannerApiRequestFactory;
class SensitiveDataScannerApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createScanningGroup
     * @throws ApiException if the response code was not in [200, 299]
     */
    createScanningGroup(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SensitiveDataScannerCreateGroupResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SensitiveDataScannerCreateGroupResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createScanningRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    createScanningRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SensitiveDataScannerCreateRuleResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SensitiveDataScannerCreateRuleResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteScanningGroup
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteScanningGroup(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SensitiveDataScannerGroupDeleteResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SensitiveDataScannerGroupDeleteResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteScanningRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteScanningRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SensitiveDataScannerRuleDeleteResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SensitiveDataScannerRuleDeleteResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listScanningGroups
     * @throws ApiException if the response code was not in [200, 299]
     */
    listScanningGroups(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SensitiveDataScannerGetConfigResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SensitiveDataScannerGetConfigResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listStandardPatterns
     * @throws ApiException if the response code was not in [200, 299]
     */
    listStandardPatterns(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SensitiveDataScannerStandardPatternsResponseData");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SensitiveDataScannerStandardPatternsResponseData", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to reorderScanningGroups
     * @throws ApiException if the response code was not in [200, 299]
     */
    reorderScanningGroups(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SensitiveDataScannerReorderGroupsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SensitiveDataScannerReorderGroupsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateScanningGroup
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateScanningGroup(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SensitiveDataScannerGroupUpdateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SensitiveDataScannerGroupUpdateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateScanningRule
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateScanningRule(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SensitiveDataScannerRuleUpdateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "SensitiveDataScannerRuleUpdateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.SensitiveDataScannerApiResponseProcessor = SensitiveDataScannerApiResponseProcessor;
class SensitiveDataScannerApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory ||
                new SensitiveDataScannerApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new SensitiveDataScannerApiResponseProcessor();
    }
    /**
     * Create a scanning group.
     * The request MAY include a configuration relationship.
     * A rules relationship can be omitted entirely, but if it is included it MUST be
     * null or an empty array (rules cannot be created at the same time).
     * The new group will be ordered last within the configuration.
     * @param param The request object
     */
    createScanningGroup(param, options) {
        const requestContextPromise = this.requestFactory.createScanningGroup(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createScanningGroup(responseContext);
            });
        });
    }
    /**
     * Create a scanning rule in a sensitive data scanner group, ordered last.
     * The posted rule MUST include a group relationship.
     * It MUST include either a standard_pattern relationship or a regex attribute, but not both.
     * If included_attributes is empty or missing, we will scan all attributes except
     * excluded_attributes. If both are missing, we will scan the whole event.
     * @param param The request object
     */
    createScanningRule(param, options) {
        const requestContextPromise = this.requestFactory.createScanningRule(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createScanningRule(responseContext);
            });
        });
    }
    /**
     * Delete a given group.
     * @param param The request object
     */
    deleteScanningGroup(param, options) {
        const requestContextPromise = this.requestFactory.deleteScanningGroup(param.groupId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteScanningGroup(responseContext);
            });
        });
    }
    /**
     * Delete a given rule.
     * @param param The request object
     */
    deleteScanningRule(param, options) {
        const requestContextPromise = this.requestFactory.deleteScanningRule(param.ruleId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteScanningRule(responseContext);
            });
        });
    }
    /**
     * List all the Scanning groups in your organization.
     * @param param The request object
     */
    listScanningGroups(options) {
        const requestContextPromise = this.requestFactory.listScanningGroups(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listScanningGroups(responseContext);
            });
        });
    }
    /**
     * Returns all standard patterns.
     * @param param The request object
     */
    listStandardPatterns(options) {
        const requestContextPromise = this.requestFactory.listStandardPatterns(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listStandardPatterns(responseContext);
            });
        });
    }
    /**
     * Reorder the list of groups.
     * @param param The request object
     */
    reorderScanningGroups(param, options) {
        const requestContextPromise = this.requestFactory.reorderScanningGroups(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.reorderScanningGroups(responseContext);
            });
        });
    }
    /**
     * Update a group, including the order of the rules.
     * Rules within the group are reordered by including a rules relationship. If the rules
     * relationship is present, its data section MUST contain linkages for all of the rules
     * currently in the group, and MUST NOT contain any others.
     * @param param The request object
     */
    updateScanningGroup(param, options) {
        const requestContextPromise = this.requestFactory.updateScanningGroup(param.groupId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateScanningGroup(responseContext);
            });
        });
    }
    /**
     * Update a scanning rule.
     * The request body MUST NOT include a standard_pattern relationship, as that relationship
     * is non-editable. Trying to edit the regex attribute of a rule with a standard_pattern
     * relationship will also result in an error.
     * @param param The request object
     */
    updateScanningRule(param, options) {
        const requestContextPromise = this.requestFactory.updateScanningRule(param.ruleId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateScanningRule(responseContext);
            });
        });
    }
}
exports.SensitiveDataScannerApi = SensitiveDataScannerApi;
//# sourceMappingURL=SensitiveDataScannerApi.js.map

/***/ }),

/***/ 1204:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceAccountsApi = exports.ServiceAccountsApiResponseProcessor = exports.ServiceAccountsApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class ServiceAccountsApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createServiceAccount(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createServiceAccount");
            }
            // Path Params
            const localVarPath = "/api/v2/service_accounts";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ServiceAccountsApi.createServiceAccount").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "ServiceAccountCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    createServiceAccountApplicationKey(serviceAccountId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'serviceAccountId' is not null or undefined
            if (serviceAccountId === null || serviceAccountId === undefined) {
                throw new baseapi_1.RequiredError("serviceAccountId", "createServiceAccountApplicationKey");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createServiceAccountApplicationKey");
            }
            // Path Params
            const localVarPath = "/api/v2/service_accounts/{service_account_id}/application_keys".replace("{service_account_id}", encodeURIComponent(String(serviceAccountId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ServiceAccountsApi.createServiceAccountApplicationKey").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "ApplicationKeyCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteServiceAccountApplicationKey(serviceAccountId, appKeyId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'serviceAccountId' is not null or undefined
            if (serviceAccountId === null || serviceAccountId === undefined) {
                throw new baseapi_1.RequiredError("serviceAccountId", "deleteServiceAccountApplicationKey");
            }
            // verify required parameter 'appKeyId' is not null or undefined
            if (appKeyId === null || appKeyId === undefined) {
                throw new baseapi_1.RequiredError("appKeyId", "deleteServiceAccountApplicationKey");
            }
            // Path Params
            const localVarPath = "/api/v2/service_accounts/{service_account_id}/application_keys/{app_key_id}"
                .replace("{service_account_id}", encodeURIComponent(String(serviceAccountId)))
                .replace("{app_key_id}", encodeURIComponent(String(appKeyId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ServiceAccountsApi.deleteServiceAccountApplicationKey").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getServiceAccountApplicationKey(serviceAccountId, appKeyId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'serviceAccountId' is not null or undefined
            if (serviceAccountId === null || serviceAccountId === undefined) {
                throw new baseapi_1.RequiredError("serviceAccountId", "getServiceAccountApplicationKey");
            }
            // verify required parameter 'appKeyId' is not null or undefined
            if (appKeyId === null || appKeyId === undefined) {
                throw new baseapi_1.RequiredError("appKeyId", "getServiceAccountApplicationKey");
            }
            // Path Params
            const localVarPath = "/api/v2/service_accounts/{service_account_id}/application_keys/{app_key_id}"
                .replace("{service_account_id}", encodeURIComponent(String(serviceAccountId)))
                .replace("{app_key_id}", encodeURIComponent(String(appKeyId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ServiceAccountsApi.getServiceAccountApplicationKey").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listServiceAccountApplicationKeys(serviceAccountId, pageSize, pageNumber, sort, filter, filterCreatedAtStart, filterCreatedAtEnd, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'serviceAccountId' is not null or undefined
            if (serviceAccountId === null || serviceAccountId === undefined) {
                throw new baseapi_1.RequiredError("serviceAccountId", "listServiceAccountApplicationKeys");
            }
            // Path Params
            const localVarPath = "/api/v2/service_accounts/{service_account_id}/application_keys".replace("{service_account_id}", encodeURIComponent(String(serviceAccountId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ServiceAccountsApi.listServiceAccountApplicationKeys").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page[size]", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "number", "int64"));
            }
            if (pageNumber !== undefined) {
                requestContext.setQueryParam("page[number]", ObjectSerializer_1.ObjectSerializer.serialize(pageNumber, "number", "int64"));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "ApplicationKeysSort", ""));
            }
            if (filter !== undefined) {
                requestContext.setQueryParam("filter", ObjectSerializer_1.ObjectSerializer.serialize(filter, "string", ""));
            }
            if (filterCreatedAtStart !== undefined) {
                requestContext.setQueryParam("filter[created_at][start]", ObjectSerializer_1.ObjectSerializer.serialize(filterCreatedAtStart, "string", ""));
            }
            if (filterCreatedAtEnd !== undefined) {
                requestContext.setQueryParam("filter[created_at][end]", ObjectSerializer_1.ObjectSerializer.serialize(filterCreatedAtEnd, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateServiceAccountApplicationKey(serviceAccountId, appKeyId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'serviceAccountId' is not null or undefined
            if (serviceAccountId === null || serviceAccountId === undefined) {
                throw new baseapi_1.RequiredError("serviceAccountId", "updateServiceAccountApplicationKey");
            }
            // verify required parameter 'appKeyId' is not null or undefined
            if (appKeyId === null || appKeyId === undefined) {
                throw new baseapi_1.RequiredError("appKeyId", "updateServiceAccountApplicationKey");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateServiceAccountApplicationKey");
            }
            // Path Params
            const localVarPath = "/api/v2/service_accounts/{service_account_id}/application_keys/{app_key_id}"
                .replace("{service_account_id}", encodeURIComponent(String(serviceAccountId)))
                .replace("{app_key_id}", encodeURIComponent(String(appKeyId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ServiceAccountsApi.updateServiceAccountApplicationKey").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "ApplicationKeyUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.ServiceAccountsApiRequestFactory = ServiceAccountsApiRequestFactory;
class ServiceAccountsApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createServiceAccount
     * @throws ApiException if the response code was not in [200, 299]
     */
    createServiceAccount(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createServiceAccountApplicationKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    createServiceAccountApplicationKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ApplicationKeyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteServiceAccountApplicationKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteServiceAccountApplicationKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getServiceAccountApplicationKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    getServiceAccountApplicationKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "PartialApplicationKeyResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "PartialApplicationKeyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listServiceAccountApplicationKeys
     * @throws ApiException if the response code was not in [200, 299]
     */
    listServiceAccountApplicationKeys(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ListApplicationKeysResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ListApplicationKeysResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateServiceAccountApplicationKey
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateServiceAccountApplicationKey(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "PartialApplicationKeyResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "PartialApplicationKeyResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.ServiceAccountsApiResponseProcessor = ServiceAccountsApiResponseProcessor;
class ServiceAccountsApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new ServiceAccountsApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new ServiceAccountsApiResponseProcessor();
    }
    /**
     * Create a service account for your organization.
     * @param param The request object
     */
    createServiceAccount(param, options) {
        const requestContextPromise = this.requestFactory.createServiceAccount(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createServiceAccount(responseContext);
            });
        });
    }
    /**
     * Create an application key for this service account.
     * @param param The request object
     */
    createServiceAccountApplicationKey(param, options) {
        const requestContextPromise = this.requestFactory.createServiceAccountApplicationKey(param.serviceAccountId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createServiceAccountApplicationKey(responseContext);
            });
        });
    }
    /**
     * Delete an application key owned by this service account.
     * @param param The request object
     */
    deleteServiceAccountApplicationKey(param, options) {
        const requestContextPromise = this.requestFactory.deleteServiceAccountApplicationKey(param.serviceAccountId, param.appKeyId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteServiceAccountApplicationKey(responseContext);
            });
        });
    }
    /**
     * Get an application key owned by this service account.
     * @param param The request object
     */
    getServiceAccountApplicationKey(param, options) {
        const requestContextPromise = this.requestFactory.getServiceAccountApplicationKey(param.serviceAccountId, param.appKeyId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getServiceAccountApplicationKey(responseContext);
            });
        });
    }
    /**
     * List all application keys available for this service account.
     * @param param The request object
     */
    listServiceAccountApplicationKeys(param, options) {
        const requestContextPromise = this.requestFactory.listServiceAccountApplicationKeys(param.serviceAccountId, param.pageSize, param.pageNumber, param.sort, param.filter, param.filterCreatedAtStart, param.filterCreatedAtEnd, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listServiceAccountApplicationKeys(responseContext);
            });
        });
    }
    /**
     * Edit an application key owned by this service account.
     * @param param The request object
     */
    updateServiceAccountApplicationKey(param, options) {
        const requestContextPromise = this.requestFactory.updateServiceAccountApplicationKey(param.serviceAccountId, param.appKeyId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateServiceAccountApplicationKey(responseContext);
            });
        });
    }
}
exports.ServiceAccountsApi = ServiceAccountsApi;
//# sourceMappingURL=ServiceAccountsApi.js.map

/***/ }),

/***/ 58864:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionApi = exports.ServiceDefinitionApiResponseProcessor = exports.ServiceDefinitionApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class ServiceDefinitionApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createOrUpdateServiceDefinitions(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createOrUpdateServiceDefinitions");
            }
            // Path Params
            const localVarPath = "/api/v2/services/definitions";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ServiceDefinitionApi.createOrUpdateServiceDefinitions").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "ServiceDefinitionsCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    deleteServiceDefinition(serviceName, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'serviceName' is not null or undefined
            if (serviceName === null || serviceName === undefined) {
                throw new baseapi_1.RequiredError("serviceName", "deleteServiceDefinition");
            }
            // Path Params
            const localVarPath = "/api/v2/services/definitions/{service_name}".replace("{service_name}", encodeURIComponent(String(serviceName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ServiceDefinitionApi.deleteServiceDefinition").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getServiceDefinition(serviceName, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'serviceName' is not null or undefined
            if (serviceName === null || serviceName === undefined) {
                throw new baseapi_1.RequiredError("serviceName", "getServiceDefinition");
            }
            // Path Params
            const localVarPath = "/api/v2/services/definitions/{service_name}".replace("{service_name}", encodeURIComponent(String(serviceName)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ServiceDefinitionApi.getServiceDefinition").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listServiceDefinitions(_options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/services/definitions";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.ServiceDefinitionApi.listServiceDefinitions").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.ServiceDefinitionApiRequestFactory = ServiceDefinitionApiRequestFactory;
class ServiceDefinitionApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createOrUpdateServiceDefinitions
     * @throws ApiException if the response code was not in [200, 299]
     */
    createOrUpdateServiceDefinitions(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ServiceDefinitionCreateResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 409 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ServiceDefinitionCreateResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteServiceDefinition
     * @throws ApiException if the response code was not in [200, 299]
     */
    deleteServiceDefinition(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getServiceDefinition
     * @throws ApiException if the response code was not in [200, 299]
     */
    getServiceDefinition(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ServiceDefinitionGetResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 409 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ServiceDefinitionGetResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listServiceDefinitions
     * @throws ApiException if the response code was not in [200, 299]
     */
    listServiceDefinitions(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ServiceDefinitionsListResponse");
                return body;
            }
            if (response.httpStatusCode == 403 || response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "ServiceDefinitionsListResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.ServiceDefinitionApiResponseProcessor = ServiceDefinitionApiResponseProcessor;
class ServiceDefinitionApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new ServiceDefinitionApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new ServiceDefinitionApiResponseProcessor();
    }
    /**
     * Create or update service definition in the Datadog Service Catalog.
     * @param param The request object
     */
    createOrUpdateServiceDefinitions(param, options) {
        const requestContextPromise = this.requestFactory.createOrUpdateServiceDefinitions(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createOrUpdateServiceDefinitions(responseContext);
            });
        });
    }
    /**
     * Delete a single service definition in the Datadog Service Catalog.
     * @param param The request object
     */
    deleteServiceDefinition(param, options) {
        const requestContextPromise = this.requestFactory.deleteServiceDefinition(param.serviceName, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.deleteServiceDefinition(responseContext);
            });
        });
    }
    /**
     * Get a single service definition from the Datadog Service Catalog.
     * @param param The request object
     */
    getServiceDefinition(param, options) {
        const requestContextPromise = this.requestFactory.getServiceDefinition(param.serviceName, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getServiceDefinition(responseContext);
            });
        });
    }
    /**
     * Get a list of all service definitions from the Datadog Service Catalog.
     * @param param The request object
     */
    listServiceDefinitions(options) {
        const requestContextPromise = this.requestFactory.listServiceDefinitions(options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listServiceDefinitions(responseContext);
            });
        });
    }
}
exports.ServiceDefinitionApi = ServiceDefinitionApi;
//# sourceMappingURL=ServiceDefinitionApi.js.map

/***/ }),

/***/ 20563:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageMeteringApi = exports.UsageMeteringApiResponseProcessor = exports.UsageMeteringApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class UsageMeteringApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    getCostByOrg(startMonth, endMonth, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startMonth' is not null or undefined
            if (startMonth === null || startMonth === undefined) {
                throw new baseapi_1.RequiredError("startMonth", "getCostByOrg");
            }
            // Path Params
            const localVarPath = "/api/v2/usage/cost_by_org";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.UsageMeteringApi.getCostByOrg").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startMonth !== undefined) {
                requestContext.setQueryParam("start_month", ObjectSerializer_1.ObjectSerializer.serialize(startMonth, "Date", "date-time"));
            }
            if (endMonth !== undefined) {
                requestContext.setQueryParam("end_month", ObjectSerializer_1.ObjectSerializer.serialize(endMonth, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getEstimatedCostByOrg(view, startMonth, endMonth, startDate, endDate, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/usage/estimated_cost";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.UsageMeteringApi.getEstimatedCostByOrg").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (view !== undefined) {
                requestContext.setQueryParam("view", ObjectSerializer_1.ObjectSerializer.serialize(view, "string", ""));
            }
            if (startMonth !== undefined) {
                requestContext.setQueryParam("start_month", ObjectSerializer_1.ObjectSerializer.serialize(startMonth, "Date", "date-time"));
            }
            if (endMonth !== undefined) {
                requestContext.setQueryParam("end_month", ObjectSerializer_1.ObjectSerializer.serialize(endMonth, "Date", "date-time"));
            }
            if (startDate !== undefined) {
                requestContext.setQueryParam("start_date", ObjectSerializer_1.ObjectSerializer.serialize(startDate, "Date", "date-time"));
            }
            if (endDate !== undefined) {
                requestContext.setQueryParam("end_date", ObjectSerializer_1.ObjectSerializer.serialize(endDate, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getHistoricalCostByOrg(startMonth, view, endMonth, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startMonth' is not null or undefined
            if (startMonth === null || startMonth === undefined) {
                throw new baseapi_1.RequiredError("startMonth", "getHistoricalCostByOrg");
            }
            // Path Params
            const localVarPath = "/api/v2/usage/historical_cost";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.UsageMeteringApi.getHistoricalCostByOrg").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (view !== undefined) {
                requestContext.setQueryParam("view", ObjectSerializer_1.ObjectSerializer.serialize(view, "string", ""));
            }
            if (startMonth !== undefined) {
                requestContext.setQueryParam("start_month", ObjectSerializer_1.ObjectSerializer.serialize(startMonth, "Date", "date-time"));
            }
            if (endMonth !== undefined) {
                requestContext.setQueryParam("end_month", ObjectSerializer_1.ObjectSerializer.serialize(endMonth, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getHourlyUsage(filterTimestampStart, filterProductFamilies, filterTimestampEnd, filterIncludeDescendants, filterVersions, pageLimit, pageNextRecordId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'filterTimestampStart' is not null or undefined
            if (filterTimestampStart === null || filterTimestampStart === undefined) {
                throw new baseapi_1.RequiredError("filterTimestampStart", "getHourlyUsage");
            }
            // verify required parameter 'filterProductFamilies' is not null or undefined
            if (filterProductFamilies === null || filterProductFamilies === undefined) {
                throw new baseapi_1.RequiredError("filterProductFamilies", "getHourlyUsage");
            }
            // Path Params
            const localVarPath = "/api/v2/usage/hourly_usage";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.UsageMeteringApi.getHourlyUsage").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (filterTimestampStart !== undefined) {
                requestContext.setQueryParam("filter[timestamp][start]", ObjectSerializer_1.ObjectSerializer.serialize(filterTimestampStart, "Date", "date-time"));
            }
            if (filterTimestampEnd !== undefined) {
                requestContext.setQueryParam("filter[timestamp][end]", ObjectSerializer_1.ObjectSerializer.serialize(filterTimestampEnd, "Date", "date-time"));
            }
            if (filterProductFamilies !== undefined) {
                requestContext.setQueryParam("filter[product_families]", ObjectSerializer_1.ObjectSerializer.serialize(filterProductFamilies, "string", ""));
            }
            if (filterIncludeDescendants !== undefined) {
                requestContext.setQueryParam("filter[include_descendants]", ObjectSerializer_1.ObjectSerializer.serialize(filterIncludeDescendants, "boolean", ""));
            }
            if (filterVersions !== undefined) {
                requestContext.setQueryParam("filter[versions]", ObjectSerializer_1.ObjectSerializer.serialize(filterVersions, "string", ""));
            }
            if (pageLimit !== undefined) {
                requestContext.setQueryParam("page[limit]", ObjectSerializer_1.ObjectSerializer.serialize(pageLimit, "number", "int32"));
            }
            if (pageNextRecordId !== undefined) {
                requestContext.setQueryParam("page[next_record_id]", ObjectSerializer_1.ObjectSerializer.serialize(pageNextRecordId, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageApplicationSecurityMonitoring(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageApplicationSecurityMonitoring");
            }
            // Path Params
            const localVarPath = "/api/v2/usage/application_security";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.UsageMeteringApi.getUsageApplicationSecurityMonitoring").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageLambdaTracedInvocations(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageLambdaTracedInvocations");
            }
            // Path Params
            const localVarPath = "/api/v2/usage/lambda_traced_invocations";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.UsageMeteringApi.getUsageLambdaTracedInvocations").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUsageObservabilityPipelines(startHr, endHr, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'startHr' is not null or undefined
            if (startHr === null || startHr === undefined) {
                throw new baseapi_1.RequiredError("startHr", "getUsageObservabilityPipelines");
            }
            // Path Params
            const localVarPath = "/api/v2/usage/observability_pipelines";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.UsageMeteringApi.getUsageObservabilityPipelines").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json;datetime-format=rfc3339");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (startHr !== undefined) {
                requestContext.setQueryParam("start_hr", ObjectSerializer_1.ObjectSerializer.serialize(startHr, "Date", "date-time"));
            }
            if (endHr !== undefined) {
                requestContext.setQueryParam("end_hr", ObjectSerializer_1.ObjectSerializer.serialize(endHr, "Date", "date-time"));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.UsageMeteringApiRequestFactory = UsageMeteringApiRequestFactory;
class UsageMeteringApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getCostByOrg
     * @throws ApiException if the response code was not in [200, 299]
     */
    getCostByOrg(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CostByOrgResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CostByOrgResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getEstimatedCostByOrg
     * @throws ApiException if the response code was not in [200, 299]
     */
    getEstimatedCostByOrg(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CostByOrgResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CostByOrgResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getHistoricalCostByOrg
     * @throws ApiException if the response code was not in [200, 299]
     */
    getHistoricalCostByOrg(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CostByOrgResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "CostByOrgResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getHourlyUsage
     * @throws ApiException if the response code was not in [200, 299]
     */
    getHourlyUsage(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "HourlyUsageResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "HourlyUsageResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageApplicationSecurityMonitoring
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageApplicationSecurityMonitoring(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageApplicationSecurityMonitoringResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageApplicationSecurityMonitoringResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageLambdaTracedInvocations
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageLambdaTracedInvocations(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageLambdaTracedInvocationsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageLambdaTracedInvocationsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUsageObservabilityPipelines
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUsageObservabilityPipelines(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageObservabilityPipelinesResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsageObservabilityPipelinesResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.UsageMeteringApiResponseProcessor = UsageMeteringApiResponseProcessor;
class UsageMeteringApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new UsageMeteringApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new UsageMeteringApiResponseProcessor();
    }
    /**
     * Get cost across multi-org account.
     * Cost by org data for a given month becomes available no later than the 16th of the following month.
     * **Note:** This endpoint has been deprecated. Please use the new endpoint
     * [`/historical_cost`](https://docs.datadoghq.com/api/latest/usage-metering/#get-historical-cost-across-your-account)
     * instead.
     * @param param The request object
     */
    getCostByOrg(param, options) {
        const requestContextPromise = this.requestFactory.getCostByOrg(param.startMonth, param.endMonth, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getCostByOrg(responseContext);
            });
        });
    }
    /**
     * Get estimated cost across multi-org and single root-org accounts.
     * Estimated cost data is only available for the current month and previous month
     * and is delayed by up to 72 hours from when it was incurred.
     * To access historical costs prior to this, use the `/historical_cost` endpoint.
     * @param param The request object
     */
    getEstimatedCostByOrg(param = {}, options) {
        const requestContextPromise = this.requestFactory.getEstimatedCostByOrg(param.view, param.startMonth, param.endMonth, param.startDate, param.endDate, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getEstimatedCostByOrg(responseContext);
            });
        });
    }
    /**
     * Get historical cost across multi-org and single root-org accounts.
     * Cost data for a given month becomes available no later than the 16th of the following month.
     * @param param The request object
     */
    getHistoricalCostByOrg(param, options) {
        const requestContextPromise = this.requestFactory.getHistoricalCostByOrg(param.startMonth, param.view, param.endMonth, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getHistoricalCostByOrg(responseContext);
            });
        });
    }
    /**
     * Get hourly usage by product family.
     * @param param The request object
     */
    getHourlyUsage(param, options) {
        const requestContextPromise = this.requestFactory.getHourlyUsage(param.filterTimestampStart, param.filterProductFamilies, param.filterTimestampEnd, param.filterIncludeDescendants, param.filterVersions, param.pageLimit, param.pageNextRecordId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getHourlyUsage(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for application security .
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family)
     * @param param The request object
     */
    getUsageApplicationSecurityMonitoring(param, options) {
        const requestContextPromise = this.requestFactory.getUsageApplicationSecurityMonitoring(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageApplicationSecurityMonitoring(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for lambda traced invocations.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family)
     * @param param The request object
     */
    getUsageLambdaTracedInvocations(param, options) {
        const requestContextPromise = this.requestFactory.getUsageLambdaTracedInvocations(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageLambdaTracedInvocations(responseContext);
            });
        });
    }
    /**
     * Get hourly usage for observability pipelines.
     * **Note:** hourly usage data for all products is now available in the [Get hourly usage by product family API](https://docs.datadoghq.com/api/latest/usage-metering/#get-hourly-usage-by-product-family)
     * @param param The request object
     */
    getUsageObservabilityPipelines(param, options) {
        const requestContextPromise = this.requestFactory.getUsageObservabilityPipelines(param.startHr, param.endHr, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUsageObservabilityPipelines(responseContext);
            });
        });
    }
}
exports.UsageMeteringApi = UsageMeteringApi;
//# sourceMappingURL=UsageMeteringApi.js.map

/***/ }),

/***/ 25328:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersApi = exports.UsersApiResponseProcessor = exports.UsersApiRequestFactory = void 0;
const baseapi_1 = __webpack_require__(62279);
const configuration_1 = __webpack_require__(34130);
const http_1 = __webpack_require__(69942);
const logger_1 = __webpack_require__(1141);
const ObjectSerializer_1 = __webpack_require__(47805);
const exception_1 = __webpack_require__(41001);
class UsersApiRequestFactory extends baseapi_1.BaseAPIRequestFactory {
    createUser(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "createUser");
            }
            // Path Params
            const localVarPath = "/api/v2/users";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.UsersApi.createUser").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "UserCreateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    disableUser(userId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new baseapi_1.RequiredError("userId", "disableUser");
            }
            // Path Params
            const localVarPath = "/api/v2/users/{user_id}".replace("{user_id}", encodeURIComponent(String(userId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.UsersApi.disableUser").makeRequestContext(localVarPath, http_1.HttpMethod.DELETE);
            requestContext.setHeaderParam("Accept", "*/*");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getInvitation(userInvitationUuid, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'userInvitationUuid' is not null or undefined
            if (userInvitationUuid === null || userInvitationUuid === undefined) {
                throw new baseapi_1.RequiredError("userInvitationUuid", "getInvitation");
            }
            // Path Params
            const localVarPath = "/api/v2/user_invitations/{user_invitation_uuid}".replace("{user_invitation_uuid}", encodeURIComponent(String(userInvitationUuid)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.UsersApi.getInvitation").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    getUser(userId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new baseapi_1.RequiredError("userId", "getUser");
            }
            // Path Params
            const localVarPath = "/api/v2/users/{user_id}".replace("{user_id}", encodeURIComponent(String(userId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.UsersApi.getUser").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listUserOrganizations(userId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new baseapi_1.RequiredError("userId", "listUserOrganizations");
            }
            // Path Params
            const localVarPath = "/api/v2/users/{user_id}/orgs".replace("{user_id}", encodeURIComponent(String(userId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.UsersApi.listUserOrganizations").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listUserPermissions(userId, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new baseapi_1.RequiredError("userId", "listUserPermissions");
            }
            // Path Params
            const localVarPath = "/api/v2/users/{user_id}/permissions".replace("{user_id}", encodeURIComponent(String(userId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.UsersApi.listUserPermissions").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    listUsers(pageSize, pageNumber, sort, sortDir, filter, filterStatus, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // Path Params
            const localVarPath = "/api/v2/users";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.UsersApi.listUsers").makeRequestContext(localVarPath, http_1.HttpMethod.GET);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Query Params
            if (pageSize !== undefined) {
                requestContext.setQueryParam("page[size]", ObjectSerializer_1.ObjectSerializer.serialize(pageSize, "number", "int64"));
            }
            if (pageNumber !== undefined) {
                requestContext.setQueryParam("page[number]", ObjectSerializer_1.ObjectSerializer.serialize(pageNumber, "number", "int64"));
            }
            if (sort !== undefined) {
                requestContext.setQueryParam("sort", ObjectSerializer_1.ObjectSerializer.serialize(sort, "string", ""));
            }
            if (sortDir !== undefined) {
                requestContext.setQueryParam("sort_dir", ObjectSerializer_1.ObjectSerializer.serialize(sortDir, "QuerySortOrder", ""));
            }
            if (filter !== undefined) {
                requestContext.setQueryParam("filter", ObjectSerializer_1.ObjectSerializer.serialize(filter, "string", ""));
            }
            if (filterStatus !== undefined) {
                requestContext.setQueryParam("filter[status]", ObjectSerializer_1.ObjectSerializer.serialize(filterStatus, "string", ""));
            }
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    sendInvitations(body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "sendInvitations");
            }
            // Path Params
            const localVarPath = "/api/v2/user_invitations";
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.UsersApi.sendInvitations").makeRequestContext(localVarPath, http_1.HttpMethod.POST);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "UserInvitationsRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
    updateUser(userId, body, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const _config = _options || this.configuration;
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new baseapi_1.RequiredError("userId", "updateUser");
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new baseapi_1.RequiredError("body", "updateUser");
            }
            // Path Params
            const localVarPath = "/api/v2/users/{user_id}".replace("{user_id}", encodeURIComponent(String(userId)));
            // Make Request Context
            const requestContext = (0, configuration_1.getServer)(_config, "v2.UsersApi.updateUser").makeRequestContext(localVarPath, http_1.HttpMethod.PATCH);
            requestContext.setHeaderParam("Accept", "application/json");
            requestContext.setHttpConfig(_config.httpConfig);
            // Body Params
            const contentType = ObjectSerializer_1.ObjectSerializer.getPreferredMediaType([
                "application/json",
            ]);
            requestContext.setHeaderParam("Content-Type", contentType);
            const serializedBody = ObjectSerializer_1.ObjectSerializer.stringify(ObjectSerializer_1.ObjectSerializer.serialize(body, "UserUpdateRequest", ""), contentType);
            requestContext.setBody(serializedBody);
            // Apply auth methods
            (0, configuration_1.applySecurityAuthentication)(_config, requestContext, [
                "AuthZ",
                "apiKeyAuth",
                "appKeyAuth",
            ]);
            return requestContext;
        });
    }
}
exports.UsersApiRequestFactory = UsersApiRequestFactory;
class UsersApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createUser
     * @throws ApiException if the response code was not in [200, 299]
     */
    createUser(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to disableUser
     * @throws ApiException if the response code was not in [200, 299]
     */
    disableUser(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 204) {
                return;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "void", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getInvitation
     * @throws ApiException if the response code was not in [200, 299]
     */
    getInvitation(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserInvitationResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserInvitationResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getUser
     * @throws ApiException if the response code was not in [200, 299]
     */
    getUser(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listUserOrganizations
     * @throws ApiException if the response code was not in [200, 299]
     */
    listUserOrganizations(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listUserPermissions
     * @throws ApiException if the response code was not in [200, 299]
     */
    listUserPermissions(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "PermissionsResponse");
                return body;
            }
            if (response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "PermissionsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listUsers
     * @throws ApiException if the response code was not in [200, 299]
     */
    listUsers(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsersResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UsersResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to sendInvitations
     * @throws ApiException if the response code was not in [200, 299]
     */
    sendInvitations(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 201) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserInvitationsResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserInvitationsResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to updateUser
     * @throws ApiException if the response code was not in [200, 299]
     */
    updateUser(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = ObjectSerializer_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
            if (response.httpStatusCode == 200) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserResponse");
                return body;
            }
            if (response.httpStatusCode == 400 ||
                response.httpStatusCode == 403 ||
                response.httpStatusCode == 404 ||
                response.httpStatusCode == 422 ||
                response.httpStatusCode == 429) {
                const bodyText = ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType);
                let body;
                try {
                    body = ObjectSerializer_1.ObjectSerializer.deserialize(bodyText, "APIErrorResponse");
                }
                catch (error) {
                    logger_1.logger.info(`Got error deserializing error: ${error}`);
                    throw new exception_1.ApiException(response.httpStatusCode, bodyText);
                }
                throw new exception_1.ApiException(response.httpStatusCode, body);
            }
            // Work around for missing responses in specification, e.g. for petstore.yaml
            if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
                const body = ObjectSerializer_1.ObjectSerializer.deserialize(ObjectSerializer_1.ObjectSerializer.parse(yield response.body.text(), contentType), "UserResponse", "");
                return body;
            }
            const body = (yield response.body.text()) || "";
            throw new exception_1.ApiException(response.httpStatusCode, 'Unknown API Status Code!\nBody: "' + body + '"');
        });
    }
}
exports.UsersApiResponseProcessor = UsersApiResponseProcessor;
class UsersApi {
    constructor(configuration, requestFactory, responseProcessor) {
        this.configuration = configuration;
        this.requestFactory =
            requestFactory || new UsersApiRequestFactory(configuration);
        this.responseProcessor =
            responseProcessor || new UsersApiResponseProcessor();
    }
    /**
     * Create a user for your organization.
     * @param param The request object
     */
    createUser(param, options) {
        const requestContextPromise = this.requestFactory.createUser(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.createUser(responseContext);
            });
        });
    }
    /**
     * Disable a user. Can only be used with an application key belonging
     * to an administrator user.
     * @param param The request object
     */
    disableUser(param, options) {
        const requestContextPromise = this.requestFactory.disableUser(param.userId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.disableUser(responseContext);
            });
        });
    }
    /**
     * Returns a single user invitation by its UUID.
     * @param param The request object
     */
    getInvitation(param, options) {
        const requestContextPromise = this.requestFactory.getInvitation(param.userInvitationUuid, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getInvitation(responseContext);
            });
        });
    }
    /**
     * Get a user in the organization specified by the users `user_id`.
     * @param param The request object
     */
    getUser(param, options) {
        const requestContextPromise = this.requestFactory.getUser(param.userId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.getUser(responseContext);
            });
        });
    }
    /**
     * Get a user organization. Returns the user information and all organizations
     * joined by this user.
     * @param param The request object
     */
    listUserOrganizations(param, options) {
        const requestContextPromise = this.requestFactory.listUserOrganizations(param.userId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listUserOrganizations(responseContext);
            });
        });
    }
    /**
     * Get a user permission set. Returns a list of the users permissions
     * granted by the associated user's roles.
     * @param param The request object
     */
    listUserPermissions(param, options) {
        const requestContextPromise = this.requestFactory.listUserPermissions(param.userId, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listUserPermissions(responseContext);
            });
        });
    }
    /**
     * Get the list of all users in the organization. This list includes
     * all users even if they are deactivated or unverified.
     * @param param The request object
     */
    listUsers(param = {}, options) {
        const requestContextPromise = this.requestFactory.listUsers(param.pageSize, param.pageNumber, param.sort, param.sortDir, param.filter, param.filterStatus, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.listUsers(responseContext);
            });
        });
    }
    /**
     * Sends emails to one or more users inviting them to join the organization.
     * @param param The request object
     */
    sendInvitations(param, options) {
        const requestContextPromise = this.requestFactory.sendInvitations(param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.sendInvitations(responseContext);
            });
        });
    }
    /**
     * Edit a user. Can only be used with an application key belonging
     * to an administrator user.
     * @param param The request object
     */
    updateUser(param, options) {
        const requestContextPromise = this.requestFactory.updateUser(param.userId, param.body, options);
        return requestContextPromise.then((requestContext) => {
            return this.configuration.httpApi
                .send(requestContext)
                .then((responseContext) => {
                return this.responseProcessor.updateUser(responseContext);
            });
        });
    }
}
exports.UsersApi = UsersApi;
//# sourceMappingURL=UsersApi.js.map

/***/ }),

/***/ 23687:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuditLogsEventAttributes = exports.AuditLogsEvent = exports.ApplicationKeyUpdateRequest = exports.ApplicationKeyUpdateData = exports.ApplicationKeyUpdateAttributes = exports.ApplicationKeyResponse = exports.ApplicationKeyRelationships = exports.ApplicationKeyCreateRequest = exports.ApplicationKeyCreateData = exports.ApplicationKeyCreateAttributes = exports.APIKeyUpdateRequest = exports.APIKeyUpdateData = exports.APIKeyUpdateAttributes = exports.APIKeysResponse = exports.APIKeyResponse = exports.APIKeyRelationships = exports.APIKeyCreateRequest = exports.APIKeyCreateData = exports.APIKeyCreateAttributes = exports.APIErrorResponse = exports.UsersApi = exports.UsageMeteringApi = exports.ServiceDefinitionApi = exports.ServiceAccountsApi = exports.SensitiveDataScannerApi = exports.SecurityMonitoringApi = exports.RolesApi = exports.RUMApi = exports.ProcessesApi = exports.OrganizationsApi = exports.OpsgenieIntegrationApi = exports.MonitorsApi = exports.MetricsApi = exports.LogsMetricsApi = exports.LogsArchivesApi = exports.LogsApi = exports.KeyManagementApi = exports.IncidentsApi = exports.IncidentTeamsApi = exports.IncidentServicesApi = exports.FastlyIntegrationApi = exports.EventsApi = exports.DashboardListsApi = exports.ConfluentCloudApi = exports.CloudflareIntegrationApi = exports.CloudWorkloadSecurityApi = exports.CIVisibilityTestsApi = exports.CIVisibilityPipelinesApi = exports.AuthNMappingsApi = exports.AuditApi = void 0;
exports.CIAppTestsBucketResponse = exports.CIAppTestsAnalyticsAggregateResponse = exports.CIAppTestsAggregationBucketsResponse = exports.CIAppTestsAggregateRequest = exports.CIAppTestEventsResponse = exports.CIAppTestEventsRequest = exports.CIAppTestEvent = exports.CIAppResponsePage = exports.CIAppResponseMetadataWithPagination = exports.CIAppResponseMetadata = exports.CIAppResponseLinks = exports.CIAppQueryPageOptions = exports.CIAppQueryOptions = exports.CIAppPipelinesQueryFilter = exports.CIAppPipelinesGroupBy = exports.CIAppPipelinesBucketResponse = exports.CIAppPipelinesAnalyticsAggregateResponse = exports.CIAppPipelinesAggregationBucketsResponse = exports.CIAppPipelinesAggregateRequest = exports.CIAppPipelineEventsResponse = exports.CIAppPipelineEventsRequest = exports.CIAppPipelineEvent = exports.CIAppGroupByHistogram = exports.CIAppEventAttributes = exports.CIAppCompute = exports.CIAppAggregateSort = exports.CIAppAggregateBucketValueTimeseriesPoint = exports.ChargebackBreakdown = exports.AuthNMappingUpdateRequest = exports.AuthNMappingUpdateRelationships = exports.AuthNMappingUpdateData = exports.AuthNMappingUpdateAttributes = exports.AuthNMappingsResponse = exports.AuthNMappingResponse = exports.AuthNMappingRelationships = exports.AuthNMappingCreateRequest = exports.AuthNMappingCreateRelationships = exports.AuthNMappingCreateData = exports.AuthNMappingCreateAttributes = exports.AuthNMappingAttributes = exports.AuthNMapping = exports.AuditLogsWarning = exports.AuditLogsSearchEventsRequest = exports.AuditLogsResponsePage = exports.AuditLogsResponseMetadata = exports.AuditLogsResponseLinks = exports.AuditLogsQueryPageOptions = exports.AuditLogsQueryOptions = exports.AuditLogsQueryFilter = exports.AuditLogsEventsResponse = void 0;
exports.CostByOrg = exports.ConfluentResourcesResponse = exports.ConfluentResourceResponseData = exports.ConfluentResourceResponseAttributes = exports.ConfluentResourceResponse = exports.ConfluentResourceRequestData = exports.ConfluentResourceRequestAttributes = exports.ConfluentResourceRequest = exports.ConfluentAccountUpdateRequestData = exports.ConfluentAccountUpdateRequestAttributes = exports.ConfluentAccountUpdateRequest = exports.ConfluentAccountsResponse = exports.ConfluentAccountResponseData = exports.ConfluentAccountResponseAttributes = exports.ConfluentAccountResponse = exports.ConfluentAccountResourceAttributes = exports.ConfluentAccountCreateRequestData = exports.ConfluentAccountCreateRequestAttributes = exports.ConfluentAccountCreateRequest = exports.CloudWorkloadSecurityAgentRuleUpdateRequest = exports.CloudWorkloadSecurityAgentRuleUpdaterAttributes = exports.CloudWorkloadSecurityAgentRuleUpdateData = exports.CloudWorkloadSecurityAgentRuleUpdateAttributes = exports.CloudWorkloadSecurityAgentRulesListResponse = exports.CloudWorkloadSecurityAgentRuleResponse = exports.CloudWorkloadSecurityAgentRuleData = exports.CloudWorkloadSecurityAgentRuleCreatorAttributes = exports.CloudWorkloadSecurityAgentRuleCreateRequest = exports.CloudWorkloadSecurityAgentRuleCreateData = exports.CloudWorkloadSecurityAgentRuleCreateAttributes = exports.CloudWorkloadSecurityAgentRuleAttributes = exports.CloudflareAccountUpdateRequestData = exports.CloudflareAccountUpdateRequestAttributes = exports.CloudflareAccountUpdateRequest = exports.CloudflareAccountsResponse = exports.CloudflareAccountResponseData = exports.CloudflareAccountResponseAttributes = exports.CloudflareAccountResponse = exports.CloudflareAccountCreateRequestData = exports.CloudflareAccountCreateRequestAttributes = exports.CloudflareAccountCreateRequest = exports.CloudConfigurationRuleOptions = exports.CloudConfigurationRuleCreatePayload = exports.CloudConfigurationRuleComplianceSignalOptions = exports.CloudConfigurationRuleCaseCreate = exports.CloudConfigurationRegoRule = exports.CloudConfigurationComplianceRuleOptions = exports.CIAppWarning = exports.CIAppTestsQueryFilter = exports.CIAppTestsGroupBy = void 0;
exports.FormulaLimit = exports.FastlyServicesResponse = exports.FastlyServiceResponse = exports.FastlyServiceRequest = exports.FastlyServiceData = exports.FastlyServiceAttributes = exports.FastlyService = exports.FastlyAccountUpdateRequestData = exports.FastlyAccountUpdateRequestAttributes = exports.FastlyAccountUpdateRequest = exports.FastlyAccountsResponse = exports.FastlyAccountResponseData = exports.FastlyAccountResponse = exports.FastlyAccountCreateRequestData = exports.FastlyAccountCreateRequestAttributes = exports.FastlyAccountCreateRequest = exports.FastlyAccounResponseAttributes = exports.EventsWarning = exports.EventsTimeseriesQuery = exports.EventsSearch = exports.EventsScalarQuery = exports.EventsResponseMetadataPage = exports.EventsResponseMetadata = exports.EventsRequestPage = exports.EventsQueryOptions = exports.EventsQueryFilter = exports.EventsListResponseLinks = exports.EventsListResponse = exports.EventsListRequest = exports.EventsGroupBySort = exports.EventsGroupBy = exports.EventsCompute = exports.EventResponseAttributes = exports.EventResponse = exports.EventAttributes = exports.Event = exports.DataScalarColumn = exports.DashboardListUpdateItemsResponse = exports.DashboardListUpdateItemsRequest = exports.DashboardListItems = exports.DashboardListItemResponse = exports.DashboardListItemRequest = exports.DashboardListItem = exports.DashboardListDeleteItemsResponse = exports.DashboardListDeleteItemsRequest = exports.DashboardListAddItemsResponse = exports.DashboardListAddItemsRequest = exports.Creator = exports.CostByOrgResponse = exports.CostByOrgAttributes = void 0;
exports.IncidentServiceCreateData = exports.IncidentServiceCreateAttributes = exports.IncidentSearchResponseUserFacetData = exports.IncidentSearchResponsePropertyFieldFacetData = exports.IncidentSearchResponseNumericFacetDataAggregates = exports.IncidentSearchResponseNumericFacetData = exports.IncidentSearchResponseIncidentsData = exports.IncidentSearchResponseFieldFacetData = exports.IncidentSearchResponseFacetsData = exports.IncidentSearchResponseData = exports.IncidentSearchResponseAttributes = exports.IncidentSearchResponse = exports.IncidentResponseRelationships = exports.IncidentResponseMetaPagination = exports.IncidentResponseMeta = exports.IncidentResponseData = exports.IncidentResponseAttributes = exports.IncidentResponse = exports.IncidentNotificationHandle = exports.IncidentFieldAttributesSingleValue = exports.IncidentFieldAttributesMultipleValue = exports.IncidentCreateRequest = exports.IncidentCreateRelationships = exports.IncidentCreateData = exports.IncidentCreateAttributes = exports.IncidentAttachmentUpdateResponse = exports.IncidentAttachmentUpdateRequest = exports.IncidentAttachmentUpdateData = exports.IncidentAttachmentsResponse = exports.IncidentAttachmentsPostmortemAttributesAttachmentObject = exports.IncidentAttachmentRelationships = exports.IncidentAttachmentPostmortemAttributes = exports.IncidentAttachmentLinkAttributesAttachmentObject = exports.IncidentAttachmentLinkAttributes = exports.IncidentAttachmentData = exports.IdPMetadataFormData = exports.HTTPLogItem = exports.HTTPLogErrors = exports.HTTPLogError = exports.HourlyUsageResponse = exports.HourlyUsagePagination = exports.HourlyUsageMetadata = exports.HourlyUsageMeasurement = exports.HourlyUsageAttributes = exports.HourlyUsage = exports.GroupScalarColumn = exports.FullApplicationKeyAttributes = exports.FullApplicationKey = exports.FullAPIKeyAttributes = exports.FullAPIKey = void 0;
exports.LogsArchiveIntegrationS3 = exports.LogsArchiveIntegrationGCS = exports.LogsArchiveIntegrationAzure = exports.LogsArchiveDestinationS3 = exports.LogsArchiveDestinationGCS = exports.LogsArchiveDestinationAzure = exports.LogsArchiveDefinition = exports.LogsArchiveCreateRequestDefinition = exports.LogsArchiveCreateRequestAttributes = exports.LogsArchiveCreateRequest = exports.LogsArchiveAttributes = exports.LogsArchive = exports.LogsAggregateSort = exports.LogsAggregateResponseData = exports.LogsAggregateResponse = exports.LogsAggregateRequestPage = exports.LogsAggregateRequest = exports.LogsAggregateBucketValueTimeseriesPoint = exports.LogsAggregateBucket = exports.LogAttributes = exports.Log = exports.ListApplicationKeysResponse = exports.IntakePayloadAccepted = exports.IncidentUpdateRequest = exports.IncidentUpdateRelationships = exports.IncidentUpdateData = exports.IncidentUpdateAttributes = exports.IncidentTimelineCellMarkdownCreateAttributesContent = exports.IncidentTimelineCellMarkdownCreateAttributes = exports.IncidentTeamUpdateRequest = exports.IncidentTeamUpdateData = exports.IncidentTeamUpdateAttributes = exports.IncidentTeamsResponse = exports.IncidentTeamResponseData = exports.IncidentTeamResponseAttributes = exports.IncidentTeamResponse = exports.IncidentTeamRelationships = exports.IncidentTeamCreateRequest = exports.IncidentTeamCreateData = exports.IncidentTeamCreateAttributes = exports.IncidentsResponse = exports.IncidentServiceUpdateRequest = exports.IncidentServiceUpdateData = exports.IncidentServiceUpdateAttributes = exports.IncidentServicesResponse = exports.IncidentServiceResponseData = exports.IncidentServiceResponseAttributes = exports.IncidentServiceResponse = exports.IncidentServiceRelationships = exports.IncidentServiceCreateRequest = void 0;
exports.MetricEstimate = exports.MetricDistinctVolumeAttributes = exports.MetricDistinctVolume = exports.MetricCustomAggregation = exports.MetricBulkTagConfigStatusAttributes = exports.MetricBulkTagConfigStatus = exports.MetricBulkTagConfigResponse = exports.MetricBulkTagConfigDeleteRequest = exports.MetricBulkTagConfigDeleteAttributes = exports.MetricBulkTagConfigDelete = exports.MetricBulkTagConfigCreateRequest = exports.MetricBulkTagConfigCreateAttributes = exports.MetricBulkTagConfigCreate = exports.MetricAllTagsResponse = exports.MetricAllTagsAttributes = exports.MetricAllTags = exports.Metric = exports.LogsWarning = exports.LogsResponseMetadataPage = exports.LogsResponseMetadata = exports.LogsQueryOptions = exports.LogsQueryFilter = exports.LogsMetricUpdateRequest = exports.LogsMetricUpdateData = exports.LogsMetricUpdateCompute = exports.LogsMetricUpdateAttributes = exports.LogsMetricsResponse = exports.LogsMetricResponseGroupBy = exports.LogsMetricResponseFilter = exports.LogsMetricResponseData = exports.LogsMetricResponseCompute = exports.LogsMetricResponseAttributes = exports.LogsMetricResponse = exports.LogsMetricGroupBy = exports.LogsMetricFilter = exports.LogsMetricCreateRequest = exports.LogsMetricCreateData = exports.LogsMetricCreateAttributes = exports.LogsMetricCompute = exports.LogsListResponseLinks = exports.LogsListResponse = exports.LogsListRequestPage = exports.LogsListRequest = exports.LogsGroupByHistogram = exports.LogsGroupBy = exports.LogsCompute = exports.LogsArchives = exports.LogsArchiveOrderDefinition = exports.LogsArchiveOrderAttributes = exports.LogsArchiveOrder = void 0;
exports.OpsgenieServiceUpdateData = exports.OpsgenieServiceUpdateAttributes = exports.OpsgenieServicesResponse = exports.OpsgenieServiceResponseData = exports.OpsgenieServiceResponseAttributes = exports.OpsgenieServiceResponse = exports.OpsgenieServiceCreateRequest = exports.OpsgenieServiceCreateData = exports.OpsgenieServiceCreateAttributes = exports.NullableRelationshipToUserData = exports.NullableRelationshipToUser = exports.MonitorType = exports.MonitorConfigPolicyTagPolicyCreateRequest = exports.MonitorConfigPolicyTagPolicy = exports.MonitorConfigPolicyResponseData = exports.MonitorConfigPolicyResponse = exports.MonitorConfigPolicyListResponse = exports.MonitorConfigPolicyEditRequest = exports.MonitorConfigPolicyEditData = exports.MonitorConfigPolicyCreateRequest = exports.MonitorConfigPolicyCreateData = exports.MonitorConfigPolicyAttributeResponse = exports.MonitorConfigPolicyAttributeEditRequest = exports.MonitorConfigPolicyAttributeCreateRequest = exports.MetricVolumesResponse = exports.MetricTagConfigurationUpdateRequest = exports.MetricTagConfigurationUpdateData = exports.MetricTagConfigurationUpdateAttributes = exports.MetricTagConfigurationResponse = exports.MetricTagConfigurationCreateRequest = exports.MetricTagConfigurationCreateData = exports.MetricTagConfigurationCreateAttributes = exports.MetricTagConfigurationAttributes = exports.MetricTagConfiguration = exports.MetricSuggestedTagsAttributes = exports.MetricSuggestedTagsAndAggregationsResponse = exports.MetricSuggestedTagsAndAggregations = exports.MetricsTimeseriesQuery = exports.MetricsScalarQuery = exports.MetricSeries = exports.MetricsAndMetricTagConfigurationsResponse = exports.MetricResource = exports.MetricPoint = exports.MetricPayload = exports.MetricOrigin = exports.MetricMetadata = exports.MetricIngestedIndexedVolumeAttributes = exports.MetricIngestedIndexedVolume = exports.MetricEstimateResponse = exports.MetricEstimateAttributes = void 0;
exports.RoleRelationships = exports.RoleCreateResponseData = exports.RoleCreateResponse = exports.RoleCreateRequest = exports.RoleCreateData = exports.RoleCreateAttributes = exports.RoleCloneRequest = exports.RoleCloneAttributes = exports.RoleClone = exports.RoleAttributes = exports.Role = exports.ResponseMetaAttributes = exports.RelationshipToUsers = exports.RelationshipToUserData = exports.RelationshipToUser = exports.RelationshipToSAMLAssertionAttributeData = exports.RelationshipToSAMLAssertionAttribute = exports.RelationshipToRoles = exports.RelationshipToRoleData = exports.RelationshipToRole = exports.RelationshipToPermissions = exports.RelationshipToPermissionData = exports.RelationshipToPermission = exports.RelationshipToOrganizations = exports.RelationshipToOrganizationData = exports.RelationshipToOrganization = exports.RelationshipToIncidentPostmortemData = exports.RelationshipToIncidentPostmortem = exports.RelationshipToIncidentIntegrationMetadatas = exports.RelationshipToIncidentIntegrationMetadataData = exports.RelationshipToIncidentAttachmentData = exports.RelationshipToIncidentAttachment = exports.QueryFormula = exports.ProcessSummaryAttributes = exports.ProcessSummary = exports.ProcessSummariesResponse = exports.ProcessSummariesMetaPage = exports.ProcessSummariesMeta = exports.PermissionsResponse = exports.PermissionAttributes = exports.Permission = exports.PartialApplicationKeyResponse = exports.PartialApplicationKeyAttributes = exports.PartialApplicationKey = exports.PartialAPIKeyAttributes = exports.PartialAPIKey = exports.Pagination = exports.OrganizationAttributes = exports.Organization = exports.OpsgenieServiceUpdateRequest = void 0;
exports.SecurityFilter = exports.ScalarResponse = exports.ScalarMeta = exports.ScalarFormulaResponseAtrributes = exports.ScalarFormulaRequestAttributes = exports.ScalarFormulaRequest = exports.ScalarFormulaQueryResponse = exports.ScalarFormulaQueryRequest = exports.SAMLAssertionAttributeAttributes = exports.SAMLAssertionAttribute = exports.RUMWarning = exports.RUMSearchEventsRequest = exports.RUMResponsePage = exports.RUMResponseMetadata = exports.RUMResponseLinks = exports.RUMQueryPageOptions = exports.RUMQueryOptions = exports.RUMQueryFilter = exports.RUMGroupByHistogram = exports.RUMGroupBy = exports.RUMEventsResponse = exports.RUMEventAttributes = exports.RUMEvent = exports.RUMCompute = exports.RUMBucketResponse = exports.RUMApplicationUpdateRequest = exports.RUMApplicationUpdateAttributes = exports.RUMApplicationUpdate = exports.RUMApplicationsResponse = exports.RUMApplicationResponse = exports.RUMApplicationListAttributes = exports.RUMApplicationList = exports.RUMApplicationCreateRequest = exports.RUMApplicationCreateAttributes = exports.RUMApplicationCreate = exports.RUMApplicationAttributes = exports.RUMApplication = exports.RUMAnalyticsAggregateResponse = exports.RUMAggregationBucketsResponse = exports.RUMAggregateSort = exports.RUMAggregateRequest = exports.RUMAggregateBucketValueTimeseriesPoint = exports.RoleUpdateResponseData = exports.RoleUpdateResponse = exports.RoleUpdateRequest = exports.RoleUpdateData = exports.RoleUpdateAttributes = exports.RolesResponse = exports.RoleResponseRelationships = exports.RoleResponse = void 0;
exports.SensitiveDataScannerConfigRequest = exports.SecurityMonitoringTriageUser = exports.SecurityMonitoringStandardRuleResponse = exports.SecurityMonitoringStandardRuleQuery = exports.SecurityMonitoringStandardRuleCreatePayload = exports.SecurityMonitoringSignalTriageUpdateResponse = exports.SecurityMonitoringSignalTriageUpdateData = exports.SecurityMonitoringSignalTriageAttributes = exports.SecurityMonitoringSignalStateUpdateRequest = exports.SecurityMonitoringSignalStateUpdateData = exports.SecurityMonitoringSignalStateUpdateAttributes = exports.SecurityMonitoringSignalsListResponseMetaPage = exports.SecurityMonitoringSignalsListResponseMeta = exports.SecurityMonitoringSignalsListResponseLinks = exports.SecurityMonitoringSignalsListResponse = exports.SecurityMonitoringSignalRuleResponseQuery = exports.SecurityMonitoringSignalRuleResponse = exports.SecurityMonitoringSignalRuleQuery = exports.SecurityMonitoringSignalRuleCreatePayload = exports.SecurityMonitoringSignalListRequestPage = exports.SecurityMonitoringSignalListRequestFilter = exports.SecurityMonitoringSignalListRequest = exports.SecurityMonitoringSignalIncidentsUpdateRequest = exports.SecurityMonitoringSignalIncidentsUpdateData = exports.SecurityMonitoringSignalIncidentsUpdateAttributes = exports.SecurityMonitoringSignalAttributes = exports.SecurityMonitoringSignalAssigneeUpdateRequest = exports.SecurityMonitoringSignalAssigneeUpdateData = exports.SecurityMonitoringSignalAssigneeUpdateAttributes = exports.SecurityMonitoringSignal = exports.SecurityMonitoringRuleUpdatePayload = exports.SecurityMonitoringRuleOptions = exports.SecurityMonitoringRuleNewValueOptions = exports.SecurityMonitoringRuleImpossibleTravelOptions = exports.SecurityMonitoringRuleCaseCreate = exports.SecurityMonitoringRuleCase = exports.SecurityMonitoringListRulesResponse = exports.SecurityMonitoringFilter = exports.SecurityFilterUpdateRequest = exports.SecurityFilterUpdateData = exports.SecurityFilterUpdateAttributes = exports.SecurityFiltersResponse = exports.SecurityFilterResponse = exports.SecurityFilterMeta = exports.SecurityFilterExclusionFilterResponse = exports.SecurityFilterExclusionFilter = exports.SecurityFilterCreateRequest = exports.SecurityFilterCreateData = exports.SecurityFilterCreateAttributes = exports.SecurityFilterAttributes = void 0;
exports.ServiceDefinitionCreateResponse = exports.ServiceAccountCreateRequest = exports.ServiceAccountCreateData = exports.ServiceAccountCreateAttributes = exports.SensitiveDataScannerTextReplacement = exports.SensitiveDataScannerStandardPatternsResponseItem = exports.SensitiveDataScannerStandardPatternsResponseData = exports.SensitiveDataScannerStandardPatternData = exports.SensitiveDataScannerStandardPatternAttributes = exports.SensitiveDataScannerStandardPattern = exports.SensitiveDataScannerRuleUpdateResponse = exports.SensitiveDataScannerRuleUpdateRequest = exports.SensitiveDataScannerRuleUpdate = exports.SensitiveDataScannerRuleResponse = exports.SensitiveDataScannerRuleRelationships = exports.SensitiveDataScannerRuleIncludedItem = exports.SensitiveDataScannerRuleDeleteResponse = exports.SensitiveDataScannerRuleDeleteRequest = exports.SensitiveDataScannerRuleData = exports.SensitiveDataScannerRuleCreateRequest = exports.SensitiveDataScannerRuleCreate = exports.SensitiveDataScannerRuleAttributes = exports.SensitiveDataScannerRule = exports.SensitiveDataScannerReorderGroupsResponse = exports.SensitiveDataScannerReorderConfig = exports.SensitiveDataScannerMetaVersionOnly = exports.SensitiveDataScannerMeta = exports.SensitiveDataScannerGroupUpdateResponse = exports.SensitiveDataScannerGroupUpdateRequest = exports.SensitiveDataScannerGroupUpdate = exports.SensitiveDataScannerGroupResponse = exports.SensitiveDataScannerGroupRelationships = exports.SensitiveDataScannerGroupList = exports.SensitiveDataScannerGroupItem = exports.SensitiveDataScannerGroupIncludedItem = exports.SensitiveDataScannerGroupDeleteResponse = exports.SensitiveDataScannerGroupDeleteRequest = exports.SensitiveDataScannerGroupData = exports.SensitiveDataScannerGroupCreateRequest = exports.SensitiveDataScannerGroupCreate = exports.SensitiveDataScannerGroupAttributes = exports.SensitiveDataScannerGroup = exports.SensitiveDataScannerGetConfigResponseData = exports.SensitiveDataScannerGetConfigResponse = exports.SensitiveDataScannerFilter = exports.SensitiveDataScannerCreateRuleResponse = exports.SensitiveDataScannerCreateGroupResponse = exports.SensitiveDataScannerConfigurationRelationships = exports.SensitiveDataScannerConfigurationData = exports.SensitiveDataScannerConfiguration = void 0;
exports.UserUpdateAttributes = exports.UsersResponse = exports.UserResponseRelationships = exports.UserResponse = exports.UserRelationships = exports.UserInvitationsResponse = exports.UserInvitationsRequest = exports.UserInvitationResponseData = exports.UserInvitationResponse = exports.UserInvitationRelationships = exports.UserInvitationDataAttributes = exports.UserInvitationData = exports.UserCreateRequest = exports.UserCreateData = exports.UserCreateAttributes = exports.UserAttributes = exports.User = exports.UsageTimeSeriesObject = exports.UsageObservabilityPipelinesResponse = exports.UsageLambdaTracedInvocationsResponse = exports.UsageDataObject = exports.UsageAttributesObject = exports.UsageApplicationSecurityMonitoringResponse = exports.Unit = exports.TimeseriesResponseSeries = exports.TimeseriesResponseAttributes = exports.TimeseriesResponse = exports.TimeseriesFormulaRequestAttributes = exports.TimeseriesFormulaRequest = exports.TimeseriesFormulaQueryResponse = exports.TimeseriesFormulaQueryRequest = exports.ServiceDefinitionV2Slack = exports.ServiceDefinitionV2Repo = exports.ServiceDefinitionV2Opsgenie = exports.ServiceDefinitionV2Link = exports.ServiceDefinitionV2Integrations = exports.ServiceDefinitionV2Email = exports.ServiceDefinitionV2Doc = exports.ServiceDefinitionV2 = exports.ServiceDefinitionV1Resource = exports.ServiceDefinitionV1Org = exports.ServiceDefinitionV1Integrations = exports.ServiceDefinitionV1Info = exports.ServiceDefinitionV1Contact = exports.ServiceDefinitionV1 = exports.ServiceDefinitionsListResponse = exports.ServiceDefinitionMeta = exports.ServiceDefinitionGetResponse = exports.ServiceDefinitionDataAttributes = exports.ServiceDefinitionData = void 0;
exports.ObjectSerializer = exports.UserUpdateRequest = exports.UserUpdateData = void 0;
var AuditApi_1 = __webpack_require__(65768);
Object.defineProperty(exports, "AuditApi", ({ enumerable: true, get: function () { return AuditApi_1.AuditApi; } }));
var AuthNMappingsApi_1 = __webpack_require__(36121);
Object.defineProperty(exports, "AuthNMappingsApi", ({ enumerable: true, get: function () { return AuthNMappingsApi_1.AuthNMappingsApi; } }));
var CIVisibilityPipelinesApi_1 = __webpack_require__(8704);
Object.defineProperty(exports, "CIVisibilityPipelinesApi", ({ enumerable: true, get: function () { return CIVisibilityPipelinesApi_1.CIVisibilityPipelinesApi; } }));
var CIVisibilityTestsApi_1 = __webpack_require__(56061);
Object.defineProperty(exports, "CIVisibilityTestsApi", ({ enumerable: true, get: function () { return CIVisibilityTestsApi_1.CIVisibilityTestsApi; } }));
var CloudWorkloadSecurityApi_1 = __webpack_require__(42023);
Object.defineProperty(exports, "CloudWorkloadSecurityApi", ({ enumerable: true, get: function () { return CloudWorkloadSecurityApi_1.CloudWorkloadSecurityApi; } }));
var CloudflareIntegrationApi_1 = __webpack_require__(22819);
Object.defineProperty(exports, "CloudflareIntegrationApi", ({ enumerable: true, get: function () { return CloudflareIntegrationApi_1.CloudflareIntegrationApi; } }));
var ConfluentCloudApi_1 = __webpack_require__(85828);
Object.defineProperty(exports, "ConfluentCloudApi", ({ enumerable: true, get: function () { return ConfluentCloudApi_1.ConfluentCloudApi; } }));
var DashboardListsApi_1 = __webpack_require__(50063);
Object.defineProperty(exports, "DashboardListsApi", ({ enumerable: true, get: function () { return DashboardListsApi_1.DashboardListsApi; } }));
var EventsApi_1 = __webpack_require__(8300);
Object.defineProperty(exports, "EventsApi", ({ enumerable: true, get: function () { return EventsApi_1.EventsApi; } }));
var FastlyIntegrationApi_1 = __webpack_require__(7349);
Object.defineProperty(exports, "FastlyIntegrationApi", ({ enumerable: true, get: function () { return FastlyIntegrationApi_1.FastlyIntegrationApi; } }));
var IncidentServicesApi_1 = __webpack_require__(6990);
Object.defineProperty(exports, "IncidentServicesApi", ({ enumerable: true, get: function () { return IncidentServicesApi_1.IncidentServicesApi; } }));
var IncidentTeamsApi_1 = __webpack_require__(97201);
Object.defineProperty(exports, "IncidentTeamsApi", ({ enumerable: true, get: function () { return IncidentTeamsApi_1.IncidentTeamsApi; } }));
var IncidentsApi_1 = __webpack_require__(9580);
Object.defineProperty(exports, "IncidentsApi", ({ enumerable: true, get: function () { return IncidentsApi_1.IncidentsApi; } }));
var KeyManagementApi_1 = __webpack_require__(95951);
Object.defineProperty(exports, "KeyManagementApi", ({ enumerable: true, get: function () { return KeyManagementApi_1.KeyManagementApi; } }));
var LogsApi_1 = __webpack_require__(94716);
Object.defineProperty(exports, "LogsApi", ({ enumerable: true, get: function () { return LogsApi_1.LogsApi; } }));
var LogsArchivesApi_1 = __webpack_require__(73593);
Object.defineProperty(exports, "LogsArchivesApi", ({ enumerable: true, get: function () { return LogsArchivesApi_1.LogsArchivesApi; } }));
var LogsMetricsApi_1 = __webpack_require__(12943);
Object.defineProperty(exports, "LogsMetricsApi", ({ enumerable: true, get: function () { return LogsMetricsApi_1.LogsMetricsApi; } }));
var MetricsApi_1 = __webpack_require__(47719);
Object.defineProperty(exports, "MetricsApi", ({ enumerable: true, get: function () { return MetricsApi_1.MetricsApi; } }));
var MonitorsApi_1 = __webpack_require__(83263);
Object.defineProperty(exports, "MonitorsApi", ({ enumerable: true, get: function () { return MonitorsApi_1.MonitorsApi; } }));
var OpsgenieIntegrationApi_1 = __webpack_require__(44111);
Object.defineProperty(exports, "OpsgenieIntegrationApi", ({ enumerable: true, get: function () { return OpsgenieIntegrationApi_1.OpsgenieIntegrationApi; } }));
var OrganizationsApi_1 = __webpack_require__(49292);
Object.defineProperty(exports, "OrganizationsApi", ({ enumerable: true, get: function () { return OrganizationsApi_1.OrganizationsApi; } }));
var ProcessesApi_1 = __webpack_require__(2718);
Object.defineProperty(exports, "ProcessesApi", ({ enumerable: true, get: function () { return ProcessesApi_1.ProcessesApi; } }));
var RUMApi_1 = __webpack_require__(53106);
Object.defineProperty(exports, "RUMApi", ({ enumerable: true, get: function () { return RUMApi_1.RUMApi; } }));
var RolesApi_1 = __webpack_require__(49755);
Object.defineProperty(exports, "RolesApi", ({ enumerable: true, get: function () { return RolesApi_1.RolesApi; } }));
var SecurityMonitoringApi_1 = __webpack_require__(94005);
Object.defineProperty(exports, "SecurityMonitoringApi", ({ enumerable: true, get: function () { return SecurityMonitoringApi_1.SecurityMonitoringApi; } }));
var SensitiveDataScannerApi_1 = __webpack_require__(1235);
Object.defineProperty(exports, "SensitiveDataScannerApi", ({ enumerable: true, get: function () { return SensitiveDataScannerApi_1.SensitiveDataScannerApi; } }));
var ServiceAccountsApi_1 = __webpack_require__(1204);
Object.defineProperty(exports, "ServiceAccountsApi", ({ enumerable: true, get: function () { return ServiceAccountsApi_1.ServiceAccountsApi; } }));
var ServiceDefinitionApi_1 = __webpack_require__(58864);
Object.defineProperty(exports, "ServiceDefinitionApi", ({ enumerable: true, get: function () { return ServiceDefinitionApi_1.ServiceDefinitionApi; } }));
var UsageMeteringApi_1 = __webpack_require__(20563);
Object.defineProperty(exports, "UsageMeteringApi", ({ enumerable: true, get: function () { return UsageMeteringApi_1.UsageMeteringApi; } }));
var UsersApi_1 = __webpack_require__(25328);
Object.defineProperty(exports, "UsersApi", ({ enumerable: true, get: function () { return UsersApi_1.UsersApi; } }));
var APIErrorResponse_1 = __webpack_require__(70205);
Object.defineProperty(exports, "APIErrorResponse", ({ enumerable: true, get: function () { return APIErrorResponse_1.APIErrorResponse; } }));
var APIKeyCreateAttributes_1 = __webpack_require__(59524);
Object.defineProperty(exports, "APIKeyCreateAttributes", ({ enumerable: true, get: function () { return APIKeyCreateAttributes_1.APIKeyCreateAttributes; } }));
var APIKeyCreateData_1 = __webpack_require__(18279);
Object.defineProperty(exports, "APIKeyCreateData", ({ enumerable: true, get: function () { return APIKeyCreateData_1.APIKeyCreateData; } }));
var APIKeyCreateRequest_1 = __webpack_require__(58893);
Object.defineProperty(exports, "APIKeyCreateRequest", ({ enumerable: true, get: function () { return APIKeyCreateRequest_1.APIKeyCreateRequest; } }));
var APIKeyRelationships_1 = __webpack_require__(54551);
Object.defineProperty(exports, "APIKeyRelationships", ({ enumerable: true, get: function () { return APIKeyRelationships_1.APIKeyRelationships; } }));
var APIKeyResponse_1 = __webpack_require__(97531);
Object.defineProperty(exports, "APIKeyResponse", ({ enumerable: true, get: function () { return APIKeyResponse_1.APIKeyResponse; } }));
var APIKeysResponse_1 = __webpack_require__(13214);
Object.defineProperty(exports, "APIKeysResponse", ({ enumerable: true, get: function () { return APIKeysResponse_1.APIKeysResponse; } }));
var APIKeyUpdateAttributes_1 = __webpack_require__(65168);
Object.defineProperty(exports, "APIKeyUpdateAttributes", ({ enumerable: true, get: function () { return APIKeyUpdateAttributes_1.APIKeyUpdateAttributes; } }));
var APIKeyUpdateData_1 = __webpack_require__(51292);
Object.defineProperty(exports, "APIKeyUpdateData", ({ enumerable: true, get: function () { return APIKeyUpdateData_1.APIKeyUpdateData; } }));
var APIKeyUpdateRequest_1 = __webpack_require__(20585);
Object.defineProperty(exports, "APIKeyUpdateRequest", ({ enumerable: true, get: function () { return APIKeyUpdateRequest_1.APIKeyUpdateRequest; } }));
var ApplicationKeyCreateAttributes_1 = __webpack_require__(71500);
Object.defineProperty(exports, "ApplicationKeyCreateAttributes", ({ enumerable: true, get: function () { return ApplicationKeyCreateAttributes_1.ApplicationKeyCreateAttributes; } }));
var ApplicationKeyCreateData_1 = __webpack_require__(39673);
Object.defineProperty(exports, "ApplicationKeyCreateData", ({ enumerable: true, get: function () { return ApplicationKeyCreateData_1.ApplicationKeyCreateData; } }));
var ApplicationKeyCreateRequest_1 = __webpack_require__(89736);
Object.defineProperty(exports, "ApplicationKeyCreateRequest", ({ enumerable: true, get: function () { return ApplicationKeyCreateRequest_1.ApplicationKeyCreateRequest; } }));
var ApplicationKeyRelationships_1 = __webpack_require__(65634);
Object.defineProperty(exports, "ApplicationKeyRelationships", ({ enumerable: true, get: function () { return ApplicationKeyRelationships_1.ApplicationKeyRelationships; } }));
var ApplicationKeyResponse_1 = __webpack_require__(73297);
Object.defineProperty(exports, "ApplicationKeyResponse", ({ enumerable: true, get: function () { return ApplicationKeyResponse_1.ApplicationKeyResponse; } }));
var ApplicationKeyUpdateAttributes_1 = __webpack_require__(38052);
Object.defineProperty(exports, "ApplicationKeyUpdateAttributes", ({ enumerable: true, get: function () { return ApplicationKeyUpdateAttributes_1.ApplicationKeyUpdateAttributes; } }));
var ApplicationKeyUpdateData_1 = __webpack_require__(3655);
Object.defineProperty(exports, "ApplicationKeyUpdateData", ({ enumerable: true, get: function () { return ApplicationKeyUpdateData_1.ApplicationKeyUpdateData; } }));
var ApplicationKeyUpdateRequest_1 = __webpack_require__(19103);
Object.defineProperty(exports, "ApplicationKeyUpdateRequest", ({ enumerable: true, get: function () { return ApplicationKeyUpdateRequest_1.ApplicationKeyUpdateRequest; } }));
var AuditLogsEvent_1 = __webpack_require__(30095);
Object.defineProperty(exports, "AuditLogsEvent", ({ enumerable: true, get: function () { return AuditLogsEvent_1.AuditLogsEvent; } }));
var AuditLogsEventAttributes_1 = __webpack_require__(52083);
Object.defineProperty(exports, "AuditLogsEventAttributes", ({ enumerable: true, get: function () { return AuditLogsEventAttributes_1.AuditLogsEventAttributes; } }));
var AuditLogsEventsResponse_1 = __webpack_require__(64297);
Object.defineProperty(exports, "AuditLogsEventsResponse", ({ enumerable: true, get: function () { return AuditLogsEventsResponse_1.AuditLogsEventsResponse; } }));
var AuditLogsQueryFilter_1 = __webpack_require__(22659);
Object.defineProperty(exports, "AuditLogsQueryFilter", ({ enumerable: true, get: function () { return AuditLogsQueryFilter_1.AuditLogsQueryFilter; } }));
var AuditLogsQueryOptions_1 = __webpack_require__(68991);
Object.defineProperty(exports, "AuditLogsQueryOptions", ({ enumerable: true, get: function () { return AuditLogsQueryOptions_1.AuditLogsQueryOptions; } }));
var AuditLogsQueryPageOptions_1 = __webpack_require__(46706);
Object.defineProperty(exports, "AuditLogsQueryPageOptions", ({ enumerable: true, get: function () { return AuditLogsQueryPageOptions_1.AuditLogsQueryPageOptions; } }));
var AuditLogsResponseLinks_1 = __webpack_require__(67454);
Object.defineProperty(exports, "AuditLogsResponseLinks", ({ enumerable: true, get: function () { return AuditLogsResponseLinks_1.AuditLogsResponseLinks; } }));
var AuditLogsResponseMetadata_1 = __webpack_require__(41903);
Object.defineProperty(exports, "AuditLogsResponseMetadata", ({ enumerable: true, get: function () { return AuditLogsResponseMetadata_1.AuditLogsResponseMetadata; } }));
var AuditLogsResponsePage_1 = __webpack_require__(4131);
Object.defineProperty(exports, "AuditLogsResponsePage", ({ enumerable: true, get: function () { return AuditLogsResponsePage_1.AuditLogsResponsePage; } }));
var AuditLogsSearchEventsRequest_1 = __webpack_require__(52614);
Object.defineProperty(exports, "AuditLogsSearchEventsRequest", ({ enumerable: true, get: function () { return AuditLogsSearchEventsRequest_1.AuditLogsSearchEventsRequest; } }));
var AuditLogsWarning_1 = __webpack_require__(28817);
Object.defineProperty(exports, "AuditLogsWarning", ({ enumerable: true, get: function () { return AuditLogsWarning_1.AuditLogsWarning; } }));
var AuthNMapping_1 = __webpack_require__(80723);
Object.defineProperty(exports, "AuthNMapping", ({ enumerable: true, get: function () { return AuthNMapping_1.AuthNMapping; } }));
var AuthNMappingAttributes_1 = __webpack_require__(70543);
Object.defineProperty(exports, "AuthNMappingAttributes", ({ enumerable: true, get: function () { return AuthNMappingAttributes_1.AuthNMappingAttributes; } }));
var AuthNMappingCreateAttributes_1 = __webpack_require__(47073);
Object.defineProperty(exports, "AuthNMappingCreateAttributes", ({ enumerable: true, get: function () { return AuthNMappingCreateAttributes_1.AuthNMappingCreateAttributes; } }));
var AuthNMappingCreateData_1 = __webpack_require__(2847);
Object.defineProperty(exports, "AuthNMappingCreateData", ({ enumerable: true, get: function () { return AuthNMappingCreateData_1.AuthNMappingCreateData; } }));
var AuthNMappingCreateRelationships_1 = __webpack_require__(20943);
Object.defineProperty(exports, "AuthNMappingCreateRelationships", ({ enumerable: true, get: function () { return AuthNMappingCreateRelationships_1.AuthNMappingCreateRelationships; } }));
var AuthNMappingCreateRequest_1 = __webpack_require__(32773);
Object.defineProperty(exports, "AuthNMappingCreateRequest", ({ enumerable: true, get: function () { return AuthNMappingCreateRequest_1.AuthNMappingCreateRequest; } }));
var AuthNMappingRelationships_1 = __webpack_require__(17587);
Object.defineProperty(exports, "AuthNMappingRelationships", ({ enumerable: true, get: function () { return AuthNMappingRelationships_1.AuthNMappingRelationships; } }));
var AuthNMappingResponse_1 = __webpack_require__(60064);
Object.defineProperty(exports, "AuthNMappingResponse", ({ enumerable: true, get: function () { return AuthNMappingResponse_1.AuthNMappingResponse; } }));
var AuthNMappingsResponse_1 = __webpack_require__(18439);
Object.defineProperty(exports, "AuthNMappingsResponse", ({ enumerable: true, get: function () { return AuthNMappingsResponse_1.AuthNMappingsResponse; } }));
var AuthNMappingUpdateAttributes_1 = __webpack_require__(61653);
Object.defineProperty(exports, "AuthNMappingUpdateAttributes", ({ enumerable: true, get: function () { return AuthNMappingUpdateAttributes_1.AuthNMappingUpdateAttributes; } }));
var AuthNMappingUpdateData_1 = __webpack_require__(98430);
Object.defineProperty(exports, "AuthNMappingUpdateData", ({ enumerable: true, get: function () { return AuthNMappingUpdateData_1.AuthNMappingUpdateData; } }));
var AuthNMappingUpdateRelationships_1 = __webpack_require__(39731);
Object.defineProperty(exports, "AuthNMappingUpdateRelationships", ({ enumerable: true, get: function () { return AuthNMappingUpdateRelationships_1.AuthNMappingUpdateRelationships; } }));
var AuthNMappingUpdateRequest_1 = __webpack_require__(18093);
Object.defineProperty(exports, "AuthNMappingUpdateRequest", ({ enumerable: true, get: function () { return AuthNMappingUpdateRequest_1.AuthNMappingUpdateRequest; } }));
var ChargebackBreakdown_1 = __webpack_require__(16467);
Object.defineProperty(exports, "ChargebackBreakdown", ({ enumerable: true, get: function () { return ChargebackBreakdown_1.ChargebackBreakdown; } }));
var CIAppAggregateBucketValueTimeseriesPoint_1 = __webpack_require__(86227);
Object.defineProperty(exports, "CIAppAggregateBucketValueTimeseriesPoint", ({ enumerable: true, get: function () { return CIAppAggregateBucketValueTimeseriesPoint_1.CIAppAggregateBucketValueTimeseriesPoint; } }));
var CIAppAggregateSort_1 = __webpack_require__(13896);
Object.defineProperty(exports, "CIAppAggregateSort", ({ enumerable: true, get: function () { return CIAppAggregateSort_1.CIAppAggregateSort; } }));
var CIAppCompute_1 = __webpack_require__(5294);
Object.defineProperty(exports, "CIAppCompute", ({ enumerable: true, get: function () { return CIAppCompute_1.CIAppCompute; } }));
var CIAppEventAttributes_1 = __webpack_require__(5795);
Object.defineProperty(exports, "CIAppEventAttributes", ({ enumerable: true, get: function () { return CIAppEventAttributes_1.CIAppEventAttributes; } }));
var CIAppGroupByHistogram_1 = __webpack_require__(84337);
Object.defineProperty(exports, "CIAppGroupByHistogram", ({ enumerable: true, get: function () { return CIAppGroupByHistogram_1.CIAppGroupByHistogram; } }));
var CIAppPipelineEvent_1 = __webpack_require__(92629);
Object.defineProperty(exports, "CIAppPipelineEvent", ({ enumerable: true, get: function () { return CIAppPipelineEvent_1.CIAppPipelineEvent; } }));
var CIAppPipelineEventsRequest_1 = __webpack_require__(7634);
Object.defineProperty(exports, "CIAppPipelineEventsRequest", ({ enumerable: true, get: function () { return CIAppPipelineEventsRequest_1.CIAppPipelineEventsRequest; } }));
var CIAppPipelineEventsResponse_1 = __webpack_require__(81393);
Object.defineProperty(exports, "CIAppPipelineEventsResponse", ({ enumerable: true, get: function () { return CIAppPipelineEventsResponse_1.CIAppPipelineEventsResponse; } }));
var CIAppPipelinesAggregateRequest_1 = __webpack_require__(9879);
Object.defineProperty(exports, "CIAppPipelinesAggregateRequest", ({ enumerable: true, get: function () { return CIAppPipelinesAggregateRequest_1.CIAppPipelinesAggregateRequest; } }));
var CIAppPipelinesAggregationBucketsResponse_1 = __webpack_require__(48758);
Object.defineProperty(exports, "CIAppPipelinesAggregationBucketsResponse", ({ enumerable: true, get: function () { return CIAppPipelinesAggregationBucketsResponse_1.CIAppPipelinesAggregationBucketsResponse; } }));
var CIAppPipelinesAnalyticsAggregateResponse_1 = __webpack_require__(92621);
Object.defineProperty(exports, "CIAppPipelinesAnalyticsAggregateResponse", ({ enumerable: true, get: function () { return CIAppPipelinesAnalyticsAggregateResponse_1.CIAppPipelinesAnalyticsAggregateResponse; } }));
var CIAppPipelinesBucketResponse_1 = __webpack_require__(61408);
Object.defineProperty(exports, "CIAppPipelinesBucketResponse", ({ enumerable: true, get: function () { return CIAppPipelinesBucketResponse_1.CIAppPipelinesBucketResponse; } }));
var CIAppPipelinesGroupBy_1 = __webpack_require__(89633);
Object.defineProperty(exports, "CIAppPipelinesGroupBy", ({ enumerable: true, get: function () { return CIAppPipelinesGroupBy_1.CIAppPipelinesGroupBy; } }));
var CIAppPipelinesQueryFilter_1 = __webpack_require__(2272);
Object.defineProperty(exports, "CIAppPipelinesQueryFilter", ({ enumerable: true, get: function () { return CIAppPipelinesQueryFilter_1.CIAppPipelinesQueryFilter; } }));
var CIAppQueryOptions_1 = __webpack_require__(58517);
Object.defineProperty(exports, "CIAppQueryOptions", ({ enumerable: true, get: function () { return CIAppQueryOptions_1.CIAppQueryOptions; } }));
var CIAppQueryPageOptions_1 = __webpack_require__(89457);
Object.defineProperty(exports, "CIAppQueryPageOptions", ({ enumerable: true, get: function () { return CIAppQueryPageOptions_1.CIAppQueryPageOptions; } }));
var CIAppResponseLinks_1 = __webpack_require__(49266);
Object.defineProperty(exports, "CIAppResponseLinks", ({ enumerable: true, get: function () { return CIAppResponseLinks_1.CIAppResponseLinks; } }));
var CIAppResponseMetadata_1 = __webpack_require__(89609);
Object.defineProperty(exports, "CIAppResponseMetadata", ({ enumerable: true, get: function () { return CIAppResponseMetadata_1.CIAppResponseMetadata; } }));
var CIAppResponseMetadataWithPagination_1 = __webpack_require__(82475);
Object.defineProperty(exports, "CIAppResponseMetadataWithPagination", ({ enumerable: true, get: function () { return CIAppResponseMetadataWithPagination_1.CIAppResponseMetadataWithPagination; } }));
var CIAppResponsePage_1 = __webpack_require__(34502);
Object.defineProperty(exports, "CIAppResponsePage", ({ enumerable: true, get: function () { return CIAppResponsePage_1.CIAppResponsePage; } }));
var CIAppTestEvent_1 = __webpack_require__(38943);
Object.defineProperty(exports, "CIAppTestEvent", ({ enumerable: true, get: function () { return CIAppTestEvent_1.CIAppTestEvent; } }));
var CIAppTestEventsRequest_1 = __webpack_require__(94731);
Object.defineProperty(exports, "CIAppTestEventsRequest", ({ enumerable: true, get: function () { return CIAppTestEventsRequest_1.CIAppTestEventsRequest; } }));
var CIAppTestEventsResponse_1 = __webpack_require__(12138);
Object.defineProperty(exports, "CIAppTestEventsResponse", ({ enumerable: true, get: function () { return CIAppTestEventsResponse_1.CIAppTestEventsResponse; } }));
var CIAppTestsAggregateRequest_1 = __webpack_require__(3854);
Object.defineProperty(exports, "CIAppTestsAggregateRequest", ({ enumerable: true, get: function () { return CIAppTestsAggregateRequest_1.CIAppTestsAggregateRequest; } }));
var CIAppTestsAggregationBucketsResponse_1 = __webpack_require__(64466);
Object.defineProperty(exports, "CIAppTestsAggregationBucketsResponse", ({ enumerable: true, get: function () { return CIAppTestsAggregationBucketsResponse_1.CIAppTestsAggregationBucketsResponse; } }));
var CIAppTestsAnalyticsAggregateResponse_1 = __webpack_require__(17669);
Object.defineProperty(exports, "CIAppTestsAnalyticsAggregateResponse", ({ enumerable: true, get: function () { return CIAppTestsAnalyticsAggregateResponse_1.CIAppTestsAnalyticsAggregateResponse; } }));
var CIAppTestsBucketResponse_1 = __webpack_require__(34463);
Object.defineProperty(exports, "CIAppTestsBucketResponse", ({ enumerable: true, get: function () { return CIAppTestsBucketResponse_1.CIAppTestsBucketResponse; } }));
var CIAppTestsGroupBy_1 = __webpack_require__(59491);
Object.defineProperty(exports, "CIAppTestsGroupBy", ({ enumerable: true, get: function () { return CIAppTestsGroupBy_1.CIAppTestsGroupBy; } }));
var CIAppTestsQueryFilter_1 = __webpack_require__(27928);
Object.defineProperty(exports, "CIAppTestsQueryFilter", ({ enumerable: true, get: function () { return CIAppTestsQueryFilter_1.CIAppTestsQueryFilter; } }));
var CIAppWarning_1 = __webpack_require__(86117);
Object.defineProperty(exports, "CIAppWarning", ({ enumerable: true, get: function () { return CIAppWarning_1.CIAppWarning; } }));
var CloudConfigurationComplianceRuleOptions_1 = __webpack_require__(38115);
Object.defineProperty(exports, "CloudConfigurationComplianceRuleOptions", ({ enumerable: true, get: function () { return CloudConfigurationComplianceRuleOptions_1.CloudConfigurationComplianceRuleOptions; } }));
var CloudConfigurationRegoRule_1 = __webpack_require__(7582);
Object.defineProperty(exports, "CloudConfigurationRegoRule", ({ enumerable: true, get: function () { return CloudConfigurationRegoRule_1.CloudConfigurationRegoRule; } }));
var CloudConfigurationRuleCaseCreate_1 = __webpack_require__(17477);
Object.defineProperty(exports, "CloudConfigurationRuleCaseCreate", ({ enumerable: true, get: function () { return CloudConfigurationRuleCaseCreate_1.CloudConfigurationRuleCaseCreate; } }));
var CloudConfigurationRuleComplianceSignalOptions_1 = __webpack_require__(11004);
Object.defineProperty(exports, "CloudConfigurationRuleComplianceSignalOptions", ({ enumerable: true, get: function () { return CloudConfigurationRuleComplianceSignalOptions_1.CloudConfigurationRuleComplianceSignalOptions; } }));
var CloudConfigurationRuleCreatePayload_1 = __webpack_require__(1935);
Object.defineProperty(exports, "CloudConfigurationRuleCreatePayload", ({ enumerable: true, get: function () { return CloudConfigurationRuleCreatePayload_1.CloudConfigurationRuleCreatePayload; } }));
var CloudConfigurationRuleOptions_1 = __webpack_require__(47654);
Object.defineProperty(exports, "CloudConfigurationRuleOptions", ({ enumerable: true, get: function () { return CloudConfigurationRuleOptions_1.CloudConfigurationRuleOptions; } }));
var CloudflareAccountCreateRequest_1 = __webpack_require__(85346);
Object.defineProperty(exports, "CloudflareAccountCreateRequest", ({ enumerable: true, get: function () { return CloudflareAccountCreateRequest_1.CloudflareAccountCreateRequest; } }));
var CloudflareAccountCreateRequestAttributes_1 = __webpack_require__(45414);
Object.defineProperty(exports, "CloudflareAccountCreateRequestAttributes", ({ enumerable: true, get: function () { return CloudflareAccountCreateRequestAttributes_1.CloudflareAccountCreateRequestAttributes; } }));
var CloudflareAccountCreateRequestData_1 = __webpack_require__(19660);
Object.defineProperty(exports, "CloudflareAccountCreateRequestData", ({ enumerable: true, get: function () { return CloudflareAccountCreateRequestData_1.CloudflareAccountCreateRequestData; } }));
var CloudflareAccountResponse_1 = __webpack_require__(53134);
Object.defineProperty(exports, "CloudflareAccountResponse", ({ enumerable: true, get: function () { return CloudflareAccountResponse_1.CloudflareAccountResponse; } }));
var CloudflareAccountResponseAttributes_1 = __webpack_require__(614);
Object.defineProperty(exports, "CloudflareAccountResponseAttributes", ({ enumerable: true, get: function () { return CloudflareAccountResponseAttributes_1.CloudflareAccountResponseAttributes; } }));
var CloudflareAccountResponseData_1 = __webpack_require__(29339);
Object.defineProperty(exports, "CloudflareAccountResponseData", ({ enumerable: true, get: function () { return CloudflareAccountResponseData_1.CloudflareAccountResponseData; } }));
var CloudflareAccountsResponse_1 = __webpack_require__(25675);
Object.defineProperty(exports, "CloudflareAccountsResponse", ({ enumerable: true, get: function () { return CloudflareAccountsResponse_1.CloudflareAccountsResponse; } }));
var CloudflareAccountUpdateRequest_1 = __webpack_require__(73177);
Object.defineProperty(exports, "CloudflareAccountUpdateRequest", ({ enumerable: true, get: function () { return CloudflareAccountUpdateRequest_1.CloudflareAccountUpdateRequest; } }));
var CloudflareAccountUpdateRequestAttributes_1 = __webpack_require__(25778);
Object.defineProperty(exports, "CloudflareAccountUpdateRequestAttributes", ({ enumerable: true, get: function () { return CloudflareAccountUpdateRequestAttributes_1.CloudflareAccountUpdateRequestAttributes; } }));
var CloudflareAccountUpdateRequestData_1 = __webpack_require__(18693);
Object.defineProperty(exports, "CloudflareAccountUpdateRequestData", ({ enumerable: true, get: function () { return CloudflareAccountUpdateRequestData_1.CloudflareAccountUpdateRequestData; } }));
var CloudWorkloadSecurityAgentRuleAttributes_1 = __webpack_require__(60792);
Object.defineProperty(exports, "CloudWorkloadSecurityAgentRuleAttributes", ({ enumerable: true, get: function () { return CloudWorkloadSecurityAgentRuleAttributes_1.CloudWorkloadSecurityAgentRuleAttributes; } }));
var CloudWorkloadSecurityAgentRuleCreateAttributes_1 = __webpack_require__(91982);
Object.defineProperty(exports, "CloudWorkloadSecurityAgentRuleCreateAttributes", ({ enumerable: true, get: function () { return CloudWorkloadSecurityAgentRuleCreateAttributes_1.CloudWorkloadSecurityAgentRuleCreateAttributes; } }));
var CloudWorkloadSecurityAgentRuleCreateData_1 = __webpack_require__(57506);
Object.defineProperty(exports, "CloudWorkloadSecurityAgentRuleCreateData", ({ enumerable: true, get: function () { return CloudWorkloadSecurityAgentRuleCreateData_1.CloudWorkloadSecurityAgentRuleCreateData; } }));
var CloudWorkloadSecurityAgentRuleCreateRequest_1 = __webpack_require__(11249);
Object.defineProperty(exports, "CloudWorkloadSecurityAgentRuleCreateRequest", ({ enumerable: true, get: function () { return CloudWorkloadSecurityAgentRuleCreateRequest_1.CloudWorkloadSecurityAgentRuleCreateRequest; } }));
var CloudWorkloadSecurityAgentRuleCreatorAttributes_1 = __webpack_require__(34366);
Object.defineProperty(exports, "CloudWorkloadSecurityAgentRuleCreatorAttributes", ({ enumerable: true, get: function () { return CloudWorkloadSecurityAgentRuleCreatorAttributes_1.CloudWorkloadSecurityAgentRuleCreatorAttributes; } }));
var CloudWorkloadSecurityAgentRuleData_1 = __webpack_require__(79526);
Object.defineProperty(exports, "CloudWorkloadSecurityAgentRuleData", ({ enumerable: true, get: function () { return CloudWorkloadSecurityAgentRuleData_1.CloudWorkloadSecurityAgentRuleData; } }));
var CloudWorkloadSecurityAgentRuleResponse_1 = __webpack_require__(70516);
Object.defineProperty(exports, "CloudWorkloadSecurityAgentRuleResponse", ({ enumerable: true, get: function () { return CloudWorkloadSecurityAgentRuleResponse_1.CloudWorkloadSecurityAgentRuleResponse; } }));
var CloudWorkloadSecurityAgentRulesListResponse_1 = __webpack_require__(42739);
Object.defineProperty(exports, "CloudWorkloadSecurityAgentRulesListResponse", ({ enumerable: true, get: function () { return CloudWorkloadSecurityAgentRulesListResponse_1.CloudWorkloadSecurityAgentRulesListResponse; } }));
var CloudWorkloadSecurityAgentRuleUpdateAttributes_1 = __webpack_require__(43319);
Object.defineProperty(exports, "CloudWorkloadSecurityAgentRuleUpdateAttributes", ({ enumerable: true, get: function () { return CloudWorkloadSecurityAgentRuleUpdateAttributes_1.CloudWorkloadSecurityAgentRuleUpdateAttributes; } }));
var CloudWorkloadSecurityAgentRuleUpdateData_1 = __webpack_require__(92347);
Object.defineProperty(exports, "CloudWorkloadSecurityAgentRuleUpdateData", ({ enumerable: true, get: function () { return CloudWorkloadSecurityAgentRuleUpdateData_1.CloudWorkloadSecurityAgentRuleUpdateData; } }));
var CloudWorkloadSecurityAgentRuleUpdaterAttributes_1 = __webpack_require__(22606);
Object.defineProperty(exports, "CloudWorkloadSecurityAgentRuleUpdaterAttributes", ({ enumerable: true, get: function () { return CloudWorkloadSecurityAgentRuleUpdaterAttributes_1.CloudWorkloadSecurityAgentRuleUpdaterAttributes; } }));
var CloudWorkloadSecurityAgentRuleUpdateRequest_1 = __webpack_require__(96586);
Object.defineProperty(exports, "CloudWorkloadSecurityAgentRuleUpdateRequest", ({ enumerable: true, get: function () { return CloudWorkloadSecurityAgentRuleUpdateRequest_1.CloudWorkloadSecurityAgentRuleUpdateRequest; } }));
var ConfluentAccountCreateRequest_1 = __webpack_require__(2398);
Object.defineProperty(exports, "ConfluentAccountCreateRequest", ({ enumerable: true, get: function () { return ConfluentAccountCreateRequest_1.ConfluentAccountCreateRequest; } }));
var ConfluentAccountCreateRequestAttributes_1 = __webpack_require__(28121);
Object.defineProperty(exports, "ConfluentAccountCreateRequestAttributes", ({ enumerable: true, get: function () { return ConfluentAccountCreateRequestAttributes_1.ConfluentAccountCreateRequestAttributes; } }));
var ConfluentAccountCreateRequestData_1 = __webpack_require__(43932);
Object.defineProperty(exports, "ConfluentAccountCreateRequestData", ({ enumerable: true, get: function () { return ConfluentAccountCreateRequestData_1.ConfluentAccountCreateRequestData; } }));
var ConfluentAccountResourceAttributes_1 = __webpack_require__(96316);
Object.defineProperty(exports, "ConfluentAccountResourceAttributes", ({ enumerable: true, get: function () { return ConfluentAccountResourceAttributes_1.ConfluentAccountResourceAttributes; } }));
var ConfluentAccountResponse_1 = __webpack_require__(98659);
Object.defineProperty(exports, "ConfluentAccountResponse", ({ enumerable: true, get: function () { return ConfluentAccountResponse_1.ConfluentAccountResponse; } }));
var ConfluentAccountResponseAttributes_1 = __webpack_require__(31345);
Object.defineProperty(exports, "ConfluentAccountResponseAttributes", ({ enumerable: true, get: function () { return ConfluentAccountResponseAttributes_1.ConfluentAccountResponseAttributes; } }));
var ConfluentAccountResponseData_1 = __webpack_require__(43122);
Object.defineProperty(exports, "ConfluentAccountResponseData", ({ enumerable: true, get: function () { return ConfluentAccountResponseData_1.ConfluentAccountResponseData; } }));
var ConfluentAccountsResponse_1 = __webpack_require__(66438);
Object.defineProperty(exports, "ConfluentAccountsResponse", ({ enumerable: true, get: function () { return ConfluentAccountsResponse_1.ConfluentAccountsResponse; } }));
var ConfluentAccountUpdateRequest_1 = __webpack_require__(36313);
Object.defineProperty(exports, "ConfluentAccountUpdateRequest", ({ enumerable: true, get: function () { return ConfluentAccountUpdateRequest_1.ConfluentAccountUpdateRequest; } }));
var ConfluentAccountUpdateRequestAttributes_1 = __webpack_require__(34989);
Object.defineProperty(exports, "ConfluentAccountUpdateRequestAttributes", ({ enumerable: true, get: function () { return ConfluentAccountUpdateRequestAttributes_1.ConfluentAccountUpdateRequestAttributes; } }));
var ConfluentAccountUpdateRequestData_1 = __webpack_require__(19026);
Object.defineProperty(exports, "ConfluentAccountUpdateRequestData", ({ enumerable: true, get: function () { return ConfluentAccountUpdateRequestData_1.ConfluentAccountUpdateRequestData; } }));
var ConfluentResourceRequest_1 = __webpack_require__(44539);
Object.defineProperty(exports, "ConfluentResourceRequest", ({ enumerable: true, get: function () { return ConfluentResourceRequest_1.ConfluentResourceRequest; } }));
var ConfluentResourceRequestAttributes_1 = __webpack_require__(19799);
Object.defineProperty(exports, "ConfluentResourceRequestAttributes", ({ enumerable: true, get: function () { return ConfluentResourceRequestAttributes_1.ConfluentResourceRequestAttributes; } }));
var ConfluentResourceRequestData_1 = __webpack_require__(40667);
Object.defineProperty(exports, "ConfluentResourceRequestData", ({ enumerable: true, get: function () { return ConfluentResourceRequestData_1.ConfluentResourceRequestData; } }));
var ConfluentResourceResponse_1 = __webpack_require__(4896);
Object.defineProperty(exports, "ConfluentResourceResponse", ({ enumerable: true, get: function () { return ConfluentResourceResponse_1.ConfluentResourceResponse; } }));
var ConfluentResourceResponseAttributes_1 = __webpack_require__(32977);
Object.defineProperty(exports, "ConfluentResourceResponseAttributes", ({ enumerable: true, get: function () { return ConfluentResourceResponseAttributes_1.ConfluentResourceResponseAttributes; } }));
var ConfluentResourceResponseData_1 = __webpack_require__(92723);
Object.defineProperty(exports, "ConfluentResourceResponseData", ({ enumerable: true, get: function () { return ConfluentResourceResponseData_1.ConfluentResourceResponseData; } }));
var ConfluentResourcesResponse_1 = __webpack_require__(92452);
Object.defineProperty(exports, "ConfluentResourcesResponse", ({ enumerable: true, get: function () { return ConfluentResourcesResponse_1.ConfluentResourcesResponse; } }));
var CostByOrg_1 = __webpack_require__(62609);
Object.defineProperty(exports, "CostByOrg", ({ enumerable: true, get: function () { return CostByOrg_1.CostByOrg; } }));
var CostByOrgAttributes_1 = __webpack_require__(268);
Object.defineProperty(exports, "CostByOrgAttributes", ({ enumerable: true, get: function () { return CostByOrgAttributes_1.CostByOrgAttributes; } }));
var CostByOrgResponse_1 = __webpack_require__(79292);
Object.defineProperty(exports, "CostByOrgResponse", ({ enumerable: true, get: function () { return CostByOrgResponse_1.CostByOrgResponse; } }));
var Creator_1 = __webpack_require__(81580);
Object.defineProperty(exports, "Creator", ({ enumerable: true, get: function () { return Creator_1.Creator; } }));
var DashboardListAddItemsRequest_1 = __webpack_require__(1746);
Object.defineProperty(exports, "DashboardListAddItemsRequest", ({ enumerable: true, get: function () { return DashboardListAddItemsRequest_1.DashboardListAddItemsRequest; } }));
var DashboardListAddItemsResponse_1 = __webpack_require__(97047);
Object.defineProperty(exports, "DashboardListAddItemsResponse", ({ enumerable: true, get: function () { return DashboardListAddItemsResponse_1.DashboardListAddItemsResponse; } }));
var DashboardListDeleteItemsRequest_1 = __webpack_require__(6487);
Object.defineProperty(exports, "DashboardListDeleteItemsRequest", ({ enumerable: true, get: function () { return DashboardListDeleteItemsRequest_1.DashboardListDeleteItemsRequest; } }));
var DashboardListDeleteItemsResponse_1 = __webpack_require__(79067);
Object.defineProperty(exports, "DashboardListDeleteItemsResponse", ({ enumerable: true, get: function () { return DashboardListDeleteItemsResponse_1.DashboardListDeleteItemsResponse; } }));
var DashboardListItem_1 = __webpack_require__(25719);
Object.defineProperty(exports, "DashboardListItem", ({ enumerable: true, get: function () { return DashboardListItem_1.DashboardListItem; } }));
var DashboardListItemRequest_1 = __webpack_require__(72262);
Object.defineProperty(exports, "DashboardListItemRequest", ({ enumerable: true, get: function () { return DashboardListItemRequest_1.DashboardListItemRequest; } }));
var DashboardListItemResponse_1 = __webpack_require__(24037);
Object.defineProperty(exports, "DashboardListItemResponse", ({ enumerable: true, get: function () { return DashboardListItemResponse_1.DashboardListItemResponse; } }));
var DashboardListItems_1 = __webpack_require__(19638);
Object.defineProperty(exports, "DashboardListItems", ({ enumerable: true, get: function () { return DashboardListItems_1.DashboardListItems; } }));
var DashboardListUpdateItemsRequest_1 = __webpack_require__(88487);
Object.defineProperty(exports, "DashboardListUpdateItemsRequest", ({ enumerable: true, get: function () { return DashboardListUpdateItemsRequest_1.DashboardListUpdateItemsRequest; } }));
var DashboardListUpdateItemsResponse_1 = __webpack_require__(3644);
Object.defineProperty(exports, "DashboardListUpdateItemsResponse", ({ enumerable: true, get: function () { return DashboardListUpdateItemsResponse_1.DashboardListUpdateItemsResponse; } }));
var DataScalarColumn_1 = __webpack_require__(83457);
Object.defineProperty(exports, "DataScalarColumn", ({ enumerable: true, get: function () { return DataScalarColumn_1.DataScalarColumn; } }));
var Event_1 = __webpack_require__(80441);
Object.defineProperty(exports, "Event", ({ enumerable: true, get: function () { return Event_1.Event; } }));
var EventAttributes_1 = __webpack_require__(54941);
Object.defineProperty(exports, "EventAttributes", ({ enumerable: true, get: function () { return EventAttributes_1.EventAttributes; } }));
var EventResponse_1 = __webpack_require__(77892);
Object.defineProperty(exports, "EventResponse", ({ enumerable: true, get: function () { return EventResponse_1.EventResponse; } }));
var EventResponseAttributes_1 = __webpack_require__(90525);
Object.defineProperty(exports, "EventResponseAttributes", ({ enumerable: true, get: function () { return EventResponseAttributes_1.EventResponseAttributes; } }));
var EventsCompute_1 = __webpack_require__(57394);
Object.defineProperty(exports, "EventsCompute", ({ enumerable: true, get: function () { return EventsCompute_1.EventsCompute; } }));
var EventsGroupBy_1 = __webpack_require__(96960);
Object.defineProperty(exports, "EventsGroupBy", ({ enumerable: true, get: function () { return EventsGroupBy_1.EventsGroupBy; } }));
var EventsGroupBySort_1 = __webpack_require__(61256);
Object.defineProperty(exports, "EventsGroupBySort", ({ enumerable: true, get: function () { return EventsGroupBySort_1.EventsGroupBySort; } }));
var EventsListRequest_1 = __webpack_require__(23754);
Object.defineProperty(exports, "EventsListRequest", ({ enumerable: true, get: function () { return EventsListRequest_1.EventsListRequest; } }));
var EventsListResponse_1 = __webpack_require__(43236);
Object.defineProperty(exports, "EventsListResponse", ({ enumerable: true, get: function () { return EventsListResponse_1.EventsListResponse; } }));
var EventsListResponseLinks_1 = __webpack_require__(80820);
Object.defineProperty(exports, "EventsListResponseLinks", ({ enumerable: true, get: function () { return EventsListResponseLinks_1.EventsListResponseLinks; } }));
var EventsQueryFilter_1 = __webpack_require__(31925);
Object.defineProperty(exports, "EventsQueryFilter", ({ enumerable: true, get: function () { return EventsQueryFilter_1.EventsQueryFilter; } }));
var EventsQueryOptions_1 = __webpack_require__(64638);
Object.defineProperty(exports, "EventsQueryOptions", ({ enumerable: true, get: function () { return EventsQueryOptions_1.EventsQueryOptions; } }));
var EventsRequestPage_1 = __webpack_require__(57858);
Object.defineProperty(exports, "EventsRequestPage", ({ enumerable: true, get: function () { return EventsRequestPage_1.EventsRequestPage; } }));
var EventsResponseMetadata_1 = __webpack_require__(24290);
Object.defineProperty(exports, "EventsResponseMetadata", ({ enumerable: true, get: function () { return EventsResponseMetadata_1.EventsResponseMetadata; } }));
var EventsResponseMetadataPage_1 = __webpack_require__(90178);
Object.defineProperty(exports, "EventsResponseMetadataPage", ({ enumerable: true, get: function () { return EventsResponseMetadataPage_1.EventsResponseMetadataPage; } }));
var EventsScalarQuery_1 = __webpack_require__(69968);
Object.defineProperty(exports, "EventsScalarQuery", ({ enumerable: true, get: function () { return EventsScalarQuery_1.EventsScalarQuery; } }));
var EventsSearch_1 = __webpack_require__(98043);
Object.defineProperty(exports, "EventsSearch", ({ enumerable: true, get: function () { return EventsSearch_1.EventsSearch; } }));
var EventsTimeseriesQuery_1 = __webpack_require__(55504);
Object.defineProperty(exports, "EventsTimeseriesQuery", ({ enumerable: true, get: function () { return EventsTimeseriesQuery_1.EventsTimeseriesQuery; } }));
var EventsWarning_1 = __webpack_require__(72766);
Object.defineProperty(exports, "EventsWarning", ({ enumerable: true, get: function () { return EventsWarning_1.EventsWarning; } }));
var FastlyAccounResponseAttributes_1 = __webpack_require__(99983);
Object.defineProperty(exports, "FastlyAccounResponseAttributes", ({ enumerable: true, get: function () { return FastlyAccounResponseAttributes_1.FastlyAccounResponseAttributes; } }));
var FastlyAccountCreateRequest_1 = __webpack_require__(25259);
Object.defineProperty(exports, "FastlyAccountCreateRequest", ({ enumerable: true, get: function () { return FastlyAccountCreateRequest_1.FastlyAccountCreateRequest; } }));
var FastlyAccountCreateRequestAttributes_1 = __webpack_require__(95711);
Object.defineProperty(exports, "FastlyAccountCreateRequestAttributes", ({ enumerable: true, get: function () { return FastlyAccountCreateRequestAttributes_1.FastlyAccountCreateRequestAttributes; } }));
var FastlyAccountCreateRequestData_1 = __webpack_require__(18422);
Object.defineProperty(exports, "FastlyAccountCreateRequestData", ({ enumerable: true, get: function () { return FastlyAccountCreateRequestData_1.FastlyAccountCreateRequestData; } }));
var FastlyAccountResponse_1 = __webpack_require__(15310);
Object.defineProperty(exports, "FastlyAccountResponse", ({ enumerable: true, get: function () { return FastlyAccountResponse_1.FastlyAccountResponse; } }));
var FastlyAccountResponseData_1 = __webpack_require__(4599);
Object.defineProperty(exports, "FastlyAccountResponseData", ({ enumerable: true, get: function () { return FastlyAccountResponseData_1.FastlyAccountResponseData; } }));
var FastlyAccountsResponse_1 = __webpack_require__(11681);
Object.defineProperty(exports, "FastlyAccountsResponse", ({ enumerable: true, get: function () { return FastlyAccountsResponse_1.FastlyAccountsResponse; } }));
var FastlyAccountUpdateRequest_1 = __webpack_require__(15128);
Object.defineProperty(exports, "FastlyAccountUpdateRequest", ({ enumerable: true, get: function () { return FastlyAccountUpdateRequest_1.FastlyAccountUpdateRequest; } }));
var FastlyAccountUpdateRequestAttributes_1 = __webpack_require__(30189);
Object.defineProperty(exports, "FastlyAccountUpdateRequestAttributes", ({ enumerable: true, get: function () { return FastlyAccountUpdateRequestAttributes_1.FastlyAccountUpdateRequestAttributes; } }));
var FastlyAccountUpdateRequestData_1 = __webpack_require__(550);
Object.defineProperty(exports, "FastlyAccountUpdateRequestData", ({ enumerable: true, get: function () { return FastlyAccountUpdateRequestData_1.FastlyAccountUpdateRequestData; } }));
var FastlyService_1 = __webpack_require__(8518);
Object.defineProperty(exports, "FastlyService", ({ enumerable: true, get: function () { return FastlyService_1.FastlyService; } }));
var FastlyServiceAttributes_1 = __webpack_require__(83707);
Object.defineProperty(exports, "FastlyServiceAttributes", ({ enumerable: true, get: function () { return FastlyServiceAttributes_1.FastlyServiceAttributes; } }));
var FastlyServiceData_1 = __webpack_require__(79404);
Object.defineProperty(exports, "FastlyServiceData", ({ enumerable: true, get: function () { return FastlyServiceData_1.FastlyServiceData; } }));
var FastlyServiceRequest_1 = __webpack_require__(8366);
Object.defineProperty(exports, "FastlyServiceRequest", ({ enumerable: true, get: function () { return FastlyServiceRequest_1.FastlyServiceRequest; } }));
var FastlyServiceResponse_1 = __webpack_require__(27210);
Object.defineProperty(exports, "FastlyServiceResponse", ({ enumerable: true, get: function () { return FastlyServiceResponse_1.FastlyServiceResponse; } }));
var FastlyServicesResponse_1 = __webpack_require__(7220);
Object.defineProperty(exports, "FastlyServicesResponse", ({ enumerable: true, get: function () { return FastlyServicesResponse_1.FastlyServicesResponse; } }));
var FormulaLimit_1 = __webpack_require__(97118);
Object.defineProperty(exports, "FormulaLimit", ({ enumerable: true, get: function () { return FormulaLimit_1.FormulaLimit; } }));
var FullAPIKey_1 = __webpack_require__(56159);
Object.defineProperty(exports, "FullAPIKey", ({ enumerable: true, get: function () { return FullAPIKey_1.FullAPIKey; } }));
var FullAPIKeyAttributes_1 = __webpack_require__(25642);
Object.defineProperty(exports, "FullAPIKeyAttributes", ({ enumerable: true, get: function () { return FullAPIKeyAttributes_1.FullAPIKeyAttributes; } }));
var FullApplicationKey_1 = __webpack_require__(54147);
Object.defineProperty(exports, "FullApplicationKey", ({ enumerable: true, get: function () { return FullApplicationKey_1.FullApplicationKey; } }));
var FullApplicationKeyAttributes_1 = __webpack_require__(79380);
Object.defineProperty(exports, "FullApplicationKeyAttributes", ({ enumerable: true, get: function () { return FullApplicationKeyAttributes_1.FullApplicationKeyAttributes; } }));
var GroupScalarColumn_1 = __webpack_require__(2189);
Object.defineProperty(exports, "GroupScalarColumn", ({ enumerable: true, get: function () { return GroupScalarColumn_1.GroupScalarColumn; } }));
var HourlyUsage_1 = __webpack_require__(26722);
Object.defineProperty(exports, "HourlyUsage", ({ enumerable: true, get: function () { return HourlyUsage_1.HourlyUsage; } }));
var HourlyUsageAttributes_1 = __webpack_require__(89886);
Object.defineProperty(exports, "HourlyUsageAttributes", ({ enumerable: true, get: function () { return HourlyUsageAttributes_1.HourlyUsageAttributes; } }));
var HourlyUsageMeasurement_1 = __webpack_require__(45509);
Object.defineProperty(exports, "HourlyUsageMeasurement", ({ enumerable: true, get: function () { return HourlyUsageMeasurement_1.HourlyUsageMeasurement; } }));
var HourlyUsageMetadata_1 = __webpack_require__(12821);
Object.defineProperty(exports, "HourlyUsageMetadata", ({ enumerable: true, get: function () { return HourlyUsageMetadata_1.HourlyUsageMetadata; } }));
var HourlyUsagePagination_1 = __webpack_require__(79406);
Object.defineProperty(exports, "HourlyUsagePagination", ({ enumerable: true, get: function () { return HourlyUsagePagination_1.HourlyUsagePagination; } }));
var HourlyUsageResponse_1 = __webpack_require__(70015);
Object.defineProperty(exports, "HourlyUsageResponse", ({ enumerable: true, get: function () { return HourlyUsageResponse_1.HourlyUsageResponse; } }));
var HTTPLogError_1 = __webpack_require__(73991);
Object.defineProperty(exports, "HTTPLogError", ({ enumerable: true, get: function () { return HTTPLogError_1.HTTPLogError; } }));
var HTTPLogErrors_1 = __webpack_require__(18911);
Object.defineProperty(exports, "HTTPLogErrors", ({ enumerable: true, get: function () { return HTTPLogErrors_1.HTTPLogErrors; } }));
var HTTPLogItem_1 = __webpack_require__(40312);
Object.defineProperty(exports, "HTTPLogItem", ({ enumerable: true, get: function () { return HTTPLogItem_1.HTTPLogItem; } }));
var IdPMetadataFormData_1 = __webpack_require__(68145);
Object.defineProperty(exports, "IdPMetadataFormData", ({ enumerable: true, get: function () { return IdPMetadataFormData_1.IdPMetadataFormData; } }));
var IncidentAttachmentData_1 = __webpack_require__(25208);
Object.defineProperty(exports, "IncidentAttachmentData", ({ enumerable: true, get: function () { return IncidentAttachmentData_1.IncidentAttachmentData; } }));
var IncidentAttachmentLinkAttributes_1 = __webpack_require__(78737);
Object.defineProperty(exports, "IncidentAttachmentLinkAttributes", ({ enumerable: true, get: function () { return IncidentAttachmentLinkAttributes_1.IncidentAttachmentLinkAttributes; } }));
var IncidentAttachmentLinkAttributesAttachmentObject_1 = __webpack_require__(12645);
Object.defineProperty(exports, "IncidentAttachmentLinkAttributesAttachmentObject", ({ enumerable: true, get: function () { return IncidentAttachmentLinkAttributesAttachmentObject_1.IncidentAttachmentLinkAttributesAttachmentObject; } }));
var IncidentAttachmentPostmortemAttributes_1 = __webpack_require__(14721);
Object.defineProperty(exports, "IncidentAttachmentPostmortemAttributes", ({ enumerable: true, get: function () { return IncidentAttachmentPostmortemAttributes_1.IncidentAttachmentPostmortemAttributes; } }));
var IncidentAttachmentRelationships_1 = __webpack_require__(11967);
Object.defineProperty(exports, "IncidentAttachmentRelationships", ({ enumerable: true, get: function () { return IncidentAttachmentRelationships_1.IncidentAttachmentRelationships; } }));
var IncidentAttachmentsPostmortemAttributesAttachmentObject_1 = __webpack_require__(46618);
Object.defineProperty(exports, "IncidentAttachmentsPostmortemAttributesAttachmentObject", ({ enumerable: true, get: function () { return IncidentAttachmentsPostmortemAttributesAttachmentObject_1.IncidentAttachmentsPostmortemAttributesAttachmentObject; } }));
var IncidentAttachmentsResponse_1 = __webpack_require__(37959);
Object.defineProperty(exports, "IncidentAttachmentsResponse", ({ enumerable: true, get: function () { return IncidentAttachmentsResponse_1.IncidentAttachmentsResponse; } }));
var IncidentAttachmentUpdateData_1 = __webpack_require__(36350);
Object.defineProperty(exports, "IncidentAttachmentUpdateData", ({ enumerable: true, get: function () { return IncidentAttachmentUpdateData_1.IncidentAttachmentUpdateData; } }));
var IncidentAttachmentUpdateRequest_1 = __webpack_require__(72450);
Object.defineProperty(exports, "IncidentAttachmentUpdateRequest", ({ enumerable: true, get: function () { return IncidentAttachmentUpdateRequest_1.IncidentAttachmentUpdateRequest; } }));
var IncidentAttachmentUpdateResponse_1 = __webpack_require__(23453);
Object.defineProperty(exports, "IncidentAttachmentUpdateResponse", ({ enumerable: true, get: function () { return IncidentAttachmentUpdateResponse_1.IncidentAttachmentUpdateResponse; } }));
var IncidentCreateAttributes_1 = __webpack_require__(85021);
Object.defineProperty(exports, "IncidentCreateAttributes", ({ enumerable: true, get: function () { return IncidentCreateAttributes_1.IncidentCreateAttributes; } }));
var IncidentCreateData_1 = __webpack_require__(33708);
Object.defineProperty(exports, "IncidentCreateData", ({ enumerable: true, get: function () { return IncidentCreateData_1.IncidentCreateData; } }));
var IncidentCreateRelationships_1 = __webpack_require__(87980);
Object.defineProperty(exports, "IncidentCreateRelationships", ({ enumerable: true, get: function () { return IncidentCreateRelationships_1.IncidentCreateRelationships; } }));
var IncidentCreateRequest_1 = __webpack_require__(79893);
Object.defineProperty(exports, "IncidentCreateRequest", ({ enumerable: true, get: function () { return IncidentCreateRequest_1.IncidentCreateRequest; } }));
var IncidentFieldAttributesMultipleValue_1 = __webpack_require__(85167);
Object.defineProperty(exports, "IncidentFieldAttributesMultipleValue", ({ enumerable: true, get: function () { return IncidentFieldAttributesMultipleValue_1.IncidentFieldAttributesMultipleValue; } }));
var IncidentFieldAttributesSingleValue_1 = __webpack_require__(65717);
Object.defineProperty(exports, "IncidentFieldAttributesSingleValue", ({ enumerable: true, get: function () { return IncidentFieldAttributesSingleValue_1.IncidentFieldAttributesSingleValue; } }));
var IncidentNotificationHandle_1 = __webpack_require__(64132);
Object.defineProperty(exports, "IncidentNotificationHandle", ({ enumerable: true, get: function () { return IncidentNotificationHandle_1.IncidentNotificationHandle; } }));
var IncidentResponse_1 = __webpack_require__(85933);
Object.defineProperty(exports, "IncidentResponse", ({ enumerable: true, get: function () { return IncidentResponse_1.IncidentResponse; } }));
var IncidentResponseAttributes_1 = __webpack_require__(72948);
Object.defineProperty(exports, "IncidentResponseAttributes", ({ enumerable: true, get: function () { return IncidentResponseAttributes_1.IncidentResponseAttributes; } }));
var IncidentResponseData_1 = __webpack_require__(20274);
Object.defineProperty(exports, "IncidentResponseData", ({ enumerable: true, get: function () { return IncidentResponseData_1.IncidentResponseData; } }));
var IncidentResponseMeta_1 = __webpack_require__(16729);
Object.defineProperty(exports, "IncidentResponseMeta", ({ enumerable: true, get: function () { return IncidentResponseMeta_1.IncidentResponseMeta; } }));
var IncidentResponseMetaPagination_1 = __webpack_require__(97345);
Object.defineProperty(exports, "IncidentResponseMetaPagination", ({ enumerable: true, get: function () { return IncidentResponseMetaPagination_1.IncidentResponseMetaPagination; } }));
var IncidentResponseRelationships_1 = __webpack_require__(88233);
Object.defineProperty(exports, "IncidentResponseRelationships", ({ enumerable: true, get: function () { return IncidentResponseRelationships_1.IncidentResponseRelationships; } }));
var IncidentSearchResponse_1 = __webpack_require__(89998);
Object.defineProperty(exports, "IncidentSearchResponse", ({ enumerable: true, get: function () { return IncidentSearchResponse_1.IncidentSearchResponse; } }));
var IncidentSearchResponseAttributes_1 = __webpack_require__(56435);
Object.defineProperty(exports, "IncidentSearchResponseAttributes", ({ enumerable: true, get: function () { return IncidentSearchResponseAttributes_1.IncidentSearchResponseAttributes; } }));
var IncidentSearchResponseData_1 = __webpack_require__(24443);
Object.defineProperty(exports, "IncidentSearchResponseData", ({ enumerable: true, get: function () { return IncidentSearchResponseData_1.IncidentSearchResponseData; } }));
var IncidentSearchResponseFacetsData_1 = __webpack_require__(42940);
Object.defineProperty(exports, "IncidentSearchResponseFacetsData", ({ enumerable: true, get: function () { return IncidentSearchResponseFacetsData_1.IncidentSearchResponseFacetsData; } }));
var IncidentSearchResponseFieldFacetData_1 = __webpack_require__(90951);
Object.defineProperty(exports, "IncidentSearchResponseFieldFacetData", ({ enumerable: true, get: function () { return IncidentSearchResponseFieldFacetData_1.IncidentSearchResponseFieldFacetData; } }));
var IncidentSearchResponseIncidentsData_1 = __webpack_require__(16704);
Object.defineProperty(exports, "IncidentSearchResponseIncidentsData", ({ enumerable: true, get: function () { return IncidentSearchResponseIncidentsData_1.IncidentSearchResponseIncidentsData; } }));
var IncidentSearchResponseNumericFacetData_1 = __webpack_require__(15843);
Object.defineProperty(exports, "IncidentSearchResponseNumericFacetData", ({ enumerable: true, get: function () { return IncidentSearchResponseNumericFacetData_1.IncidentSearchResponseNumericFacetData; } }));
var IncidentSearchResponseNumericFacetDataAggregates_1 = __webpack_require__(9253);
Object.defineProperty(exports, "IncidentSearchResponseNumericFacetDataAggregates", ({ enumerable: true, get: function () { return IncidentSearchResponseNumericFacetDataAggregates_1.IncidentSearchResponseNumericFacetDataAggregates; } }));
var IncidentSearchResponsePropertyFieldFacetData_1 = __webpack_require__(23290);
Object.defineProperty(exports, "IncidentSearchResponsePropertyFieldFacetData", ({ enumerable: true, get: function () { return IncidentSearchResponsePropertyFieldFacetData_1.IncidentSearchResponsePropertyFieldFacetData; } }));
var IncidentSearchResponseUserFacetData_1 = __webpack_require__(64690);
Object.defineProperty(exports, "IncidentSearchResponseUserFacetData", ({ enumerable: true, get: function () { return IncidentSearchResponseUserFacetData_1.IncidentSearchResponseUserFacetData; } }));
var IncidentServiceCreateAttributes_1 = __webpack_require__(81262);
Object.defineProperty(exports, "IncidentServiceCreateAttributes", ({ enumerable: true, get: function () { return IncidentServiceCreateAttributes_1.IncidentServiceCreateAttributes; } }));
var IncidentServiceCreateData_1 = __webpack_require__(50275);
Object.defineProperty(exports, "IncidentServiceCreateData", ({ enumerable: true, get: function () { return IncidentServiceCreateData_1.IncidentServiceCreateData; } }));
var IncidentServiceCreateRequest_1 = __webpack_require__(61042);
Object.defineProperty(exports, "IncidentServiceCreateRequest", ({ enumerable: true, get: function () { return IncidentServiceCreateRequest_1.IncidentServiceCreateRequest; } }));
var IncidentServiceRelationships_1 = __webpack_require__(67742);
Object.defineProperty(exports, "IncidentServiceRelationships", ({ enumerable: true, get: function () { return IncidentServiceRelationships_1.IncidentServiceRelationships; } }));
var IncidentServiceResponse_1 = __webpack_require__(8010);
Object.defineProperty(exports, "IncidentServiceResponse", ({ enumerable: true, get: function () { return IncidentServiceResponse_1.IncidentServiceResponse; } }));
var IncidentServiceResponseAttributes_1 = __webpack_require__(64840);
Object.defineProperty(exports, "IncidentServiceResponseAttributes", ({ enumerable: true, get: function () { return IncidentServiceResponseAttributes_1.IncidentServiceResponseAttributes; } }));
var IncidentServiceResponseData_1 = __webpack_require__(13259);
Object.defineProperty(exports, "IncidentServiceResponseData", ({ enumerable: true, get: function () { return IncidentServiceResponseData_1.IncidentServiceResponseData; } }));
var IncidentServicesResponse_1 = __webpack_require__(67102);
Object.defineProperty(exports, "IncidentServicesResponse", ({ enumerable: true, get: function () { return IncidentServicesResponse_1.IncidentServicesResponse; } }));
var IncidentServiceUpdateAttributes_1 = __webpack_require__(2935);
Object.defineProperty(exports, "IncidentServiceUpdateAttributes", ({ enumerable: true, get: function () { return IncidentServiceUpdateAttributes_1.IncidentServiceUpdateAttributes; } }));
var IncidentServiceUpdateData_1 = __webpack_require__(63215);
Object.defineProperty(exports, "IncidentServiceUpdateData", ({ enumerable: true, get: function () { return IncidentServiceUpdateData_1.IncidentServiceUpdateData; } }));
var IncidentServiceUpdateRequest_1 = __webpack_require__(97971);
Object.defineProperty(exports, "IncidentServiceUpdateRequest", ({ enumerable: true, get: function () { return IncidentServiceUpdateRequest_1.IncidentServiceUpdateRequest; } }));
var IncidentsResponse_1 = __webpack_require__(84660);
Object.defineProperty(exports, "IncidentsResponse", ({ enumerable: true, get: function () { return IncidentsResponse_1.IncidentsResponse; } }));
var IncidentTeamCreateAttributes_1 = __webpack_require__(20944);
Object.defineProperty(exports, "IncidentTeamCreateAttributes", ({ enumerable: true, get: function () { return IncidentTeamCreateAttributes_1.IncidentTeamCreateAttributes; } }));
var IncidentTeamCreateData_1 = __webpack_require__(83456);
Object.defineProperty(exports, "IncidentTeamCreateData", ({ enumerable: true, get: function () { return IncidentTeamCreateData_1.IncidentTeamCreateData; } }));
var IncidentTeamCreateRequest_1 = __webpack_require__(46712);
Object.defineProperty(exports, "IncidentTeamCreateRequest", ({ enumerable: true, get: function () { return IncidentTeamCreateRequest_1.IncidentTeamCreateRequest; } }));
var IncidentTeamRelationships_1 = __webpack_require__(31266);
Object.defineProperty(exports, "IncidentTeamRelationships", ({ enumerable: true, get: function () { return IncidentTeamRelationships_1.IncidentTeamRelationships; } }));
var IncidentTeamResponse_1 = __webpack_require__(88841);
Object.defineProperty(exports, "IncidentTeamResponse", ({ enumerable: true, get: function () { return IncidentTeamResponse_1.IncidentTeamResponse; } }));
var IncidentTeamResponseAttributes_1 = __webpack_require__(13482);
Object.defineProperty(exports, "IncidentTeamResponseAttributes", ({ enumerable: true, get: function () { return IncidentTeamResponseAttributes_1.IncidentTeamResponseAttributes; } }));
var IncidentTeamResponseData_1 = __webpack_require__(79651);
Object.defineProperty(exports, "IncidentTeamResponseData", ({ enumerable: true, get: function () { return IncidentTeamResponseData_1.IncidentTeamResponseData; } }));
var IncidentTeamsResponse_1 = __webpack_require__(72162);
Object.defineProperty(exports, "IncidentTeamsResponse", ({ enumerable: true, get: function () { return IncidentTeamsResponse_1.IncidentTeamsResponse; } }));
var IncidentTeamUpdateAttributes_1 = __webpack_require__(14799);
Object.defineProperty(exports, "IncidentTeamUpdateAttributes", ({ enumerable: true, get: function () { return IncidentTeamUpdateAttributes_1.IncidentTeamUpdateAttributes; } }));
var IncidentTeamUpdateData_1 = __webpack_require__(41914);
Object.defineProperty(exports, "IncidentTeamUpdateData", ({ enumerable: true, get: function () { return IncidentTeamUpdateData_1.IncidentTeamUpdateData; } }));
var IncidentTeamUpdateRequest_1 = __webpack_require__(1174);
Object.defineProperty(exports, "IncidentTeamUpdateRequest", ({ enumerable: true, get: function () { return IncidentTeamUpdateRequest_1.IncidentTeamUpdateRequest; } }));
var IncidentTimelineCellMarkdownCreateAttributes_1 = __webpack_require__(48212);
Object.defineProperty(exports, "IncidentTimelineCellMarkdownCreateAttributes", ({ enumerable: true, get: function () { return IncidentTimelineCellMarkdownCreateAttributes_1.IncidentTimelineCellMarkdownCreateAttributes; } }));
var IncidentTimelineCellMarkdownCreateAttributesContent_1 = __webpack_require__(4504);
Object.defineProperty(exports, "IncidentTimelineCellMarkdownCreateAttributesContent", ({ enumerable: true, get: function () { return IncidentTimelineCellMarkdownCreateAttributesContent_1.IncidentTimelineCellMarkdownCreateAttributesContent; } }));
var IncidentUpdateAttributes_1 = __webpack_require__(87879);
Object.defineProperty(exports, "IncidentUpdateAttributes", ({ enumerable: true, get: function () { return IncidentUpdateAttributes_1.IncidentUpdateAttributes; } }));
var IncidentUpdateData_1 = __webpack_require__(14695);
Object.defineProperty(exports, "IncidentUpdateData", ({ enumerable: true, get: function () { return IncidentUpdateData_1.IncidentUpdateData; } }));
var IncidentUpdateRelationships_1 = __webpack_require__(40863);
Object.defineProperty(exports, "IncidentUpdateRelationships", ({ enumerable: true, get: function () { return IncidentUpdateRelationships_1.IncidentUpdateRelationships; } }));
var IncidentUpdateRequest_1 = __webpack_require__(94252);
Object.defineProperty(exports, "IncidentUpdateRequest", ({ enumerable: true, get: function () { return IncidentUpdateRequest_1.IncidentUpdateRequest; } }));
var IntakePayloadAccepted_1 = __webpack_require__(50768);
Object.defineProperty(exports, "IntakePayloadAccepted", ({ enumerable: true, get: function () { return IntakePayloadAccepted_1.IntakePayloadAccepted; } }));
var ListApplicationKeysResponse_1 = __webpack_require__(33213);
Object.defineProperty(exports, "ListApplicationKeysResponse", ({ enumerable: true, get: function () { return ListApplicationKeysResponse_1.ListApplicationKeysResponse; } }));
var Log_1 = __webpack_require__(50679);
Object.defineProperty(exports, "Log", ({ enumerable: true, get: function () { return Log_1.Log; } }));
var LogAttributes_1 = __webpack_require__(82583);
Object.defineProperty(exports, "LogAttributes", ({ enumerable: true, get: function () { return LogAttributes_1.LogAttributes; } }));
var LogsAggregateBucket_1 = __webpack_require__(48920);
Object.defineProperty(exports, "LogsAggregateBucket", ({ enumerable: true, get: function () { return LogsAggregateBucket_1.LogsAggregateBucket; } }));
var LogsAggregateBucketValueTimeseriesPoint_1 = __webpack_require__(87989);
Object.defineProperty(exports, "LogsAggregateBucketValueTimeseriesPoint", ({ enumerable: true, get: function () { return LogsAggregateBucketValueTimeseriesPoint_1.LogsAggregateBucketValueTimeseriesPoint; } }));
var LogsAggregateRequest_1 = __webpack_require__(13619);
Object.defineProperty(exports, "LogsAggregateRequest", ({ enumerable: true, get: function () { return LogsAggregateRequest_1.LogsAggregateRequest; } }));
var LogsAggregateRequestPage_1 = __webpack_require__(73702);
Object.defineProperty(exports, "LogsAggregateRequestPage", ({ enumerable: true, get: function () { return LogsAggregateRequestPage_1.LogsAggregateRequestPage; } }));
var LogsAggregateResponse_1 = __webpack_require__(42578);
Object.defineProperty(exports, "LogsAggregateResponse", ({ enumerable: true, get: function () { return LogsAggregateResponse_1.LogsAggregateResponse; } }));
var LogsAggregateResponseData_1 = __webpack_require__(95647);
Object.defineProperty(exports, "LogsAggregateResponseData", ({ enumerable: true, get: function () { return LogsAggregateResponseData_1.LogsAggregateResponseData; } }));
var LogsAggregateSort_1 = __webpack_require__(49817);
Object.defineProperty(exports, "LogsAggregateSort", ({ enumerable: true, get: function () { return LogsAggregateSort_1.LogsAggregateSort; } }));
var LogsArchive_1 = __webpack_require__(15665);
Object.defineProperty(exports, "LogsArchive", ({ enumerable: true, get: function () { return LogsArchive_1.LogsArchive; } }));
var LogsArchiveAttributes_1 = __webpack_require__(14064);
Object.defineProperty(exports, "LogsArchiveAttributes", ({ enumerable: true, get: function () { return LogsArchiveAttributes_1.LogsArchiveAttributes; } }));
var LogsArchiveCreateRequest_1 = __webpack_require__(20167);
Object.defineProperty(exports, "LogsArchiveCreateRequest", ({ enumerable: true, get: function () { return LogsArchiveCreateRequest_1.LogsArchiveCreateRequest; } }));
var LogsArchiveCreateRequestAttributes_1 = __webpack_require__(44357);
Object.defineProperty(exports, "LogsArchiveCreateRequestAttributes", ({ enumerable: true, get: function () { return LogsArchiveCreateRequestAttributes_1.LogsArchiveCreateRequestAttributes; } }));
var LogsArchiveCreateRequestDefinition_1 = __webpack_require__(41915);
Object.defineProperty(exports, "LogsArchiveCreateRequestDefinition", ({ enumerable: true, get: function () { return LogsArchiveCreateRequestDefinition_1.LogsArchiveCreateRequestDefinition; } }));
var LogsArchiveDefinition_1 = __webpack_require__(48978);
Object.defineProperty(exports, "LogsArchiveDefinition", ({ enumerable: true, get: function () { return LogsArchiveDefinition_1.LogsArchiveDefinition; } }));
var LogsArchiveDestinationAzure_1 = __webpack_require__(29038);
Object.defineProperty(exports, "LogsArchiveDestinationAzure", ({ enumerable: true, get: function () { return LogsArchiveDestinationAzure_1.LogsArchiveDestinationAzure; } }));
var LogsArchiveDestinationGCS_1 = __webpack_require__(71657);
Object.defineProperty(exports, "LogsArchiveDestinationGCS", ({ enumerable: true, get: function () { return LogsArchiveDestinationGCS_1.LogsArchiveDestinationGCS; } }));
var LogsArchiveDestinationS3_1 = __webpack_require__(87520);
Object.defineProperty(exports, "LogsArchiveDestinationS3", ({ enumerable: true, get: function () { return LogsArchiveDestinationS3_1.LogsArchiveDestinationS3; } }));
var LogsArchiveIntegrationAzure_1 = __webpack_require__(90187);
Object.defineProperty(exports, "LogsArchiveIntegrationAzure", ({ enumerable: true, get: function () { return LogsArchiveIntegrationAzure_1.LogsArchiveIntegrationAzure; } }));
var LogsArchiveIntegrationGCS_1 = __webpack_require__(83645);
Object.defineProperty(exports, "LogsArchiveIntegrationGCS", ({ enumerable: true, get: function () { return LogsArchiveIntegrationGCS_1.LogsArchiveIntegrationGCS; } }));
var LogsArchiveIntegrationS3_1 = __webpack_require__(9681);
Object.defineProperty(exports, "LogsArchiveIntegrationS3", ({ enumerable: true, get: function () { return LogsArchiveIntegrationS3_1.LogsArchiveIntegrationS3; } }));
var LogsArchiveOrder_1 = __webpack_require__(13220);
Object.defineProperty(exports, "LogsArchiveOrder", ({ enumerable: true, get: function () { return LogsArchiveOrder_1.LogsArchiveOrder; } }));
var LogsArchiveOrderAttributes_1 = __webpack_require__(33277);
Object.defineProperty(exports, "LogsArchiveOrderAttributes", ({ enumerable: true, get: function () { return LogsArchiveOrderAttributes_1.LogsArchiveOrderAttributes; } }));
var LogsArchiveOrderDefinition_1 = __webpack_require__(74878);
Object.defineProperty(exports, "LogsArchiveOrderDefinition", ({ enumerable: true, get: function () { return LogsArchiveOrderDefinition_1.LogsArchiveOrderDefinition; } }));
var LogsArchives_1 = __webpack_require__(16852);
Object.defineProperty(exports, "LogsArchives", ({ enumerable: true, get: function () { return LogsArchives_1.LogsArchives; } }));
var LogsCompute_1 = __webpack_require__(19236);
Object.defineProperty(exports, "LogsCompute", ({ enumerable: true, get: function () { return LogsCompute_1.LogsCompute; } }));
var LogsGroupBy_1 = __webpack_require__(21104);
Object.defineProperty(exports, "LogsGroupBy", ({ enumerable: true, get: function () { return LogsGroupBy_1.LogsGroupBy; } }));
var LogsGroupByHistogram_1 = __webpack_require__(2133);
Object.defineProperty(exports, "LogsGroupByHistogram", ({ enumerable: true, get: function () { return LogsGroupByHistogram_1.LogsGroupByHistogram; } }));
var LogsListRequest_1 = __webpack_require__(46975);
Object.defineProperty(exports, "LogsListRequest", ({ enumerable: true, get: function () { return LogsListRequest_1.LogsListRequest; } }));
var LogsListRequestPage_1 = __webpack_require__(92486);
Object.defineProperty(exports, "LogsListRequestPage", ({ enumerable: true, get: function () { return LogsListRequestPage_1.LogsListRequestPage; } }));
var LogsListResponse_1 = __webpack_require__(62282);
Object.defineProperty(exports, "LogsListResponse", ({ enumerable: true, get: function () { return LogsListResponse_1.LogsListResponse; } }));
var LogsListResponseLinks_1 = __webpack_require__(79413);
Object.defineProperty(exports, "LogsListResponseLinks", ({ enumerable: true, get: function () { return LogsListResponseLinks_1.LogsListResponseLinks; } }));
var LogsMetricCompute_1 = __webpack_require__(74170);
Object.defineProperty(exports, "LogsMetricCompute", ({ enumerable: true, get: function () { return LogsMetricCompute_1.LogsMetricCompute; } }));
var LogsMetricCreateAttributes_1 = __webpack_require__(27156);
Object.defineProperty(exports, "LogsMetricCreateAttributes", ({ enumerable: true, get: function () { return LogsMetricCreateAttributes_1.LogsMetricCreateAttributes; } }));
var LogsMetricCreateData_1 = __webpack_require__(67578);
Object.defineProperty(exports, "LogsMetricCreateData", ({ enumerable: true, get: function () { return LogsMetricCreateData_1.LogsMetricCreateData; } }));
var LogsMetricCreateRequest_1 = __webpack_require__(64489);
Object.defineProperty(exports, "LogsMetricCreateRequest", ({ enumerable: true, get: function () { return LogsMetricCreateRequest_1.LogsMetricCreateRequest; } }));
var LogsMetricFilter_1 = __webpack_require__(95980);
Object.defineProperty(exports, "LogsMetricFilter", ({ enumerable: true, get: function () { return LogsMetricFilter_1.LogsMetricFilter; } }));
var LogsMetricGroupBy_1 = __webpack_require__(21776);
Object.defineProperty(exports, "LogsMetricGroupBy", ({ enumerable: true, get: function () { return LogsMetricGroupBy_1.LogsMetricGroupBy; } }));
var LogsMetricResponse_1 = __webpack_require__(86871);
Object.defineProperty(exports, "LogsMetricResponse", ({ enumerable: true, get: function () { return LogsMetricResponse_1.LogsMetricResponse; } }));
var LogsMetricResponseAttributes_1 = __webpack_require__(94655);
Object.defineProperty(exports, "LogsMetricResponseAttributes", ({ enumerable: true, get: function () { return LogsMetricResponseAttributes_1.LogsMetricResponseAttributes; } }));
var LogsMetricResponseCompute_1 = __webpack_require__(66641);
Object.defineProperty(exports, "LogsMetricResponseCompute", ({ enumerable: true, get: function () { return LogsMetricResponseCompute_1.LogsMetricResponseCompute; } }));
var LogsMetricResponseData_1 = __webpack_require__(2519);
Object.defineProperty(exports, "LogsMetricResponseData", ({ enumerable: true, get: function () { return LogsMetricResponseData_1.LogsMetricResponseData; } }));
var LogsMetricResponseFilter_1 = __webpack_require__(37718);
Object.defineProperty(exports, "LogsMetricResponseFilter", ({ enumerable: true, get: function () { return LogsMetricResponseFilter_1.LogsMetricResponseFilter; } }));
var LogsMetricResponseGroupBy_1 = __webpack_require__(83284);
Object.defineProperty(exports, "LogsMetricResponseGroupBy", ({ enumerable: true, get: function () { return LogsMetricResponseGroupBy_1.LogsMetricResponseGroupBy; } }));
var LogsMetricsResponse_1 = __webpack_require__(57793);
Object.defineProperty(exports, "LogsMetricsResponse", ({ enumerable: true, get: function () { return LogsMetricsResponse_1.LogsMetricsResponse; } }));
var LogsMetricUpdateAttributes_1 = __webpack_require__(43114);
Object.defineProperty(exports, "LogsMetricUpdateAttributes", ({ enumerable: true, get: function () { return LogsMetricUpdateAttributes_1.LogsMetricUpdateAttributes; } }));
var LogsMetricUpdateCompute_1 = __webpack_require__(70970);
Object.defineProperty(exports, "LogsMetricUpdateCompute", ({ enumerable: true, get: function () { return LogsMetricUpdateCompute_1.LogsMetricUpdateCompute; } }));
var LogsMetricUpdateData_1 = __webpack_require__(32319);
Object.defineProperty(exports, "LogsMetricUpdateData", ({ enumerable: true, get: function () { return LogsMetricUpdateData_1.LogsMetricUpdateData; } }));
var LogsMetricUpdateRequest_1 = __webpack_require__(84033);
Object.defineProperty(exports, "LogsMetricUpdateRequest", ({ enumerable: true, get: function () { return LogsMetricUpdateRequest_1.LogsMetricUpdateRequest; } }));
var LogsQueryFilter_1 = __webpack_require__(36574);
Object.defineProperty(exports, "LogsQueryFilter", ({ enumerable: true, get: function () { return LogsQueryFilter_1.LogsQueryFilter; } }));
var LogsQueryOptions_1 = __webpack_require__(75773);
Object.defineProperty(exports, "LogsQueryOptions", ({ enumerable: true, get: function () { return LogsQueryOptions_1.LogsQueryOptions; } }));
var LogsResponseMetadata_1 = __webpack_require__(9675);
Object.defineProperty(exports, "LogsResponseMetadata", ({ enumerable: true, get: function () { return LogsResponseMetadata_1.LogsResponseMetadata; } }));
var LogsResponseMetadataPage_1 = __webpack_require__(9159);
Object.defineProperty(exports, "LogsResponseMetadataPage", ({ enumerable: true, get: function () { return LogsResponseMetadataPage_1.LogsResponseMetadataPage; } }));
var LogsWarning_1 = __webpack_require__(32347);
Object.defineProperty(exports, "LogsWarning", ({ enumerable: true, get: function () { return LogsWarning_1.LogsWarning; } }));
var Metric_1 = __webpack_require__(81125);
Object.defineProperty(exports, "Metric", ({ enumerable: true, get: function () { return Metric_1.Metric; } }));
var MetricAllTags_1 = __webpack_require__(92059);
Object.defineProperty(exports, "MetricAllTags", ({ enumerable: true, get: function () { return MetricAllTags_1.MetricAllTags; } }));
var MetricAllTagsAttributes_1 = __webpack_require__(5563);
Object.defineProperty(exports, "MetricAllTagsAttributes", ({ enumerable: true, get: function () { return MetricAllTagsAttributes_1.MetricAllTagsAttributes; } }));
var MetricAllTagsResponse_1 = __webpack_require__(72220);
Object.defineProperty(exports, "MetricAllTagsResponse", ({ enumerable: true, get: function () { return MetricAllTagsResponse_1.MetricAllTagsResponse; } }));
var MetricBulkTagConfigCreate_1 = __webpack_require__(91782);
Object.defineProperty(exports, "MetricBulkTagConfigCreate", ({ enumerable: true, get: function () { return MetricBulkTagConfigCreate_1.MetricBulkTagConfigCreate; } }));
var MetricBulkTagConfigCreateAttributes_1 = __webpack_require__(32326);
Object.defineProperty(exports, "MetricBulkTagConfigCreateAttributes", ({ enumerable: true, get: function () { return MetricBulkTagConfigCreateAttributes_1.MetricBulkTagConfigCreateAttributes; } }));
var MetricBulkTagConfigCreateRequest_1 = __webpack_require__(4270);
Object.defineProperty(exports, "MetricBulkTagConfigCreateRequest", ({ enumerable: true, get: function () { return MetricBulkTagConfigCreateRequest_1.MetricBulkTagConfigCreateRequest; } }));
var MetricBulkTagConfigDelete_1 = __webpack_require__(72280);
Object.defineProperty(exports, "MetricBulkTagConfigDelete", ({ enumerable: true, get: function () { return MetricBulkTagConfigDelete_1.MetricBulkTagConfigDelete; } }));
var MetricBulkTagConfigDeleteAttributes_1 = __webpack_require__(86757);
Object.defineProperty(exports, "MetricBulkTagConfigDeleteAttributes", ({ enumerable: true, get: function () { return MetricBulkTagConfigDeleteAttributes_1.MetricBulkTagConfigDeleteAttributes; } }));
var MetricBulkTagConfigDeleteRequest_1 = __webpack_require__(3217);
Object.defineProperty(exports, "MetricBulkTagConfigDeleteRequest", ({ enumerable: true, get: function () { return MetricBulkTagConfigDeleteRequest_1.MetricBulkTagConfigDeleteRequest; } }));
var MetricBulkTagConfigResponse_1 = __webpack_require__(40953);
Object.defineProperty(exports, "MetricBulkTagConfigResponse", ({ enumerable: true, get: function () { return MetricBulkTagConfigResponse_1.MetricBulkTagConfigResponse; } }));
var MetricBulkTagConfigStatus_1 = __webpack_require__(57682);
Object.defineProperty(exports, "MetricBulkTagConfigStatus", ({ enumerable: true, get: function () { return MetricBulkTagConfigStatus_1.MetricBulkTagConfigStatus; } }));
var MetricBulkTagConfigStatusAttributes_1 = __webpack_require__(82262);
Object.defineProperty(exports, "MetricBulkTagConfigStatusAttributes", ({ enumerable: true, get: function () { return MetricBulkTagConfigStatusAttributes_1.MetricBulkTagConfigStatusAttributes; } }));
var MetricCustomAggregation_1 = __webpack_require__(17484);
Object.defineProperty(exports, "MetricCustomAggregation", ({ enumerable: true, get: function () { return MetricCustomAggregation_1.MetricCustomAggregation; } }));
var MetricDistinctVolume_1 = __webpack_require__(85654);
Object.defineProperty(exports, "MetricDistinctVolume", ({ enumerable: true, get: function () { return MetricDistinctVolume_1.MetricDistinctVolume; } }));
var MetricDistinctVolumeAttributes_1 = __webpack_require__(23953);
Object.defineProperty(exports, "MetricDistinctVolumeAttributes", ({ enumerable: true, get: function () { return MetricDistinctVolumeAttributes_1.MetricDistinctVolumeAttributes; } }));
var MetricEstimate_1 = __webpack_require__(55051);
Object.defineProperty(exports, "MetricEstimate", ({ enumerable: true, get: function () { return MetricEstimate_1.MetricEstimate; } }));
var MetricEstimateAttributes_1 = __webpack_require__(50065);
Object.defineProperty(exports, "MetricEstimateAttributes", ({ enumerable: true, get: function () { return MetricEstimateAttributes_1.MetricEstimateAttributes; } }));
var MetricEstimateResponse_1 = __webpack_require__(65503);
Object.defineProperty(exports, "MetricEstimateResponse", ({ enumerable: true, get: function () { return MetricEstimateResponse_1.MetricEstimateResponse; } }));
var MetricIngestedIndexedVolume_1 = __webpack_require__(8882);
Object.defineProperty(exports, "MetricIngestedIndexedVolume", ({ enumerable: true, get: function () { return MetricIngestedIndexedVolume_1.MetricIngestedIndexedVolume; } }));
var MetricIngestedIndexedVolumeAttributes_1 = __webpack_require__(65551);
Object.defineProperty(exports, "MetricIngestedIndexedVolumeAttributes", ({ enumerable: true, get: function () { return MetricIngestedIndexedVolumeAttributes_1.MetricIngestedIndexedVolumeAttributes; } }));
var MetricMetadata_1 = __webpack_require__(92399);
Object.defineProperty(exports, "MetricMetadata", ({ enumerable: true, get: function () { return MetricMetadata_1.MetricMetadata; } }));
var MetricOrigin_1 = __webpack_require__(94810);
Object.defineProperty(exports, "MetricOrigin", ({ enumerable: true, get: function () { return MetricOrigin_1.MetricOrigin; } }));
var MetricPayload_1 = __webpack_require__(49429);
Object.defineProperty(exports, "MetricPayload", ({ enumerable: true, get: function () { return MetricPayload_1.MetricPayload; } }));
var MetricPoint_1 = __webpack_require__(71586);
Object.defineProperty(exports, "MetricPoint", ({ enumerable: true, get: function () { return MetricPoint_1.MetricPoint; } }));
var MetricResource_1 = __webpack_require__(85867);
Object.defineProperty(exports, "MetricResource", ({ enumerable: true, get: function () { return MetricResource_1.MetricResource; } }));
var MetricsAndMetricTagConfigurationsResponse_1 = __webpack_require__(43052);
Object.defineProperty(exports, "MetricsAndMetricTagConfigurationsResponse", ({ enumerable: true, get: function () { return MetricsAndMetricTagConfigurationsResponse_1.MetricsAndMetricTagConfigurationsResponse; } }));
var MetricSeries_1 = __webpack_require__(38882);
Object.defineProperty(exports, "MetricSeries", ({ enumerable: true, get: function () { return MetricSeries_1.MetricSeries; } }));
var MetricsScalarQuery_1 = __webpack_require__(49485);
Object.defineProperty(exports, "MetricsScalarQuery", ({ enumerable: true, get: function () { return MetricsScalarQuery_1.MetricsScalarQuery; } }));
var MetricsTimeseriesQuery_1 = __webpack_require__(39342);
Object.defineProperty(exports, "MetricsTimeseriesQuery", ({ enumerable: true, get: function () { return MetricsTimeseriesQuery_1.MetricsTimeseriesQuery; } }));
var MetricSuggestedTagsAndAggregations_1 = __webpack_require__(48241);
Object.defineProperty(exports, "MetricSuggestedTagsAndAggregations", ({ enumerable: true, get: function () { return MetricSuggestedTagsAndAggregations_1.MetricSuggestedTagsAndAggregations; } }));
var MetricSuggestedTagsAndAggregationsResponse_1 = __webpack_require__(39816);
Object.defineProperty(exports, "MetricSuggestedTagsAndAggregationsResponse", ({ enumerable: true, get: function () { return MetricSuggestedTagsAndAggregationsResponse_1.MetricSuggestedTagsAndAggregationsResponse; } }));
var MetricSuggestedTagsAttributes_1 = __webpack_require__(26853);
Object.defineProperty(exports, "MetricSuggestedTagsAttributes", ({ enumerable: true, get: function () { return MetricSuggestedTagsAttributes_1.MetricSuggestedTagsAttributes; } }));
var MetricTagConfiguration_1 = __webpack_require__(35857);
Object.defineProperty(exports, "MetricTagConfiguration", ({ enumerable: true, get: function () { return MetricTagConfiguration_1.MetricTagConfiguration; } }));
var MetricTagConfigurationAttributes_1 = __webpack_require__(9851);
Object.defineProperty(exports, "MetricTagConfigurationAttributes", ({ enumerable: true, get: function () { return MetricTagConfigurationAttributes_1.MetricTagConfigurationAttributes; } }));
var MetricTagConfigurationCreateAttributes_1 = __webpack_require__(19186);
Object.defineProperty(exports, "MetricTagConfigurationCreateAttributes", ({ enumerable: true, get: function () { return MetricTagConfigurationCreateAttributes_1.MetricTagConfigurationCreateAttributes; } }));
var MetricTagConfigurationCreateData_1 = __webpack_require__(66135);
Object.defineProperty(exports, "MetricTagConfigurationCreateData", ({ enumerable: true, get: function () { return MetricTagConfigurationCreateData_1.MetricTagConfigurationCreateData; } }));
var MetricTagConfigurationCreateRequest_1 = __webpack_require__(84050);
Object.defineProperty(exports, "MetricTagConfigurationCreateRequest", ({ enumerable: true, get: function () { return MetricTagConfigurationCreateRequest_1.MetricTagConfigurationCreateRequest; } }));
var MetricTagConfigurationResponse_1 = __webpack_require__(55797);
Object.defineProperty(exports, "MetricTagConfigurationResponse", ({ enumerable: true, get: function () { return MetricTagConfigurationResponse_1.MetricTagConfigurationResponse; } }));
var MetricTagConfigurationUpdateAttributes_1 = __webpack_require__(19503);
Object.defineProperty(exports, "MetricTagConfigurationUpdateAttributes", ({ enumerable: true, get: function () { return MetricTagConfigurationUpdateAttributes_1.MetricTagConfigurationUpdateAttributes; } }));
var MetricTagConfigurationUpdateData_1 = __webpack_require__(63194);
Object.defineProperty(exports, "MetricTagConfigurationUpdateData", ({ enumerable: true, get: function () { return MetricTagConfigurationUpdateData_1.MetricTagConfigurationUpdateData; } }));
var MetricTagConfigurationUpdateRequest_1 = __webpack_require__(19976);
Object.defineProperty(exports, "MetricTagConfigurationUpdateRequest", ({ enumerable: true, get: function () { return MetricTagConfigurationUpdateRequest_1.MetricTagConfigurationUpdateRequest; } }));
var MetricVolumesResponse_1 = __webpack_require__(72742);
Object.defineProperty(exports, "MetricVolumesResponse", ({ enumerable: true, get: function () { return MetricVolumesResponse_1.MetricVolumesResponse; } }));
var MonitorConfigPolicyAttributeCreateRequest_1 = __webpack_require__(13129);
Object.defineProperty(exports, "MonitorConfigPolicyAttributeCreateRequest", ({ enumerable: true, get: function () { return MonitorConfigPolicyAttributeCreateRequest_1.MonitorConfigPolicyAttributeCreateRequest; } }));
var MonitorConfigPolicyAttributeEditRequest_1 = __webpack_require__(8044);
Object.defineProperty(exports, "MonitorConfigPolicyAttributeEditRequest", ({ enumerable: true, get: function () { return MonitorConfigPolicyAttributeEditRequest_1.MonitorConfigPolicyAttributeEditRequest; } }));
var MonitorConfigPolicyAttributeResponse_1 = __webpack_require__(76229);
Object.defineProperty(exports, "MonitorConfigPolicyAttributeResponse", ({ enumerable: true, get: function () { return MonitorConfigPolicyAttributeResponse_1.MonitorConfigPolicyAttributeResponse; } }));
var MonitorConfigPolicyCreateData_1 = __webpack_require__(53026);
Object.defineProperty(exports, "MonitorConfigPolicyCreateData", ({ enumerable: true, get: function () { return MonitorConfigPolicyCreateData_1.MonitorConfigPolicyCreateData; } }));
var MonitorConfigPolicyCreateRequest_1 = __webpack_require__(41863);
Object.defineProperty(exports, "MonitorConfigPolicyCreateRequest", ({ enumerable: true, get: function () { return MonitorConfigPolicyCreateRequest_1.MonitorConfigPolicyCreateRequest; } }));
var MonitorConfigPolicyEditData_1 = __webpack_require__(66735);
Object.defineProperty(exports, "MonitorConfigPolicyEditData", ({ enumerable: true, get: function () { return MonitorConfigPolicyEditData_1.MonitorConfigPolicyEditData; } }));
var MonitorConfigPolicyEditRequest_1 = __webpack_require__(91060);
Object.defineProperty(exports, "MonitorConfigPolicyEditRequest", ({ enumerable: true, get: function () { return MonitorConfigPolicyEditRequest_1.MonitorConfigPolicyEditRequest; } }));
var MonitorConfigPolicyListResponse_1 = __webpack_require__(79750);
Object.defineProperty(exports, "MonitorConfigPolicyListResponse", ({ enumerable: true, get: function () { return MonitorConfigPolicyListResponse_1.MonitorConfigPolicyListResponse; } }));
var MonitorConfigPolicyResponse_1 = __webpack_require__(86660);
Object.defineProperty(exports, "MonitorConfigPolicyResponse", ({ enumerable: true, get: function () { return MonitorConfigPolicyResponse_1.MonitorConfigPolicyResponse; } }));
var MonitorConfigPolicyResponseData_1 = __webpack_require__(14042);
Object.defineProperty(exports, "MonitorConfigPolicyResponseData", ({ enumerable: true, get: function () { return MonitorConfigPolicyResponseData_1.MonitorConfigPolicyResponseData; } }));
var MonitorConfigPolicyTagPolicy_1 = __webpack_require__(60362);
Object.defineProperty(exports, "MonitorConfigPolicyTagPolicy", ({ enumerable: true, get: function () { return MonitorConfigPolicyTagPolicy_1.MonitorConfigPolicyTagPolicy; } }));
var MonitorConfigPolicyTagPolicyCreateRequest_1 = __webpack_require__(40171);
Object.defineProperty(exports, "MonitorConfigPolicyTagPolicyCreateRequest", ({ enumerable: true, get: function () { return MonitorConfigPolicyTagPolicyCreateRequest_1.MonitorConfigPolicyTagPolicyCreateRequest; } }));
var MonitorType_1 = __webpack_require__(2743);
Object.defineProperty(exports, "MonitorType", ({ enumerable: true, get: function () { return MonitorType_1.MonitorType; } }));
var NullableRelationshipToUser_1 = __webpack_require__(71426);
Object.defineProperty(exports, "NullableRelationshipToUser", ({ enumerable: true, get: function () { return NullableRelationshipToUser_1.NullableRelationshipToUser; } }));
var NullableRelationshipToUserData_1 = __webpack_require__(16203);
Object.defineProperty(exports, "NullableRelationshipToUserData", ({ enumerable: true, get: function () { return NullableRelationshipToUserData_1.NullableRelationshipToUserData; } }));
var OpsgenieServiceCreateAttributes_1 = __webpack_require__(96016);
Object.defineProperty(exports, "OpsgenieServiceCreateAttributes", ({ enumerable: true, get: function () { return OpsgenieServiceCreateAttributes_1.OpsgenieServiceCreateAttributes; } }));
var OpsgenieServiceCreateData_1 = __webpack_require__(44394);
Object.defineProperty(exports, "OpsgenieServiceCreateData", ({ enumerable: true, get: function () { return OpsgenieServiceCreateData_1.OpsgenieServiceCreateData; } }));
var OpsgenieServiceCreateRequest_1 = __webpack_require__(641);
Object.defineProperty(exports, "OpsgenieServiceCreateRequest", ({ enumerable: true, get: function () { return OpsgenieServiceCreateRequest_1.OpsgenieServiceCreateRequest; } }));
var OpsgenieServiceResponse_1 = __webpack_require__(3424);
Object.defineProperty(exports, "OpsgenieServiceResponse", ({ enumerable: true, get: function () { return OpsgenieServiceResponse_1.OpsgenieServiceResponse; } }));
var OpsgenieServiceResponseAttributes_1 = __webpack_require__(36633);
Object.defineProperty(exports, "OpsgenieServiceResponseAttributes", ({ enumerable: true, get: function () { return OpsgenieServiceResponseAttributes_1.OpsgenieServiceResponseAttributes; } }));
var OpsgenieServiceResponseData_1 = __webpack_require__(89232);
Object.defineProperty(exports, "OpsgenieServiceResponseData", ({ enumerable: true, get: function () { return OpsgenieServiceResponseData_1.OpsgenieServiceResponseData; } }));
var OpsgenieServicesResponse_1 = __webpack_require__(43059);
Object.defineProperty(exports, "OpsgenieServicesResponse", ({ enumerable: true, get: function () { return OpsgenieServicesResponse_1.OpsgenieServicesResponse; } }));
var OpsgenieServiceUpdateAttributes_1 = __webpack_require__(46808);
Object.defineProperty(exports, "OpsgenieServiceUpdateAttributes", ({ enumerable: true, get: function () { return OpsgenieServiceUpdateAttributes_1.OpsgenieServiceUpdateAttributes; } }));
var OpsgenieServiceUpdateData_1 = __webpack_require__(89005);
Object.defineProperty(exports, "OpsgenieServiceUpdateData", ({ enumerable: true, get: function () { return OpsgenieServiceUpdateData_1.OpsgenieServiceUpdateData; } }));
var OpsgenieServiceUpdateRequest_1 = __webpack_require__(52502);
Object.defineProperty(exports, "OpsgenieServiceUpdateRequest", ({ enumerable: true, get: function () { return OpsgenieServiceUpdateRequest_1.OpsgenieServiceUpdateRequest; } }));
var Organization_1 = __webpack_require__(6229);
Object.defineProperty(exports, "Organization", ({ enumerable: true, get: function () { return Organization_1.Organization; } }));
var OrganizationAttributes_1 = __webpack_require__(77933);
Object.defineProperty(exports, "OrganizationAttributes", ({ enumerable: true, get: function () { return OrganizationAttributes_1.OrganizationAttributes; } }));
var Pagination_1 = __webpack_require__(35680);
Object.defineProperty(exports, "Pagination", ({ enumerable: true, get: function () { return Pagination_1.Pagination; } }));
var PartialAPIKey_1 = __webpack_require__(64447);
Object.defineProperty(exports, "PartialAPIKey", ({ enumerable: true, get: function () { return PartialAPIKey_1.PartialAPIKey; } }));
var PartialAPIKeyAttributes_1 = __webpack_require__(99573);
Object.defineProperty(exports, "PartialAPIKeyAttributes", ({ enumerable: true, get: function () { return PartialAPIKeyAttributes_1.PartialAPIKeyAttributes; } }));
var PartialApplicationKey_1 = __webpack_require__(67979);
Object.defineProperty(exports, "PartialApplicationKey", ({ enumerable: true, get: function () { return PartialApplicationKey_1.PartialApplicationKey; } }));
var PartialApplicationKeyAttributes_1 = __webpack_require__(96197);
Object.defineProperty(exports, "PartialApplicationKeyAttributes", ({ enumerable: true, get: function () { return PartialApplicationKeyAttributes_1.PartialApplicationKeyAttributes; } }));
var PartialApplicationKeyResponse_1 = __webpack_require__(52459);
Object.defineProperty(exports, "PartialApplicationKeyResponse", ({ enumerable: true, get: function () { return PartialApplicationKeyResponse_1.PartialApplicationKeyResponse; } }));
var Permission_1 = __webpack_require__(50681);
Object.defineProperty(exports, "Permission", ({ enumerable: true, get: function () { return Permission_1.Permission; } }));
var PermissionAttributes_1 = __webpack_require__(84187);
Object.defineProperty(exports, "PermissionAttributes", ({ enumerable: true, get: function () { return PermissionAttributes_1.PermissionAttributes; } }));
var PermissionsResponse_1 = __webpack_require__(99426);
Object.defineProperty(exports, "PermissionsResponse", ({ enumerable: true, get: function () { return PermissionsResponse_1.PermissionsResponse; } }));
var ProcessSummariesMeta_1 = __webpack_require__(30341);
Object.defineProperty(exports, "ProcessSummariesMeta", ({ enumerable: true, get: function () { return ProcessSummariesMeta_1.ProcessSummariesMeta; } }));
var ProcessSummariesMetaPage_1 = __webpack_require__(88359);
Object.defineProperty(exports, "ProcessSummariesMetaPage", ({ enumerable: true, get: function () { return ProcessSummariesMetaPage_1.ProcessSummariesMetaPage; } }));
var ProcessSummariesResponse_1 = __webpack_require__(61750);
Object.defineProperty(exports, "ProcessSummariesResponse", ({ enumerable: true, get: function () { return ProcessSummariesResponse_1.ProcessSummariesResponse; } }));
var ProcessSummary_1 = __webpack_require__(35834);
Object.defineProperty(exports, "ProcessSummary", ({ enumerable: true, get: function () { return ProcessSummary_1.ProcessSummary; } }));
var ProcessSummaryAttributes_1 = __webpack_require__(81126);
Object.defineProperty(exports, "ProcessSummaryAttributes", ({ enumerable: true, get: function () { return ProcessSummaryAttributes_1.ProcessSummaryAttributes; } }));
var QueryFormula_1 = __webpack_require__(24419);
Object.defineProperty(exports, "QueryFormula", ({ enumerable: true, get: function () { return QueryFormula_1.QueryFormula; } }));
var RelationshipToIncidentAttachment_1 = __webpack_require__(87288);
Object.defineProperty(exports, "RelationshipToIncidentAttachment", ({ enumerable: true, get: function () { return RelationshipToIncidentAttachment_1.RelationshipToIncidentAttachment; } }));
var RelationshipToIncidentAttachmentData_1 = __webpack_require__(6475);
Object.defineProperty(exports, "RelationshipToIncidentAttachmentData", ({ enumerable: true, get: function () { return RelationshipToIncidentAttachmentData_1.RelationshipToIncidentAttachmentData; } }));
var RelationshipToIncidentIntegrationMetadataData_1 = __webpack_require__(43443);
Object.defineProperty(exports, "RelationshipToIncidentIntegrationMetadataData", ({ enumerable: true, get: function () { return RelationshipToIncidentIntegrationMetadataData_1.RelationshipToIncidentIntegrationMetadataData; } }));
var RelationshipToIncidentIntegrationMetadatas_1 = __webpack_require__(91471);
Object.defineProperty(exports, "RelationshipToIncidentIntegrationMetadatas", ({ enumerable: true, get: function () { return RelationshipToIncidentIntegrationMetadatas_1.RelationshipToIncidentIntegrationMetadatas; } }));
var RelationshipToIncidentPostmortem_1 = __webpack_require__(91589);
Object.defineProperty(exports, "RelationshipToIncidentPostmortem", ({ enumerable: true, get: function () { return RelationshipToIncidentPostmortem_1.RelationshipToIncidentPostmortem; } }));
var RelationshipToIncidentPostmortemData_1 = __webpack_require__(57515);
Object.defineProperty(exports, "RelationshipToIncidentPostmortemData", ({ enumerable: true, get: function () { return RelationshipToIncidentPostmortemData_1.RelationshipToIncidentPostmortemData; } }));
var RelationshipToOrganization_1 = __webpack_require__(1786);
Object.defineProperty(exports, "RelationshipToOrganization", ({ enumerable: true, get: function () { return RelationshipToOrganization_1.RelationshipToOrganization; } }));
var RelationshipToOrganizationData_1 = __webpack_require__(3098);
Object.defineProperty(exports, "RelationshipToOrganizationData", ({ enumerable: true, get: function () { return RelationshipToOrganizationData_1.RelationshipToOrganizationData; } }));
var RelationshipToOrganizations_1 = __webpack_require__(16352);
Object.defineProperty(exports, "RelationshipToOrganizations", ({ enumerable: true, get: function () { return RelationshipToOrganizations_1.RelationshipToOrganizations; } }));
var RelationshipToPermission_1 = __webpack_require__(91286);
Object.defineProperty(exports, "RelationshipToPermission", ({ enumerable: true, get: function () { return RelationshipToPermission_1.RelationshipToPermission; } }));
var RelationshipToPermissionData_1 = __webpack_require__(84713);
Object.defineProperty(exports, "RelationshipToPermissionData", ({ enumerable: true, get: function () { return RelationshipToPermissionData_1.RelationshipToPermissionData; } }));
var RelationshipToPermissions_1 = __webpack_require__(50913);
Object.defineProperty(exports, "RelationshipToPermissions", ({ enumerable: true, get: function () { return RelationshipToPermissions_1.RelationshipToPermissions; } }));
var RelationshipToRole_1 = __webpack_require__(38615);
Object.defineProperty(exports, "RelationshipToRole", ({ enumerable: true, get: function () { return RelationshipToRole_1.RelationshipToRole; } }));
var RelationshipToRoleData_1 = __webpack_require__(30312);
Object.defineProperty(exports, "RelationshipToRoleData", ({ enumerable: true, get: function () { return RelationshipToRoleData_1.RelationshipToRoleData; } }));
var RelationshipToRoles_1 = __webpack_require__(62595);
Object.defineProperty(exports, "RelationshipToRoles", ({ enumerable: true, get: function () { return RelationshipToRoles_1.RelationshipToRoles; } }));
var RelationshipToSAMLAssertionAttribute_1 = __webpack_require__(62436);
Object.defineProperty(exports, "RelationshipToSAMLAssertionAttribute", ({ enumerable: true, get: function () { return RelationshipToSAMLAssertionAttribute_1.RelationshipToSAMLAssertionAttribute; } }));
var RelationshipToSAMLAssertionAttributeData_1 = __webpack_require__(93258);
Object.defineProperty(exports, "RelationshipToSAMLAssertionAttributeData", ({ enumerable: true, get: function () { return RelationshipToSAMLAssertionAttributeData_1.RelationshipToSAMLAssertionAttributeData; } }));
var RelationshipToUser_1 = __webpack_require__(93801);
Object.defineProperty(exports, "RelationshipToUser", ({ enumerable: true, get: function () { return RelationshipToUser_1.RelationshipToUser; } }));
var RelationshipToUserData_1 = __webpack_require__(16328);
Object.defineProperty(exports, "RelationshipToUserData", ({ enumerable: true, get: function () { return RelationshipToUserData_1.RelationshipToUserData; } }));
var RelationshipToUsers_1 = __webpack_require__(51783);
Object.defineProperty(exports, "RelationshipToUsers", ({ enumerable: true, get: function () { return RelationshipToUsers_1.RelationshipToUsers; } }));
var ResponseMetaAttributes_1 = __webpack_require__(14990);
Object.defineProperty(exports, "ResponseMetaAttributes", ({ enumerable: true, get: function () { return ResponseMetaAttributes_1.ResponseMetaAttributes; } }));
var Role_1 = __webpack_require__(49248);
Object.defineProperty(exports, "Role", ({ enumerable: true, get: function () { return Role_1.Role; } }));
var RoleAttributes_1 = __webpack_require__(82581);
Object.defineProperty(exports, "RoleAttributes", ({ enumerable: true, get: function () { return RoleAttributes_1.RoleAttributes; } }));
var RoleClone_1 = __webpack_require__(96579);
Object.defineProperty(exports, "RoleClone", ({ enumerable: true, get: function () { return RoleClone_1.RoleClone; } }));
var RoleCloneAttributes_1 = __webpack_require__(34979);
Object.defineProperty(exports, "RoleCloneAttributes", ({ enumerable: true, get: function () { return RoleCloneAttributes_1.RoleCloneAttributes; } }));
var RoleCloneRequest_1 = __webpack_require__(33124);
Object.defineProperty(exports, "RoleCloneRequest", ({ enumerable: true, get: function () { return RoleCloneRequest_1.RoleCloneRequest; } }));
var RoleCreateAttributes_1 = __webpack_require__(65979);
Object.defineProperty(exports, "RoleCreateAttributes", ({ enumerable: true, get: function () { return RoleCreateAttributes_1.RoleCreateAttributes; } }));
var RoleCreateData_1 = __webpack_require__(67319);
Object.defineProperty(exports, "RoleCreateData", ({ enumerable: true, get: function () { return RoleCreateData_1.RoleCreateData; } }));
var RoleCreateRequest_1 = __webpack_require__(95305);
Object.defineProperty(exports, "RoleCreateRequest", ({ enumerable: true, get: function () { return RoleCreateRequest_1.RoleCreateRequest; } }));
var RoleCreateResponse_1 = __webpack_require__(87293);
Object.defineProperty(exports, "RoleCreateResponse", ({ enumerable: true, get: function () { return RoleCreateResponse_1.RoleCreateResponse; } }));
var RoleCreateResponseData_1 = __webpack_require__(72479);
Object.defineProperty(exports, "RoleCreateResponseData", ({ enumerable: true, get: function () { return RoleCreateResponseData_1.RoleCreateResponseData; } }));
var RoleRelationships_1 = __webpack_require__(71594);
Object.defineProperty(exports, "RoleRelationships", ({ enumerable: true, get: function () { return RoleRelationships_1.RoleRelationships; } }));
var RoleResponse_1 = __webpack_require__(2524);
Object.defineProperty(exports, "RoleResponse", ({ enumerable: true, get: function () { return RoleResponse_1.RoleResponse; } }));
var RoleResponseRelationships_1 = __webpack_require__(66950);
Object.defineProperty(exports, "RoleResponseRelationships", ({ enumerable: true, get: function () { return RoleResponseRelationships_1.RoleResponseRelationships; } }));
var RolesResponse_1 = __webpack_require__(95334);
Object.defineProperty(exports, "RolesResponse", ({ enumerable: true, get: function () { return RolesResponse_1.RolesResponse; } }));
var RoleUpdateAttributes_1 = __webpack_require__(84628);
Object.defineProperty(exports, "RoleUpdateAttributes", ({ enumerable: true, get: function () { return RoleUpdateAttributes_1.RoleUpdateAttributes; } }));
var RoleUpdateData_1 = __webpack_require__(77060);
Object.defineProperty(exports, "RoleUpdateData", ({ enumerable: true, get: function () { return RoleUpdateData_1.RoleUpdateData; } }));
var RoleUpdateRequest_1 = __webpack_require__(63322);
Object.defineProperty(exports, "RoleUpdateRequest", ({ enumerable: true, get: function () { return RoleUpdateRequest_1.RoleUpdateRequest; } }));
var RoleUpdateResponse_1 = __webpack_require__(22307);
Object.defineProperty(exports, "RoleUpdateResponse", ({ enumerable: true, get: function () { return RoleUpdateResponse_1.RoleUpdateResponse; } }));
var RoleUpdateResponseData_1 = __webpack_require__(39190);
Object.defineProperty(exports, "RoleUpdateResponseData", ({ enumerable: true, get: function () { return RoleUpdateResponseData_1.RoleUpdateResponseData; } }));
var RUMAggregateBucketValueTimeseriesPoint_1 = __webpack_require__(71);
Object.defineProperty(exports, "RUMAggregateBucketValueTimeseriesPoint", ({ enumerable: true, get: function () { return RUMAggregateBucketValueTimeseriesPoint_1.RUMAggregateBucketValueTimeseriesPoint; } }));
var RUMAggregateRequest_1 = __webpack_require__(98438);
Object.defineProperty(exports, "RUMAggregateRequest", ({ enumerable: true, get: function () { return RUMAggregateRequest_1.RUMAggregateRequest; } }));
var RUMAggregateSort_1 = __webpack_require__(66861);
Object.defineProperty(exports, "RUMAggregateSort", ({ enumerable: true, get: function () { return RUMAggregateSort_1.RUMAggregateSort; } }));
var RUMAggregationBucketsResponse_1 = __webpack_require__(50116);
Object.defineProperty(exports, "RUMAggregationBucketsResponse", ({ enumerable: true, get: function () { return RUMAggregationBucketsResponse_1.RUMAggregationBucketsResponse; } }));
var RUMAnalyticsAggregateResponse_1 = __webpack_require__(9558);
Object.defineProperty(exports, "RUMAnalyticsAggregateResponse", ({ enumerable: true, get: function () { return RUMAnalyticsAggregateResponse_1.RUMAnalyticsAggregateResponse; } }));
var RUMApplication_1 = __webpack_require__(20447);
Object.defineProperty(exports, "RUMApplication", ({ enumerable: true, get: function () { return RUMApplication_1.RUMApplication; } }));
var RUMApplicationAttributes_1 = __webpack_require__(5619);
Object.defineProperty(exports, "RUMApplicationAttributes", ({ enumerable: true, get: function () { return RUMApplicationAttributes_1.RUMApplicationAttributes; } }));
var RUMApplicationCreate_1 = __webpack_require__(7740);
Object.defineProperty(exports, "RUMApplicationCreate", ({ enumerable: true, get: function () { return RUMApplicationCreate_1.RUMApplicationCreate; } }));
var RUMApplicationCreateAttributes_1 = __webpack_require__(41625);
Object.defineProperty(exports, "RUMApplicationCreateAttributes", ({ enumerable: true, get: function () { return RUMApplicationCreateAttributes_1.RUMApplicationCreateAttributes; } }));
var RUMApplicationCreateRequest_1 = __webpack_require__(27250);
Object.defineProperty(exports, "RUMApplicationCreateRequest", ({ enumerable: true, get: function () { return RUMApplicationCreateRequest_1.RUMApplicationCreateRequest; } }));
var RUMApplicationList_1 = __webpack_require__(3318);
Object.defineProperty(exports, "RUMApplicationList", ({ enumerable: true, get: function () { return RUMApplicationList_1.RUMApplicationList; } }));
var RUMApplicationListAttributes_1 = __webpack_require__(26043);
Object.defineProperty(exports, "RUMApplicationListAttributes", ({ enumerable: true, get: function () { return RUMApplicationListAttributes_1.RUMApplicationListAttributes; } }));
var RUMApplicationResponse_1 = __webpack_require__(59012);
Object.defineProperty(exports, "RUMApplicationResponse", ({ enumerable: true, get: function () { return RUMApplicationResponse_1.RUMApplicationResponse; } }));
var RUMApplicationsResponse_1 = __webpack_require__(62857);
Object.defineProperty(exports, "RUMApplicationsResponse", ({ enumerable: true, get: function () { return RUMApplicationsResponse_1.RUMApplicationsResponse; } }));
var RUMApplicationUpdate_1 = __webpack_require__(11541);
Object.defineProperty(exports, "RUMApplicationUpdate", ({ enumerable: true, get: function () { return RUMApplicationUpdate_1.RUMApplicationUpdate; } }));
var RUMApplicationUpdateAttributes_1 = __webpack_require__(3394);
Object.defineProperty(exports, "RUMApplicationUpdateAttributes", ({ enumerable: true, get: function () { return RUMApplicationUpdateAttributes_1.RUMApplicationUpdateAttributes; } }));
var RUMApplicationUpdateRequest_1 = __webpack_require__(12932);
Object.defineProperty(exports, "RUMApplicationUpdateRequest", ({ enumerable: true, get: function () { return RUMApplicationUpdateRequest_1.RUMApplicationUpdateRequest; } }));
var RUMBucketResponse_1 = __webpack_require__(37302);
Object.defineProperty(exports, "RUMBucketResponse", ({ enumerable: true, get: function () { return RUMBucketResponse_1.RUMBucketResponse; } }));
var RUMCompute_1 = __webpack_require__(34658);
Object.defineProperty(exports, "RUMCompute", ({ enumerable: true, get: function () { return RUMCompute_1.RUMCompute; } }));
var RUMEvent_1 = __webpack_require__(44075);
Object.defineProperty(exports, "RUMEvent", ({ enumerable: true, get: function () { return RUMEvent_1.RUMEvent; } }));
var RUMEventAttributes_1 = __webpack_require__(31323);
Object.defineProperty(exports, "RUMEventAttributes", ({ enumerable: true, get: function () { return RUMEventAttributes_1.RUMEventAttributes; } }));
var RUMEventsResponse_1 = __webpack_require__(42841);
Object.defineProperty(exports, "RUMEventsResponse", ({ enumerable: true, get: function () { return RUMEventsResponse_1.RUMEventsResponse; } }));
var RUMGroupBy_1 = __webpack_require__(82421);
Object.defineProperty(exports, "RUMGroupBy", ({ enumerable: true, get: function () { return RUMGroupBy_1.RUMGroupBy; } }));
var RUMGroupByHistogram_1 = __webpack_require__(27195);
Object.defineProperty(exports, "RUMGroupByHistogram", ({ enumerable: true, get: function () { return RUMGroupByHistogram_1.RUMGroupByHistogram; } }));
var RUMQueryFilter_1 = __webpack_require__(4455);
Object.defineProperty(exports, "RUMQueryFilter", ({ enumerable: true, get: function () { return RUMQueryFilter_1.RUMQueryFilter; } }));
var RUMQueryOptions_1 = __webpack_require__(53313);
Object.defineProperty(exports, "RUMQueryOptions", ({ enumerable: true, get: function () { return RUMQueryOptions_1.RUMQueryOptions; } }));
var RUMQueryPageOptions_1 = __webpack_require__(89982);
Object.defineProperty(exports, "RUMQueryPageOptions", ({ enumerable: true, get: function () { return RUMQueryPageOptions_1.RUMQueryPageOptions; } }));
var RUMResponseLinks_1 = __webpack_require__(62690);
Object.defineProperty(exports, "RUMResponseLinks", ({ enumerable: true, get: function () { return RUMResponseLinks_1.RUMResponseLinks; } }));
var RUMResponseMetadata_1 = __webpack_require__(10700);
Object.defineProperty(exports, "RUMResponseMetadata", ({ enumerable: true, get: function () { return RUMResponseMetadata_1.RUMResponseMetadata; } }));
var RUMResponsePage_1 = __webpack_require__(49457);
Object.defineProperty(exports, "RUMResponsePage", ({ enumerable: true, get: function () { return RUMResponsePage_1.RUMResponsePage; } }));
var RUMSearchEventsRequest_1 = __webpack_require__(97557);
Object.defineProperty(exports, "RUMSearchEventsRequest", ({ enumerable: true, get: function () { return RUMSearchEventsRequest_1.RUMSearchEventsRequest; } }));
var RUMWarning_1 = __webpack_require__(66821);
Object.defineProperty(exports, "RUMWarning", ({ enumerable: true, get: function () { return RUMWarning_1.RUMWarning; } }));
var SAMLAssertionAttribute_1 = __webpack_require__(98228);
Object.defineProperty(exports, "SAMLAssertionAttribute", ({ enumerable: true, get: function () { return SAMLAssertionAttribute_1.SAMLAssertionAttribute; } }));
var SAMLAssertionAttributeAttributes_1 = __webpack_require__(73923);
Object.defineProperty(exports, "SAMLAssertionAttributeAttributes", ({ enumerable: true, get: function () { return SAMLAssertionAttributeAttributes_1.SAMLAssertionAttributeAttributes; } }));
var ScalarFormulaQueryRequest_1 = __webpack_require__(31259);
Object.defineProperty(exports, "ScalarFormulaQueryRequest", ({ enumerable: true, get: function () { return ScalarFormulaQueryRequest_1.ScalarFormulaQueryRequest; } }));
var ScalarFormulaQueryResponse_1 = __webpack_require__(3057);
Object.defineProperty(exports, "ScalarFormulaQueryResponse", ({ enumerable: true, get: function () { return ScalarFormulaQueryResponse_1.ScalarFormulaQueryResponse; } }));
var ScalarFormulaRequest_1 = __webpack_require__(84643);
Object.defineProperty(exports, "ScalarFormulaRequest", ({ enumerable: true, get: function () { return ScalarFormulaRequest_1.ScalarFormulaRequest; } }));
var ScalarFormulaRequestAttributes_1 = __webpack_require__(27526);
Object.defineProperty(exports, "ScalarFormulaRequestAttributes", ({ enumerable: true, get: function () { return ScalarFormulaRequestAttributes_1.ScalarFormulaRequestAttributes; } }));
var ScalarFormulaResponseAtrributes_1 = __webpack_require__(60572);
Object.defineProperty(exports, "ScalarFormulaResponseAtrributes", ({ enumerable: true, get: function () { return ScalarFormulaResponseAtrributes_1.ScalarFormulaResponseAtrributes; } }));
var ScalarMeta_1 = __webpack_require__(1470);
Object.defineProperty(exports, "ScalarMeta", ({ enumerable: true, get: function () { return ScalarMeta_1.ScalarMeta; } }));
var ScalarResponse_1 = __webpack_require__(70331);
Object.defineProperty(exports, "ScalarResponse", ({ enumerable: true, get: function () { return ScalarResponse_1.ScalarResponse; } }));
var SecurityFilter_1 = __webpack_require__(55447);
Object.defineProperty(exports, "SecurityFilter", ({ enumerable: true, get: function () { return SecurityFilter_1.SecurityFilter; } }));
var SecurityFilterAttributes_1 = __webpack_require__(98576);
Object.defineProperty(exports, "SecurityFilterAttributes", ({ enumerable: true, get: function () { return SecurityFilterAttributes_1.SecurityFilterAttributes; } }));
var SecurityFilterCreateAttributes_1 = __webpack_require__(39164);
Object.defineProperty(exports, "SecurityFilterCreateAttributes", ({ enumerable: true, get: function () { return SecurityFilterCreateAttributes_1.SecurityFilterCreateAttributes; } }));
var SecurityFilterCreateData_1 = __webpack_require__(73922);
Object.defineProperty(exports, "SecurityFilterCreateData", ({ enumerable: true, get: function () { return SecurityFilterCreateData_1.SecurityFilterCreateData; } }));
var SecurityFilterCreateRequest_1 = __webpack_require__(80376);
Object.defineProperty(exports, "SecurityFilterCreateRequest", ({ enumerable: true, get: function () { return SecurityFilterCreateRequest_1.SecurityFilterCreateRequest; } }));
var SecurityFilterExclusionFilter_1 = __webpack_require__(70566);
Object.defineProperty(exports, "SecurityFilterExclusionFilter", ({ enumerable: true, get: function () { return SecurityFilterExclusionFilter_1.SecurityFilterExclusionFilter; } }));
var SecurityFilterExclusionFilterResponse_1 = __webpack_require__(33320);
Object.defineProperty(exports, "SecurityFilterExclusionFilterResponse", ({ enumerable: true, get: function () { return SecurityFilterExclusionFilterResponse_1.SecurityFilterExclusionFilterResponse; } }));
var SecurityFilterMeta_1 = __webpack_require__(27674);
Object.defineProperty(exports, "SecurityFilterMeta", ({ enumerable: true, get: function () { return SecurityFilterMeta_1.SecurityFilterMeta; } }));
var SecurityFilterResponse_1 = __webpack_require__(53785);
Object.defineProperty(exports, "SecurityFilterResponse", ({ enumerable: true, get: function () { return SecurityFilterResponse_1.SecurityFilterResponse; } }));
var SecurityFiltersResponse_1 = __webpack_require__(92892);
Object.defineProperty(exports, "SecurityFiltersResponse", ({ enumerable: true, get: function () { return SecurityFiltersResponse_1.SecurityFiltersResponse; } }));
var SecurityFilterUpdateAttributes_1 = __webpack_require__(70723);
Object.defineProperty(exports, "SecurityFilterUpdateAttributes", ({ enumerable: true, get: function () { return SecurityFilterUpdateAttributes_1.SecurityFilterUpdateAttributes; } }));
var SecurityFilterUpdateData_1 = __webpack_require__(64889);
Object.defineProperty(exports, "SecurityFilterUpdateData", ({ enumerable: true, get: function () { return SecurityFilterUpdateData_1.SecurityFilterUpdateData; } }));
var SecurityFilterUpdateRequest_1 = __webpack_require__(67365);
Object.defineProperty(exports, "SecurityFilterUpdateRequest", ({ enumerable: true, get: function () { return SecurityFilterUpdateRequest_1.SecurityFilterUpdateRequest; } }));
var SecurityMonitoringFilter_1 = __webpack_require__(24483);
Object.defineProperty(exports, "SecurityMonitoringFilter", ({ enumerable: true, get: function () { return SecurityMonitoringFilter_1.SecurityMonitoringFilter; } }));
var SecurityMonitoringListRulesResponse_1 = __webpack_require__(73982);
Object.defineProperty(exports, "SecurityMonitoringListRulesResponse", ({ enumerable: true, get: function () { return SecurityMonitoringListRulesResponse_1.SecurityMonitoringListRulesResponse; } }));
var SecurityMonitoringRuleCase_1 = __webpack_require__(38467);
Object.defineProperty(exports, "SecurityMonitoringRuleCase", ({ enumerable: true, get: function () { return SecurityMonitoringRuleCase_1.SecurityMonitoringRuleCase; } }));
var SecurityMonitoringRuleCaseCreate_1 = __webpack_require__(50909);
Object.defineProperty(exports, "SecurityMonitoringRuleCaseCreate", ({ enumerable: true, get: function () { return SecurityMonitoringRuleCaseCreate_1.SecurityMonitoringRuleCaseCreate; } }));
var SecurityMonitoringRuleImpossibleTravelOptions_1 = __webpack_require__(25690);
Object.defineProperty(exports, "SecurityMonitoringRuleImpossibleTravelOptions", ({ enumerable: true, get: function () { return SecurityMonitoringRuleImpossibleTravelOptions_1.SecurityMonitoringRuleImpossibleTravelOptions; } }));
var SecurityMonitoringRuleNewValueOptions_1 = __webpack_require__(10646);
Object.defineProperty(exports, "SecurityMonitoringRuleNewValueOptions", ({ enumerable: true, get: function () { return SecurityMonitoringRuleNewValueOptions_1.SecurityMonitoringRuleNewValueOptions; } }));
var SecurityMonitoringRuleOptions_1 = __webpack_require__(41277);
Object.defineProperty(exports, "SecurityMonitoringRuleOptions", ({ enumerable: true, get: function () { return SecurityMonitoringRuleOptions_1.SecurityMonitoringRuleOptions; } }));
var SecurityMonitoringRuleUpdatePayload_1 = __webpack_require__(21004);
Object.defineProperty(exports, "SecurityMonitoringRuleUpdatePayload", ({ enumerable: true, get: function () { return SecurityMonitoringRuleUpdatePayload_1.SecurityMonitoringRuleUpdatePayload; } }));
var SecurityMonitoringSignal_1 = __webpack_require__(73354);
Object.defineProperty(exports, "SecurityMonitoringSignal", ({ enumerable: true, get: function () { return SecurityMonitoringSignal_1.SecurityMonitoringSignal; } }));
var SecurityMonitoringSignalAssigneeUpdateAttributes_1 = __webpack_require__(14090);
Object.defineProperty(exports, "SecurityMonitoringSignalAssigneeUpdateAttributes", ({ enumerable: true, get: function () { return SecurityMonitoringSignalAssigneeUpdateAttributes_1.SecurityMonitoringSignalAssigneeUpdateAttributes; } }));
var SecurityMonitoringSignalAssigneeUpdateData_1 = __webpack_require__(12839);
Object.defineProperty(exports, "SecurityMonitoringSignalAssigneeUpdateData", ({ enumerable: true, get: function () { return SecurityMonitoringSignalAssigneeUpdateData_1.SecurityMonitoringSignalAssigneeUpdateData; } }));
var SecurityMonitoringSignalAssigneeUpdateRequest_1 = __webpack_require__(65035);
Object.defineProperty(exports, "SecurityMonitoringSignalAssigneeUpdateRequest", ({ enumerable: true, get: function () { return SecurityMonitoringSignalAssigneeUpdateRequest_1.SecurityMonitoringSignalAssigneeUpdateRequest; } }));
var SecurityMonitoringSignalAttributes_1 = __webpack_require__(81335);
Object.defineProperty(exports, "SecurityMonitoringSignalAttributes", ({ enumerable: true, get: function () { return SecurityMonitoringSignalAttributes_1.SecurityMonitoringSignalAttributes; } }));
var SecurityMonitoringSignalIncidentsUpdateAttributes_1 = __webpack_require__(54429);
Object.defineProperty(exports, "SecurityMonitoringSignalIncidentsUpdateAttributes", ({ enumerable: true, get: function () { return SecurityMonitoringSignalIncidentsUpdateAttributes_1.SecurityMonitoringSignalIncidentsUpdateAttributes; } }));
var SecurityMonitoringSignalIncidentsUpdateData_1 = __webpack_require__(94861);
Object.defineProperty(exports, "SecurityMonitoringSignalIncidentsUpdateData", ({ enumerable: true, get: function () { return SecurityMonitoringSignalIncidentsUpdateData_1.SecurityMonitoringSignalIncidentsUpdateData; } }));
var SecurityMonitoringSignalIncidentsUpdateRequest_1 = __webpack_require__(54497);
Object.defineProperty(exports, "SecurityMonitoringSignalIncidentsUpdateRequest", ({ enumerable: true, get: function () { return SecurityMonitoringSignalIncidentsUpdateRequest_1.SecurityMonitoringSignalIncidentsUpdateRequest; } }));
var SecurityMonitoringSignalListRequest_1 = __webpack_require__(13723);
Object.defineProperty(exports, "SecurityMonitoringSignalListRequest", ({ enumerable: true, get: function () { return SecurityMonitoringSignalListRequest_1.SecurityMonitoringSignalListRequest; } }));
var SecurityMonitoringSignalListRequestFilter_1 = __webpack_require__(75078);
Object.defineProperty(exports, "SecurityMonitoringSignalListRequestFilter", ({ enumerable: true, get: function () { return SecurityMonitoringSignalListRequestFilter_1.SecurityMonitoringSignalListRequestFilter; } }));
var SecurityMonitoringSignalListRequestPage_1 = __webpack_require__(31123);
Object.defineProperty(exports, "SecurityMonitoringSignalListRequestPage", ({ enumerable: true, get: function () { return SecurityMonitoringSignalListRequestPage_1.SecurityMonitoringSignalListRequestPage; } }));
var SecurityMonitoringSignalRuleCreatePayload_1 = __webpack_require__(81883);
Object.defineProperty(exports, "SecurityMonitoringSignalRuleCreatePayload", ({ enumerable: true, get: function () { return SecurityMonitoringSignalRuleCreatePayload_1.SecurityMonitoringSignalRuleCreatePayload; } }));
var SecurityMonitoringSignalRuleQuery_1 = __webpack_require__(93930);
Object.defineProperty(exports, "SecurityMonitoringSignalRuleQuery", ({ enumerable: true, get: function () { return SecurityMonitoringSignalRuleQuery_1.SecurityMonitoringSignalRuleQuery; } }));
var SecurityMonitoringSignalRuleResponse_1 = __webpack_require__(2788);
Object.defineProperty(exports, "SecurityMonitoringSignalRuleResponse", ({ enumerable: true, get: function () { return SecurityMonitoringSignalRuleResponse_1.SecurityMonitoringSignalRuleResponse; } }));
var SecurityMonitoringSignalRuleResponseQuery_1 = __webpack_require__(87097);
Object.defineProperty(exports, "SecurityMonitoringSignalRuleResponseQuery", ({ enumerable: true, get: function () { return SecurityMonitoringSignalRuleResponseQuery_1.SecurityMonitoringSignalRuleResponseQuery; } }));
var SecurityMonitoringSignalsListResponse_1 = __webpack_require__(8869);
Object.defineProperty(exports, "SecurityMonitoringSignalsListResponse", ({ enumerable: true, get: function () { return SecurityMonitoringSignalsListResponse_1.SecurityMonitoringSignalsListResponse; } }));
var SecurityMonitoringSignalsListResponseLinks_1 = __webpack_require__(53523);
Object.defineProperty(exports, "SecurityMonitoringSignalsListResponseLinks", ({ enumerable: true, get: function () { return SecurityMonitoringSignalsListResponseLinks_1.SecurityMonitoringSignalsListResponseLinks; } }));
var SecurityMonitoringSignalsListResponseMeta_1 = __webpack_require__(39585);
Object.defineProperty(exports, "SecurityMonitoringSignalsListResponseMeta", ({ enumerable: true, get: function () { return SecurityMonitoringSignalsListResponseMeta_1.SecurityMonitoringSignalsListResponseMeta; } }));
var SecurityMonitoringSignalsListResponseMetaPage_1 = __webpack_require__(54327);
Object.defineProperty(exports, "SecurityMonitoringSignalsListResponseMetaPage", ({ enumerable: true, get: function () { return SecurityMonitoringSignalsListResponseMetaPage_1.SecurityMonitoringSignalsListResponseMetaPage; } }));
var SecurityMonitoringSignalStateUpdateAttributes_1 = __webpack_require__(15491);
Object.defineProperty(exports, "SecurityMonitoringSignalStateUpdateAttributes", ({ enumerable: true, get: function () { return SecurityMonitoringSignalStateUpdateAttributes_1.SecurityMonitoringSignalStateUpdateAttributes; } }));
var SecurityMonitoringSignalStateUpdateData_1 = __webpack_require__(48336);
Object.defineProperty(exports, "SecurityMonitoringSignalStateUpdateData", ({ enumerable: true, get: function () { return SecurityMonitoringSignalStateUpdateData_1.SecurityMonitoringSignalStateUpdateData; } }));
var SecurityMonitoringSignalStateUpdateRequest_1 = __webpack_require__(42649);
Object.defineProperty(exports, "SecurityMonitoringSignalStateUpdateRequest", ({ enumerable: true, get: function () { return SecurityMonitoringSignalStateUpdateRequest_1.SecurityMonitoringSignalStateUpdateRequest; } }));
var SecurityMonitoringSignalTriageAttributes_1 = __webpack_require__(38673);
Object.defineProperty(exports, "SecurityMonitoringSignalTriageAttributes", ({ enumerable: true, get: function () { return SecurityMonitoringSignalTriageAttributes_1.SecurityMonitoringSignalTriageAttributes; } }));
var SecurityMonitoringSignalTriageUpdateData_1 = __webpack_require__(21346);
Object.defineProperty(exports, "SecurityMonitoringSignalTriageUpdateData", ({ enumerable: true, get: function () { return SecurityMonitoringSignalTriageUpdateData_1.SecurityMonitoringSignalTriageUpdateData; } }));
var SecurityMonitoringSignalTriageUpdateResponse_1 = __webpack_require__(97439);
Object.defineProperty(exports, "SecurityMonitoringSignalTriageUpdateResponse", ({ enumerable: true, get: function () { return SecurityMonitoringSignalTriageUpdateResponse_1.SecurityMonitoringSignalTriageUpdateResponse; } }));
var SecurityMonitoringStandardRuleCreatePayload_1 = __webpack_require__(29677);
Object.defineProperty(exports, "SecurityMonitoringStandardRuleCreatePayload", ({ enumerable: true, get: function () { return SecurityMonitoringStandardRuleCreatePayload_1.SecurityMonitoringStandardRuleCreatePayload; } }));
var SecurityMonitoringStandardRuleQuery_1 = __webpack_require__(49427);
Object.defineProperty(exports, "SecurityMonitoringStandardRuleQuery", ({ enumerable: true, get: function () { return SecurityMonitoringStandardRuleQuery_1.SecurityMonitoringStandardRuleQuery; } }));
var SecurityMonitoringStandardRuleResponse_1 = __webpack_require__(37779);
Object.defineProperty(exports, "SecurityMonitoringStandardRuleResponse", ({ enumerable: true, get: function () { return SecurityMonitoringStandardRuleResponse_1.SecurityMonitoringStandardRuleResponse; } }));
var SecurityMonitoringTriageUser_1 = __webpack_require__(38314);
Object.defineProperty(exports, "SecurityMonitoringTriageUser", ({ enumerable: true, get: function () { return SecurityMonitoringTriageUser_1.SecurityMonitoringTriageUser; } }));
var SensitiveDataScannerConfigRequest_1 = __webpack_require__(82462);
Object.defineProperty(exports, "SensitiveDataScannerConfigRequest", ({ enumerable: true, get: function () { return SensitiveDataScannerConfigRequest_1.SensitiveDataScannerConfigRequest; } }));
var SensitiveDataScannerConfiguration_1 = __webpack_require__(67945);
Object.defineProperty(exports, "SensitiveDataScannerConfiguration", ({ enumerable: true, get: function () { return SensitiveDataScannerConfiguration_1.SensitiveDataScannerConfiguration; } }));
var SensitiveDataScannerConfigurationData_1 = __webpack_require__(3706);
Object.defineProperty(exports, "SensitiveDataScannerConfigurationData", ({ enumerable: true, get: function () { return SensitiveDataScannerConfigurationData_1.SensitiveDataScannerConfigurationData; } }));
var SensitiveDataScannerConfigurationRelationships_1 = __webpack_require__(91265);
Object.defineProperty(exports, "SensitiveDataScannerConfigurationRelationships", ({ enumerable: true, get: function () { return SensitiveDataScannerConfigurationRelationships_1.SensitiveDataScannerConfigurationRelationships; } }));
var SensitiveDataScannerCreateGroupResponse_1 = __webpack_require__(20832);
Object.defineProperty(exports, "SensitiveDataScannerCreateGroupResponse", ({ enumerable: true, get: function () { return SensitiveDataScannerCreateGroupResponse_1.SensitiveDataScannerCreateGroupResponse; } }));
var SensitiveDataScannerCreateRuleResponse_1 = __webpack_require__(52528);
Object.defineProperty(exports, "SensitiveDataScannerCreateRuleResponse", ({ enumerable: true, get: function () { return SensitiveDataScannerCreateRuleResponse_1.SensitiveDataScannerCreateRuleResponse; } }));
var SensitiveDataScannerFilter_1 = __webpack_require__(25030);
Object.defineProperty(exports, "SensitiveDataScannerFilter", ({ enumerable: true, get: function () { return SensitiveDataScannerFilter_1.SensitiveDataScannerFilter; } }));
var SensitiveDataScannerGetConfigResponse_1 = __webpack_require__(28829);
Object.defineProperty(exports, "SensitiveDataScannerGetConfigResponse", ({ enumerable: true, get: function () { return SensitiveDataScannerGetConfigResponse_1.SensitiveDataScannerGetConfigResponse; } }));
var SensitiveDataScannerGetConfigResponseData_1 = __webpack_require__(54486);
Object.defineProperty(exports, "SensitiveDataScannerGetConfigResponseData", ({ enumerable: true, get: function () { return SensitiveDataScannerGetConfigResponseData_1.SensitiveDataScannerGetConfigResponseData; } }));
var SensitiveDataScannerGroup_1 = __webpack_require__(84787);
Object.defineProperty(exports, "SensitiveDataScannerGroup", ({ enumerable: true, get: function () { return SensitiveDataScannerGroup_1.SensitiveDataScannerGroup; } }));
var SensitiveDataScannerGroupAttributes_1 = __webpack_require__(38169);
Object.defineProperty(exports, "SensitiveDataScannerGroupAttributes", ({ enumerable: true, get: function () { return SensitiveDataScannerGroupAttributes_1.SensitiveDataScannerGroupAttributes; } }));
var SensitiveDataScannerGroupCreate_1 = __webpack_require__(50135);
Object.defineProperty(exports, "SensitiveDataScannerGroupCreate", ({ enumerable: true, get: function () { return SensitiveDataScannerGroupCreate_1.SensitiveDataScannerGroupCreate; } }));
var SensitiveDataScannerGroupCreateRequest_1 = __webpack_require__(30524);
Object.defineProperty(exports, "SensitiveDataScannerGroupCreateRequest", ({ enumerable: true, get: function () { return SensitiveDataScannerGroupCreateRequest_1.SensitiveDataScannerGroupCreateRequest; } }));
var SensitiveDataScannerGroupData_1 = __webpack_require__(8282);
Object.defineProperty(exports, "SensitiveDataScannerGroupData", ({ enumerable: true, get: function () { return SensitiveDataScannerGroupData_1.SensitiveDataScannerGroupData; } }));
var SensitiveDataScannerGroupDeleteRequest_1 = __webpack_require__(6445);
Object.defineProperty(exports, "SensitiveDataScannerGroupDeleteRequest", ({ enumerable: true, get: function () { return SensitiveDataScannerGroupDeleteRequest_1.SensitiveDataScannerGroupDeleteRequest; } }));
var SensitiveDataScannerGroupDeleteResponse_1 = __webpack_require__(93600);
Object.defineProperty(exports, "SensitiveDataScannerGroupDeleteResponse", ({ enumerable: true, get: function () { return SensitiveDataScannerGroupDeleteResponse_1.SensitiveDataScannerGroupDeleteResponse; } }));
var SensitiveDataScannerGroupIncludedItem_1 = __webpack_require__(21332);
Object.defineProperty(exports, "SensitiveDataScannerGroupIncludedItem", ({ enumerable: true, get: function () { return SensitiveDataScannerGroupIncludedItem_1.SensitiveDataScannerGroupIncludedItem; } }));
var SensitiveDataScannerGroupItem_1 = __webpack_require__(32080);
Object.defineProperty(exports, "SensitiveDataScannerGroupItem", ({ enumerable: true, get: function () { return SensitiveDataScannerGroupItem_1.SensitiveDataScannerGroupItem; } }));
var SensitiveDataScannerGroupList_1 = __webpack_require__(406);
Object.defineProperty(exports, "SensitiveDataScannerGroupList", ({ enumerable: true, get: function () { return SensitiveDataScannerGroupList_1.SensitiveDataScannerGroupList; } }));
var SensitiveDataScannerGroupRelationships_1 = __webpack_require__(88193);
Object.defineProperty(exports, "SensitiveDataScannerGroupRelationships", ({ enumerable: true, get: function () { return SensitiveDataScannerGroupRelationships_1.SensitiveDataScannerGroupRelationships; } }));
var SensitiveDataScannerGroupResponse_1 = __webpack_require__(68081);
Object.defineProperty(exports, "SensitiveDataScannerGroupResponse", ({ enumerable: true, get: function () { return SensitiveDataScannerGroupResponse_1.SensitiveDataScannerGroupResponse; } }));
var SensitiveDataScannerGroupUpdate_1 = __webpack_require__(96818);
Object.defineProperty(exports, "SensitiveDataScannerGroupUpdate", ({ enumerable: true, get: function () { return SensitiveDataScannerGroupUpdate_1.SensitiveDataScannerGroupUpdate; } }));
var SensitiveDataScannerGroupUpdateRequest_1 = __webpack_require__(25051);
Object.defineProperty(exports, "SensitiveDataScannerGroupUpdateRequest", ({ enumerable: true, get: function () { return SensitiveDataScannerGroupUpdateRequest_1.SensitiveDataScannerGroupUpdateRequest; } }));
var SensitiveDataScannerGroupUpdateResponse_1 = __webpack_require__(83278);
Object.defineProperty(exports, "SensitiveDataScannerGroupUpdateResponse", ({ enumerable: true, get: function () { return SensitiveDataScannerGroupUpdateResponse_1.SensitiveDataScannerGroupUpdateResponse; } }));
var SensitiveDataScannerMeta_1 = __webpack_require__(65690);
Object.defineProperty(exports, "SensitiveDataScannerMeta", ({ enumerable: true, get: function () { return SensitiveDataScannerMeta_1.SensitiveDataScannerMeta; } }));
var SensitiveDataScannerMetaVersionOnly_1 = __webpack_require__(53588);
Object.defineProperty(exports, "SensitiveDataScannerMetaVersionOnly", ({ enumerable: true, get: function () { return SensitiveDataScannerMetaVersionOnly_1.SensitiveDataScannerMetaVersionOnly; } }));
var SensitiveDataScannerReorderConfig_1 = __webpack_require__(69317);
Object.defineProperty(exports, "SensitiveDataScannerReorderConfig", ({ enumerable: true, get: function () { return SensitiveDataScannerReorderConfig_1.SensitiveDataScannerReorderConfig; } }));
var SensitiveDataScannerReorderGroupsResponse_1 = __webpack_require__(90270);
Object.defineProperty(exports, "SensitiveDataScannerReorderGroupsResponse", ({ enumerable: true, get: function () { return SensitiveDataScannerReorderGroupsResponse_1.SensitiveDataScannerReorderGroupsResponse; } }));
var SensitiveDataScannerRule_1 = __webpack_require__(37961);
Object.defineProperty(exports, "SensitiveDataScannerRule", ({ enumerable: true, get: function () { return SensitiveDataScannerRule_1.SensitiveDataScannerRule; } }));
var SensitiveDataScannerRuleAttributes_1 = __webpack_require__(66455);
Object.defineProperty(exports, "SensitiveDataScannerRuleAttributes", ({ enumerable: true, get: function () { return SensitiveDataScannerRuleAttributes_1.SensitiveDataScannerRuleAttributes; } }));
var SensitiveDataScannerRuleCreate_1 = __webpack_require__(31674);
Object.defineProperty(exports, "SensitiveDataScannerRuleCreate", ({ enumerable: true, get: function () { return SensitiveDataScannerRuleCreate_1.SensitiveDataScannerRuleCreate; } }));
var SensitiveDataScannerRuleCreateRequest_1 = __webpack_require__(22917);
Object.defineProperty(exports, "SensitiveDataScannerRuleCreateRequest", ({ enumerable: true, get: function () { return SensitiveDataScannerRuleCreateRequest_1.SensitiveDataScannerRuleCreateRequest; } }));
var SensitiveDataScannerRuleData_1 = __webpack_require__(81643);
Object.defineProperty(exports, "SensitiveDataScannerRuleData", ({ enumerable: true, get: function () { return SensitiveDataScannerRuleData_1.SensitiveDataScannerRuleData; } }));
var SensitiveDataScannerRuleDeleteRequest_1 = __webpack_require__(93391);
Object.defineProperty(exports, "SensitiveDataScannerRuleDeleteRequest", ({ enumerable: true, get: function () { return SensitiveDataScannerRuleDeleteRequest_1.SensitiveDataScannerRuleDeleteRequest; } }));
var SensitiveDataScannerRuleDeleteResponse_1 = __webpack_require__(37715);
Object.defineProperty(exports, "SensitiveDataScannerRuleDeleteResponse", ({ enumerable: true, get: function () { return SensitiveDataScannerRuleDeleteResponse_1.SensitiveDataScannerRuleDeleteResponse; } }));
var SensitiveDataScannerRuleIncludedItem_1 = __webpack_require__(26218);
Object.defineProperty(exports, "SensitiveDataScannerRuleIncludedItem", ({ enumerable: true, get: function () { return SensitiveDataScannerRuleIncludedItem_1.SensitiveDataScannerRuleIncludedItem; } }));
var SensitiveDataScannerRuleRelationships_1 = __webpack_require__(14442);
Object.defineProperty(exports, "SensitiveDataScannerRuleRelationships", ({ enumerable: true, get: function () { return SensitiveDataScannerRuleRelationships_1.SensitiveDataScannerRuleRelationships; } }));
var SensitiveDataScannerRuleResponse_1 = __webpack_require__(33872);
Object.defineProperty(exports, "SensitiveDataScannerRuleResponse", ({ enumerable: true, get: function () { return SensitiveDataScannerRuleResponse_1.SensitiveDataScannerRuleResponse; } }));
var SensitiveDataScannerRuleUpdate_1 = __webpack_require__(83537);
Object.defineProperty(exports, "SensitiveDataScannerRuleUpdate", ({ enumerable: true, get: function () { return SensitiveDataScannerRuleUpdate_1.SensitiveDataScannerRuleUpdate; } }));
var SensitiveDataScannerRuleUpdateRequest_1 = __webpack_require__(73584);
Object.defineProperty(exports, "SensitiveDataScannerRuleUpdateRequest", ({ enumerable: true, get: function () { return SensitiveDataScannerRuleUpdateRequest_1.SensitiveDataScannerRuleUpdateRequest; } }));
var SensitiveDataScannerRuleUpdateResponse_1 = __webpack_require__(89412);
Object.defineProperty(exports, "SensitiveDataScannerRuleUpdateResponse", ({ enumerable: true, get: function () { return SensitiveDataScannerRuleUpdateResponse_1.SensitiveDataScannerRuleUpdateResponse; } }));
var SensitiveDataScannerStandardPattern_1 = __webpack_require__(17483);
Object.defineProperty(exports, "SensitiveDataScannerStandardPattern", ({ enumerable: true, get: function () { return SensitiveDataScannerStandardPattern_1.SensitiveDataScannerStandardPattern; } }));
var SensitiveDataScannerStandardPatternAttributes_1 = __webpack_require__(33843);
Object.defineProperty(exports, "SensitiveDataScannerStandardPatternAttributes", ({ enumerable: true, get: function () { return SensitiveDataScannerStandardPatternAttributes_1.SensitiveDataScannerStandardPatternAttributes; } }));
var SensitiveDataScannerStandardPatternData_1 = __webpack_require__(52824);
Object.defineProperty(exports, "SensitiveDataScannerStandardPatternData", ({ enumerable: true, get: function () { return SensitiveDataScannerStandardPatternData_1.SensitiveDataScannerStandardPatternData; } }));
var SensitiveDataScannerStandardPatternsResponseData_1 = __webpack_require__(10167);
Object.defineProperty(exports, "SensitiveDataScannerStandardPatternsResponseData", ({ enumerable: true, get: function () { return SensitiveDataScannerStandardPatternsResponseData_1.SensitiveDataScannerStandardPatternsResponseData; } }));
var SensitiveDataScannerStandardPatternsResponseItem_1 = __webpack_require__(36681);
Object.defineProperty(exports, "SensitiveDataScannerStandardPatternsResponseItem", ({ enumerable: true, get: function () { return SensitiveDataScannerStandardPatternsResponseItem_1.SensitiveDataScannerStandardPatternsResponseItem; } }));
var SensitiveDataScannerTextReplacement_1 = __webpack_require__(49101);
Object.defineProperty(exports, "SensitiveDataScannerTextReplacement", ({ enumerable: true, get: function () { return SensitiveDataScannerTextReplacement_1.SensitiveDataScannerTextReplacement; } }));
var ServiceAccountCreateAttributes_1 = __webpack_require__(90326);
Object.defineProperty(exports, "ServiceAccountCreateAttributes", ({ enumerable: true, get: function () { return ServiceAccountCreateAttributes_1.ServiceAccountCreateAttributes; } }));
var ServiceAccountCreateData_1 = __webpack_require__(62468);
Object.defineProperty(exports, "ServiceAccountCreateData", ({ enumerable: true, get: function () { return ServiceAccountCreateData_1.ServiceAccountCreateData; } }));
var ServiceAccountCreateRequest_1 = __webpack_require__(5390);
Object.defineProperty(exports, "ServiceAccountCreateRequest", ({ enumerable: true, get: function () { return ServiceAccountCreateRequest_1.ServiceAccountCreateRequest; } }));
var ServiceDefinitionCreateResponse_1 = __webpack_require__(42713);
Object.defineProperty(exports, "ServiceDefinitionCreateResponse", ({ enumerable: true, get: function () { return ServiceDefinitionCreateResponse_1.ServiceDefinitionCreateResponse; } }));
var ServiceDefinitionData_1 = __webpack_require__(30060);
Object.defineProperty(exports, "ServiceDefinitionData", ({ enumerable: true, get: function () { return ServiceDefinitionData_1.ServiceDefinitionData; } }));
var ServiceDefinitionDataAttributes_1 = __webpack_require__(46642);
Object.defineProperty(exports, "ServiceDefinitionDataAttributes", ({ enumerable: true, get: function () { return ServiceDefinitionDataAttributes_1.ServiceDefinitionDataAttributes; } }));
var ServiceDefinitionGetResponse_1 = __webpack_require__(41368);
Object.defineProperty(exports, "ServiceDefinitionGetResponse", ({ enumerable: true, get: function () { return ServiceDefinitionGetResponse_1.ServiceDefinitionGetResponse; } }));
var ServiceDefinitionMeta_1 = __webpack_require__(22530);
Object.defineProperty(exports, "ServiceDefinitionMeta", ({ enumerable: true, get: function () { return ServiceDefinitionMeta_1.ServiceDefinitionMeta; } }));
var ServiceDefinitionsListResponse_1 = __webpack_require__(25597);
Object.defineProperty(exports, "ServiceDefinitionsListResponse", ({ enumerable: true, get: function () { return ServiceDefinitionsListResponse_1.ServiceDefinitionsListResponse; } }));
var ServiceDefinitionV1_1 = __webpack_require__(97979);
Object.defineProperty(exports, "ServiceDefinitionV1", ({ enumerable: true, get: function () { return ServiceDefinitionV1_1.ServiceDefinitionV1; } }));
var ServiceDefinitionV1Contact_1 = __webpack_require__(95884);
Object.defineProperty(exports, "ServiceDefinitionV1Contact", ({ enumerable: true, get: function () { return ServiceDefinitionV1Contact_1.ServiceDefinitionV1Contact; } }));
var ServiceDefinitionV1Info_1 = __webpack_require__(78827);
Object.defineProperty(exports, "ServiceDefinitionV1Info", ({ enumerable: true, get: function () { return ServiceDefinitionV1Info_1.ServiceDefinitionV1Info; } }));
var ServiceDefinitionV1Integrations_1 = __webpack_require__(30350);
Object.defineProperty(exports, "ServiceDefinitionV1Integrations", ({ enumerable: true, get: function () { return ServiceDefinitionV1Integrations_1.ServiceDefinitionV1Integrations; } }));
var ServiceDefinitionV1Org_1 = __webpack_require__(91764);
Object.defineProperty(exports, "ServiceDefinitionV1Org", ({ enumerable: true, get: function () { return ServiceDefinitionV1Org_1.ServiceDefinitionV1Org; } }));
var ServiceDefinitionV1Resource_1 = __webpack_require__(78038);
Object.defineProperty(exports, "ServiceDefinitionV1Resource", ({ enumerable: true, get: function () { return ServiceDefinitionV1Resource_1.ServiceDefinitionV1Resource; } }));
var ServiceDefinitionV2_1 = __webpack_require__(39172);
Object.defineProperty(exports, "ServiceDefinitionV2", ({ enumerable: true, get: function () { return ServiceDefinitionV2_1.ServiceDefinitionV2; } }));
var ServiceDefinitionV2Doc_1 = __webpack_require__(86073);
Object.defineProperty(exports, "ServiceDefinitionV2Doc", ({ enumerable: true, get: function () { return ServiceDefinitionV2Doc_1.ServiceDefinitionV2Doc; } }));
var ServiceDefinitionV2Email_1 = __webpack_require__(97378);
Object.defineProperty(exports, "ServiceDefinitionV2Email", ({ enumerable: true, get: function () { return ServiceDefinitionV2Email_1.ServiceDefinitionV2Email; } }));
var ServiceDefinitionV2Integrations_1 = __webpack_require__(74370);
Object.defineProperty(exports, "ServiceDefinitionV2Integrations", ({ enumerable: true, get: function () { return ServiceDefinitionV2Integrations_1.ServiceDefinitionV2Integrations; } }));
var ServiceDefinitionV2Link_1 = __webpack_require__(36812);
Object.defineProperty(exports, "ServiceDefinitionV2Link", ({ enumerable: true, get: function () { return ServiceDefinitionV2Link_1.ServiceDefinitionV2Link; } }));
var ServiceDefinitionV2Opsgenie_1 = __webpack_require__(6735);
Object.defineProperty(exports, "ServiceDefinitionV2Opsgenie", ({ enumerable: true, get: function () { return ServiceDefinitionV2Opsgenie_1.ServiceDefinitionV2Opsgenie; } }));
var ServiceDefinitionV2Repo_1 = __webpack_require__(81097);
Object.defineProperty(exports, "ServiceDefinitionV2Repo", ({ enumerable: true, get: function () { return ServiceDefinitionV2Repo_1.ServiceDefinitionV2Repo; } }));
var ServiceDefinitionV2Slack_1 = __webpack_require__(61789);
Object.defineProperty(exports, "ServiceDefinitionV2Slack", ({ enumerable: true, get: function () { return ServiceDefinitionV2Slack_1.ServiceDefinitionV2Slack; } }));
var TimeseriesFormulaQueryRequest_1 = __webpack_require__(78461);
Object.defineProperty(exports, "TimeseriesFormulaQueryRequest", ({ enumerable: true, get: function () { return TimeseriesFormulaQueryRequest_1.TimeseriesFormulaQueryRequest; } }));
var TimeseriesFormulaQueryResponse_1 = __webpack_require__(57031);
Object.defineProperty(exports, "TimeseriesFormulaQueryResponse", ({ enumerable: true, get: function () { return TimeseriesFormulaQueryResponse_1.TimeseriesFormulaQueryResponse; } }));
var TimeseriesFormulaRequest_1 = __webpack_require__(18358);
Object.defineProperty(exports, "TimeseriesFormulaRequest", ({ enumerable: true, get: function () { return TimeseriesFormulaRequest_1.TimeseriesFormulaRequest; } }));
var TimeseriesFormulaRequestAttributes_1 = __webpack_require__(30379);
Object.defineProperty(exports, "TimeseriesFormulaRequestAttributes", ({ enumerable: true, get: function () { return TimeseriesFormulaRequestAttributes_1.TimeseriesFormulaRequestAttributes; } }));
var TimeseriesResponse_1 = __webpack_require__(83296);
Object.defineProperty(exports, "TimeseriesResponse", ({ enumerable: true, get: function () { return TimeseriesResponse_1.TimeseriesResponse; } }));
var TimeseriesResponseAttributes_1 = __webpack_require__(11229);
Object.defineProperty(exports, "TimeseriesResponseAttributes", ({ enumerable: true, get: function () { return TimeseriesResponseAttributes_1.TimeseriesResponseAttributes; } }));
var TimeseriesResponseSeries_1 = __webpack_require__(46581);
Object.defineProperty(exports, "TimeseriesResponseSeries", ({ enumerable: true, get: function () { return TimeseriesResponseSeries_1.TimeseriesResponseSeries; } }));
var Unit_1 = __webpack_require__(31458);
Object.defineProperty(exports, "Unit", ({ enumerable: true, get: function () { return Unit_1.Unit; } }));
var UsageApplicationSecurityMonitoringResponse_1 = __webpack_require__(87933);
Object.defineProperty(exports, "UsageApplicationSecurityMonitoringResponse", ({ enumerable: true, get: function () { return UsageApplicationSecurityMonitoringResponse_1.UsageApplicationSecurityMonitoringResponse; } }));
var UsageAttributesObject_1 = __webpack_require__(14031);
Object.defineProperty(exports, "UsageAttributesObject", ({ enumerable: true, get: function () { return UsageAttributesObject_1.UsageAttributesObject; } }));
var UsageDataObject_1 = __webpack_require__(43595);
Object.defineProperty(exports, "UsageDataObject", ({ enumerable: true, get: function () { return UsageDataObject_1.UsageDataObject; } }));
var UsageLambdaTracedInvocationsResponse_1 = __webpack_require__(79017);
Object.defineProperty(exports, "UsageLambdaTracedInvocationsResponse", ({ enumerable: true, get: function () { return UsageLambdaTracedInvocationsResponse_1.UsageLambdaTracedInvocationsResponse; } }));
var UsageObservabilityPipelinesResponse_1 = __webpack_require__(33947);
Object.defineProperty(exports, "UsageObservabilityPipelinesResponse", ({ enumerable: true, get: function () { return UsageObservabilityPipelinesResponse_1.UsageObservabilityPipelinesResponse; } }));
var UsageTimeSeriesObject_1 = __webpack_require__(11483);
Object.defineProperty(exports, "UsageTimeSeriesObject", ({ enumerable: true, get: function () { return UsageTimeSeriesObject_1.UsageTimeSeriesObject; } }));
var User_1 = __webpack_require__(47786);
Object.defineProperty(exports, "User", ({ enumerable: true, get: function () { return User_1.User; } }));
var UserAttributes_1 = __webpack_require__(42432);
Object.defineProperty(exports, "UserAttributes", ({ enumerable: true, get: function () { return UserAttributes_1.UserAttributes; } }));
var UserCreateAttributes_1 = __webpack_require__(66656);
Object.defineProperty(exports, "UserCreateAttributes", ({ enumerable: true, get: function () { return UserCreateAttributes_1.UserCreateAttributes; } }));
var UserCreateData_1 = __webpack_require__(66646);
Object.defineProperty(exports, "UserCreateData", ({ enumerable: true, get: function () { return UserCreateData_1.UserCreateData; } }));
var UserCreateRequest_1 = __webpack_require__(87642);
Object.defineProperty(exports, "UserCreateRequest", ({ enumerable: true, get: function () { return UserCreateRequest_1.UserCreateRequest; } }));
var UserInvitationData_1 = __webpack_require__(77954);
Object.defineProperty(exports, "UserInvitationData", ({ enumerable: true, get: function () { return UserInvitationData_1.UserInvitationData; } }));
var UserInvitationDataAttributes_1 = __webpack_require__(3798);
Object.defineProperty(exports, "UserInvitationDataAttributes", ({ enumerable: true, get: function () { return UserInvitationDataAttributes_1.UserInvitationDataAttributes; } }));
var UserInvitationRelationships_1 = __webpack_require__(18252);
Object.defineProperty(exports, "UserInvitationRelationships", ({ enumerable: true, get: function () { return UserInvitationRelationships_1.UserInvitationRelationships; } }));
var UserInvitationResponse_1 = __webpack_require__(14586);
Object.defineProperty(exports, "UserInvitationResponse", ({ enumerable: true, get: function () { return UserInvitationResponse_1.UserInvitationResponse; } }));
var UserInvitationResponseData_1 = __webpack_require__(35653);
Object.defineProperty(exports, "UserInvitationResponseData", ({ enumerable: true, get: function () { return UserInvitationResponseData_1.UserInvitationResponseData; } }));
var UserInvitationsRequest_1 = __webpack_require__(89585);
Object.defineProperty(exports, "UserInvitationsRequest", ({ enumerable: true, get: function () { return UserInvitationsRequest_1.UserInvitationsRequest; } }));
var UserInvitationsResponse_1 = __webpack_require__(49353);
Object.defineProperty(exports, "UserInvitationsResponse", ({ enumerable: true, get: function () { return UserInvitationsResponse_1.UserInvitationsResponse; } }));
var UserRelationships_1 = __webpack_require__(58125);
Object.defineProperty(exports, "UserRelationships", ({ enumerable: true, get: function () { return UserRelationships_1.UserRelationships; } }));
var UserResponse_1 = __webpack_require__(18779);
Object.defineProperty(exports, "UserResponse", ({ enumerable: true, get: function () { return UserResponse_1.UserResponse; } }));
var UserResponseRelationships_1 = __webpack_require__(20157);
Object.defineProperty(exports, "UserResponseRelationships", ({ enumerable: true, get: function () { return UserResponseRelationships_1.UserResponseRelationships; } }));
var UsersResponse_1 = __webpack_require__(18577);
Object.defineProperty(exports, "UsersResponse", ({ enumerable: true, get: function () { return UsersResponse_1.UsersResponse; } }));
var UserUpdateAttributes_1 = __webpack_require__(68822);
Object.defineProperty(exports, "UserUpdateAttributes", ({ enumerable: true, get: function () { return UserUpdateAttributes_1.UserUpdateAttributes; } }));
var UserUpdateData_1 = __webpack_require__(21330);
Object.defineProperty(exports, "UserUpdateData", ({ enumerable: true, get: function () { return UserUpdateData_1.UserUpdateData; } }));
var UserUpdateRequest_1 = __webpack_require__(59906);
Object.defineProperty(exports, "UserUpdateRequest", ({ enumerable: true, get: function () { return UserUpdateRequest_1.UserUpdateRequest; } }));
var ObjectSerializer_1 = __webpack_require__(47805);
Object.defineProperty(exports, "ObjectSerializer", ({ enumerable: true, get: function () { return ObjectSerializer_1.ObjectSerializer; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 70205:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.APIErrorResponse = void 0;
/**
 * API error response.
 */
class APIErrorResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return APIErrorResponse.attributeTypeMap;
    }
}
exports.APIErrorResponse = APIErrorResponse;
/**
 * @ignore
 */
APIErrorResponse.attributeTypeMap = {
    errors: {
        baseName: "errors",
        type: "Array<string>",
        required: true,
    },
};
//# sourceMappingURL=APIErrorResponse.js.map

/***/ }),

/***/ 59524:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.APIKeyCreateAttributes = void 0;
/**
 * Attributes used to create an API Key.
 */
class APIKeyCreateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return APIKeyCreateAttributes.attributeTypeMap;
    }
}
exports.APIKeyCreateAttributes = APIKeyCreateAttributes;
/**
 * @ignore
 */
APIKeyCreateAttributes.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=APIKeyCreateAttributes.js.map

/***/ }),

/***/ 18279:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.APIKeyCreateData = void 0;
/**
 * Object used to create an API key.
 */
class APIKeyCreateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return APIKeyCreateData.attributeTypeMap;
    }
}
exports.APIKeyCreateData = APIKeyCreateData;
/**
 * @ignore
 */
APIKeyCreateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "APIKeyCreateAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "APIKeysType",
        required: true,
    },
};
//# sourceMappingURL=APIKeyCreateData.js.map

/***/ }),

/***/ 58893:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.APIKeyCreateRequest = void 0;
/**
 * Request used to create an API key.
 */
class APIKeyCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return APIKeyCreateRequest.attributeTypeMap;
    }
}
exports.APIKeyCreateRequest = APIKeyCreateRequest;
/**
 * @ignore
 */
APIKeyCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "APIKeyCreateData",
        required: true,
    },
};
//# sourceMappingURL=APIKeyCreateRequest.js.map

/***/ }),

/***/ 54551:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.APIKeyRelationships = void 0;
/**
 * Resources related to the API key.
 */
class APIKeyRelationships {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return APIKeyRelationships.attributeTypeMap;
    }
}
exports.APIKeyRelationships = APIKeyRelationships;
/**
 * @ignore
 */
APIKeyRelationships.attributeTypeMap = {
    createdBy: {
        baseName: "created_by",
        type: "RelationshipToUser",
    },
    modifiedBy: {
        baseName: "modified_by",
        type: "RelationshipToUser",
    },
};
//# sourceMappingURL=APIKeyRelationships.js.map

/***/ }),

/***/ 97531:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.APIKeyResponse = void 0;
/**
 * Response for retrieving an API key.
 */
class APIKeyResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return APIKeyResponse.attributeTypeMap;
    }
}
exports.APIKeyResponse = APIKeyResponse;
/**
 * @ignore
 */
APIKeyResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "FullAPIKey",
    },
    included: {
        baseName: "included",
        type: "Array<APIKeyResponseIncludedItem>",
    },
};
//# sourceMappingURL=APIKeyResponse.js.map

/***/ }),

/***/ 65168:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.APIKeyUpdateAttributes = void 0;
/**
 * Attributes used to update an API Key.
 */
class APIKeyUpdateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return APIKeyUpdateAttributes.attributeTypeMap;
    }
}
exports.APIKeyUpdateAttributes = APIKeyUpdateAttributes;
/**
 * @ignore
 */
APIKeyUpdateAttributes.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=APIKeyUpdateAttributes.js.map

/***/ }),

/***/ 51292:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.APIKeyUpdateData = void 0;
/**
 * Object used to update an API key.
 */
class APIKeyUpdateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return APIKeyUpdateData.attributeTypeMap;
    }
}
exports.APIKeyUpdateData = APIKeyUpdateData;
/**
 * @ignore
 */
APIKeyUpdateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "APIKeyUpdateAttributes",
        required: true,
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "APIKeysType",
        required: true,
    },
};
//# sourceMappingURL=APIKeyUpdateData.js.map

/***/ }),

/***/ 20585:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.APIKeyUpdateRequest = void 0;
/**
 * Request used to update an API key.
 */
class APIKeyUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return APIKeyUpdateRequest.attributeTypeMap;
    }
}
exports.APIKeyUpdateRequest = APIKeyUpdateRequest;
/**
 * @ignore
 */
APIKeyUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "APIKeyUpdateData",
        required: true,
    },
};
//# sourceMappingURL=APIKeyUpdateRequest.js.map

/***/ }),

/***/ 13214:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.APIKeysResponse = void 0;
/**
 * Response for a list of API keys.
 */
class APIKeysResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return APIKeysResponse.attributeTypeMap;
    }
}
exports.APIKeysResponse = APIKeysResponse;
/**
 * @ignore
 */
APIKeysResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<PartialAPIKey>",
    },
    included: {
        baseName: "included",
        type: "Array<APIKeyResponseIncludedItem>",
    },
};
//# sourceMappingURL=APIKeysResponse.js.map

/***/ }),

/***/ 71500:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApplicationKeyCreateAttributes = void 0;
/**
 * Attributes used to create an application Key.
 */
class ApplicationKeyCreateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ApplicationKeyCreateAttributes.attributeTypeMap;
    }
}
exports.ApplicationKeyCreateAttributes = ApplicationKeyCreateAttributes;
/**
 * @ignore
 */
ApplicationKeyCreateAttributes.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    scopes: {
        baseName: "scopes",
        type: "Array<string>",
    },
};
//# sourceMappingURL=ApplicationKeyCreateAttributes.js.map

/***/ }),

/***/ 39673:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApplicationKeyCreateData = void 0;
/**
 * Object used to create an application key.
 */
class ApplicationKeyCreateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ApplicationKeyCreateData.attributeTypeMap;
    }
}
exports.ApplicationKeyCreateData = ApplicationKeyCreateData;
/**
 * @ignore
 */
ApplicationKeyCreateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "ApplicationKeyCreateAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "ApplicationKeysType",
        required: true,
    },
};
//# sourceMappingURL=ApplicationKeyCreateData.js.map

/***/ }),

/***/ 89736:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApplicationKeyCreateRequest = void 0;
/**
 * Request used to create an application key.
 */
class ApplicationKeyCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ApplicationKeyCreateRequest.attributeTypeMap;
    }
}
exports.ApplicationKeyCreateRequest = ApplicationKeyCreateRequest;
/**
 * @ignore
 */
ApplicationKeyCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "ApplicationKeyCreateData",
        required: true,
    },
};
//# sourceMappingURL=ApplicationKeyCreateRequest.js.map

/***/ }),

/***/ 65634:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApplicationKeyRelationships = void 0;
/**
 * Resources related to the application key.
 */
class ApplicationKeyRelationships {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ApplicationKeyRelationships.attributeTypeMap;
    }
}
exports.ApplicationKeyRelationships = ApplicationKeyRelationships;
/**
 * @ignore
 */
ApplicationKeyRelationships.attributeTypeMap = {
    ownedBy: {
        baseName: "owned_by",
        type: "RelationshipToUser",
    },
};
//# sourceMappingURL=ApplicationKeyRelationships.js.map

/***/ }),

/***/ 73297:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApplicationKeyResponse = void 0;
/**
 * Response for retrieving an application key.
 */
class ApplicationKeyResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ApplicationKeyResponse.attributeTypeMap;
    }
}
exports.ApplicationKeyResponse = ApplicationKeyResponse;
/**
 * @ignore
 */
ApplicationKeyResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "FullApplicationKey",
    },
    included: {
        baseName: "included",
        type: "Array<ApplicationKeyResponseIncludedItem>",
    },
};
//# sourceMappingURL=ApplicationKeyResponse.js.map

/***/ }),

/***/ 38052:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApplicationKeyUpdateAttributes = void 0;
/**
 * Attributes used to update an application Key.
 */
class ApplicationKeyUpdateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ApplicationKeyUpdateAttributes.attributeTypeMap;
    }
}
exports.ApplicationKeyUpdateAttributes = ApplicationKeyUpdateAttributes;
/**
 * @ignore
 */
ApplicationKeyUpdateAttributes.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
    },
    scopes: {
        baseName: "scopes",
        type: "Array<string>",
    },
};
//# sourceMappingURL=ApplicationKeyUpdateAttributes.js.map

/***/ }),

/***/ 3655:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApplicationKeyUpdateData = void 0;
/**
 * Object used to update an application key.
 */
class ApplicationKeyUpdateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ApplicationKeyUpdateData.attributeTypeMap;
    }
}
exports.ApplicationKeyUpdateData = ApplicationKeyUpdateData;
/**
 * @ignore
 */
ApplicationKeyUpdateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "ApplicationKeyUpdateAttributes",
        required: true,
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "ApplicationKeysType",
        required: true,
    },
};
//# sourceMappingURL=ApplicationKeyUpdateData.js.map

/***/ }),

/***/ 19103:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApplicationKeyUpdateRequest = void 0;
/**
 * Request used to update an application key.
 */
class ApplicationKeyUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ApplicationKeyUpdateRequest.attributeTypeMap;
    }
}
exports.ApplicationKeyUpdateRequest = ApplicationKeyUpdateRequest;
/**
 * @ignore
 */
ApplicationKeyUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "ApplicationKeyUpdateData",
        required: true,
    },
};
//# sourceMappingURL=ApplicationKeyUpdateRequest.js.map

/***/ }),

/***/ 30095:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuditLogsEvent = void 0;
/**
 * Object description of an Audit Logs event after it is processed and stored by Datadog.
 */
class AuditLogsEvent {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuditLogsEvent.attributeTypeMap;
    }
}
exports.AuditLogsEvent = AuditLogsEvent;
/**
 * @ignore
 */
AuditLogsEvent.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "AuditLogsEventAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "AuditLogsEventType",
    },
};
//# sourceMappingURL=AuditLogsEvent.js.map

/***/ }),

/***/ 52083:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuditLogsEventAttributes = void 0;
/**
 * JSON object containing all event attributes and their associated values.
 */
class AuditLogsEventAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuditLogsEventAttributes.attributeTypeMap;
    }
}
exports.AuditLogsEventAttributes = AuditLogsEventAttributes;
/**
 * @ignore
 */
AuditLogsEventAttributes.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "{ [key: string]: any; }",
    },
    service: {
        baseName: "service",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    timestamp: {
        baseName: "timestamp",
        type: "Date",
        format: "date-time",
    },
};
//# sourceMappingURL=AuditLogsEventAttributes.js.map

/***/ }),

/***/ 64297:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuditLogsEventsResponse = void 0;
/**
 * Response object with all events matching the request and pagination information.
 */
class AuditLogsEventsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuditLogsEventsResponse.attributeTypeMap;
    }
}
exports.AuditLogsEventsResponse = AuditLogsEventsResponse;
/**
 * @ignore
 */
AuditLogsEventsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<AuditLogsEvent>",
    },
    links: {
        baseName: "links",
        type: "AuditLogsResponseLinks",
    },
    meta: {
        baseName: "meta",
        type: "AuditLogsResponseMetadata",
    },
};
//# sourceMappingURL=AuditLogsEventsResponse.js.map

/***/ }),

/***/ 22659:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuditLogsQueryFilter = void 0;
/**
 * Search and filter query settings.
 */
class AuditLogsQueryFilter {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuditLogsQueryFilter.attributeTypeMap;
    }
}
exports.AuditLogsQueryFilter = AuditLogsQueryFilter;
/**
 * @ignore
 */
AuditLogsQueryFilter.attributeTypeMap = {
    from: {
        baseName: "from",
        type: "string",
    },
    query: {
        baseName: "query",
        type: "string",
    },
    to: {
        baseName: "to",
        type: "string",
    },
};
//# sourceMappingURL=AuditLogsQueryFilter.js.map

/***/ }),

/***/ 68991:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuditLogsQueryOptions = void 0;
/**
 * Global query options that are used during the query.
 * Note: Specify either timezone or time offset, not both. Otherwise, the query fails.
 */
class AuditLogsQueryOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuditLogsQueryOptions.attributeTypeMap;
    }
}
exports.AuditLogsQueryOptions = AuditLogsQueryOptions;
/**
 * @ignore
 */
AuditLogsQueryOptions.attributeTypeMap = {
    timeOffset: {
        baseName: "time_offset",
        type: "number",
        format: "int64",
    },
    timezone: {
        baseName: "timezone",
        type: "string",
    },
};
//# sourceMappingURL=AuditLogsQueryOptions.js.map

/***/ }),

/***/ 46706:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuditLogsQueryPageOptions = void 0;
/**
 * Paging attributes for listing events.
 */
class AuditLogsQueryPageOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuditLogsQueryPageOptions.attributeTypeMap;
    }
}
exports.AuditLogsQueryPageOptions = AuditLogsQueryPageOptions;
/**
 * @ignore
 */
AuditLogsQueryPageOptions.attributeTypeMap = {
    cursor: {
        baseName: "cursor",
        type: "string",
    },
    limit: {
        baseName: "limit",
        type: "number",
        format: "int32",
    },
};
//# sourceMappingURL=AuditLogsQueryPageOptions.js.map

/***/ }),

/***/ 67454:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuditLogsResponseLinks = void 0;
/**
 * Links attributes.
 */
class AuditLogsResponseLinks {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuditLogsResponseLinks.attributeTypeMap;
    }
}
exports.AuditLogsResponseLinks = AuditLogsResponseLinks;
/**
 * @ignore
 */
AuditLogsResponseLinks.attributeTypeMap = {
    next: {
        baseName: "next",
        type: "string",
    },
};
//# sourceMappingURL=AuditLogsResponseLinks.js.map

/***/ }),

/***/ 41903:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuditLogsResponseMetadata = void 0;
/**
 * The metadata associated with a request.
 */
class AuditLogsResponseMetadata {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuditLogsResponseMetadata.attributeTypeMap;
    }
}
exports.AuditLogsResponseMetadata = AuditLogsResponseMetadata;
/**
 * @ignore
 */
AuditLogsResponseMetadata.attributeTypeMap = {
    elapsed: {
        baseName: "elapsed",
        type: "number",
        format: "int64",
    },
    page: {
        baseName: "page",
        type: "AuditLogsResponsePage",
    },
    requestId: {
        baseName: "request_id",
        type: "string",
    },
    status: {
        baseName: "status",
        type: "AuditLogsResponseStatus",
    },
    warnings: {
        baseName: "warnings",
        type: "Array<AuditLogsWarning>",
    },
};
//# sourceMappingURL=AuditLogsResponseMetadata.js.map

/***/ }),

/***/ 4131:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuditLogsResponsePage = void 0;
/**
 * Paging attributes.
 */
class AuditLogsResponsePage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuditLogsResponsePage.attributeTypeMap;
    }
}
exports.AuditLogsResponsePage = AuditLogsResponsePage;
/**
 * @ignore
 */
AuditLogsResponsePage.attributeTypeMap = {
    after: {
        baseName: "after",
        type: "string",
    },
};
//# sourceMappingURL=AuditLogsResponsePage.js.map

/***/ }),

/***/ 52614:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuditLogsSearchEventsRequest = void 0;
/**
 * The request for a Audit Logs events list.
 */
class AuditLogsSearchEventsRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuditLogsSearchEventsRequest.attributeTypeMap;
    }
}
exports.AuditLogsSearchEventsRequest = AuditLogsSearchEventsRequest;
/**
 * @ignore
 */
AuditLogsSearchEventsRequest.attributeTypeMap = {
    filter: {
        baseName: "filter",
        type: "AuditLogsQueryFilter",
    },
    options: {
        baseName: "options",
        type: "AuditLogsQueryOptions",
    },
    page: {
        baseName: "page",
        type: "AuditLogsQueryPageOptions",
    },
    sort: {
        baseName: "sort",
        type: "AuditLogsSort",
    },
};
//# sourceMappingURL=AuditLogsSearchEventsRequest.js.map

/***/ }),

/***/ 28817:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuditLogsWarning = void 0;
/**
 * Warning message indicating something that went wrong with the query.
 */
class AuditLogsWarning {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuditLogsWarning.attributeTypeMap;
    }
}
exports.AuditLogsWarning = AuditLogsWarning;
/**
 * @ignore
 */
AuditLogsWarning.attributeTypeMap = {
    code: {
        baseName: "code",
        type: "string",
    },
    detail: {
        baseName: "detail",
        type: "string",
    },
    title: {
        baseName: "title",
        type: "string",
    },
};
//# sourceMappingURL=AuditLogsWarning.js.map

/***/ }),

/***/ 80723:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthNMapping = void 0;
/**
 * The AuthN Mapping object returned by API.
 */
class AuthNMapping {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuthNMapping.attributeTypeMap;
    }
}
exports.AuthNMapping = AuthNMapping;
/**
 * @ignore
 */
AuthNMapping.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "AuthNMappingAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    relationships: {
        baseName: "relationships",
        type: "AuthNMappingRelationships",
    },
    type: {
        baseName: "type",
        type: "AuthNMappingsType",
        required: true,
    },
};
//# sourceMappingURL=AuthNMapping.js.map

/***/ }),

/***/ 70543:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthNMappingAttributes = void 0;
/**
 * Attributes of AuthN Mapping.
 */
class AuthNMappingAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuthNMappingAttributes.attributeTypeMap;
    }
}
exports.AuthNMappingAttributes = AuthNMappingAttributes;
/**
 * @ignore
 */
AuthNMappingAttributes.attributeTypeMap = {
    attributeKey: {
        baseName: "attribute_key",
        type: "string",
    },
    attributeValue: {
        baseName: "attribute_value",
        type: "string",
    },
    createdAt: {
        baseName: "created_at",
        type: "Date",
        format: "date-time",
    },
    modifiedAt: {
        baseName: "modified_at",
        type: "Date",
        format: "date-time",
    },
    samlAssertionAttributeId: {
        baseName: "saml_assertion_attribute_id",
        type: "string",
    },
};
//# sourceMappingURL=AuthNMappingAttributes.js.map

/***/ }),

/***/ 47073:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthNMappingCreateAttributes = void 0;
/**
 * Key/Value pair of attributes used for create request.
 */
class AuthNMappingCreateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuthNMappingCreateAttributes.attributeTypeMap;
    }
}
exports.AuthNMappingCreateAttributes = AuthNMappingCreateAttributes;
/**
 * @ignore
 */
AuthNMappingCreateAttributes.attributeTypeMap = {
    attributeKey: {
        baseName: "attribute_key",
        type: "string",
    },
    attributeValue: {
        baseName: "attribute_value",
        type: "string",
    },
};
//# sourceMappingURL=AuthNMappingCreateAttributes.js.map

/***/ }),

/***/ 2847:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthNMappingCreateData = void 0;
/**
 * Data for creating an AuthN Mapping.
 */
class AuthNMappingCreateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuthNMappingCreateData.attributeTypeMap;
    }
}
exports.AuthNMappingCreateData = AuthNMappingCreateData;
/**
 * @ignore
 */
AuthNMappingCreateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "AuthNMappingCreateAttributes",
    },
    relationships: {
        baseName: "relationships",
        type: "AuthNMappingCreateRelationships",
    },
    type: {
        baseName: "type",
        type: "AuthNMappingsType",
        required: true,
    },
};
//# sourceMappingURL=AuthNMappingCreateData.js.map

/***/ }),

/***/ 20943:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthNMappingCreateRelationships = void 0;
/**
 * Relationship of AuthN Mapping create object to Role.
 */
class AuthNMappingCreateRelationships {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuthNMappingCreateRelationships.attributeTypeMap;
    }
}
exports.AuthNMappingCreateRelationships = AuthNMappingCreateRelationships;
/**
 * @ignore
 */
AuthNMappingCreateRelationships.attributeTypeMap = {
    role: {
        baseName: "role",
        type: "RelationshipToRole",
    },
};
//# sourceMappingURL=AuthNMappingCreateRelationships.js.map

/***/ }),

/***/ 32773:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthNMappingCreateRequest = void 0;
/**
 * Request for creating an AuthN Mapping.
 */
class AuthNMappingCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuthNMappingCreateRequest.attributeTypeMap;
    }
}
exports.AuthNMappingCreateRequest = AuthNMappingCreateRequest;
/**
 * @ignore
 */
AuthNMappingCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "AuthNMappingCreateData",
        required: true,
    },
};
//# sourceMappingURL=AuthNMappingCreateRequest.js.map

/***/ }),

/***/ 17587:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthNMappingRelationships = void 0;
/**
 * All relationships associated with AuthN Mapping.
 */
class AuthNMappingRelationships {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuthNMappingRelationships.attributeTypeMap;
    }
}
exports.AuthNMappingRelationships = AuthNMappingRelationships;
/**
 * @ignore
 */
AuthNMappingRelationships.attributeTypeMap = {
    role: {
        baseName: "role",
        type: "RelationshipToRole",
    },
    samlAssertionAttribute: {
        baseName: "saml_assertion_attribute",
        type: "RelationshipToSAMLAssertionAttribute",
    },
};
//# sourceMappingURL=AuthNMappingRelationships.js.map

/***/ }),

/***/ 60064:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthNMappingResponse = void 0;
/**
 * AuthN Mapping response from the API.
 */
class AuthNMappingResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuthNMappingResponse.attributeTypeMap;
    }
}
exports.AuthNMappingResponse = AuthNMappingResponse;
/**
 * @ignore
 */
AuthNMappingResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "AuthNMapping",
    },
    included: {
        baseName: "included",
        type: "Array<AuthNMappingIncluded>",
    },
};
//# sourceMappingURL=AuthNMappingResponse.js.map

/***/ }),

/***/ 61653:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthNMappingUpdateAttributes = void 0;
/**
 * Key/Value pair of attributes used for update request.
 */
class AuthNMappingUpdateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuthNMappingUpdateAttributes.attributeTypeMap;
    }
}
exports.AuthNMappingUpdateAttributes = AuthNMappingUpdateAttributes;
/**
 * @ignore
 */
AuthNMappingUpdateAttributes.attributeTypeMap = {
    attributeKey: {
        baseName: "attribute_key",
        type: "string",
    },
    attributeValue: {
        baseName: "attribute_value",
        type: "string",
    },
};
//# sourceMappingURL=AuthNMappingUpdateAttributes.js.map

/***/ }),

/***/ 98430:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthNMappingUpdateData = void 0;
/**
 * Data for updating an AuthN Mapping.
 */
class AuthNMappingUpdateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuthNMappingUpdateData.attributeTypeMap;
    }
}
exports.AuthNMappingUpdateData = AuthNMappingUpdateData;
/**
 * @ignore
 */
AuthNMappingUpdateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "AuthNMappingUpdateAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    relationships: {
        baseName: "relationships",
        type: "AuthNMappingUpdateRelationships",
    },
    type: {
        baseName: "type",
        type: "AuthNMappingsType",
        required: true,
    },
};
//# sourceMappingURL=AuthNMappingUpdateData.js.map

/***/ }),

/***/ 39731:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthNMappingUpdateRelationships = void 0;
/**
 * Relationship of AuthN Mapping update object to Role.
 */
class AuthNMappingUpdateRelationships {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuthNMappingUpdateRelationships.attributeTypeMap;
    }
}
exports.AuthNMappingUpdateRelationships = AuthNMappingUpdateRelationships;
/**
 * @ignore
 */
AuthNMappingUpdateRelationships.attributeTypeMap = {
    role: {
        baseName: "role",
        type: "RelationshipToRole",
    },
};
//# sourceMappingURL=AuthNMappingUpdateRelationships.js.map

/***/ }),

/***/ 18093:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthNMappingUpdateRequest = void 0;
/**
 * Request to update an AuthN Mapping.
 */
class AuthNMappingUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuthNMappingUpdateRequest.attributeTypeMap;
    }
}
exports.AuthNMappingUpdateRequest = AuthNMappingUpdateRequest;
/**
 * @ignore
 */
AuthNMappingUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "AuthNMappingUpdateData",
        required: true,
    },
};
//# sourceMappingURL=AuthNMappingUpdateRequest.js.map

/***/ }),

/***/ 18439:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthNMappingsResponse = void 0;
/**
 * Array of AuthN Mappings response.
 */
class AuthNMappingsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return AuthNMappingsResponse.attributeTypeMap;
    }
}
exports.AuthNMappingsResponse = AuthNMappingsResponse;
/**
 * @ignore
 */
AuthNMappingsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<AuthNMapping>",
    },
    included: {
        baseName: "included",
        type: "Array<AuthNMappingIncluded>",
    },
    meta: {
        baseName: "meta",
        type: "ResponseMetaAttributes",
    },
};
//# sourceMappingURL=AuthNMappingsResponse.js.map

/***/ }),

/***/ 86227:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppAggregateBucketValueTimeseriesPoint = void 0;
/**
 * A timeseries point.
 */
class CIAppAggregateBucketValueTimeseriesPoint {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppAggregateBucketValueTimeseriesPoint.attributeTypeMap;
    }
}
exports.CIAppAggregateBucketValueTimeseriesPoint = CIAppAggregateBucketValueTimeseriesPoint;
/**
 * @ignore
 */
CIAppAggregateBucketValueTimeseriesPoint.attributeTypeMap = {
    time: {
        baseName: "time",
        type: "Date",
        format: "date-time",
    },
    value: {
        baseName: "value",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=CIAppAggregateBucketValueTimeseriesPoint.js.map

/***/ }),

/***/ 13896:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppAggregateSort = void 0;
/**
 * A sort rule.
 */
class CIAppAggregateSort {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppAggregateSort.attributeTypeMap;
    }
}
exports.CIAppAggregateSort = CIAppAggregateSort;
/**
 * @ignore
 */
CIAppAggregateSort.attributeTypeMap = {
    aggregation: {
        baseName: "aggregation",
        type: "CIAppAggregationFunction",
    },
    metric: {
        baseName: "metric",
        type: "string",
    },
    order: {
        baseName: "order",
        type: "CIAppSortOrder",
    },
    type: {
        baseName: "type",
        type: "CIAppAggregateSortType",
    },
};
//# sourceMappingURL=CIAppAggregateSort.js.map

/***/ }),

/***/ 5294:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppCompute = void 0;
/**
 * A compute rule to compute metrics or timeseries.
 */
class CIAppCompute {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppCompute.attributeTypeMap;
    }
}
exports.CIAppCompute = CIAppCompute;
/**
 * @ignore
 */
CIAppCompute.attributeTypeMap = {
    aggregation: {
        baseName: "aggregation",
        type: "CIAppAggregationFunction",
        required: true,
    },
    interval: {
        baseName: "interval",
        type: "string",
    },
    metric: {
        baseName: "metric",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "CIAppComputeType",
    },
};
//# sourceMappingURL=CIAppCompute.js.map

/***/ }),

/***/ 5795:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppEventAttributes = void 0;
/**
 * JSON object containing all event attributes and their associated values.
 */
class CIAppEventAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppEventAttributes.attributeTypeMap;
    }
}
exports.CIAppEventAttributes = CIAppEventAttributes;
/**
 * @ignore
 */
CIAppEventAttributes.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "{ [key: string]: any; }",
    },
    service: {
        baseName: "service",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    timestamp: {
        baseName: "timestamp",
        type: "Date",
        format: "date-time",
    },
};
//# sourceMappingURL=CIAppEventAttributes.js.map

/***/ }),

/***/ 84337:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppGroupByHistogram = void 0;
/**
 * Used to perform a histogram computation (only for measure facets).
 * At most, 100 buckets are allowed, the number of buckets is `(max - min)/interval`.
 */
class CIAppGroupByHistogram {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppGroupByHistogram.attributeTypeMap;
    }
}
exports.CIAppGroupByHistogram = CIAppGroupByHistogram;
/**
 * @ignore
 */
CIAppGroupByHistogram.attributeTypeMap = {
    interval: {
        baseName: "interval",
        type: "number",
        required: true,
        format: "double",
    },
    max: {
        baseName: "max",
        type: "number",
        required: true,
        format: "double",
    },
    min: {
        baseName: "min",
        type: "number",
        required: true,
        format: "double",
    },
};
//# sourceMappingURL=CIAppGroupByHistogram.js.map

/***/ }),

/***/ 92629:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppPipelineEvent = void 0;
/**
 * Object description of a pipeline event after being processed and stored by Datadog.
 */
class CIAppPipelineEvent {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppPipelineEvent.attributeTypeMap;
    }
}
exports.CIAppPipelineEvent = CIAppPipelineEvent;
/**
 * @ignore
 */
CIAppPipelineEvent.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "CIAppEventAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "CIAppPipelineEventTypeName",
    },
};
//# sourceMappingURL=CIAppPipelineEvent.js.map

/***/ }),

/***/ 7634:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppPipelineEventsRequest = void 0;
/**
 * The request for a pipelines search.
 */
class CIAppPipelineEventsRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppPipelineEventsRequest.attributeTypeMap;
    }
}
exports.CIAppPipelineEventsRequest = CIAppPipelineEventsRequest;
/**
 * @ignore
 */
CIAppPipelineEventsRequest.attributeTypeMap = {
    filter: {
        baseName: "filter",
        type: "CIAppPipelinesQueryFilter",
    },
    options: {
        baseName: "options",
        type: "CIAppQueryOptions",
    },
    page: {
        baseName: "page",
        type: "CIAppQueryPageOptions",
    },
    sort: {
        baseName: "sort",
        type: "CIAppSort",
    },
};
//# sourceMappingURL=CIAppPipelineEventsRequest.js.map

/***/ }),

/***/ 81393:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppPipelineEventsResponse = void 0;
/**
 * Response object with all pipeline events matching the request and pagination information.
 */
class CIAppPipelineEventsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppPipelineEventsResponse.attributeTypeMap;
    }
}
exports.CIAppPipelineEventsResponse = CIAppPipelineEventsResponse;
/**
 * @ignore
 */
CIAppPipelineEventsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<CIAppPipelineEvent>",
    },
    links: {
        baseName: "links",
        type: "CIAppResponseLinks",
    },
    meta: {
        baseName: "meta",
        type: "CIAppResponseMetadataWithPagination",
    },
};
//# sourceMappingURL=CIAppPipelineEventsResponse.js.map

/***/ }),

/***/ 9879:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppPipelinesAggregateRequest = void 0;
/**
 * The object sent with the request to retrieve aggregation buckets of pipeline events from your organization.
 */
class CIAppPipelinesAggregateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppPipelinesAggregateRequest.attributeTypeMap;
    }
}
exports.CIAppPipelinesAggregateRequest = CIAppPipelinesAggregateRequest;
/**
 * @ignore
 */
CIAppPipelinesAggregateRequest.attributeTypeMap = {
    compute: {
        baseName: "compute",
        type: "Array<CIAppCompute>",
    },
    filter: {
        baseName: "filter",
        type: "CIAppPipelinesQueryFilter",
    },
    groupBy: {
        baseName: "group_by",
        type: "Array<CIAppPipelinesGroupBy>",
    },
    options: {
        baseName: "options",
        type: "CIAppQueryOptions",
    },
};
//# sourceMappingURL=CIAppPipelinesAggregateRequest.js.map

/***/ }),

/***/ 48758:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppPipelinesAggregationBucketsResponse = void 0;
/**
 * The query results.
 */
class CIAppPipelinesAggregationBucketsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppPipelinesAggregationBucketsResponse.attributeTypeMap;
    }
}
exports.CIAppPipelinesAggregationBucketsResponse = CIAppPipelinesAggregationBucketsResponse;
/**
 * @ignore
 */
CIAppPipelinesAggregationBucketsResponse.attributeTypeMap = {
    buckets: {
        baseName: "buckets",
        type: "Array<CIAppPipelinesBucketResponse>",
    },
};
//# sourceMappingURL=CIAppPipelinesAggregationBucketsResponse.js.map

/***/ }),

/***/ 92621:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppPipelinesAnalyticsAggregateResponse = void 0;
/**
 * The response object for the pipeline events aggregate API endpoint.
 */
class CIAppPipelinesAnalyticsAggregateResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppPipelinesAnalyticsAggregateResponse.attributeTypeMap;
    }
}
exports.CIAppPipelinesAnalyticsAggregateResponse = CIAppPipelinesAnalyticsAggregateResponse;
/**
 * @ignore
 */
CIAppPipelinesAnalyticsAggregateResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "CIAppPipelinesAggregationBucketsResponse",
    },
    links: {
        baseName: "links",
        type: "CIAppResponseLinks",
    },
    meta: {
        baseName: "meta",
        type: "CIAppResponseMetadata",
    },
};
//# sourceMappingURL=CIAppPipelinesAnalyticsAggregateResponse.js.map

/***/ }),

/***/ 61408:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppPipelinesBucketResponse = void 0;
/**
 * Bucket values.
 */
class CIAppPipelinesBucketResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppPipelinesBucketResponse.attributeTypeMap;
    }
}
exports.CIAppPipelinesBucketResponse = CIAppPipelinesBucketResponse;
/**
 * @ignore
 */
CIAppPipelinesBucketResponse.attributeTypeMap = {
    by: {
        baseName: "by",
        type: "{ [key: string]: any; }",
    },
    computes: {
        baseName: "computes",
        type: "{ [key: string]: CIAppAggregateBucketValue; }",
    },
};
//# sourceMappingURL=CIAppPipelinesBucketResponse.js.map

/***/ }),

/***/ 89633:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppPipelinesGroupBy = void 0;
/**
 * A group-by rule.
 */
class CIAppPipelinesGroupBy {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppPipelinesGroupBy.attributeTypeMap;
    }
}
exports.CIAppPipelinesGroupBy = CIAppPipelinesGroupBy;
/**
 * @ignore
 */
CIAppPipelinesGroupBy.attributeTypeMap = {
    facet: {
        baseName: "facet",
        type: "string",
        required: true,
    },
    histogram: {
        baseName: "histogram",
        type: "CIAppGroupByHistogram",
    },
    limit: {
        baseName: "limit",
        type: "number",
        format: "int64",
    },
    missing: {
        baseName: "missing",
        type: "CIAppGroupByMissing",
    },
    sort: {
        baseName: "sort",
        type: "CIAppAggregateSort",
    },
    total: {
        baseName: "total",
        type: "CIAppGroupByTotal",
    },
};
//# sourceMappingURL=CIAppPipelinesGroupBy.js.map

/***/ }),

/***/ 2272:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppPipelinesQueryFilter = void 0;
/**
 * The search and filter query settings.
 */
class CIAppPipelinesQueryFilter {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppPipelinesQueryFilter.attributeTypeMap;
    }
}
exports.CIAppPipelinesQueryFilter = CIAppPipelinesQueryFilter;
/**
 * @ignore
 */
CIAppPipelinesQueryFilter.attributeTypeMap = {
    from: {
        baseName: "from",
        type: "string",
    },
    query: {
        baseName: "query",
        type: "string",
    },
    to: {
        baseName: "to",
        type: "string",
    },
};
//# sourceMappingURL=CIAppPipelinesQueryFilter.js.map

/***/ }),

/***/ 58517:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppQueryOptions = void 0;
/**
 * Global query options that are used during the query.
 * Only supply timezone or time offset, not both. Otherwise, the query fails.
 */
class CIAppQueryOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppQueryOptions.attributeTypeMap;
    }
}
exports.CIAppQueryOptions = CIAppQueryOptions;
/**
 * @ignore
 */
CIAppQueryOptions.attributeTypeMap = {
    timeOffset: {
        baseName: "time_offset",
        type: "number",
        format: "int64",
    },
    timezone: {
        baseName: "timezone",
        type: "string",
    },
};
//# sourceMappingURL=CIAppQueryOptions.js.map

/***/ }),

/***/ 89457:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppQueryPageOptions = void 0;
/**
 * Paging attributes for listing events.
 */
class CIAppQueryPageOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppQueryPageOptions.attributeTypeMap;
    }
}
exports.CIAppQueryPageOptions = CIAppQueryPageOptions;
/**
 * @ignore
 */
CIAppQueryPageOptions.attributeTypeMap = {
    cursor: {
        baseName: "cursor",
        type: "string",
    },
    limit: {
        baseName: "limit",
        type: "number",
        format: "int32",
    },
};
//# sourceMappingURL=CIAppQueryPageOptions.js.map

/***/ }),

/***/ 49266:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppResponseLinks = void 0;
/**
 * Links attributes.
 */
class CIAppResponseLinks {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppResponseLinks.attributeTypeMap;
    }
}
exports.CIAppResponseLinks = CIAppResponseLinks;
/**
 * @ignore
 */
CIAppResponseLinks.attributeTypeMap = {
    next: {
        baseName: "next",
        type: "string",
    },
};
//# sourceMappingURL=CIAppResponseLinks.js.map

/***/ }),

/***/ 89609:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppResponseMetadata = void 0;
/**
 * The metadata associated with a request.
 */
class CIAppResponseMetadata {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppResponseMetadata.attributeTypeMap;
    }
}
exports.CIAppResponseMetadata = CIAppResponseMetadata;
/**
 * @ignore
 */
CIAppResponseMetadata.attributeTypeMap = {
    elapsed: {
        baseName: "elapsed",
        type: "number",
        format: "int64",
    },
    requestId: {
        baseName: "request_id",
        type: "string",
    },
    status: {
        baseName: "status",
        type: "CIAppResponseStatus",
    },
    warnings: {
        baseName: "warnings",
        type: "Array<CIAppWarning>",
    },
};
//# sourceMappingURL=CIAppResponseMetadata.js.map

/***/ }),

/***/ 82475:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppResponseMetadataWithPagination = void 0;
/**
 * The metadata associated with a request.
 */
class CIAppResponseMetadataWithPagination {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppResponseMetadataWithPagination.attributeTypeMap;
    }
}
exports.CIAppResponseMetadataWithPagination = CIAppResponseMetadataWithPagination;
/**
 * @ignore
 */
CIAppResponseMetadataWithPagination.attributeTypeMap = {
    elapsed: {
        baseName: "elapsed",
        type: "number",
        format: "int64",
    },
    page: {
        baseName: "page",
        type: "CIAppResponsePage",
    },
    requestId: {
        baseName: "request_id",
        type: "string",
    },
    status: {
        baseName: "status",
        type: "CIAppResponseStatus",
    },
    warnings: {
        baseName: "warnings",
        type: "Array<CIAppWarning>",
    },
};
//# sourceMappingURL=CIAppResponseMetadataWithPagination.js.map

/***/ }),

/***/ 34502:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppResponsePage = void 0;
/**
 * Paging attributes.
 */
class CIAppResponsePage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppResponsePage.attributeTypeMap;
    }
}
exports.CIAppResponsePage = CIAppResponsePage;
/**
 * @ignore
 */
CIAppResponsePage.attributeTypeMap = {
    after: {
        baseName: "after",
        type: "string",
    },
};
//# sourceMappingURL=CIAppResponsePage.js.map

/***/ }),

/***/ 38943:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppTestEvent = void 0;
/**
 * Object description of test event after being processed and stored by Datadog.
 */
class CIAppTestEvent {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppTestEvent.attributeTypeMap;
    }
}
exports.CIAppTestEvent = CIAppTestEvent;
/**
 * @ignore
 */
CIAppTestEvent.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "CIAppEventAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "CIAppTestEventTypeName",
    },
};
//# sourceMappingURL=CIAppTestEvent.js.map

/***/ }),

/***/ 94731:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppTestEventsRequest = void 0;
/**
 * The request for a tests search.
 */
class CIAppTestEventsRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppTestEventsRequest.attributeTypeMap;
    }
}
exports.CIAppTestEventsRequest = CIAppTestEventsRequest;
/**
 * @ignore
 */
CIAppTestEventsRequest.attributeTypeMap = {
    filter: {
        baseName: "filter",
        type: "CIAppTestsQueryFilter",
    },
    options: {
        baseName: "options",
        type: "CIAppQueryOptions",
    },
    page: {
        baseName: "page",
        type: "CIAppQueryPageOptions",
    },
    sort: {
        baseName: "sort",
        type: "CIAppSort",
    },
};
//# sourceMappingURL=CIAppTestEventsRequest.js.map

/***/ }),

/***/ 12138:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppTestEventsResponse = void 0;
/**
 * Response object with all test events matching the request and pagination information.
 */
class CIAppTestEventsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppTestEventsResponse.attributeTypeMap;
    }
}
exports.CIAppTestEventsResponse = CIAppTestEventsResponse;
/**
 * @ignore
 */
CIAppTestEventsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<CIAppTestEvent>",
    },
    links: {
        baseName: "links",
        type: "CIAppResponseLinks",
    },
    meta: {
        baseName: "meta",
        type: "CIAppResponseMetadataWithPagination",
    },
};
//# sourceMappingURL=CIAppTestEventsResponse.js.map

/***/ }),

/***/ 3854:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppTestsAggregateRequest = void 0;
/**
 * The object sent with the request to retrieve aggregation buckets of test events from your organization.
 */
class CIAppTestsAggregateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppTestsAggregateRequest.attributeTypeMap;
    }
}
exports.CIAppTestsAggregateRequest = CIAppTestsAggregateRequest;
/**
 * @ignore
 */
CIAppTestsAggregateRequest.attributeTypeMap = {
    compute: {
        baseName: "compute",
        type: "Array<CIAppCompute>",
    },
    filter: {
        baseName: "filter",
        type: "CIAppTestsQueryFilter",
    },
    groupBy: {
        baseName: "group_by",
        type: "Array<CIAppTestsGroupBy>",
    },
    options: {
        baseName: "options",
        type: "CIAppQueryOptions",
    },
};
//# sourceMappingURL=CIAppTestsAggregateRequest.js.map

/***/ }),

/***/ 64466:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppTestsAggregationBucketsResponse = void 0;
/**
 * The query results.
 */
class CIAppTestsAggregationBucketsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppTestsAggregationBucketsResponse.attributeTypeMap;
    }
}
exports.CIAppTestsAggregationBucketsResponse = CIAppTestsAggregationBucketsResponse;
/**
 * @ignore
 */
CIAppTestsAggregationBucketsResponse.attributeTypeMap = {
    buckets: {
        baseName: "buckets",
        type: "Array<CIAppTestsBucketResponse>",
    },
};
//# sourceMappingURL=CIAppTestsAggregationBucketsResponse.js.map

/***/ }),

/***/ 17669:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppTestsAnalyticsAggregateResponse = void 0;
/**
 * The response object for the test events aggregate API endpoint.
 */
class CIAppTestsAnalyticsAggregateResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppTestsAnalyticsAggregateResponse.attributeTypeMap;
    }
}
exports.CIAppTestsAnalyticsAggregateResponse = CIAppTestsAnalyticsAggregateResponse;
/**
 * @ignore
 */
CIAppTestsAnalyticsAggregateResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "CIAppTestsAggregationBucketsResponse",
    },
    links: {
        baseName: "links",
        type: "CIAppResponseLinks",
    },
    meta: {
        baseName: "meta",
        type: "CIAppResponseMetadata",
    },
};
//# sourceMappingURL=CIAppTestsAnalyticsAggregateResponse.js.map

/***/ }),

/***/ 34463:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppTestsBucketResponse = void 0;
/**
 * Bucket values.
 */
class CIAppTestsBucketResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppTestsBucketResponse.attributeTypeMap;
    }
}
exports.CIAppTestsBucketResponse = CIAppTestsBucketResponse;
/**
 * @ignore
 */
CIAppTestsBucketResponse.attributeTypeMap = {
    by: {
        baseName: "by",
        type: "{ [key: string]: any; }",
    },
    computes: {
        baseName: "computes",
        type: "{ [key: string]: CIAppAggregateBucketValue; }",
    },
};
//# sourceMappingURL=CIAppTestsBucketResponse.js.map

/***/ }),

/***/ 59491:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppTestsGroupBy = void 0;
/**
 * A group-by rule.
 */
class CIAppTestsGroupBy {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppTestsGroupBy.attributeTypeMap;
    }
}
exports.CIAppTestsGroupBy = CIAppTestsGroupBy;
/**
 * @ignore
 */
CIAppTestsGroupBy.attributeTypeMap = {
    facet: {
        baseName: "facet",
        type: "string",
        required: true,
    },
    histogram: {
        baseName: "histogram",
        type: "CIAppGroupByHistogram",
    },
    limit: {
        baseName: "limit",
        type: "number",
        format: "int64",
    },
    missing: {
        baseName: "missing",
        type: "CIAppGroupByMissing",
    },
    sort: {
        baseName: "sort",
        type: "CIAppAggregateSort",
    },
    total: {
        baseName: "total",
        type: "CIAppGroupByTotal",
    },
};
//# sourceMappingURL=CIAppTestsGroupBy.js.map

/***/ }),

/***/ 27928:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppTestsQueryFilter = void 0;
/**
 * The search and filter query settings.
 */
class CIAppTestsQueryFilter {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppTestsQueryFilter.attributeTypeMap;
    }
}
exports.CIAppTestsQueryFilter = CIAppTestsQueryFilter;
/**
 * @ignore
 */
CIAppTestsQueryFilter.attributeTypeMap = {
    from: {
        baseName: "from",
        type: "string",
    },
    query: {
        baseName: "query",
        type: "string",
    },
    to: {
        baseName: "to",
        type: "string",
    },
};
//# sourceMappingURL=CIAppTestsQueryFilter.js.map

/***/ }),

/***/ 86117:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CIAppWarning = void 0;
/**
 * A warning message indicating something that went wrong with the query.
 */
class CIAppWarning {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CIAppWarning.attributeTypeMap;
    }
}
exports.CIAppWarning = CIAppWarning;
/**
 * @ignore
 */
CIAppWarning.attributeTypeMap = {
    code: {
        baseName: "code",
        type: "string",
    },
    detail: {
        baseName: "detail",
        type: "string",
    },
    title: {
        baseName: "title",
        type: "string",
    },
};
//# sourceMappingURL=CIAppWarning.js.map

/***/ }),

/***/ 16467:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChargebackBreakdown = void 0;
/**
 * Charges breakdown.
 */
class ChargebackBreakdown {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ChargebackBreakdown.attributeTypeMap;
    }
}
exports.ChargebackBreakdown = ChargebackBreakdown;
/**
 * @ignore
 */
ChargebackBreakdown.attributeTypeMap = {
    chargeType: {
        baseName: "charge_type",
        type: "string",
    },
    cost: {
        baseName: "cost",
        type: "number",
        format: "double",
    },
    productName: {
        baseName: "product_name",
        type: "string",
    },
};
//# sourceMappingURL=ChargebackBreakdown.js.map

/***/ }),

/***/ 38115:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudConfigurationComplianceRuleOptions = void 0;
/**
 * Options for cloud_configuration rules.
 * Fields `resourceType` and `regoRule` are mandatory when managing custom `cloud_configuration` rules.
 */
class CloudConfigurationComplianceRuleOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudConfigurationComplianceRuleOptions.attributeTypeMap;
    }
}
exports.CloudConfigurationComplianceRuleOptions = CloudConfigurationComplianceRuleOptions;
/**
 * @ignore
 */
CloudConfigurationComplianceRuleOptions.attributeTypeMap = {
    complexRule: {
        baseName: "complexRule",
        type: "boolean",
    },
    regoRule: {
        baseName: "regoRule",
        type: "CloudConfigurationRegoRule",
    },
    resourceType: {
        baseName: "resourceType",
        type: "string",
    },
};
//# sourceMappingURL=CloudConfigurationComplianceRuleOptions.js.map

/***/ }),

/***/ 7582:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudConfigurationRegoRule = void 0;
/**
 * Rule details.
 */
class CloudConfigurationRegoRule {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudConfigurationRegoRule.attributeTypeMap;
    }
}
exports.CloudConfigurationRegoRule = CloudConfigurationRegoRule;
/**
 * @ignore
 */
CloudConfigurationRegoRule.attributeTypeMap = {
    policy: {
        baseName: "policy",
        type: "string",
        required: true,
    },
    resourceTypes: {
        baseName: "resourceTypes",
        type: "Array<string>",
        required: true,
    },
};
//# sourceMappingURL=CloudConfigurationRegoRule.js.map

/***/ }),

/***/ 17477:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudConfigurationRuleCaseCreate = void 0;
/**
 * Description of signals.
 */
class CloudConfigurationRuleCaseCreate {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudConfigurationRuleCaseCreate.attributeTypeMap;
    }
}
exports.CloudConfigurationRuleCaseCreate = CloudConfigurationRuleCaseCreate;
/**
 * @ignore
 */
CloudConfigurationRuleCaseCreate.attributeTypeMap = {
    notifications: {
        baseName: "notifications",
        type: "Array<string>",
    },
    status: {
        baseName: "status",
        type: "SecurityMonitoringRuleSeverity",
        required: true,
    },
};
//# sourceMappingURL=CloudConfigurationRuleCaseCreate.js.map

/***/ }),

/***/ 11004:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudConfigurationRuleComplianceSignalOptions = void 0;
/**
 * How to generate compliance signals. Useful for cloud_configuration rules only.
 */
class CloudConfigurationRuleComplianceSignalOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudConfigurationRuleComplianceSignalOptions.attributeTypeMap;
    }
}
exports.CloudConfigurationRuleComplianceSignalOptions = CloudConfigurationRuleComplianceSignalOptions;
/**
 * @ignore
 */
CloudConfigurationRuleComplianceSignalOptions.attributeTypeMap = {
    userActivationStatus: {
        baseName: "userActivationStatus",
        type: "boolean",
    },
    userGroupByFields: {
        baseName: "userGroupByFields",
        type: "Array<string>",
    },
};
//# sourceMappingURL=CloudConfigurationRuleComplianceSignalOptions.js.map

/***/ }),

/***/ 1935:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudConfigurationRuleCreatePayload = void 0;
/**
 * Create a new cloud configuration rule.
 */
class CloudConfigurationRuleCreatePayload {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudConfigurationRuleCreatePayload.attributeTypeMap;
    }
}
exports.CloudConfigurationRuleCreatePayload = CloudConfigurationRuleCreatePayload;
/**
 * @ignore
 */
CloudConfigurationRuleCreatePayload.attributeTypeMap = {
    cases: {
        baseName: "cases",
        type: "Array<CloudConfigurationRuleCaseCreate>",
        required: true,
    },
    complianceSignalOptions: {
        baseName: "complianceSignalOptions",
        type: "CloudConfigurationRuleComplianceSignalOptions",
        required: true,
    },
    isEnabled: {
        baseName: "isEnabled",
        type: "boolean",
        required: true,
    },
    message: {
        baseName: "message",
        type: "string",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    options: {
        baseName: "options",
        type: "CloudConfigurationRuleOptions",
        required: true,
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    type: {
        baseName: "type",
        type: "CloudConfigurationRuleType",
    },
};
//# sourceMappingURL=CloudConfigurationRuleCreatePayload.js.map

/***/ }),

/***/ 47654:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudConfigurationRuleOptions = void 0;
/**
 * Options on cloud configuration rules.
 */
class CloudConfigurationRuleOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudConfigurationRuleOptions.attributeTypeMap;
    }
}
exports.CloudConfigurationRuleOptions = CloudConfigurationRuleOptions;
/**
 * @ignore
 */
CloudConfigurationRuleOptions.attributeTypeMap = {
    complianceRuleOptions: {
        baseName: "complianceRuleOptions",
        type: "CloudConfigurationComplianceRuleOptions",
        required: true,
    },
};
//# sourceMappingURL=CloudConfigurationRuleOptions.js.map

/***/ }),

/***/ 60792:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudWorkloadSecurityAgentRuleAttributes = void 0;
/**
 * A Cloud Workload Security Agent rule returned by the API.
 */
class CloudWorkloadSecurityAgentRuleAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudWorkloadSecurityAgentRuleAttributes.attributeTypeMap;
    }
}
exports.CloudWorkloadSecurityAgentRuleAttributes = CloudWorkloadSecurityAgentRuleAttributes;
/**
 * @ignore
 */
CloudWorkloadSecurityAgentRuleAttributes.attributeTypeMap = {
    category: {
        baseName: "category",
        type: "string",
    },
    creationDate: {
        baseName: "creationDate",
        type: "number",
        format: "int64",
    },
    creator: {
        baseName: "creator",
        type: "CloudWorkloadSecurityAgentRuleCreatorAttributes",
    },
    defaultRule: {
        baseName: "defaultRule",
        type: "boolean",
    },
    description: {
        baseName: "description",
        type: "string",
    },
    enabled: {
        baseName: "enabled",
        type: "boolean",
    },
    expression: {
        baseName: "expression",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    updatedAt: {
        baseName: "updatedAt",
        type: "number",
        format: "int64",
    },
    updater: {
        baseName: "updater",
        type: "CloudWorkloadSecurityAgentRuleUpdaterAttributes",
    },
    version: {
        baseName: "version",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=CloudWorkloadSecurityAgentRuleAttributes.js.map

/***/ }),

/***/ 91982:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudWorkloadSecurityAgentRuleCreateAttributes = void 0;
/**
 * Create a new Cloud Workload Security Agent rule.
 */
class CloudWorkloadSecurityAgentRuleCreateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudWorkloadSecurityAgentRuleCreateAttributes.attributeTypeMap;
    }
}
exports.CloudWorkloadSecurityAgentRuleCreateAttributes = CloudWorkloadSecurityAgentRuleCreateAttributes;
/**
 * @ignore
 */
CloudWorkloadSecurityAgentRuleCreateAttributes.attributeTypeMap = {
    description: {
        baseName: "description",
        type: "string",
    },
    enabled: {
        baseName: "enabled",
        type: "boolean",
    },
    expression: {
        baseName: "expression",
        type: "string",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=CloudWorkloadSecurityAgentRuleCreateAttributes.js.map

/***/ }),

/***/ 57506:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudWorkloadSecurityAgentRuleCreateData = void 0;
/**
 * Object for a single Agent rule.
 */
class CloudWorkloadSecurityAgentRuleCreateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudWorkloadSecurityAgentRuleCreateData.attributeTypeMap;
    }
}
exports.CloudWorkloadSecurityAgentRuleCreateData = CloudWorkloadSecurityAgentRuleCreateData;
/**
 * @ignore
 */
CloudWorkloadSecurityAgentRuleCreateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "CloudWorkloadSecurityAgentRuleCreateAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "CloudWorkloadSecurityAgentRuleType",
        required: true,
    },
};
//# sourceMappingURL=CloudWorkloadSecurityAgentRuleCreateData.js.map

/***/ }),

/***/ 11249:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudWorkloadSecurityAgentRuleCreateRequest = void 0;
/**
 * Request object that includes the Agent rule to create.
 */
class CloudWorkloadSecurityAgentRuleCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudWorkloadSecurityAgentRuleCreateRequest.attributeTypeMap;
    }
}
exports.CloudWorkloadSecurityAgentRuleCreateRequest = CloudWorkloadSecurityAgentRuleCreateRequest;
/**
 * @ignore
 */
CloudWorkloadSecurityAgentRuleCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "CloudWorkloadSecurityAgentRuleCreateData",
        required: true,
    },
};
//# sourceMappingURL=CloudWorkloadSecurityAgentRuleCreateRequest.js.map

/***/ }),

/***/ 34366:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudWorkloadSecurityAgentRuleCreatorAttributes = void 0;
/**
 * The attributes of the user who created the Agent rule.
 */
class CloudWorkloadSecurityAgentRuleCreatorAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudWorkloadSecurityAgentRuleCreatorAttributes.attributeTypeMap;
    }
}
exports.CloudWorkloadSecurityAgentRuleCreatorAttributes = CloudWorkloadSecurityAgentRuleCreatorAttributes;
/**
 * @ignore
 */
CloudWorkloadSecurityAgentRuleCreatorAttributes.attributeTypeMap = {
    handle: {
        baseName: "handle",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=CloudWorkloadSecurityAgentRuleCreatorAttributes.js.map

/***/ }),

/***/ 79526:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudWorkloadSecurityAgentRuleData = void 0;
/**
 * Object for a single Agent rule.
 */
class CloudWorkloadSecurityAgentRuleData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudWorkloadSecurityAgentRuleData.attributeTypeMap;
    }
}
exports.CloudWorkloadSecurityAgentRuleData = CloudWorkloadSecurityAgentRuleData;
/**
 * @ignore
 */
CloudWorkloadSecurityAgentRuleData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "CloudWorkloadSecurityAgentRuleAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "CloudWorkloadSecurityAgentRuleType",
    },
};
//# sourceMappingURL=CloudWorkloadSecurityAgentRuleData.js.map

/***/ }),

/***/ 70516:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudWorkloadSecurityAgentRuleResponse = void 0;
/**
 * Response object that includes an Agent rule.
 */
class CloudWorkloadSecurityAgentRuleResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudWorkloadSecurityAgentRuleResponse.attributeTypeMap;
    }
}
exports.CloudWorkloadSecurityAgentRuleResponse = CloudWorkloadSecurityAgentRuleResponse;
/**
 * @ignore
 */
CloudWorkloadSecurityAgentRuleResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "CloudWorkloadSecurityAgentRuleData",
    },
};
//# sourceMappingURL=CloudWorkloadSecurityAgentRuleResponse.js.map

/***/ }),

/***/ 43319:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudWorkloadSecurityAgentRuleUpdateAttributes = void 0;
/**
 * Update an existing Cloud Workload Security Agent rule.
 */
class CloudWorkloadSecurityAgentRuleUpdateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudWorkloadSecurityAgentRuleUpdateAttributes.attributeTypeMap;
    }
}
exports.CloudWorkloadSecurityAgentRuleUpdateAttributes = CloudWorkloadSecurityAgentRuleUpdateAttributes;
/**
 * @ignore
 */
CloudWorkloadSecurityAgentRuleUpdateAttributes.attributeTypeMap = {
    description: {
        baseName: "description",
        type: "string",
    },
    enabled: {
        baseName: "enabled",
        type: "boolean",
    },
    expression: {
        baseName: "expression",
        type: "string",
    },
};
//# sourceMappingURL=CloudWorkloadSecurityAgentRuleUpdateAttributes.js.map

/***/ }),

/***/ 92347:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudWorkloadSecurityAgentRuleUpdateData = void 0;
/**
 * Object for a single Agent rule.
 */
class CloudWorkloadSecurityAgentRuleUpdateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudWorkloadSecurityAgentRuleUpdateData.attributeTypeMap;
    }
}
exports.CloudWorkloadSecurityAgentRuleUpdateData = CloudWorkloadSecurityAgentRuleUpdateData;
/**
 * @ignore
 */
CloudWorkloadSecurityAgentRuleUpdateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "CloudWorkloadSecurityAgentRuleUpdateAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "CloudWorkloadSecurityAgentRuleType",
        required: true,
    },
};
//# sourceMappingURL=CloudWorkloadSecurityAgentRuleUpdateData.js.map

/***/ }),

/***/ 96586:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudWorkloadSecurityAgentRuleUpdateRequest = void 0;
/**
 * Request object that includes the Agent rule with the attributes to update.
 */
class CloudWorkloadSecurityAgentRuleUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudWorkloadSecurityAgentRuleUpdateRequest.attributeTypeMap;
    }
}
exports.CloudWorkloadSecurityAgentRuleUpdateRequest = CloudWorkloadSecurityAgentRuleUpdateRequest;
/**
 * @ignore
 */
CloudWorkloadSecurityAgentRuleUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "CloudWorkloadSecurityAgentRuleUpdateData",
        required: true,
    },
};
//# sourceMappingURL=CloudWorkloadSecurityAgentRuleUpdateRequest.js.map

/***/ }),

/***/ 22606:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudWorkloadSecurityAgentRuleUpdaterAttributes = void 0;
/**
 * The attributes of the user who last updated the Agent rule.
 */
class CloudWorkloadSecurityAgentRuleUpdaterAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudWorkloadSecurityAgentRuleUpdaterAttributes.attributeTypeMap;
    }
}
exports.CloudWorkloadSecurityAgentRuleUpdaterAttributes = CloudWorkloadSecurityAgentRuleUpdaterAttributes;
/**
 * @ignore
 */
CloudWorkloadSecurityAgentRuleUpdaterAttributes.attributeTypeMap = {
    handle: {
        baseName: "handle",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=CloudWorkloadSecurityAgentRuleUpdaterAttributes.js.map

/***/ }),

/***/ 42739:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudWorkloadSecurityAgentRulesListResponse = void 0;
/**
 * Response object that includes a list of Agent rule.
 */
class CloudWorkloadSecurityAgentRulesListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudWorkloadSecurityAgentRulesListResponse.attributeTypeMap;
    }
}
exports.CloudWorkloadSecurityAgentRulesListResponse = CloudWorkloadSecurityAgentRulesListResponse;
/**
 * @ignore
 */
CloudWorkloadSecurityAgentRulesListResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<CloudWorkloadSecurityAgentRuleData>",
    },
};
//# sourceMappingURL=CloudWorkloadSecurityAgentRulesListResponse.js.map

/***/ }),

/***/ 85346:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudflareAccountCreateRequest = void 0;
/**
 * Payload schema when adding a Cloudflare account.
 */
class CloudflareAccountCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudflareAccountCreateRequest.attributeTypeMap;
    }
}
exports.CloudflareAccountCreateRequest = CloudflareAccountCreateRequest;
/**
 * @ignore
 */
CloudflareAccountCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "CloudflareAccountCreateRequestData",
        required: true,
    },
};
//# sourceMappingURL=CloudflareAccountCreateRequest.js.map

/***/ }),

/***/ 45414:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudflareAccountCreateRequestAttributes = void 0;
/**
 * Attributes object for creating a Cloudflare account.
 */
class CloudflareAccountCreateRequestAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudflareAccountCreateRequestAttributes.attributeTypeMap;
    }
}
exports.CloudflareAccountCreateRequestAttributes = CloudflareAccountCreateRequestAttributes;
/**
 * @ignore
 */
CloudflareAccountCreateRequestAttributes.attributeTypeMap = {
    apiKey: {
        baseName: "api_key",
        type: "string",
        required: true,
    },
    email: {
        baseName: "email",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=CloudflareAccountCreateRequestAttributes.js.map

/***/ }),

/***/ 19660:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudflareAccountCreateRequestData = void 0;
/**
 * Data object for creating a Cloudflare account.
 */
class CloudflareAccountCreateRequestData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudflareAccountCreateRequestData.attributeTypeMap;
    }
}
exports.CloudflareAccountCreateRequestData = CloudflareAccountCreateRequestData;
/**
 * @ignore
 */
CloudflareAccountCreateRequestData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "CloudflareAccountCreateRequestAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "CloudflareAccountType",
        required: true,
    },
};
//# sourceMappingURL=CloudflareAccountCreateRequestData.js.map

/***/ }),

/***/ 53134:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudflareAccountResponse = void 0;
/**
 * The expected response schema when getting a Cloudflare account.
 */
class CloudflareAccountResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudflareAccountResponse.attributeTypeMap;
    }
}
exports.CloudflareAccountResponse = CloudflareAccountResponse;
/**
 * @ignore
 */
CloudflareAccountResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "CloudflareAccountResponseData",
    },
};
//# sourceMappingURL=CloudflareAccountResponse.js.map

/***/ }),

/***/ 614:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudflareAccountResponseAttributes = void 0;
/**
 * Attributes object of a Cloudflare account.
 */
class CloudflareAccountResponseAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudflareAccountResponseAttributes.attributeTypeMap;
    }
}
exports.CloudflareAccountResponseAttributes = CloudflareAccountResponseAttributes;
/**
 * @ignore
 */
CloudflareAccountResponseAttributes.attributeTypeMap = {
    email: {
        baseName: "email",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=CloudflareAccountResponseAttributes.js.map

/***/ }),

/***/ 29339:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudflareAccountResponseData = void 0;
/**
 * Data object of a Cloudflare account.
 */
class CloudflareAccountResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudflareAccountResponseData.attributeTypeMap;
    }
}
exports.CloudflareAccountResponseData = CloudflareAccountResponseData;
/**
 * @ignore
 */
CloudflareAccountResponseData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "CloudflareAccountResponseAttributes",
        required: true,
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "CloudflareAccountType",
        required: true,
    },
};
//# sourceMappingURL=CloudflareAccountResponseData.js.map

/***/ }),

/***/ 73177:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudflareAccountUpdateRequest = void 0;
/**
 * Payload schema when updating a Cloudflare account.
 */
class CloudflareAccountUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudflareAccountUpdateRequest.attributeTypeMap;
    }
}
exports.CloudflareAccountUpdateRequest = CloudflareAccountUpdateRequest;
/**
 * @ignore
 */
CloudflareAccountUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "CloudflareAccountUpdateRequestData",
        required: true,
    },
};
//# sourceMappingURL=CloudflareAccountUpdateRequest.js.map

/***/ }),

/***/ 25778:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudflareAccountUpdateRequestAttributes = void 0;
/**
 * Attributes object for updating a Cloudflare account.
 */
class CloudflareAccountUpdateRequestAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudflareAccountUpdateRequestAttributes.attributeTypeMap;
    }
}
exports.CloudflareAccountUpdateRequestAttributes = CloudflareAccountUpdateRequestAttributes;
/**
 * @ignore
 */
CloudflareAccountUpdateRequestAttributes.attributeTypeMap = {
    apiKey: {
        baseName: "api_key",
        type: "string",
        required: true,
    },
    email: {
        baseName: "email",
        type: "string",
    },
};
//# sourceMappingURL=CloudflareAccountUpdateRequestAttributes.js.map

/***/ }),

/***/ 18693:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudflareAccountUpdateRequestData = void 0;
/**
 * Data object for updating a Cloudflare account.
 */
class CloudflareAccountUpdateRequestData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudflareAccountUpdateRequestData.attributeTypeMap;
    }
}
exports.CloudflareAccountUpdateRequestData = CloudflareAccountUpdateRequestData;
/**
 * @ignore
 */
CloudflareAccountUpdateRequestData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "CloudflareAccountUpdateRequestAttributes",
    },
    type: {
        baseName: "type",
        type: "CloudflareAccountType",
    },
};
//# sourceMappingURL=CloudflareAccountUpdateRequestData.js.map

/***/ }),

/***/ 25675:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudflareAccountsResponse = void 0;
/**
 * The expected response schema when getting Cloudflare accounts.
 */
class CloudflareAccountsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CloudflareAccountsResponse.attributeTypeMap;
    }
}
exports.CloudflareAccountsResponse = CloudflareAccountsResponse;
/**
 * @ignore
 */
CloudflareAccountsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<CloudflareAccountResponseData>",
    },
};
//# sourceMappingURL=CloudflareAccountsResponse.js.map

/***/ }),

/***/ 2398:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfluentAccountCreateRequest = void 0;
/**
 * Payload schema when adding a Confluent account.
 */
class ConfluentAccountCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ConfluentAccountCreateRequest.attributeTypeMap;
    }
}
exports.ConfluentAccountCreateRequest = ConfluentAccountCreateRequest;
/**
 * @ignore
 */
ConfluentAccountCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "ConfluentAccountCreateRequestData",
        required: true,
    },
};
//# sourceMappingURL=ConfluentAccountCreateRequest.js.map

/***/ }),

/***/ 28121:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfluentAccountCreateRequestAttributes = void 0;
/**
 * Attributes associated with the account creation request.
 */
class ConfluentAccountCreateRequestAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ConfluentAccountCreateRequestAttributes.attributeTypeMap;
    }
}
exports.ConfluentAccountCreateRequestAttributes = ConfluentAccountCreateRequestAttributes;
/**
 * @ignore
 */
ConfluentAccountCreateRequestAttributes.attributeTypeMap = {
    apiKey: {
        baseName: "api_key",
        type: "string",
        required: true,
    },
    apiSecret: {
        baseName: "api_secret",
        type: "string",
        required: true,
    },
    resources: {
        baseName: "resources",
        type: "Array<ConfluentAccountResourceAttributes>",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
};
//# sourceMappingURL=ConfluentAccountCreateRequestAttributes.js.map

/***/ }),

/***/ 43932:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfluentAccountCreateRequestData = void 0;
/**
 * The data body for adding a Confluent account.
 */
class ConfluentAccountCreateRequestData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ConfluentAccountCreateRequestData.attributeTypeMap;
    }
}
exports.ConfluentAccountCreateRequestData = ConfluentAccountCreateRequestData;
/**
 * @ignore
 */
ConfluentAccountCreateRequestData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "ConfluentAccountCreateRequestAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "ConfluentAccountType",
        required: true,
    },
};
//# sourceMappingURL=ConfluentAccountCreateRequestData.js.map

/***/ }),

/***/ 96316:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfluentAccountResourceAttributes = void 0;
/**
 * Attributes object for updating a Confluent resource.
 */
class ConfluentAccountResourceAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ConfluentAccountResourceAttributes.attributeTypeMap;
    }
}
exports.ConfluentAccountResourceAttributes = ConfluentAccountResourceAttributes;
/**
 * @ignore
 */
ConfluentAccountResourceAttributes.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
    },
    resourceType: {
        baseName: "resource_type",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
};
//# sourceMappingURL=ConfluentAccountResourceAttributes.js.map

/***/ }),

/***/ 98659:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfluentAccountResponse = void 0;
/**
 * The expected response schema when getting a Confluent account.
 */
class ConfluentAccountResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ConfluentAccountResponse.attributeTypeMap;
    }
}
exports.ConfluentAccountResponse = ConfluentAccountResponse;
/**
 * @ignore
 */
ConfluentAccountResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "ConfluentAccountResponseData",
    },
};
//# sourceMappingURL=ConfluentAccountResponse.js.map

/***/ }),

/***/ 31345:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfluentAccountResponseAttributes = void 0;
/**
 * The attributes of a Confluent account.
 */
class ConfluentAccountResponseAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ConfluentAccountResponseAttributes.attributeTypeMap;
    }
}
exports.ConfluentAccountResponseAttributes = ConfluentAccountResponseAttributes;
/**
 * @ignore
 */
ConfluentAccountResponseAttributes.attributeTypeMap = {
    apiKey: {
        baseName: "api_key",
        type: "string",
        required: true,
    },
    resources: {
        baseName: "resources",
        type: "Array<ConfluentResourceResponseAttributes>",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
};
//# sourceMappingURL=ConfluentAccountResponseAttributes.js.map

/***/ }),

/***/ 43122:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfluentAccountResponseData = void 0;
/**
 * An API key and API secret pair that represents a Confluent account.
 */
class ConfluentAccountResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ConfluentAccountResponseData.attributeTypeMap;
    }
}
exports.ConfluentAccountResponseData = ConfluentAccountResponseData;
/**
 * @ignore
 */
ConfluentAccountResponseData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "ConfluentAccountResponseAttributes",
        required: true,
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "ConfluentAccountType",
        required: true,
    },
};
//# sourceMappingURL=ConfluentAccountResponseData.js.map

/***/ }),

/***/ 36313:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfluentAccountUpdateRequest = void 0;
/**
 * The JSON:API request for updating a Confluent account.
 */
class ConfluentAccountUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ConfluentAccountUpdateRequest.attributeTypeMap;
    }
}
exports.ConfluentAccountUpdateRequest = ConfluentAccountUpdateRequest;
/**
 * @ignore
 */
ConfluentAccountUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "ConfluentAccountUpdateRequestData",
        required: true,
    },
};
//# sourceMappingURL=ConfluentAccountUpdateRequest.js.map

/***/ }),

/***/ 34989:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfluentAccountUpdateRequestAttributes = void 0;
/**
 * Attributes object for updating a Confluent account.
 */
class ConfluentAccountUpdateRequestAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ConfluentAccountUpdateRequestAttributes.attributeTypeMap;
    }
}
exports.ConfluentAccountUpdateRequestAttributes = ConfluentAccountUpdateRequestAttributes;
/**
 * @ignore
 */
ConfluentAccountUpdateRequestAttributes.attributeTypeMap = {
    apiKey: {
        baseName: "api_key",
        type: "string",
        required: true,
    },
    apiSecret: {
        baseName: "api_secret",
        type: "string",
        required: true,
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
};
//# sourceMappingURL=ConfluentAccountUpdateRequestAttributes.js.map

/***/ }),

/***/ 19026:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfluentAccountUpdateRequestData = void 0;
/**
 * Data object for updating a Confluent account.
 */
class ConfluentAccountUpdateRequestData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ConfluentAccountUpdateRequestData.attributeTypeMap;
    }
}
exports.ConfluentAccountUpdateRequestData = ConfluentAccountUpdateRequestData;
/**
 * @ignore
 */
ConfluentAccountUpdateRequestData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "ConfluentAccountUpdateRequestAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "ConfluentAccountType",
        required: true,
    },
};
//# sourceMappingURL=ConfluentAccountUpdateRequestData.js.map

/***/ }),

/***/ 66438:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfluentAccountsResponse = void 0;
/**
 * Confluent account returned by the API.
 */
class ConfluentAccountsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ConfluentAccountsResponse.attributeTypeMap;
    }
}
exports.ConfluentAccountsResponse = ConfluentAccountsResponse;
/**
 * @ignore
 */
ConfluentAccountsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<ConfluentAccountResponseData>",
    },
};
//# sourceMappingURL=ConfluentAccountsResponse.js.map

/***/ }),

/***/ 44539:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfluentResourceRequest = void 0;
/**
 * The JSON:API request for updating a Confluent resource.
 */
class ConfluentResourceRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ConfluentResourceRequest.attributeTypeMap;
    }
}
exports.ConfluentResourceRequest = ConfluentResourceRequest;
/**
 * @ignore
 */
ConfluentResourceRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "ConfluentResourceRequestData",
        required: true,
    },
};
//# sourceMappingURL=ConfluentResourceRequest.js.map

/***/ }),

/***/ 19799:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfluentResourceRequestAttributes = void 0;
/**
 * Attributes object for updating a Confluent resource.
 */
class ConfluentResourceRequestAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ConfluentResourceRequestAttributes.attributeTypeMap;
    }
}
exports.ConfluentResourceRequestAttributes = ConfluentResourceRequestAttributes;
/**
 * @ignore
 */
ConfluentResourceRequestAttributes.attributeTypeMap = {
    resourceType: {
        baseName: "resource_type",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
};
//# sourceMappingURL=ConfluentResourceRequestAttributes.js.map

/***/ }),

/***/ 40667:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfluentResourceRequestData = void 0;
/**
 * JSON:API request for updating a Confluent resource.
 */
class ConfluentResourceRequestData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ConfluentResourceRequestData.attributeTypeMap;
    }
}
exports.ConfluentResourceRequestData = ConfluentResourceRequestData;
/**
 * @ignore
 */
ConfluentResourceRequestData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "ConfluentResourceRequestAttributes",
        required: true,
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "ConfluentResourceType",
        required: true,
    },
};
//# sourceMappingURL=ConfluentResourceRequestData.js.map

/***/ }),

/***/ 4896:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfluentResourceResponse = void 0;
/**
 * Response schema when interacting with a Confluent resource.
 */
class ConfluentResourceResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ConfluentResourceResponse.attributeTypeMap;
    }
}
exports.ConfluentResourceResponse = ConfluentResourceResponse;
/**
 * @ignore
 */
ConfluentResourceResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "ConfluentResourceResponseData",
    },
};
//# sourceMappingURL=ConfluentResourceResponse.js.map

/***/ }),

/***/ 32977:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfluentResourceResponseAttributes = void 0;
/**
 * Model representation of a Confluent Cloud resource.
 */
class ConfluentResourceResponseAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ConfluentResourceResponseAttributes.attributeTypeMap;
    }
}
exports.ConfluentResourceResponseAttributes = ConfluentResourceResponseAttributes;
/**
 * @ignore
 */
ConfluentResourceResponseAttributes.attributeTypeMap = {
    resourceType: {
        baseName: "resource_type",
        type: "string",
        required: true,
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
};
//# sourceMappingURL=ConfluentResourceResponseAttributes.js.map

/***/ }),

/***/ 92723:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfluentResourceResponseData = void 0;
/**
 * Confluent Cloud resource data.
 */
class ConfluentResourceResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ConfluentResourceResponseData.attributeTypeMap;
    }
}
exports.ConfluentResourceResponseData = ConfluentResourceResponseData;
/**
 * @ignore
 */
ConfluentResourceResponseData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "ConfluentResourceResponseAttributes",
        required: true,
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "ConfluentResourceType",
        required: true,
    },
};
//# sourceMappingURL=ConfluentResourceResponseData.js.map

/***/ }),

/***/ 92452:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfluentResourcesResponse = void 0;
/**
 * Response schema when interacting with a list of Confluent resources.
 */
class ConfluentResourcesResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ConfluentResourcesResponse.attributeTypeMap;
    }
}
exports.ConfluentResourcesResponse = ConfluentResourcesResponse;
/**
 * @ignore
 */
ConfluentResourcesResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<ConfluentResourceResponseData>",
    },
};
//# sourceMappingURL=ConfluentResourcesResponse.js.map

/***/ }),

/***/ 62609:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CostByOrg = void 0;
/**
 * Cost data.
 */
class CostByOrg {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CostByOrg.attributeTypeMap;
    }
}
exports.CostByOrg = CostByOrg;
/**
 * @ignore
 */
CostByOrg.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "CostByOrgAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "CostByOrgType",
    },
};
//# sourceMappingURL=CostByOrg.js.map

/***/ }),

/***/ 268:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CostByOrgAttributes = void 0;
/**
 * Cost attributes data.
 */
class CostByOrgAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CostByOrgAttributes.attributeTypeMap;
    }
}
exports.CostByOrgAttributes = CostByOrgAttributes;
/**
 * @ignore
 */
CostByOrgAttributes.attributeTypeMap = {
    charges: {
        baseName: "charges",
        type: "Array<ChargebackBreakdown>",
    },
    date: {
        baseName: "date",
        type: "Date",
        format: "date-time",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    region: {
        baseName: "region",
        type: "string",
    },
    totalCost: {
        baseName: "total_cost",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=CostByOrgAttributes.js.map

/***/ }),

/***/ 79292:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CostByOrgResponse = void 0;
/**
 * Chargeback Summary response.
 */
class CostByOrgResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return CostByOrgResponse.attributeTypeMap;
    }
}
exports.CostByOrgResponse = CostByOrgResponse;
/**
 * @ignore
 */
CostByOrgResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<CostByOrg>",
    },
};
//# sourceMappingURL=CostByOrgResponse.js.map

/***/ }),

/***/ 81580:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Creator = void 0;
/**
 * Creator of the object.
 */
class Creator {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return Creator.attributeTypeMap;
    }
}
exports.Creator = Creator;
/**
 * @ignore
 */
Creator.attributeTypeMap = {
    email: {
        baseName: "email",
        type: "string",
    },
    handle: {
        baseName: "handle",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=Creator.js.map

/***/ }),

/***/ 1746:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardListAddItemsRequest = void 0;
/**
 * Request containing a list of dashboards to add.
 */
class DashboardListAddItemsRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardListAddItemsRequest.attributeTypeMap;
    }
}
exports.DashboardListAddItemsRequest = DashboardListAddItemsRequest;
/**
 * @ignore
 */
DashboardListAddItemsRequest.attributeTypeMap = {
    dashboards: {
        baseName: "dashboards",
        type: "Array<DashboardListItemRequest>",
    },
};
//# sourceMappingURL=DashboardListAddItemsRequest.js.map

/***/ }),

/***/ 97047:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardListAddItemsResponse = void 0;
/**
 * Response containing a list of added dashboards.
 */
class DashboardListAddItemsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardListAddItemsResponse.attributeTypeMap;
    }
}
exports.DashboardListAddItemsResponse = DashboardListAddItemsResponse;
/**
 * @ignore
 */
DashboardListAddItemsResponse.attributeTypeMap = {
    addedDashboardsToList: {
        baseName: "added_dashboards_to_list",
        type: "Array<DashboardListItemResponse>",
    },
};
//# sourceMappingURL=DashboardListAddItemsResponse.js.map

/***/ }),

/***/ 6487:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardListDeleteItemsRequest = void 0;
/**
 * Request containing a list of dashboards to delete.
 */
class DashboardListDeleteItemsRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardListDeleteItemsRequest.attributeTypeMap;
    }
}
exports.DashboardListDeleteItemsRequest = DashboardListDeleteItemsRequest;
/**
 * @ignore
 */
DashboardListDeleteItemsRequest.attributeTypeMap = {
    dashboards: {
        baseName: "dashboards",
        type: "Array<DashboardListItemRequest>",
    },
};
//# sourceMappingURL=DashboardListDeleteItemsRequest.js.map

/***/ }),

/***/ 79067:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardListDeleteItemsResponse = void 0;
/**
 * Response containing a list of deleted dashboards.
 */
class DashboardListDeleteItemsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardListDeleteItemsResponse.attributeTypeMap;
    }
}
exports.DashboardListDeleteItemsResponse = DashboardListDeleteItemsResponse;
/**
 * @ignore
 */
DashboardListDeleteItemsResponse.attributeTypeMap = {
    deletedDashboardsFromList: {
        baseName: "deleted_dashboards_from_list",
        type: "Array<DashboardListItemResponse>",
    },
};
//# sourceMappingURL=DashboardListDeleteItemsResponse.js.map

/***/ }),

/***/ 25719:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardListItem = void 0;
/**
 * A dashboard within a list.
 */
class DashboardListItem {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardListItem.attributeTypeMap;
    }
}
exports.DashboardListItem = DashboardListItem;
/**
 * @ignore
 */
DashboardListItem.attributeTypeMap = {
    author: {
        baseName: "author",
        type: "Creator",
    },
    created: {
        baseName: "created",
        type: "Date",
        format: "date-time",
    },
    icon: {
        baseName: "icon",
        type: "string",
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    isFavorite: {
        baseName: "is_favorite",
        type: "boolean",
    },
    isReadOnly: {
        baseName: "is_read_only",
        type: "boolean",
    },
    isShared: {
        baseName: "is_shared",
        type: "boolean",
    },
    modified: {
        baseName: "modified",
        type: "Date",
        format: "date-time",
    },
    popularity: {
        baseName: "popularity",
        type: "number",
        format: "int32",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "DashboardType",
        required: true,
    },
    url: {
        baseName: "url",
        type: "string",
    },
};
//# sourceMappingURL=DashboardListItem.js.map

/***/ }),

/***/ 72262:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardListItemRequest = void 0;
/**
 * A dashboard within a list.
 */
class DashboardListItemRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardListItemRequest.attributeTypeMap;
    }
}
exports.DashboardListItemRequest = DashboardListItemRequest;
/**
 * @ignore
 */
DashboardListItemRequest.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "DashboardType",
        required: true,
    },
};
//# sourceMappingURL=DashboardListItemRequest.js.map

/***/ }),

/***/ 24037:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardListItemResponse = void 0;
/**
 * A dashboard within a list.
 */
class DashboardListItemResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardListItemResponse.attributeTypeMap;
    }
}
exports.DashboardListItemResponse = DashboardListItemResponse;
/**
 * @ignore
 */
DashboardListItemResponse.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "DashboardType",
        required: true,
    },
};
//# sourceMappingURL=DashboardListItemResponse.js.map

/***/ }),

/***/ 19638:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardListItems = void 0;
/**
 * Dashboards within a list.
 */
class DashboardListItems {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardListItems.attributeTypeMap;
    }
}
exports.DashboardListItems = DashboardListItems;
/**
 * @ignore
 */
DashboardListItems.attributeTypeMap = {
    dashboards: {
        baseName: "dashboards",
        type: "Array<DashboardListItem>",
        required: true,
    },
    total: {
        baseName: "total",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=DashboardListItems.js.map

/***/ }),

/***/ 88487:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardListUpdateItemsRequest = void 0;
/**
 * Request containing the list of dashboards to update to.
 */
class DashboardListUpdateItemsRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardListUpdateItemsRequest.attributeTypeMap;
    }
}
exports.DashboardListUpdateItemsRequest = DashboardListUpdateItemsRequest;
/**
 * @ignore
 */
DashboardListUpdateItemsRequest.attributeTypeMap = {
    dashboards: {
        baseName: "dashboards",
        type: "Array<DashboardListItemRequest>",
    },
};
//# sourceMappingURL=DashboardListUpdateItemsRequest.js.map

/***/ }),

/***/ 3644:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardListUpdateItemsResponse = void 0;
/**
 * Response containing a list of updated dashboards.
 */
class DashboardListUpdateItemsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DashboardListUpdateItemsResponse.attributeTypeMap;
    }
}
exports.DashboardListUpdateItemsResponse = DashboardListUpdateItemsResponse;
/**
 * @ignore
 */
DashboardListUpdateItemsResponse.attributeTypeMap = {
    dashboards: {
        baseName: "dashboards",
        type: "Array<DashboardListItemResponse>",
    },
};
//# sourceMappingURL=DashboardListUpdateItemsResponse.js.map

/***/ }),

/***/ 83457:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataScalarColumn = void 0;
/**
 * A column containing the numerical results for a formula or query.
 */
class DataScalarColumn {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return DataScalarColumn.attributeTypeMap;
    }
}
exports.DataScalarColumn = DataScalarColumn;
/**
 * @ignore
 */
DataScalarColumn.attributeTypeMap = {
    meta: {
        baseName: "meta",
        type: "ScalarMeta",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "string",
    },
    values: {
        baseName: "values",
        type: "Array<number>",
        format: "double",
    },
};
//# sourceMappingURL=DataScalarColumn.js.map

/***/ }),

/***/ 80441:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Event = void 0;
/**
 * The metadata associated with a request.
 */
class Event {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return Event.attributeTypeMap;
    }
}
exports.Event = Event;
/**
 * @ignore
 */
Event.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    sourceId: {
        baseName: "source_id",
        type: "number",
        format: "int64",
    },
    type: {
        baseName: "type",
        type: "string",
    },
};
//# sourceMappingURL=Event.js.map

/***/ }),

/***/ 54941:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventAttributes = void 0;
/**
 * Object description of attributes from your event.
 */
class EventAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventAttributes.attributeTypeMap;
    }
}
exports.EventAttributes = EventAttributes;
/**
 * @ignore
 */
EventAttributes.attributeTypeMap = {
    aggregationKey: {
        baseName: "aggregation_key",
        type: "string",
    },
    dateHappened: {
        baseName: "date_happened",
        type: "number",
        format: "int64",
    },
    deviceName: {
        baseName: "device_name",
        type: "string",
    },
    duration: {
        baseName: "duration",
        type: "number",
        format: "int64",
    },
    eventObject: {
        baseName: "event_object",
        type: "string",
    },
    evt: {
        baseName: "evt",
        type: "Event",
    },
    hostname: {
        baseName: "hostname",
        type: "string",
    },
    monitor: {
        baseName: "monitor",
        type: "MonitorType",
    },
    monitorGroups: {
        baseName: "monitor_groups",
        type: "Array<string>",
    },
    monitorId: {
        baseName: "monitor_id",
        type: "number",
        format: "int64",
    },
    priority: {
        baseName: "priority",
        type: "EventPriority",
    },
    relatedEventId: {
        baseName: "related_event_id",
        type: "number",
        format: "int64",
    },
    service: {
        baseName: "service",
        type: "string",
    },
    sourceTypeName: {
        baseName: "source_type_name",
        type: "string",
    },
    sourcecategory: {
        baseName: "sourcecategory",
        type: "string",
    },
    status: {
        baseName: "status",
        type: "EventStatusType",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    timestamp: {
        baseName: "timestamp",
        type: "number",
        format: "int64",
    },
    title: {
        baseName: "title",
        type: "string",
    },
};
//# sourceMappingURL=EventAttributes.js.map

/***/ }),

/***/ 77892:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventResponse = void 0;
/**
 * The object description of an event after being processed and stored by Datadog.
 */
class EventResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventResponse.attributeTypeMap;
    }
}
exports.EventResponse = EventResponse;
/**
 * @ignore
 */
EventResponse.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "EventResponseAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "EventType",
    },
};
//# sourceMappingURL=EventResponse.js.map

/***/ }),

/***/ 90525:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventResponseAttributes = void 0;
/**
 * The object description of an event response attribute.
 */
class EventResponseAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventResponseAttributes.attributeTypeMap;
    }
}
exports.EventResponseAttributes = EventResponseAttributes;
/**
 * @ignore
 */
EventResponseAttributes.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "EventAttributes",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    timestamp: {
        baseName: "timestamp",
        type: "Date",
        format: "date-time",
    },
};
//# sourceMappingURL=EventResponseAttributes.js.map

/***/ }),

/***/ 57394:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventsCompute = void 0;
/**
 * The instructions for what to compute for this query.
 */
class EventsCompute {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventsCompute.attributeTypeMap;
    }
}
exports.EventsCompute = EventsCompute;
/**
 * @ignore
 */
EventsCompute.attributeTypeMap = {
    aggregation: {
        baseName: "aggregation",
        type: "EventsAggregation",
        required: true,
    },
    interval: {
        baseName: "interval",
        type: "number",
        format: "int64",
    },
    metric: {
        baseName: "metric",
        type: "string",
    },
};
//# sourceMappingURL=EventsCompute.js.map

/***/ }),

/***/ 96960:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventsGroupBy = void 0;
/**
 * A dimension on which to split a query's results.
 */
class EventsGroupBy {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventsGroupBy.attributeTypeMap;
    }
}
exports.EventsGroupBy = EventsGroupBy;
/**
 * @ignore
 */
EventsGroupBy.attributeTypeMap = {
    facet: {
        baseName: "facet",
        type: "string",
        required: true,
    },
    limit: {
        baseName: "limit",
        type: "number",
        format: "int32",
    },
    sort: {
        baseName: "sort",
        type: "EventsGroupBySort",
    },
};
//# sourceMappingURL=EventsGroupBy.js.map

/***/ }),

/***/ 61256:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventsGroupBySort = void 0;
/**
 * The dimension by which to sort a query's results.
 */
class EventsGroupBySort {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventsGroupBySort.attributeTypeMap;
    }
}
exports.EventsGroupBySort = EventsGroupBySort;
/**
 * @ignore
 */
EventsGroupBySort.attributeTypeMap = {
    aggregation: {
        baseName: "aggregation",
        type: "EventsAggregation",
        required: true,
    },
    metric: {
        baseName: "metric",
        type: "string",
    },
    order: {
        baseName: "order",
        type: "QuerySortOrder",
    },
    type: {
        baseName: "type",
        type: "EventsSortType",
    },
};
//# sourceMappingURL=EventsGroupBySort.js.map

/***/ }),

/***/ 23754:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventsListRequest = void 0;
/**
 * The object sent with the request to retrieve a list of events from your organization.
 */
class EventsListRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventsListRequest.attributeTypeMap;
    }
}
exports.EventsListRequest = EventsListRequest;
/**
 * @ignore
 */
EventsListRequest.attributeTypeMap = {
    filter: {
        baseName: "filter",
        type: "EventsQueryFilter",
    },
    options: {
        baseName: "options",
        type: "EventsQueryOptions",
    },
    page: {
        baseName: "page",
        type: "EventsRequestPage",
    },
    sort: {
        baseName: "sort",
        type: "EventsSort",
    },
};
//# sourceMappingURL=EventsListRequest.js.map

/***/ }),

/***/ 43236:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventsListResponse = void 0;
/**
 * The response object with all events matching the request and pagination information.
 */
class EventsListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventsListResponse.attributeTypeMap;
    }
}
exports.EventsListResponse = EventsListResponse;
/**
 * @ignore
 */
EventsListResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<EventResponse>",
    },
    links: {
        baseName: "links",
        type: "EventsListResponseLinks",
    },
    meta: {
        baseName: "meta",
        type: "EventsResponseMetadata",
    },
};
//# sourceMappingURL=EventsListResponse.js.map

/***/ }),

/***/ 80820:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventsListResponseLinks = void 0;
/**
 * Links attributes.
 */
class EventsListResponseLinks {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventsListResponseLinks.attributeTypeMap;
    }
}
exports.EventsListResponseLinks = EventsListResponseLinks;
/**
 * @ignore
 */
EventsListResponseLinks.attributeTypeMap = {
    next: {
        baseName: "next",
        type: "string",
    },
};
//# sourceMappingURL=EventsListResponseLinks.js.map

/***/ }),

/***/ 31925:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventsQueryFilter = void 0;
/**
 * The search and filter query settings.
 */
class EventsQueryFilter {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventsQueryFilter.attributeTypeMap;
    }
}
exports.EventsQueryFilter = EventsQueryFilter;
/**
 * @ignore
 */
EventsQueryFilter.attributeTypeMap = {
    from: {
        baseName: "from",
        type: "string",
    },
    query: {
        baseName: "query",
        type: "string",
    },
    to: {
        baseName: "to",
        type: "string",
    },
};
//# sourceMappingURL=EventsQueryFilter.js.map

/***/ }),

/***/ 64638:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventsQueryOptions = void 0;
/**
 * The global query options that are used. Either provide a timezone or a time offset but not both,
 * otherwise the query fails.
 */
class EventsQueryOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventsQueryOptions.attributeTypeMap;
    }
}
exports.EventsQueryOptions = EventsQueryOptions;
/**
 * @ignore
 */
EventsQueryOptions.attributeTypeMap = {
    timeOffset: {
        baseName: "timeOffset",
        type: "number",
        format: "int64",
    },
    timezone: {
        baseName: "timezone",
        type: "string",
    },
};
//# sourceMappingURL=EventsQueryOptions.js.map

/***/ }),

/***/ 57858:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventsRequestPage = void 0;
/**
 * Pagination settings.
 */
class EventsRequestPage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventsRequestPage.attributeTypeMap;
    }
}
exports.EventsRequestPage = EventsRequestPage;
/**
 * @ignore
 */
EventsRequestPage.attributeTypeMap = {
    cursor: {
        baseName: "cursor",
        type: "string",
    },
    limit: {
        baseName: "limit",
        type: "number",
        format: "int32",
    },
};
//# sourceMappingURL=EventsRequestPage.js.map

/***/ }),

/***/ 24290:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventsResponseMetadata = void 0;
/**
 * The metadata associated with a request.
 */
class EventsResponseMetadata {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventsResponseMetadata.attributeTypeMap;
    }
}
exports.EventsResponseMetadata = EventsResponseMetadata;
/**
 * @ignore
 */
EventsResponseMetadata.attributeTypeMap = {
    elapsed: {
        baseName: "elapsed",
        type: "number",
        format: "int64",
    },
    page: {
        baseName: "page",
        type: "EventsResponseMetadataPage",
    },
    requestId: {
        baseName: "request_id",
        type: "string",
    },
    warnings: {
        baseName: "warnings",
        type: "Array<EventsWarning>",
    },
};
//# sourceMappingURL=EventsResponseMetadata.js.map

/***/ }),

/***/ 90178:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventsResponseMetadataPage = void 0;
/**
 * Pagination attributes.
 */
class EventsResponseMetadataPage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventsResponseMetadataPage.attributeTypeMap;
    }
}
exports.EventsResponseMetadataPage = EventsResponseMetadataPage;
/**
 * @ignore
 */
EventsResponseMetadataPage.attributeTypeMap = {
    after: {
        baseName: "after",
        type: "string",
    },
};
//# sourceMappingURL=EventsResponseMetadataPage.js.map

/***/ }),

/***/ 69968:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventsScalarQuery = void 0;
/**
 * An individual scalar events query.
 */
class EventsScalarQuery {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventsScalarQuery.attributeTypeMap;
    }
}
exports.EventsScalarQuery = EventsScalarQuery;
/**
 * @ignore
 */
EventsScalarQuery.attributeTypeMap = {
    compute: {
        baseName: "compute",
        type: "EventsCompute",
        required: true,
    },
    dataSource: {
        baseName: "data_source",
        type: "EventsDataSource",
        required: true,
    },
    groupBy: {
        baseName: "group_by",
        type: "Array<EventsGroupBy>",
    },
    indexes: {
        baseName: "indexes",
        type: "Array<string>",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    search: {
        baseName: "search",
        type: "EventsSearch",
    },
};
//# sourceMappingURL=EventsScalarQuery.js.map

/***/ }),

/***/ 98043:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventsSearch = void 0;
/**
 * Configuration of the search/filter for an events query.
 */
class EventsSearch {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventsSearch.attributeTypeMap;
    }
}
exports.EventsSearch = EventsSearch;
/**
 * @ignore
 */
EventsSearch.attributeTypeMap = {
    query: {
        baseName: "query",
        type: "string",
    },
};
//# sourceMappingURL=EventsSearch.js.map

/***/ }),

/***/ 55504:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventsTimeseriesQuery = void 0;
/**
 * An individual timeseries events query.
 */
class EventsTimeseriesQuery {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventsTimeseriesQuery.attributeTypeMap;
    }
}
exports.EventsTimeseriesQuery = EventsTimeseriesQuery;
/**
 * @ignore
 */
EventsTimeseriesQuery.attributeTypeMap = {
    compute: {
        baseName: "compute",
        type: "EventsCompute",
        required: true,
    },
    dataSource: {
        baseName: "data_source",
        type: "EventsDataSource",
        required: true,
    },
    groupBy: {
        baseName: "group_by",
        type: "Array<EventsGroupBy>",
    },
    indexes: {
        baseName: "indexes",
        type: "Array<string>",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    search: {
        baseName: "search",
        type: "EventsSearch",
    },
};
//# sourceMappingURL=EventsTimeseriesQuery.js.map

/***/ }),

/***/ 72766:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventsWarning = void 0;
/**
 * A warning message indicating something is wrong with the query.
 */
class EventsWarning {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return EventsWarning.attributeTypeMap;
    }
}
exports.EventsWarning = EventsWarning;
/**
 * @ignore
 */
EventsWarning.attributeTypeMap = {
    code: {
        baseName: "code",
        type: "string",
    },
    detail: {
        baseName: "detail",
        type: "string",
    },
    title: {
        baseName: "title",
        type: "string",
    },
};
//# sourceMappingURL=EventsWarning.js.map

/***/ }),

/***/ 99983:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FastlyAccounResponseAttributes = void 0;
/**
 * Attributes object of a Fastly account.
 */
class FastlyAccounResponseAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FastlyAccounResponseAttributes.attributeTypeMap;
    }
}
exports.FastlyAccounResponseAttributes = FastlyAccounResponseAttributes;
/**
 * @ignore
 */
FastlyAccounResponseAttributes.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    services: {
        baseName: "services",
        type: "Array<FastlyService>",
    },
};
//# sourceMappingURL=FastlyAccounResponseAttributes.js.map

/***/ }),

/***/ 25259:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FastlyAccountCreateRequest = void 0;
/**
 * Payload schema when adding a Fastly account.
 */
class FastlyAccountCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FastlyAccountCreateRequest.attributeTypeMap;
    }
}
exports.FastlyAccountCreateRequest = FastlyAccountCreateRequest;
/**
 * @ignore
 */
FastlyAccountCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "FastlyAccountCreateRequestData",
        required: true,
    },
};
//# sourceMappingURL=FastlyAccountCreateRequest.js.map

/***/ }),

/***/ 95711:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FastlyAccountCreateRequestAttributes = void 0;
/**
 * Attributes object for creating a Fastly account.
 */
class FastlyAccountCreateRequestAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FastlyAccountCreateRequestAttributes.attributeTypeMap;
    }
}
exports.FastlyAccountCreateRequestAttributes = FastlyAccountCreateRequestAttributes;
/**
 * @ignore
 */
FastlyAccountCreateRequestAttributes.attributeTypeMap = {
    apiKey: {
        baseName: "api_key",
        type: "string",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    services: {
        baseName: "services",
        type: "Array<FastlyService>",
    },
};
//# sourceMappingURL=FastlyAccountCreateRequestAttributes.js.map

/***/ }),

/***/ 18422:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FastlyAccountCreateRequestData = void 0;
/**
 * Data object for creating a Fastly account.
 */
class FastlyAccountCreateRequestData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FastlyAccountCreateRequestData.attributeTypeMap;
    }
}
exports.FastlyAccountCreateRequestData = FastlyAccountCreateRequestData;
/**
 * @ignore
 */
FastlyAccountCreateRequestData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "FastlyAccountCreateRequestAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "FastlyAccountType",
        required: true,
    },
};
//# sourceMappingURL=FastlyAccountCreateRequestData.js.map

/***/ }),

/***/ 15310:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FastlyAccountResponse = void 0;
/**
 * The expected response schema when getting a Fastly account.
 */
class FastlyAccountResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FastlyAccountResponse.attributeTypeMap;
    }
}
exports.FastlyAccountResponse = FastlyAccountResponse;
/**
 * @ignore
 */
FastlyAccountResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "FastlyAccountResponseData",
    },
};
//# sourceMappingURL=FastlyAccountResponse.js.map

/***/ }),

/***/ 4599:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FastlyAccountResponseData = void 0;
/**
 * Data object of a Fastly account.
 */
class FastlyAccountResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FastlyAccountResponseData.attributeTypeMap;
    }
}
exports.FastlyAccountResponseData = FastlyAccountResponseData;
/**
 * @ignore
 */
FastlyAccountResponseData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "FastlyAccounResponseAttributes",
        required: true,
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "FastlyAccountType",
        required: true,
    },
};
//# sourceMappingURL=FastlyAccountResponseData.js.map

/***/ }),

/***/ 15128:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FastlyAccountUpdateRequest = void 0;
/**
 * Payload schema when updating a Fastly account.
 */
class FastlyAccountUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FastlyAccountUpdateRequest.attributeTypeMap;
    }
}
exports.FastlyAccountUpdateRequest = FastlyAccountUpdateRequest;
/**
 * @ignore
 */
FastlyAccountUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "FastlyAccountUpdateRequestData",
        required: true,
    },
};
//# sourceMappingURL=FastlyAccountUpdateRequest.js.map

/***/ }),

/***/ 30189:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FastlyAccountUpdateRequestAttributes = void 0;
/**
 * Attributes object for updating a Fastly account.
 */
class FastlyAccountUpdateRequestAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FastlyAccountUpdateRequestAttributes.attributeTypeMap;
    }
}
exports.FastlyAccountUpdateRequestAttributes = FastlyAccountUpdateRequestAttributes;
/**
 * @ignore
 */
FastlyAccountUpdateRequestAttributes.attributeTypeMap = {
    apiKey: {
        baseName: "api_key",
        type: "string",
    },
};
//# sourceMappingURL=FastlyAccountUpdateRequestAttributes.js.map

/***/ }),

/***/ 550:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FastlyAccountUpdateRequestData = void 0;
/**
 * Data object for updating a Fastly account.
 */
class FastlyAccountUpdateRequestData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FastlyAccountUpdateRequestData.attributeTypeMap;
    }
}
exports.FastlyAccountUpdateRequestData = FastlyAccountUpdateRequestData;
/**
 * @ignore
 */
FastlyAccountUpdateRequestData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "FastlyAccountUpdateRequestAttributes",
    },
    type: {
        baseName: "type",
        type: "FastlyAccountType",
    },
};
//# sourceMappingURL=FastlyAccountUpdateRequestData.js.map

/***/ }),

/***/ 11681:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FastlyAccountsResponse = void 0;
/**
 * The expected response schema when getting Fastly accounts.
 */
class FastlyAccountsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FastlyAccountsResponse.attributeTypeMap;
    }
}
exports.FastlyAccountsResponse = FastlyAccountsResponse;
/**
 * @ignore
 */
FastlyAccountsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<FastlyAccountResponseData>",
    },
};
//# sourceMappingURL=FastlyAccountsResponse.js.map

/***/ }),

/***/ 8518:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FastlyService = void 0;
/**
 * The schema representation of a Fastly service.
 */
class FastlyService {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FastlyService.attributeTypeMap;
    }
}
exports.FastlyService = FastlyService;
/**
 * @ignore
 */
FastlyService.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
};
//# sourceMappingURL=FastlyService.js.map

/***/ }),

/***/ 83707:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FastlyServiceAttributes = void 0;
/**
 * Attributes object for Fastly service requests.
 */
class FastlyServiceAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FastlyServiceAttributes.attributeTypeMap;
    }
}
exports.FastlyServiceAttributes = FastlyServiceAttributes;
/**
 * @ignore
 */
FastlyServiceAttributes.attributeTypeMap = {
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
};
//# sourceMappingURL=FastlyServiceAttributes.js.map

/***/ }),

/***/ 79404:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FastlyServiceData = void 0;
/**
 * Data object for Fastly service requests.
 */
class FastlyServiceData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FastlyServiceData.attributeTypeMap;
    }
}
exports.FastlyServiceData = FastlyServiceData;
/**
 * @ignore
 */
FastlyServiceData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "FastlyServiceAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "FastlyServiceType",
        required: true,
    },
};
//# sourceMappingURL=FastlyServiceData.js.map

/***/ }),

/***/ 8366:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FastlyServiceRequest = void 0;
/**
 * Payload schema for Fastly service requests.
 */
class FastlyServiceRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FastlyServiceRequest.attributeTypeMap;
    }
}
exports.FastlyServiceRequest = FastlyServiceRequest;
/**
 * @ignore
 */
FastlyServiceRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "FastlyServiceData",
        required: true,
    },
};
//# sourceMappingURL=FastlyServiceRequest.js.map

/***/ }),

/***/ 27210:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FastlyServiceResponse = void 0;
/**
 * The expected response schema when getting a Fastly service.
 */
class FastlyServiceResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FastlyServiceResponse.attributeTypeMap;
    }
}
exports.FastlyServiceResponse = FastlyServiceResponse;
/**
 * @ignore
 */
FastlyServiceResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "FastlyServiceData",
    },
};
//# sourceMappingURL=FastlyServiceResponse.js.map

/***/ }),

/***/ 7220:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FastlyServicesResponse = void 0;
/**
 * The expected response schema when getting Fastly services.
 */
class FastlyServicesResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FastlyServicesResponse.attributeTypeMap;
    }
}
exports.FastlyServicesResponse = FastlyServicesResponse;
/**
 * @ignore
 */
FastlyServicesResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<FastlyServiceResponse>",
    },
};
//# sourceMappingURL=FastlyServicesResponse.js.map

/***/ }),

/***/ 97118:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormulaLimit = void 0;
/**
 * Message for specifying limits to the number of values returned by a query.
 */
class FormulaLimit {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FormulaLimit.attributeTypeMap;
    }
}
exports.FormulaLimit = FormulaLimit;
/**
 * @ignore
 */
FormulaLimit.attributeTypeMap = {
    count: {
        baseName: "count",
        type: "number",
        format: "int32",
    },
    order: {
        baseName: "order",
        type: "QuerySortOrder",
    },
};
//# sourceMappingURL=FormulaLimit.js.map

/***/ }),

/***/ 56159:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FullAPIKey = void 0;
/**
 * Datadog API key.
 */
class FullAPIKey {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FullAPIKey.attributeTypeMap;
    }
}
exports.FullAPIKey = FullAPIKey;
/**
 * @ignore
 */
FullAPIKey.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "FullAPIKeyAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    relationships: {
        baseName: "relationships",
        type: "APIKeyRelationships",
    },
    type: {
        baseName: "type",
        type: "APIKeysType",
    },
};
//# sourceMappingURL=FullAPIKey.js.map

/***/ }),

/***/ 25642:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FullAPIKeyAttributes = void 0;
/**
 * Attributes of a full API key.
 */
class FullAPIKeyAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FullAPIKeyAttributes.attributeTypeMap;
    }
}
exports.FullAPIKeyAttributes = FullAPIKeyAttributes;
/**
 * @ignore
 */
FullAPIKeyAttributes.attributeTypeMap = {
    createdAt: {
        baseName: "created_at",
        type: "string",
    },
    key: {
        baseName: "key",
        type: "string",
    },
    last4: {
        baseName: "last4",
        type: "string",
    },
    modifiedAt: {
        baseName: "modified_at",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=FullAPIKeyAttributes.js.map

/***/ }),

/***/ 54147:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FullApplicationKey = void 0;
/**
 * Datadog application key.
 */
class FullApplicationKey {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FullApplicationKey.attributeTypeMap;
    }
}
exports.FullApplicationKey = FullApplicationKey;
/**
 * @ignore
 */
FullApplicationKey.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "FullApplicationKeyAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    relationships: {
        baseName: "relationships",
        type: "ApplicationKeyRelationships",
    },
    type: {
        baseName: "type",
        type: "ApplicationKeysType",
    },
};
//# sourceMappingURL=FullApplicationKey.js.map

/***/ }),

/***/ 79380:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FullApplicationKeyAttributes = void 0;
/**
 * Attributes of a full application key.
 */
class FullApplicationKeyAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return FullApplicationKeyAttributes.attributeTypeMap;
    }
}
exports.FullApplicationKeyAttributes = FullApplicationKeyAttributes;
/**
 * @ignore
 */
FullApplicationKeyAttributes.attributeTypeMap = {
    createdAt: {
        baseName: "created_at",
        type: "string",
    },
    key: {
        baseName: "key",
        type: "string",
    },
    last4: {
        baseName: "last4",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    scopes: {
        baseName: "scopes",
        type: "Array<string>",
    },
};
//# sourceMappingURL=FullApplicationKeyAttributes.js.map

/***/ }),

/***/ 2189:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GroupScalarColumn = void 0;
/**
 * A column containing the tag keys and values in a group.
 */
class GroupScalarColumn {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return GroupScalarColumn.attributeTypeMap;
    }
}
exports.GroupScalarColumn = GroupScalarColumn;
/**
 * @ignore
 */
GroupScalarColumn.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "string",
    },
    values: {
        baseName: "values",
        type: "Array<Array<string>>",
    },
};
//# sourceMappingURL=GroupScalarColumn.js.map

/***/ }),

/***/ 73991:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HTTPLogError = void 0;
/**
 * List of errors.
 */
class HTTPLogError {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HTTPLogError.attributeTypeMap;
    }
}
exports.HTTPLogError = HTTPLogError;
/**
 * @ignore
 */
HTTPLogError.attributeTypeMap = {
    detail: {
        baseName: "detail",
        type: "string",
    },
    status: {
        baseName: "status",
        type: "string",
    },
    title: {
        baseName: "title",
        type: "string",
    },
};
//# sourceMappingURL=HTTPLogError.js.map

/***/ }),

/***/ 18911:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HTTPLogErrors = void 0;
/**
 * Invalid query performed.
 */
class HTTPLogErrors {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HTTPLogErrors.attributeTypeMap;
    }
}
exports.HTTPLogErrors = HTTPLogErrors;
/**
 * @ignore
 */
HTTPLogErrors.attributeTypeMap = {
    errors: {
        baseName: "errors",
        type: "Array<HTTPLogError>",
    },
};
//# sourceMappingURL=HTTPLogErrors.js.map

/***/ }),

/***/ 40312:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HTTPLogItem = void 0;
/**
 * Logs that are sent over HTTP.
 */
class HTTPLogItem {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HTTPLogItem.attributeTypeMap;
    }
}
exports.HTTPLogItem = HTTPLogItem;
/**
 * @ignore
 */
HTTPLogItem.attributeTypeMap = {
    ddsource: {
        baseName: "ddsource",
        type: "string",
    },
    ddtags: {
        baseName: "ddtags",
        type: "string",
    },
    hostname: {
        baseName: "hostname",
        type: "string",
    },
    message: {
        baseName: "message",
        type: "string",
        required: true,
    },
    service: {
        baseName: "service",
        type: "string",
    },
    additionalProperties: {
        baseName: "additionalProperties",
        type: "string",
    },
};
//# sourceMappingURL=HTTPLogItem.js.map

/***/ }),

/***/ 26722:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HourlyUsage = void 0;
/**
 * Hourly usage for a product family for an org.
 */
class HourlyUsage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HourlyUsage.attributeTypeMap;
    }
}
exports.HourlyUsage = HourlyUsage;
/**
 * @ignore
 */
HourlyUsage.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "HourlyUsageAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "UsageTimeSeriesType",
    },
};
//# sourceMappingURL=HourlyUsage.js.map

/***/ }),

/***/ 89886:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HourlyUsageAttributes = void 0;
/**
 * Attributes of hourly usage for a product family for an org for a time period.
 */
class HourlyUsageAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HourlyUsageAttributes.attributeTypeMap;
    }
}
exports.HourlyUsageAttributes = HourlyUsageAttributes;
/**
 * @ignore
 */
HourlyUsageAttributes.attributeTypeMap = {
    measurements: {
        baseName: "measurements",
        type: "Array<HourlyUsageMeasurement>",
    },
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    productFamily: {
        baseName: "product_family",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    region: {
        baseName: "region",
        type: "string",
    },
    timestamp: {
        baseName: "timestamp",
        type: "Date",
        format: "date-time",
    },
};
//# sourceMappingURL=HourlyUsageAttributes.js.map

/***/ }),

/***/ 45509:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HourlyUsageMeasurement = void 0;
/**
 * Usage amount for a given usage type.
 */
class HourlyUsageMeasurement {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HourlyUsageMeasurement.attributeTypeMap;
    }
}
exports.HourlyUsageMeasurement = HourlyUsageMeasurement;
/**
 * @ignore
 */
HourlyUsageMeasurement.attributeTypeMap = {
    usageType: {
        baseName: "usage_type",
        type: "string",
    },
    value: {
        baseName: "value",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=HourlyUsageMeasurement.js.map

/***/ }),

/***/ 12821:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HourlyUsageMetadata = void 0;
/**
 * The object containing document metadata.
 */
class HourlyUsageMetadata {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HourlyUsageMetadata.attributeTypeMap;
    }
}
exports.HourlyUsageMetadata = HourlyUsageMetadata;
/**
 * @ignore
 */
HourlyUsageMetadata.attributeTypeMap = {
    pagination: {
        baseName: "pagination",
        type: "HourlyUsagePagination",
    },
};
//# sourceMappingURL=HourlyUsageMetadata.js.map

/***/ }),

/***/ 79406:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HourlyUsagePagination = void 0;
/**
 * The metadata for the current pagination.
 */
class HourlyUsagePagination {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HourlyUsagePagination.attributeTypeMap;
    }
}
exports.HourlyUsagePagination = HourlyUsagePagination;
/**
 * @ignore
 */
HourlyUsagePagination.attributeTypeMap = {
    nextRecordId: {
        baseName: "next_record_id",
        type: "string",
    },
};
//# sourceMappingURL=HourlyUsagePagination.js.map

/***/ }),

/***/ 70015:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HourlyUsageResponse = void 0;
/**
 * Hourly usage response.
 */
class HourlyUsageResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return HourlyUsageResponse.attributeTypeMap;
    }
}
exports.HourlyUsageResponse = HourlyUsageResponse;
/**
 * @ignore
 */
HourlyUsageResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<HourlyUsage>",
    },
    meta: {
        baseName: "meta",
        type: "HourlyUsageMetadata",
    },
};
//# sourceMappingURL=HourlyUsageResponse.js.map

/***/ }),

/***/ 68145:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IdPMetadataFormData = void 0;
/**
 * The form data submitted to upload IdP metadata
 */
class IdPMetadataFormData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IdPMetadataFormData.attributeTypeMap;
    }
}
exports.IdPMetadataFormData = IdPMetadataFormData;
/**
 * @ignore
 */
IdPMetadataFormData.attributeTypeMap = {
    idpFile: {
        baseName: "idp_file",
        type: "HttpFile",
        format: "binary",
    },
};
//# sourceMappingURL=IdPMetadataFormData.js.map

/***/ }),

/***/ 25208:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentAttachmentData = void 0;
/**
 * A single incident attachment.
 */
class IncidentAttachmentData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentAttachmentData.attributeTypeMap;
    }
}
exports.IncidentAttachmentData = IncidentAttachmentData;
/**
 * @ignore
 */
IncidentAttachmentData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "IncidentAttachmentAttributes",
        required: true,
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    relationships: {
        baseName: "relationships",
        type: "IncidentAttachmentRelationships",
        required: true,
    },
    type: {
        baseName: "type",
        type: "IncidentAttachmentType",
        required: true,
    },
};
//# sourceMappingURL=IncidentAttachmentData.js.map

/***/ }),

/***/ 78737:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentAttachmentLinkAttributes = void 0;
/**
 * The attributes object for a link attachment.
 */
class IncidentAttachmentLinkAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentAttachmentLinkAttributes.attributeTypeMap;
    }
}
exports.IncidentAttachmentLinkAttributes = IncidentAttachmentLinkAttributes;
/**
 * @ignore
 */
IncidentAttachmentLinkAttributes.attributeTypeMap = {
    attachment: {
        baseName: "attachment",
        type: "IncidentAttachmentLinkAttributesAttachmentObject",
        required: true,
    },
    attachmentType: {
        baseName: "attachment_type",
        type: "IncidentAttachmentLinkAttachmentType",
        required: true,
    },
};
//# sourceMappingURL=IncidentAttachmentLinkAttributes.js.map

/***/ }),

/***/ 12645:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentAttachmentLinkAttributesAttachmentObject = void 0;
/**
 * The link attachment.
 */
class IncidentAttachmentLinkAttributesAttachmentObject {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentAttachmentLinkAttributesAttachmentObject.attributeTypeMap;
    }
}
exports.IncidentAttachmentLinkAttributesAttachmentObject = IncidentAttachmentLinkAttributesAttachmentObject;
/**
 * @ignore
 */
IncidentAttachmentLinkAttributesAttachmentObject.attributeTypeMap = {
    documentUrl: {
        baseName: "documentUrl",
        type: "string",
        required: true,
    },
    title: {
        baseName: "title",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=IncidentAttachmentLinkAttributesAttachmentObject.js.map

/***/ }),

/***/ 14721:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentAttachmentPostmortemAttributes = void 0;
/**
 * The attributes object for a postmortem attachment.
 */
class IncidentAttachmentPostmortemAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentAttachmentPostmortemAttributes.attributeTypeMap;
    }
}
exports.IncidentAttachmentPostmortemAttributes = IncidentAttachmentPostmortemAttributes;
/**
 * @ignore
 */
IncidentAttachmentPostmortemAttributes.attributeTypeMap = {
    attachment: {
        baseName: "attachment",
        type: "IncidentAttachmentsPostmortemAttributesAttachmentObject",
        required: true,
    },
    attachmentType: {
        baseName: "attachment_type",
        type: "IncidentAttachmentPostmortemAttachmentType",
        required: true,
    },
};
//# sourceMappingURL=IncidentAttachmentPostmortemAttributes.js.map

/***/ }),

/***/ 11967:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentAttachmentRelationships = void 0;
/**
 * The incident attachment's relationships.
 */
class IncidentAttachmentRelationships {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentAttachmentRelationships.attributeTypeMap;
    }
}
exports.IncidentAttachmentRelationships = IncidentAttachmentRelationships;
/**
 * @ignore
 */
IncidentAttachmentRelationships.attributeTypeMap = {
    lastModifiedByUser: {
        baseName: "last_modified_by_user",
        type: "RelationshipToUser",
    },
};
//# sourceMappingURL=IncidentAttachmentRelationships.js.map

/***/ }),

/***/ 36350:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentAttachmentUpdateData = void 0;
/**
 * A single incident attachment.
 */
class IncidentAttachmentUpdateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentAttachmentUpdateData.attributeTypeMap;
    }
}
exports.IncidentAttachmentUpdateData = IncidentAttachmentUpdateData;
/**
 * @ignore
 */
IncidentAttachmentUpdateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "IncidentAttachmentUpdateAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "IncidentAttachmentType",
        required: true,
    },
};
//# sourceMappingURL=IncidentAttachmentUpdateData.js.map

/***/ }),

/***/ 72450:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentAttachmentUpdateRequest = void 0;
/**
 * The update request for an incident's attachments.
 */
class IncidentAttachmentUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentAttachmentUpdateRequest.attributeTypeMap;
    }
}
exports.IncidentAttachmentUpdateRequest = IncidentAttachmentUpdateRequest;
/**
 * @ignore
 */
IncidentAttachmentUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<IncidentAttachmentUpdateData>",
        required: true,
    },
};
//# sourceMappingURL=IncidentAttachmentUpdateRequest.js.map

/***/ }),

/***/ 23453:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentAttachmentUpdateResponse = void 0;
/**
 * The response object containing the created or updated incident attachments.
 */
class IncidentAttachmentUpdateResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentAttachmentUpdateResponse.attributeTypeMap;
    }
}
exports.IncidentAttachmentUpdateResponse = IncidentAttachmentUpdateResponse;
/**
 * @ignore
 */
IncidentAttachmentUpdateResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<IncidentAttachmentData>",
        required: true,
    },
    included: {
        baseName: "included",
        type: "Array<IncidentAttachmentsResponseIncludedItem>",
    },
};
//# sourceMappingURL=IncidentAttachmentUpdateResponse.js.map

/***/ }),

/***/ 46618:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentAttachmentsPostmortemAttributesAttachmentObject = void 0;
/**
 * The postmortem attachment.
 */
class IncidentAttachmentsPostmortemAttributesAttachmentObject {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentAttachmentsPostmortemAttributesAttachmentObject.attributeTypeMap;
    }
}
exports.IncidentAttachmentsPostmortemAttributesAttachmentObject = IncidentAttachmentsPostmortemAttributesAttachmentObject;
/**
 * @ignore
 */
IncidentAttachmentsPostmortemAttributesAttachmentObject.attributeTypeMap = {
    documentUrl: {
        baseName: "documentUrl",
        type: "string",
        required: true,
    },
    title: {
        baseName: "title",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=IncidentAttachmentsPostmortemAttributesAttachmentObject.js.map

/***/ }),

/***/ 37959:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentAttachmentsResponse = void 0;
/**
 * The response object containing an incident's attachments.
 */
class IncidentAttachmentsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentAttachmentsResponse.attributeTypeMap;
    }
}
exports.IncidentAttachmentsResponse = IncidentAttachmentsResponse;
/**
 * @ignore
 */
IncidentAttachmentsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<IncidentAttachmentData>",
        required: true,
    },
    included: {
        baseName: "included",
        type: "Array<IncidentAttachmentsResponseIncludedItem>",
    },
};
//# sourceMappingURL=IncidentAttachmentsResponse.js.map

/***/ }),

/***/ 85021:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentCreateAttributes = void 0;
/**
 * The incident's attributes for a create request.
 */
class IncidentCreateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentCreateAttributes.attributeTypeMap;
    }
}
exports.IncidentCreateAttributes = IncidentCreateAttributes;
/**
 * @ignore
 */
IncidentCreateAttributes.attributeTypeMap = {
    customerImpacted: {
        baseName: "customer_impacted",
        type: "boolean",
        required: true,
    },
    fields: {
        baseName: "fields",
        type: "{ [key: string]: IncidentFieldAttributes; }",
    },
    initialCells: {
        baseName: "initial_cells",
        type: "Array<IncidentTimelineCellCreateAttributes>",
    },
    notificationHandles: {
        baseName: "notification_handles",
        type: "Array<IncidentNotificationHandle>",
    },
    title: {
        baseName: "title",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=IncidentCreateAttributes.js.map

/***/ }),

/***/ 33708:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentCreateData = void 0;
/**
 * Incident data for a create request.
 */
class IncidentCreateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentCreateData.attributeTypeMap;
    }
}
exports.IncidentCreateData = IncidentCreateData;
/**
 * @ignore
 */
IncidentCreateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "IncidentCreateAttributes",
        required: true,
    },
    relationships: {
        baseName: "relationships",
        type: "IncidentCreateRelationships",
    },
    type: {
        baseName: "type",
        type: "IncidentType",
        required: true,
    },
};
//# sourceMappingURL=IncidentCreateData.js.map

/***/ }),

/***/ 87980:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentCreateRelationships = void 0;
/**
 * The relationships the incident will have with other resources once created.
 */
class IncidentCreateRelationships {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentCreateRelationships.attributeTypeMap;
    }
}
exports.IncidentCreateRelationships = IncidentCreateRelationships;
/**
 * @ignore
 */
IncidentCreateRelationships.attributeTypeMap = {
    commanderUser: {
        baseName: "commander_user",
        type: "NullableRelationshipToUser",
        required: true,
    },
};
//# sourceMappingURL=IncidentCreateRelationships.js.map

/***/ }),

/***/ 79893:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentCreateRequest = void 0;
/**
 * Create request for an incident.
 */
class IncidentCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentCreateRequest.attributeTypeMap;
    }
}
exports.IncidentCreateRequest = IncidentCreateRequest;
/**
 * @ignore
 */
IncidentCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "IncidentCreateData",
        required: true,
    },
};
//# sourceMappingURL=IncidentCreateRequest.js.map

/***/ }),

/***/ 85167:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentFieldAttributesMultipleValue = void 0;
/**
 * A field with potentially multiple values selected.
 */
class IncidentFieldAttributesMultipleValue {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentFieldAttributesMultipleValue.attributeTypeMap;
    }
}
exports.IncidentFieldAttributesMultipleValue = IncidentFieldAttributesMultipleValue;
/**
 * @ignore
 */
IncidentFieldAttributesMultipleValue.attributeTypeMap = {
    type: {
        baseName: "type",
        type: "IncidentFieldAttributesValueType",
    },
    value: {
        baseName: "value",
        type: "Array<string>",
    },
};
//# sourceMappingURL=IncidentFieldAttributesMultipleValue.js.map

/***/ }),

/***/ 65717:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentFieldAttributesSingleValue = void 0;
/**
 * A field with a single value selected.
 */
class IncidentFieldAttributesSingleValue {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentFieldAttributesSingleValue.attributeTypeMap;
    }
}
exports.IncidentFieldAttributesSingleValue = IncidentFieldAttributesSingleValue;
/**
 * @ignore
 */
IncidentFieldAttributesSingleValue.attributeTypeMap = {
    type: {
        baseName: "type",
        type: "IncidentFieldAttributesSingleValueType",
    },
    value: {
        baseName: "value",
        type: "string",
    },
};
//# sourceMappingURL=IncidentFieldAttributesSingleValue.js.map

/***/ }),

/***/ 64132:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentNotificationHandle = void 0;
/**
 * A notification handle that will be notified at incident creation.
 */
class IncidentNotificationHandle {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentNotificationHandle.attributeTypeMap;
    }
}
exports.IncidentNotificationHandle = IncidentNotificationHandle;
/**
 * @ignore
 */
IncidentNotificationHandle.attributeTypeMap = {
    displayName: {
        baseName: "display_name",
        type: "string",
    },
    handle: {
        baseName: "handle",
        type: "string",
    },
};
//# sourceMappingURL=IncidentNotificationHandle.js.map

/***/ }),

/***/ 85933:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentResponse = void 0;
/**
 * Response with an incident.
 */
class IncidentResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentResponse.attributeTypeMap;
    }
}
exports.IncidentResponse = IncidentResponse;
/**
 * @ignore
 */
IncidentResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "IncidentResponseData",
        required: true,
    },
    included: {
        baseName: "included",
        type: "Array<IncidentResponseIncludedItem>",
    },
};
//# sourceMappingURL=IncidentResponse.js.map

/***/ }),

/***/ 72948:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentResponseAttributes = void 0;
/**
 * The incident's attributes from a response.
 */
class IncidentResponseAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentResponseAttributes.attributeTypeMap;
    }
}
exports.IncidentResponseAttributes = IncidentResponseAttributes;
/**
 * @ignore
 */
IncidentResponseAttributes.attributeTypeMap = {
    created: {
        baseName: "created",
        type: "Date",
        format: "date-time",
    },
    customerImpactDuration: {
        baseName: "customer_impact_duration",
        type: "number",
        format: "int64",
    },
    customerImpactEnd: {
        baseName: "customer_impact_end",
        type: "Date",
        format: "date-time",
    },
    customerImpactScope: {
        baseName: "customer_impact_scope",
        type: "string",
    },
    customerImpactStart: {
        baseName: "customer_impact_start",
        type: "Date",
        format: "date-time",
    },
    customerImpacted: {
        baseName: "customer_impacted",
        type: "boolean",
    },
    detected: {
        baseName: "detected",
        type: "Date",
        format: "date-time",
    },
    fields: {
        baseName: "fields",
        type: "{ [key: string]: IncidentFieldAttributes; }",
    },
    modified: {
        baseName: "modified",
        type: "Date",
        format: "date-time",
    },
    notificationHandles: {
        baseName: "notification_handles",
        type: "Array<IncidentNotificationHandle>",
    },
    publicId: {
        baseName: "public_id",
        type: "number",
        format: "int64",
    },
    resolved: {
        baseName: "resolved",
        type: "Date",
        format: "date-time",
    },
    timeToDetect: {
        baseName: "time_to_detect",
        type: "number",
        format: "int64",
    },
    timeToInternalResponse: {
        baseName: "time_to_internal_response",
        type: "number",
        format: "int64",
    },
    timeToRepair: {
        baseName: "time_to_repair",
        type: "number",
        format: "int64",
    },
    timeToResolve: {
        baseName: "time_to_resolve",
        type: "number",
        format: "int64",
    },
    title: {
        baseName: "title",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=IncidentResponseAttributes.js.map

/***/ }),

/***/ 20274:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentResponseData = void 0;
/**
 * Incident data from a response.
 */
class IncidentResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentResponseData.attributeTypeMap;
    }
}
exports.IncidentResponseData = IncidentResponseData;
/**
 * @ignore
 */
IncidentResponseData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "IncidentResponseAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    relationships: {
        baseName: "relationships",
        type: "IncidentResponseRelationships",
    },
    type: {
        baseName: "type",
        type: "IncidentType",
        required: true,
    },
};
//# sourceMappingURL=IncidentResponseData.js.map

/***/ }),

/***/ 16729:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentResponseMeta = void 0;
/**
 * The metadata object containing pagination metadata.
 */
class IncidentResponseMeta {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentResponseMeta.attributeTypeMap;
    }
}
exports.IncidentResponseMeta = IncidentResponseMeta;
/**
 * @ignore
 */
IncidentResponseMeta.attributeTypeMap = {
    pagination: {
        baseName: "pagination",
        type: "IncidentResponseMetaPagination",
    },
};
//# sourceMappingURL=IncidentResponseMeta.js.map

/***/ }),

/***/ 97345:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentResponseMetaPagination = void 0;
/**
 * Pagination properties.
 */
class IncidentResponseMetaPagination {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentResponseMetaPagination.attributeTypeMap;
    }
}
exports.IncidentResponseMetaPagination = IncidentResponseMetaPagination;
/**
 * @ignore
 */
IncidentResponseMetaPagination.attributeTypeMap = {
    nextOffset: {
        baseName: "next_offset",
        type: "number",
        format: "int64",
    },
    offset: {
        baseName: "offset",
        type: "number",
        format: "int64",
    },
    size: {
        baseName: "size",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=IncidentResponseMetaPagination.js.map

/***/ }),

/***/ 88233:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentResponseRelationships = void 0;
/**
 * The incident's relationships from a response.
 */
class IncidentResponseRelationships {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentResponseRelationships.attributeTypeMap;
    }
}
exports.IncidentResponseRelationships = IncidentResponseRelationships;
/**
 * @ignore
 */
IncidentResponseRelationships.attributeTypeMap = {
    attachments: {
        baseName: "attachments",
        type: "RelationshipToIncidentAttachment",
    },
    commanderUser: {
        baseName: "commander_user",
        type: "NullableRelationshipToUser",
    },
    createdByUser: {
        baseName: "created_by_user",
        type: "RelationshipToUser",
    },
    integrations: {
        baseName: "integrations",
        type: "RelationshipToIncidentIntegrationMetadatas",
    },
    lastModifiedByUser: {
        baseName: "last_modified_by_user",
        type: "RelationshipToUser",
    },
};
//# sourceMappingURL=IncidentResponseRelationships.js.map

/***/ }),

/***/ 89998:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentSearchResponse = void 0;
/**
 * Response with incidents and facets.
 */
class IncidentSearchResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentSearchResponse.attributeTypeMap;
    }
}
exports.IncidentSearchResponse = IncidentSearchResponse;
/**
 * @ignore
 */
IncidentSearchResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "IncidentSearchResponseData",
        required: true,
    },
    included: {
        baseName: "included",
        type: "Array<IncidentResponseIncludedItem>",
    },
};
//# sourceMappingURL=IncidentSearchResponse.js.map

/***/ }),

/***/ 56435:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentSearchResponseAttributes = void 0;
/**
 * Attributes returned by an incident search.
 */
class IncidentSearchResponseAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentSearchResponseAttributes.attributeTypeMap;
    }
}
exports.IncidentSearchResponseAttributes = IncidentSearchResponseAttributes;
/**
 * @ignore
 */
IncidentSearchResponseAttributes.attributeTypeMap = {
    facets: {
        baseName: "facets",
        type: "IncidentSearchResponseFacetsData",
        required: true,
    },
    incidents: {
        baseName: "incidents",
        type: "Array<IncidentSearchResponseIncidentsData>",
        required: true,
    },
    total: {
        baseName: "total",
        type: "number",
        required: true,
        format: "int32",
    },
};
//# sourceMappingURL=IncidentSearchResponseAttributes.js.map

/***/ }),

/***/ 24443:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentSearchResponseData = void 0;
/**
 * Data returned by an incident search.
 */
class IncidentSearchResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentSearchResponseData.attributeTypeMap;
    }
}
exports.IncidentSearchResponseData = IncidentSearchResponseData;
/**
 * @ignore
 */
IncidentSearchResponseData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "IncidentSearchResponseAttributes",
    },
    type: {
        baseName: "type",
        type: "IncidentSearchResultsType",
    },
};
//# sourceMappingURL=IncidentSearchResponseData.js.map

/***/ }),

/***/ 42940:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentSearchResponseFacetsData = void 0;
/**
 * Facet data for incidents returned by a search query.
 */
class IncidentSearchResponseFacetsData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentSearchResponseFacetsData.attributeTypeMap;
    }
}
exports.IncidentSearchResponseFacetsData = IncidentSearchResponseFacetsData;
/**
 * @ignore
 */
IncidentSearchResponseFacetsData.attributeTypeMap = {
    commander: {
        baseName: "commander",
        type: "Array<IncidentSearchResponseUserFacetData>",
    },
    createdBy: {
        baseName: "created_by",
        type: "Array<IncidentSearchResponseUserFacetData>",
    },
    fields: {
        baseName: "fields",
        type: "Array<IncidentSearchResponsePropertyFieldFacetData>",
    },
    impact: {
        baseName: "impact",
        type: "Array<IncidentSearchResponseFieldFacetData>",
    },
    lastModifiedBy: {
        baseName: "last_modified_by",
        type: "Array<IncidentSearchResponseUserFacetData>",
    },
    postmortem: {
        baseName: "postmortem",
        type: "Array<IncidentSearchResponseFieldFacetData>",
    },
    responder: {
        baseName: "responder",
        type: "Array<IncidentSearchResponseUserFacetData>",
    },
    severity: {
        baseName: "severity",
        type: "Array<IncidentSearchResponseFieldFacetData>",
    },
    state: {
        baseName: "state",
        type: "Array<IncidentSearchResponseFieldFacetData>",
    },
    timeToRepair: {
        baseName: "time_to_repair",
        type: "Array<IncidentSearchResponseNumericFacetData>",
    },
    timeToResolve: {
        baseName: "time_to_resolve",
        type: "Array<IncidentSearchResponseNumericFacetData>",
    },
};
//# sourceMappingURL=IncidentSearchResponseFacetsData.js.map

/***/ }),

/***/ 90951:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentSearchResponseFieldFacetData = void 0;
/**
 * Facet value and number of occurrences for a property field of an incident.
 */
class IncidentSearchResponseFieldFacetData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentSearchResponseFieldFacetData.attributeTypeMap;
    }
}
exports.IncidentSearchResponseFieldFacetData = IncidentSearchResponseFieldFacetData;
/**
 * @ignore
 */
IncidentSearchResponseFieldFacetData.attributeTypeMap = {
    count: {
        baseName: "count",
        type: "number",
        format: "int32",
    },
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=IncidentSearchResponseFieldFacetData.js.map

/***/ }),

/***/ 16704:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentSearchResponseIncidentsData = void 0;
/**
 * Incident returned by the search.
 */
class IncidentSearchResponseIncidentsData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentSearchResponseIncidentsData.attributeTypeMap;
    }
}
exports.IncidentSearchResponseIncidentsData = IncidentSearchResponseIncidentsData;
/**
 * @ignore
 */
IncidentSearchResponseIncidentsData.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "IncidentResponseData",
        required: true,
    },
};
//# sourceMappingURL=IncidentSearchResponseIncidentsData.js.map

/***/ }),

/***/ 15843:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentSearchResponseNumericFacetData = void 0;
/**
 * Facet data numeric attributes of an incident.
 */
class IncidentSearchResponseNumericFacetData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentSearchResponseNumericFacetData.attributeTypeMap;
    }
}
exports.IncidentSearchResponseNumericFacetData = IncidentSearchResponseNumericFacetData;
/**
 * @ignore
 */
IncidentSearchResponseNumericFacetData.attributeTypeMap = {
    aggregates: {
        baseName: "aggregates",
        type: "IncidentSearchResponseNumericFacetDataAggregates",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=IncidentSearchResponseNumericFacetData.js.map

/***/ }),

/***/ 9253:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentSearchResponseNumericFacetDataAggregates = void 0;
/**
 * Aggregate information for numeric incident data.
 */
class IncidentSearchResponseNumericFacetDataAggregates {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentSearchResponseNumericFacetDataAggregates.attributeTypeMap;
    }
}
exports.IncidentSearchResponseNumericFacetDataAggregates = IncidentSearchResponseNumericFacetDataAggregates;
/**
 * @ignore
 */
IncidentSearchResponseNumericFacetDataAggregates.attributeTypeMap = {
    max: {
        baseName: "max",
        type: "number",
        format: "double",
    },
    min: {
        baseName: "min",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=IncidentSearchResponseNumericFacetDataAggregates.js.map

/***/ }),

/***/ 23290:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentSearchResponsePropertyFieldFacetData = void 0;
/**
 * Facet data for the incident property fields.
 */
class IncidentSearchResponsePropertyFieldFacetData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentSearchResponsePropertyFieldFacetData.attributeTypeMap;
    }
}
exports.IncidentSearchResponsePropertyFieldFacetData = IncidentSearchResponsePropertyFieldFacetData;
/**
 * @ignore
 */
IncidentSearchResponsePropertyFieldFacetData.attributeTypeMap = {
    aggregates: {
        baseName: "aggregates",
        type: "IncidentSearchResponseNumericFacetDataAggregates",
    },
    facets: {
        baseName: "facets",
        type: "Array<IncidentSearchResponseFieldFacetData>",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=IncidentSearchResponsePropertyFieldFacetData.js.map

/***/ }),

/***/ 64690:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentSearchResponseUserFacetData = void 0;
/**
 * Facet data for user attributes of an incident.
 */
class IncidentSearchResponseUserFacetData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentSearchResponseUserFacetData.attributeTypeMap;
    }
}
exports.IncidentSearchResponseUserFacetData = IncidentSearchResponseUserFacetData;
/**
 * @ignore
 */
IncidentSearchResponseUserFacetData.attributeTypeMap = {
    count: {
        baseName: "count",
        type: "number",
        format: "int32",
    },
    email: {
        baseName: "email",
        type: "string",
    },
    handle: {
        baseName: "handle",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    uuid: {
        baseName: "uuid",
        type: "string",
    },
};
//# sourceMappingURL=IncidentSearchResponseUserFacetData.js.map

/***/ }),

/***/ 81262:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentServiceCreateAttributes = void 0;
/**
 * The incident service's attributes for a create request.
 */
class IncidentServiceCreateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentServiceCreateAttributes.attributeTypeMap;
    }
}
exports.IncidentServiceCreateAttributes = IncidentServiceCreateAttributes;
/**
 * @ignore
 */
IncidentServiceCreateAttributes.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=IncidentServiceCreateAttributes.js.map

/***/ }),

/***/ 50275:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentServiceCreateData = void 0;
/**
 * Incident Service payload for create requests.
 */
class IncidentServiceCreateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentServiceCreateData.attributeTypeMap;
    }
}
exports.IncidentServiceCreateData = IncidentServiceCreateData;
/**
 * @ignore
 */
IncidentServiceCreateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "IncidentServiceCreateAttributes",
    },
    relationships: {
        baseName: "relationships",
        type: "IncidentServiceRelationships",
    },
    type: {
        baseName: "type",
        type: "IncidentServiceType",
        required: true,
    },
};
//# sourceMappingURL=IncidentServiceCreateData.js.map

/***/ }),

/***/ 61042:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentServiceCreateRequest = void 0;
/**
 * Create request with an incident service payload.
 */
class IncidentServiceCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentServiceCreateRequest.attributeTypeMap;
    }
}
exports.IncidentServiceCreateRequest = IncidentServiceCreateRequest;
/**
 * @ignore
 */
IncidentServiceCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "IncidentServiceCreateData",
        required: true,
    },
};
//# sourceMappingURL=IncidentServiceCreateRequest.js.map

/***/ }),

/***/ 67742:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentServiceRelationships = void 0;
/**
 * The incident service's relationships.
 */
class IncidentServiceRelationships {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentServiceRelationships.attributeTypeMap;
    }
}
exports.IncidentServiceRelationships = IncidentServiceRelationships;
/**
 * @ignore
 */
IncidentServiceRelationships.attributeTypeMap = {
    createdBy: {
        baseName: "created_by",
        type: "RelationshipToUser",
    },
    lastModifiedBy: {
        baseName: "last_modified_by",
        type: "RelationshipToUser",
    },
};
//# sourceMappingURL=IncidentServiceRelationships.js.map

/***/ }),

/***/ 8010:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentServiceResponse = void 0;
/**
 * Response with an incident service payload.
 */
class IncidentServiceResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentServiceResponse.attributeTypeMap;
    }
}
exports.IncidentServiceResponse = IncidentServiceResponse;
/**
 * @ignore
 */
IncidentServiceResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "IncidentServiceResponseData",
        required: true,
    },
    included: {
        baseName: "included",
        type: "Array<IncidentServiceIncludedItems>",
    },
};
//# sourceMappingURL=IncidentServiceResponse.js.map

/***/ }),

/***/ 64840:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentServiceResponseAttributes = void 0;
/**
 * The incident service's attributes from a response.
 */
class IncidentServiceResponseAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentServiceResponseAttributes.attributeTypeMap;
    }
}
exports.IncidentServiceResponseAttributes = IncidentServiceResponseAttributes;
/**
 * @ignore
 */
IncidentServiceResponseAttributes.attributeTypeMap = {
    created: {
        baseName: "created",
        type: "Date",
        format: "date-time",
    },
    modified: {
        baseName: "modified",
        type: "Date",
        format: "date-time",
    },
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=IncidentServiceResponseAttributes.js.map

/***/ }),

/***/ 13259:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentServiceResponseData = void 0;
/**
 * Incident Service data from responses.
 */
class IncidentServiceResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentServiceResponseData.attributeTypeMap;
    }
}
exports.IncidentServiceResponseData = IncidentServiceResponseData;
/**
 * @ignore
 */
IncidentServiceResponseData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "IncidentServiceResponseAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    relationships: {
        baseName: "relationships",
        type: "IncidentServiceRelationships",
    },
    type: {
        baseName: "type",
        type: "IncidentServiceType",
        required: true,
    },
};
//# sourceMappingURL=IncidentServiceResponseData.js.map

/***/ }),

/***/ 2935:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentServiceUpdateAttributes = void 0;
/**
 * The incident service's attributes for an update request.
 */
class IncidentServiceUpdateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentServiceUpdateAttributes.attributeTypeMap;
    }
}
exports.IncidentServiceUpdateAttributes = IncidentServiceUpdateAttributes;
/**
 * @ignore
 */
IncidentServiceUpdateAttributes.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=IncidentServiceUpdateAttributes.js.map

/***/ }),

/***/ 63215:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentServiceUpdateData = void 0;
/**
 * Incident Service payload for update requests.
 */
class IncidentServiceUpdateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentServiceUpdateData.attributeTypeMap;
    }
}
exports.IncidentServiceUpdateData = IncidentServiceUpdateData;
/**
 * @ignore
 */
IncidentServiceUpdateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "IncidentServiceUpdateAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    relationships: {
        baseName: "relationships",
        type: "IncidentServiceRelationships",
    },
    type: {
        baseName: "type",
        type: "IncidentServiceType",
        required: true,
    },
};
//# sourceMappingURL=IncidentServiceUpdateData.js.map

/***/ }),

/***/ 97971:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentServiceUpdateRequest = void 0;
/**
 * Update request with an incident service payload.
 */
class IncidentServiceUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentServiceUpdateRequest.attributeTypeMap;
    }
}
exports.IncidentServiceUpdateRequest = IncidentServiceUpdateRequest;
/**
 * @ignore
 */
IncidentServiceUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "IncidentServiceUpdateData",
        required: true,
    },
};
//# sourceMappingURL=IncidentServiceUpdateRequest.js.map

/***/ }),

/***/ 67102:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentServicesResponse = void 0;
/**
 * Response with a list of incident service payloads.
 */
class IncidentServicesResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentServicesResponse.attributeTypeMap;
    }
}
exports.IncidentServicesResponse = IncidentServicesResponse;
/**
 * @ignore
 */
IncidentServicesResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<IncidentServiceResponseData>",
        required: true,
    },
    included: {
        baseName: "included",
        type: "Array<IncidentServiceIncludedItems>",
    },
    meta: {
        baseName: "meta",
        type: "IncidentResponseMeta",
    },
};
//# sourceMappingURL=IncidentServicesResponse.js.map

/***/ }),

/***/ 20944:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentTeamCreateAttributes = void 0;
/**
 * The incident team's attributes for a create request.
 */
class IncidentTeamCreateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentTeamCreateAttributes.attributeTypeMap;
    }
}
exports.IncidentTeamCreateAttributes = IncidentTeamCreateAttributes;
/**
 * @ignore
 */
IncidentTeamCreateAttributes.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=IncidentTeamCreateAttributes.js.map

/***/ }),

/***/ 83456:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentTeamCreateData = void 0;
/**
 * Incident Team data for a create request.
 */
class IncidentTeamCreateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentTeamCreateData.attributeTypeMap;
    }
}
exports.IncidentTeamCreateData = IncidentTeamCreateData;
/**
 * @ignore
 */
IncidentTeamCreateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "IncidentTeamCreateAttributes",
    },
    relationships: {
        baseName: "relationships",
        type: "IncidentTeamRelationships",
    },
    type: {
        baseName: "type",
        type: "IncidentTeamType",
        required: true,
    },
};
//# sourceMappingURL=IncidentTeamCreateData.js.map

/***/ }),

/***/ 46712:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentTeamCreateRequest = void 0;
/**
 * Create request with an incident team payload.
 */
class IncidentTeamCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentTeamCreateRequest.attributeTypeMap;
    }
}
exports.IncidentTeamCreateRequest = IncidentTeamCreateRequest;
/**
 * @ignore
 */
IncidentTeamCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "IncidentTeamCreateData",
        required: true,
    },
};
//# sourceMappingURL=IncidentTeamCreateRequest.js.map

/***/ }),

/***/ 31266:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentTeamRelationships = void 0;
/**
 * The incident team's relationships.
 */
class IncidentTeamRelationships {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentTeamRelationships.attributeTypeMap;
    }
}
exports.IncidentTeamRelationships = IncidentTeamRelationships;
/**
 * @ignore
 */
IncidentTeamRelationships.attributeTypeMap = {
    createdBy: {
        baseName: "created_by",
        type: "RelationshipToUser",
    },
    lastModifiedBy: {
        baseName: "last_modified_by",
        type: "RelationshipToUser",
    },
};
//# sourceMappingURL=IncidentTeamRelationships.js.map

/***/ }),

/***/ 88841:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentTeamResponse = void 0;
/**
 * Response with an incident team payload.
 */
class IncidentTeamResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentTeamResponse.attributeTypeMap;
    }
}
exports.IncidentTeamResponse = IncidentTeamResponse;
/**
 * @ignore
 */
IncidentTeamResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "IncidentTeamResponseData",
        required: true,
    },
    included: {
        baseName: "included",
        type: "Array<IncidentTeamIncludedItems>",
    },
};
//# sourceMappingURL=IncidentTeamResponse.js.map

/***/ }),

/***/ 13482:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentTeamResponseAttributes = void 0;
/**
 * The incident team's attributes from a response.
 */
class IncidentTeamResponseAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentTeamResponseAttributes.attributeTypeMap;
    }
}
exports.IncidentTeamResponseAttributes = IncidentTeamResponseAttributes;
/**
 * @ignore
 */
IncidentTeamResponseAttributes.attributeTypeMap = {
    created: {
        baseName: "created",
        type: "Date",
        format: "date-time",
    },
    modified: {
        baseName: "modified",
        type: "Date",
        format: "date-time",
    },
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=IncidentTeamResponseAttributes.js.map

/***/ }),

/***/ 79651:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentTeamResponseData = void 0;
/**
 * Incident Team data from a response.
 */
class IncidentTeamResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentTeamResponseData.attributeTypeMap;
    }
}
exports.IncidentTeamResponseData = IncidentTeamResponseData;
/**
 * @ignore
 */
IncidentTeamResponseData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "IncidentTeamResponseAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    relationships: {
        baseName: "relationships",
        type: "IncidentTeamRelationships",
    },
    type: {
        baseName: "type",
        type: "IncidentTeamType",
    },
};
//# sourceMappingURL=IncidentTeamResponseData.js.map

/***/ }),

/***/ 14799:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentTeamUpdateAttributes = void 0;
/**
 * The incident team's attributes for an update request.
 */
class IncidentTeamUpdateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentTeamUpdateAttributes.attributeTypeMap;
    }
}
exports.IncidentTeamUpdateAttributes = IncidentTeamUpdateAttributes;
/**
 * @ignore
 */
IncidentTeamUpdateAttributes.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=IncidentTeamUpdateAttributes.js.map

/***/ }),

/***/ 41914:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentTeamUpdateData = void 0;
/**
 * Incident Team data for an update request.
 */
class IncidentTeamUpdateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentTeamUpdateData.attributeTypeMap;
    }
}
exports.IncidentTeamUpdateData = IncidentTeamUpdateData;
/**
 * @ignore
 */
IncidentTeamUpdateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "IncidentTeamUpdateAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    relationships: {
        baseName: "relationships",
        type: "IncidentTeamRelationships",
    },
    type: {
        baseName: "type",
        type: "IncidentTeamType",
        required: true,
    },
};
//# sourceMappingURL=IncidentTeamUpdateData.js.map

/***/ }),

/***/ 1174:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentTeamUpdateRequest = void 0;
/**
 * Update request with an incident team payload.
 */
class IncidentTeamUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentTeamUpdateRequest.attributeTypeMap;
    }
}
exports.IncidentTeamUpdateRequest = IncidentTeamUpdateRequest;
/**
 * @ignore
 */
IncidentTeamUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "IncidentTeamUpdateData",
        required: true,
    },
};
//# sourceMappingURL=IncidentTeamUpdateRequest.js.map

/***/ }),

/***/ 72162:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentTeamsResponse = void 0;
/**
 * Response with a list of incident team payloads.
 */
class IncidentTeamsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentTeamsResponse.attributeTypeMap;
    }
}
exports.IncidentTeamsResponse = IncidentTeamsResponse;
/**
 * @ignore
 */
IncidentTeamsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<IncidentTeamResponseData>",
        required: true,
    },
    included: {
        baseName: "included",
        type: "Array<IncidentTeamIncludedItems>",
    },
    meta: {
        baseName: "meta",
        type: "IncidentResponseMeta",
    },
};
//# sourceMappingURL=IncidentTeamsResponse.js.map

/***/ }),

/***/ 48212:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentTimelineCellMarkdownCreateAttributes = void 0;
/**
 * Timeline cell data for Markdown timeline cells for a create request.
 */
class IncidentTimelineCellMarkdownCreateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentTimelineCellMarkdownCreateAttributes.attributeTypeMap;
    }
}
exports.IncidentTimelineCellMarkdownCreateAttributes = IncidentTimelineCellMarkdownCreateAttributes;
/**
 * @ignore
 */
IncidentTimelineCellMarkdownCreateAttributes.attributeTypeMap = {
    cellType: {
        baseName: "cell_type",
        type: "IncidentTimelineCellMarkdownContentType",
        required: true,
    },
    content: {
        baseName: "content",
        type: "IncidentTimelineCellMarkdownCreateAttributesContent",
        required: true,
    },
    important: {
        baseName: "important",
        type: "boolean",
    },
};
//# sourceMappingURL=IncidentTimelineCellMarkdownCreateAttributes.js.map

/***/ }),

/***/ 4504:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentTimelineCellMarkdownCreateAttributesContent = void 0;
/**
 * The Markdown timeline cell contents.
 */
class IncidentTimelineCellMarkdownCreateAttributesContent {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentTimelineCellMarkdownCreateAttributesContent.attributeTypeMap;
    }
}
exports.IncidentTimelineCellMarkdownCreateAttributesContent = IncidentTimelineCellMarkdownCreateAttributesContent;
/**
 * @ignore
 */
IncidentTimelineCellMarkdownCreateAttributesContent.attributeTypeMap = {
    content: {
        baseName: "content",
        type: "string",
    },
};
//# sourceMappingURL=IncidentTimelineCellMarkdownCreateAttributesContent.js.map

/***/ }),

/***/ 87879:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentUpdateAttributes = void 0;
/**
 * The incident's attributes for an update request.
 */
class IncidentUpdateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentUpdateAttributes.attributeTypeMap;
    }
}
exports.IncidentUpdateAttributes = IncidentUpdateAttributes;
/**
 * @ignore
 */
IncidentUpdateAttributes.attributeTypeMap = {
    customerImpactEnd: {
        baseName: "customer_impact_end",
        type: "Date",
        format: "date-time",
    },
    customerImpactScope: {
        baseName: "customer_impact_scope",
        type: "string",
    },
    customerImpactStart: {
        baseName: "customer_impact_start",
        type: "Date",
        format: "date-time",
    },
    customerImpacted: {
        baseName: "customer_impacted",
        type: "boolean",
    },
    detected: {
        baseName: "detected",
        type: "Date",
        format: "date-time",
    },
    fields: {
        baseName: "fields",
        type: "{ [key: string]: IncidentFieldAttributes; }",
    },
    notificationHandles: {
        baseName: "notification_handles",
        type: "Array<IncidentNotificationHandle>",
    },
    title: {
        baseName: "title",
        type: "string",
    },
};
//# sourceMappingURL=IncidentUpdateAttributes.js.map

/***/ }),

/***/ 14695:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentUpdateData = void 0;
/**
 * Incident data for an update request.
 */
class IncidentUpdateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentUpdateData.attributeTypeMap;
    }
}
exports.IncidentUpdateData = IncidentUpdateData;
/**
 * @ignore
 */
IncidentUpdateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "IncidentUpdateAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    relationships: {
        baseName: "relationships",
        type: "IncidentUpdateRelationships",
    },
    type: {
        baseName: "type",
        type: "IncidentType",
        required: true,
    },
};
//# sourceMappingURL=IncidentUpdateData.js.map

/***/ }),

/***/ 40863:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentUpdateRelationships = void 0;
/**
 * The incident's relationships for an update request.
 */
class IncidentUpdateRelationships {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentUpdateRelationships.attributeTypeMap;
    }
}
exports.IncidentUpdateRelationships = IncidentUpdateRelationships;
/**
 * @ignore
 */
IncidentUpdateRelationships.attributeTypeMap = {
    commanderUser: {
        baseName: "commander_user",
        type: "NullableRelationshipToUser",
    },
    integrations: {
        baseName: "integrations",
        type: "RelationshipToIncidentIntegrationMetadatas",
    },
    postmortem: {
        baseName: "postmortem",
        type: "RelationshipToIncidentPostmortem",
    },
};
//# sourceMappingURL=IncidentUpdateRelationships.js.map

/***/ }),

/***/ 94252:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentUpdateRequest = void 0;
/**
 * Update request for an incident.
 */
class IncidentUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentUpdateRequest.attributeTypeMap;
    }
}
exports.IncidentUpdateRequest = IncidentUpdateRequest;
/**
 * @ignore
 */
IncidentUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "IncidentUpdateData",
        required: true,
    },
};
//# sourceMappingURL=IncidentUpdateRequest.js.map

/***/ }),

/***/ 84660:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncidentsResponse = void 0;
/**
 * Response with a list of incidents.
 */
class IncidentsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IncidentsResponse.attributeTypeMap;
    }
}
exports.IncidentsResponse = IncidentsResponse;
/**
 * @ignore
 */
IncidentsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<IncidentResponseData>",
        required: true,
    },
    included: {
        baseName: "included",
        type: "Array<IncidentResponseIncludedItem>",
    },
    meta: {
        baseName: "meta",
        type: "IncidentResponseMeta",
    },
};
//# sourceMappingURL=IncidentsResponse.js.map

/***/ }),

/***/ 50768:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IntakePayloadAccepted = void 0;
/**
 * The payload accepted for intake.
 */
class IntakePayloadAccepted {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return IntakePayloadAccepted.attributeTypeMap;
    }
}
exports.IntakePayloadAccepted = IntakePayloadAccepted;
/**
 * @ignore
 */
IntakePayloadAccepted.attributeTypeMap = {
    errors: {
        baseName: "errors",
        type: "Array<string>",
    },
};
//# sourceMappingURL=IntakePayloadAccepted.js.map

/***/ }),

/***/ 33213:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListApplicationKeysResponse = void 0;
/**
 * Response for a list of application keys.
 */
class ListApplicationKeysResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ListApplicationKeysResponse.attributeTypeMap;
    }
}
exports.ListApplicationKeysResponse = ListApplicationKeysResponse;
/**
 * @ignore
 */
ListApplicationKeysResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<PartialApplicationKey>",
    },
    included: {
        baseName: "included",
        type: "Array<ApplicationKeyResponseIncludedItem>",
    },
};
//# sourceMappingURL=ListApplicationKeysResponse.js.map

/***/ }),

/***/ 50679:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Log = void 0;
/**
 * Object description of a log after being processed and stored by Datadog.
 */
class Log {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return Log.attributeTypeMap;
    }
}
exports.Log = Log;
/**
 * @ignore
 */
Log.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "LogAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "LogType",
    },
};
//# sourceMappingURL=Log.js.map

/***/ }),

/***/ 82583:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogAttributes = void 0;
/**
 * JSON object containing all log attributes and their associated values.
 */
class LogAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogAttributes.attributeTypeMap;
    }
}
exports.LogAttributes = LogAttributes;
/**
 * @ignore
 */
LogAttributes.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "{ [key: string]: any; }",
    },
    host: {
        baseName: "host",
        type: "string",
    },
    message: {
        baseName: "message",
        type: "string",
    },
    service: {
        baseName: "service",
        type: "string",
    },
    status: {
        baseName: "status",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    timestamp: {
        baseName: "timestamp",
        type: "Date",
        format: "date-time",
    },
};
//# sourceMappingURL=LogAttributes.js.map

/***/ }),

/***/ 48920:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsAggregateBucket = void 0;
/**
 * A bucket values
 */
class LogsAggregateBucket {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsAggregateBucket.attributeTypeMap;
    }
}
exports.LogsAggregateBucket = LogsAggregateBucket;
/**
 * @ignore
 */
LogsAggregateBucket.attributeTypeMap = {
    by: {
        baseName: "by",
        type: "{ [key: string]: any; }",
    },
    computes: {
        baseName: "computes",
        type: "{ [key: string]: LogsAggregateBucketValue; }",
    },
};
//# sourceMappingURL=LogsAggregateBucket.js.map

/***/ }),

/***/ 87989:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsAggregateBucketValueTimeseriesPoint = void 0;
/**
 * A timeseries point
 */
class LogsAggregateBucketValueTimeseriesPoint {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsAggregateBucketValueTimeseriesPoint.attributeTypeMap;
    }
}
exports.LogsAggregateBucketValueTimeseriesPoint = LogsAggregateBucketValueTimeseriesPoint;
/**
 * @ignore
 */
LogsAggregateBucketValueTimeseriesPoint.attributeTypeMap = {
    time: {
        baseName: "time",
        type: "string",
    },
    value: {
        baseName: "value",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=LogsAggregateBucketValueTimeseriesPoint.js.map

/***/ }),

/***/ 13619:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsAggregateRequest = void 0;
/**
 * The object sent with the request to retrieve a list of logs from your organization.
 */
class LogsAggregateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsAggregateRequest.attributeTypeMap;
    }
}
exports.LogsAggregateRequest = LogsAggregateRequest;
/**
 * @ignore
 */
LogsAggregateRequest.attributeTypeMap = {
    compute: {
        baseName: "compute",
        type: "Array<LogsCompute>",
    },
    filter: {
        baseName: "filter",
        type: "LogsQueryFilter",
    },
    groupBy: {
        baseName: "group_by",
        type: "Array<LogsGroupBy>",
    },
    options: {
        baseName: "options",
        type: "LogsQueryOptions",
    },
    page: {
        baseName: "page",
        type: "LogsAggregateRequestPage",
    },
};
//# sourceMappingURL=LogsAggregateRequest.js.map

/***/ }),

/***/ 73702:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsAggregateRequestPage = void 0;
/**
 * Paging settings
 */
class LogsAggregateRequestPage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsAggregateRequestPage.attributeTypeMap;
    }
}
exports.LogsAggregateRequestPage = LogsAggregateRequestPage;
/**
 * @ignore
 */
LogsAggregateRequestPage.attributeTypeMap = {
    cursor: {
        baseName: "cursor",
        type: "string",
    },
};
//# sourceMappingURL=LogsAggregateRequestPage.js.map

/***/ }),

/***/ 42578:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsAggregateResponse = void 0;
/**
 * The response object for the logs aggregate API endpoint
 */
class LogsAggregateResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsAggregateResponse.attributeTypeMap;
    }
}
exports.LogsAggregateResponse = LogsAggregateResponse;
/**
 * @ignore
 */
LogsAggregateResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "LogsAggregateResponseData",
    },
    meta: {
        baseName: "meta",
        type: "LogsResponseMetadata",
    },
};
//# sourceMappingURL=LogsAggregateResponse.js.map

/***/ }),

/***/ 95647:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsAggregateResponseData = void 0;
/**
 * The query results
 */
class LogsAggregateResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsAggregateResponseData.attributeTypeMap;
    }
}
exports.LogsAggregateResponseData = LogsAggregateResponseData;
/**
 * @ignore
 */
LogsAggregateResponseData.attributeTypeMap = {
    buckets: {
        baseName: "buckets",
        type: "Array<LogsAggregateBucket>",
    },
};
//# sourceMappingURL=LogsAggregateResponseData.js.map

/***/ }),

/***/ 49817:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsAggregateSort = void 0;
/**
 * A sort rule
 */
class LogsAggregateSort {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsAggregateSort.attributeTypeMap;
    }
}
exports.LogsAggregateSort = LogsAggregateSort;
/**
 * @ignore
 */
LogsAggregateSort.attributeTypeMap = {
    aggregation: {
        baseName: "aggregation",
        type: "LogsAggregationFunction",
    },
    metric: {
        baseName: "metric",
        type: "string",
    },
    order: {
        baseName: "order",
        type: "LogsSortOrder",
    },
    type: {
        baseName: "type",
        type: "LogsAggregateSortType",
    },
};
//# sourceMappingURL=LogsAggregateSort.js.map

/***/ }),

/***/ 15665:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsArchive = void 0;
/**
 * The logs archive.
 */
class LogsArchive {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsArchive.attributeTypeMap;
    }
}
exports.LogsArchive = LogsArchive;
/**
 * @ignore
 */
LogsArchive.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "LogsArchiveDefinition",
    },
};
//# sourceMappingURL=LogsArchive.js.map

/***/ }),

/***/ 14064:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsArchiveAttributes = void 0;
/**
 * The attributes associated with the archive.
 */
class LogsArchiveAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsArchiveAttributes.attributeTypeMap;
    }
}
exports.LogsArchiveAttributes = LogsArchiveAttributes;
/**
 * @ignore
 */
LogsArchiveAttributes.attributeTypeMap = {
    destination: {
        baseName: "destination",
        type: "LogsArchiveDestination",
        required: true,
    },
    includeTags: {
        baseName: "include_tags",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    query: {
        baseName: "query",
        type: "string",
        required: true,
    },
    rehydrationMaxScanSizeInGb: {
        baseName: "rehydration_max_scan_size_in_gb",
        type: "number",
        format: "int64",
    },
    rehydrationTags: {
        baseName: "rehydration_tags",
        type: "Array<string>",
    },
    state: {
        baseName: "state",
        type: "LogsArchiveState",
    },
};
//# sourceMappingURL=LogsArchiveAttributes.js.map

/***/ }),

/***/ 20167:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsArchiveCreateRequest = void 0;
/**
 * The logs archive.
 */
class LogsArchiveCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsArchiveCreateRequest.attributeTypeMap;
    }
}
exports.LogsArchiveCreateRequest = LogsArchiveCreateRequest;
/**
 * @ignore
 */
LogsArchiveCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "LogsArchiveCreateRequestDefinition",
    },
};
//# sourceMappingURL=LogsArchiveCreateRequest.js.map

/***/ }),

/***/ 44357:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsArchiveCreateRequestAttributes = void 0;
/**
 * The attributes associated with the archive.
 */
class LogsArchiveCreateRequestAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsArchiveCreateRequestAttributes.attributeTypeMap;
    }
}
exports.LogsArchiveCreateRequestAttributes = LogsArchiveCreateRequestAttributes;
/**
 * @ignore
 */
LogsArchiveCreateRequestAttributes.attributeTypeMap = {
    destination: {
        baseName: "destination",
        type: "LogsArchiveCreateRequestDestination",
        required: true,
    },
    includeTags: {
        baseName: "include_tags",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    query: {
        baseName: "query",
        type: "string",
        required: true,
    },
    rehydrationMaxScanSizeInGb: {
        baseName: "rehydration_max_scan_size_in_gb",
        type: "number",
        format: "int64",
    },
    rehydrationTags: {
        baseName: "rehydration_tags",
        type: "Array<string>",
    },
};
//# sourceMappingURL=LogsArchiveCreateRequestAttributes.js.map

/***/ }),

/***/ 41915:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsArchiveCreateRequestDefinition = void 0;
/**
 * The definition of an archive.
 */
class LogsArchiveCreateRequestDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsArchiveCreateRequestDefinition.attributeTypeMap;
    }
}
exports.LogsArchiveCreateRequestDefinition = LogsArchiveCreateRequestDefinition;
/**
 * @ignore
 */
LogsArchiveCreateRequestDefinition.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "LogsArchiveCreateRequestAttributes",
    },
    type: {
        baseName: "type",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=LogsArchiveCreateRequestDefinition.js.map

/***/ }),

/***/ 48978:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsArchiveDefinition = void 0;
/**
 * The definition of an archive.
 */
class LogsArchiveDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsArchiveDefinition.attributeTypeMap;
    }
}
exports.LogsArchiveDefinition = LogsArchiveDefinition;
/**
 * @ignore
 */
LogsArchiveDefinition.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "LogsArchiveAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=LogsArchiveDefinition.js.map

/***/ }),

/***/ 29038:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsArchiveDestinationAzure = void 0;
/**
 * The Azure archive destination.
 */
class LogsArchiveDestinationAzure {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsArchiveDestinationAzure.attributeTypeMap;
    }
}
exports.LogsArchiveDestinationAzure = LogsArchiveDestinationAzure;
/**
 * @ignore
 */
LogsArchiveDestinationAzure.attributeTypeMap = {
    container: {
        baseName: "container",
        type: "string",
        required: true,
    },
    integration: {
        baseName: "integration",
        type: "LogsArchiveIntegrationAzure",
        required: true,
    },
    path: {
        baseName: "path",
        type: "string",
    },
    region: {
        baseName: "region",
        type: "string",
    },
    storageAccount: {
        baseName: "storage_account",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "LogsArchiveDestinationAzureType",
        required: true,
    },
};
//# sourceMappingURL=LogsArchiveDestinationAzure.js.map

/***/ }),

/***/ 71657:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsArchiveDestinationGCS = void 0;
/**
 * The GCS archive destination.
 */
class LogsArchiveDestinationGCS {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsArchiveDestinationGCS.attributeTypeMap;
    }
}
exports.LogsArchiveDestinationGCS = LogsArchiveDestinationGCS;
/**
 * @ignore
 */
LogsArchiveDestinationGCS.attributeTypeMap = {
    bucket: {
        baseName: "bucket",
        type: "string",
        required: true,
    },
    integration: {
        baseName: "integration",
        type: "LogsArchiveIntegrationGCS",
        required: true,
    },
    path: {
        baseName: "path",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "LogsArchiveDestinationGCSType",
        required: true,
    },
};
//# sourceMappingURL=LogsArchiveDestinationGCS.js.map

/***/ }),

/***/ 87520:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsArchiveDestinationS3 = void 0;
/**
 * The S3 archive destination.
 */
class LogsArchiveDestinationS3 {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsArchiveDestinationS3.attributeTypeMap;
    }
}
exports.LogsArchiveDestinationS3 = LogsArchiveDestinationS3;
/**
 * @ignore
 */
LogsArchiveDestinationS3.attributeTypeMap = {
    bucket: {
        baseName: "bucket",
        type: "string",
        required: true,
    },
    integration: {
        baseName: "integration",
        type: "LogsArchiveIntegrationS3",
        required: true,
    },
    path: {
        baseName: "path",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "LogsArchiveDestinationS3Type",
        required: true,
    },
};
//# sourceMappingURL=LogsArchiveDestinationS3.js.map

/***/ }),

/***/ 90187:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsArchiveIntegrationAzure = void 0;
/**
 * The Azure archive's integration destination.
 */
class LogsArchiveIntegrationAzure {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsArchiveIntegrationAzure.attributeTypeMap;
    }
}
exports.LogsArchiveIntegrationAzure = LogsArchiveIntegrationAzure;
/**
 * @ignore
 */
LogsArchiveIntegrationAzure.attributeTypeMap = {
    clientId: {
        baseName: "client_id",
        type: "string",
        required: true,
    },
    tenantId: {
        baseName: "tenant_id",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=LogsArchiveIntegrationAzure.js.map

/***/ }),

/***/ 83645:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsArchiveIntegrationGCS = void 0;
/**
 * The GCS archive's integration destination.
 */
class LogsArchiveIntegrationGCS {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsArchiveIntegrationGCS.attributeTypeMap;
    }
}
exports.LogsArchiveIntegrationGCS = LogsArchiveIntegrationGCS;
/**
 * @ignore
 */
LogsArchiveIntegrationGCS.attributeTypeMap = {
    clientEmail: {
        baseName: "client_email",
        type: "string",
        required: true,
    },
    projectId: {
        baseName: "project_id",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=LogsArchiveIntegrationGCS.js.map

/***/ }),

/***/ 9681:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsArchiveIntegrationS3 = void 0;
/**
 * The S3 Archive's integration destination.
 */
class LogsArchiveIntegrationS3 {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsArchiveIntegrationS3.attributeTypeMap;
    }
}
exports.LogsArchiveIntegrationS3 = LogsArchiveIntegrationS3;
/**
 * @ignore
 */
LogsArchiveIntegrationS3.attributeTypeMap = {
    accountId: {
        baseName: "account_id",
        type: "string",
        required: true,
    },
    roleName: {
        baseName: "role_name",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=LogsArchiveIntegrationS3.js.map

/***/ }),

/***/ 13220:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsArchiveOrder = void 0;
/**
 * A ordered list of archive IDs.
 */
class LogsArchiveOrder {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsArchiveOrder.attributeTypeMap;
    }
}
exports.LogsArchiveOrder = LogsArchiveOrder;
/**
 * @ignore
 */
LogsArchiveOrder.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "LogsArchiveOrderDefinition",
    },
};
//# sourceMappingURL=LogsArchiveOrder.js.map

/***/ }),

/***/ 33277:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsArchiveOrderAttributes = void 0;
/**
 * The attributes associated with the archive order.
 */
class LogsArchiveOrderAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsArchiveOrderAttributes.attributeTypeMap;
    }
}
exports.LogsArchiveOrderAttributes = LogsArchiveOrderAttributes;
/**
 * @ignore
 */
LogsArchiveOrderAttributes.attributeTypeMap = {
    archiveIds: {
        baseName: "archive_ids",
        type: "Array<string>",
        required: true,
    },
};
//# sourceMappingURL=LogsArchiveOrderAttributes.js.map

/***/ }),

/***/ 74878:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsArchiveOrderDefinition = void 0;
/**
 * The definition of an archive order.
 */
class LogsArchiveOrderDefinition {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsArchiveOrderDefinition.attributeTypeMap;
    }
}
exports.LogsArchiveOrderDefinition = LogsArchiveOrderDefinition;
/**
 * @ignore
 */
LogsArchiveOrderDefinition.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "LogsArchiveOrderAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "LogsArchiveOrderDefinitionType",
        required: true,
    },
};
//# sourceMappingURL=LogsArchiveOrderDefinition.js.map

/***/ }),

/***/ 16852:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsArchives = void 0;
/**
 * The available archives.
 */
class LogsArchives {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsArchives.attributeTypeMap;
    }
}
exports.LogsArchives = LogsArchives;
/**
 * @ignore
 */
LogsArchives.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<LogsArchiveDefinition>",
    },
};
//# sourceMappingURL=LogsArchives.js.map

/***/ }),

/***/ 19236:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsCompute = void 0;
/**
 * A compute rule to compute metrics or timeseries
 */
class LogsCompute {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsCompute.attributeTypeMap;
    }
}
exports.LogsCompute = LogsCompute;
/**
 * @ignore
 */
LogsCompute.attributeTypeMap = {
    aggregation: {
        baseName: "aggregation",
        type: "LogsAggregationFunction",
        required: true,
    },
    interval: {
        baseName: "interval",
        type: "string",
    },
    metric: {
        baseName: "metric",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "LogsComputeType",
    },
};
//# sourceMappingURL=LogsCompute.js.map

/***/ }),

/***/ 21104:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsGroupBy = void 0;
/**
 * A group by rule
 */
class LogsGroupBy {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsGroupBy.attributeTypeMap;
    }
}
exports.LogsGroupBy = LogsGroupBy;
/**
 * @ignore
 */
LogsGroupBy.attributeTypeMap = {
    facet: {
        baseName: "facet",
        type: "string",
        required: true,
    },
    histogram: {
        baseName: "histogram",
        type: "LogsGroupByHistogram",
    },
    limit: {
        baseName: "limit",
        type: "number",
        format: "int64",
    },
    missing: {
        baseName: "missing",
        type: "LogsGroupByMissing",
    },
    sort: {
        baseName: "sort",
        type: "LogsAggregateSort",
    },
    total: {
        baseName: "total",
        type: "LogsGroupByTotal",
    },
};
//# sourceMappingURL=LogsGroupBy.js.map

/***/ }),

/***/ 2133:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsGroupByHistogram = void 0;
/**
 * Used to perform a histogram computation (only for measure facets).
 * Note: At most 100 buckets are allowed, the number of buckets is (max - min)/interval.
 */
class LogsGroupByHistogram {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsGroupByHistogram.attributeTypeMap;
    }
}
exports.LogsGroupByHistogram = LogsGroupByHistogram;
/**
 * @ignore
 */
LogsGroupByHistogram.attributeTypeMap = {
    interval: {
        baseName: "interval",
        type: "number",
        required: true,
        format: "double",
    },
    max: {
        baseName: "max",
        type: "number",
        required: true,
        format: "double",
    },
    min: {
        baseName: "min",
        type: "number",
        required: true,
        format: "double",
    },
};
//# sourceMappingURL=LogsGroupByHistogram.js.map

/***/ }),

/***/ 46975:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsListRequest = void 0;
/**
 * The request for a logs list.
 */
class LogsListRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsListRequest.attributeTypeMap;
    }
}
exports.LogsListRequest = LogsListRequest;
/**
 * @ignore
 */
LogsListRequest.attributeTypeMap = {
    filter: {
        baseName: "filter",
        type: "LogsQueryFilter",
    },
    options: {
        baseName: "options",
        type: "LogsQueryOptions",
    },
    page: {
        baseName: "page",
        type: "LogsListRequestPage",
    },
    sort: {
        baseName: "sort",
        type: "LogsSort",
    },
};
//# sourceMappingURL=LogsListRequest.js.map

/***/ }),

/***/ 92486:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsListRequestPage = void 0;
/**
 * Paging attributes for listing logs.
 */
class LogsListRequestPage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsListRequestPage.attributeTypeMap;
    }
}
exports.LogsListRequestPage = LogsListRequestPage;
/**
 * @ignore
 */
LogsListRequestPage.attributeTypeMap = {
    cursor: {
        baseName: "cursor",
        type: "string",
    },
    limit: {
        baseName: "limit",
        type: "number",
        format: "int32",
    },
};
//# sourceMappingURL=LogsListRequestPage.js.map

/***/ }),

/***/ 62282:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsListResponse = void 0;
/**
 * Response object with all logs matching the request and pagination information.
 */
class LogsListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsListResponse.attributeTypeMap;
    }
}
exports.LogsListResponse = LogsListResponse;
/**
 * @ignore
 */
LogsListResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<Log>",
    },
    links: {
        baseName: "links",
        type: "LogsListResponseLinks",
    },
    meta: {
        baseName: "meta",
        type: "LogsResponseMetadata",
    },
};
//# sourceMappingURL=LogsListResponse.js.map

/***/ }),

/***/ 79413:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsListResponseLinks = void 0;
/**
 * Links attributes.
 */
class LogsListResponseLinks {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsListResponseLinks.attributeTypeMap;
    }
}
exports.LogsListResponseLinks = LogsListResponseLinks;
/**
 * @ignore
 */
LogsListResponseLinks.attributeTypeMap = {
    next: {
        baseName: "next",
        type: "string",
    },
};
//# sourceMappingURL=LogsListResponseLinks.js.map

/***/ }),

/***/ 74170:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsMetricCompute = void 0;
/**
 * The compute rule to compute the log-based metric.
 */
class LogsMetricCompute {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsMetricCompute.attributeTypeMap;
    }
}
exports.LogsMetricCompute = LogsMetricCompute;
/**
 * @ignore
 */
LogsMetricCompute.attributeTypeMap = {
    aggregationType: {
        baseName: "aggregation_type",
        type: "LogsMetricComputeAggregationType",
        required: true,
    },
    includePercentiles: {
        baseName: "include_percentiles",
        type: "boolean",
    },
    path: {
        baseName: "path",
        type: "string",
    },
};
//# sourceMappingURL=LogsMetricCompute.js.map

/***/ }),

/***/ 27156:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsMetricCreateAttributes = void 0;
/**
 * The object describing the Datadog log-based metric to create.
 */
class LogsMetricCreateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsMetricCreateAttributes.attributeTypeMap;
    }
}
exports.LogsMetricCreateAttributes = LogsMetricCreateAttributes;
/**
 * @ignore
 */
LogsMetricCreateAttributes.attributeTypeMap = {
    compute: {
        baseName: "compute",
        type: "LogsMetricCompute",
        required: true,
    },
    filter: {
        baseName: "filter",
        type: "LogsMetricFilter",
    },
    groupBy: {
        baseName: "group_by",
        type: "Array<LogsMetricGroupBy>",
    },
};
//# sourceMappingURL=LogsMetricCreateAttributes.js.map

/***/ }),

/***/ 67578:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsMetricCreateData = void 0;
/**
 * The new log-based metric properties.
 */
class LogsMetricCreateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsMetricCreateData.attributeTypeMap;
    }
}
exports.LogsMetricCreateData = LogsMetricCreateData;
/**
 * @ignore
 */
LogsMetricCreateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "LogsMetricCreateAttributes",
        required: true,
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "LogsMetricType",
        required: true,
    },
};
//# sourceMappingURL=LogsMetricCreateData.js.map

/***/ }),

/***/ 64489:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsMetricCreateRequest = void 0;
/**
 * The new log-based metric body.
 */
class LogsMetricCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsMetricCreateRequest.attributeTypeMap;
    }
}
exports.LogsMetricCreateRequest = LogsMetricCreateRequest;
/**
 * @ignore
 */
LogsMetricCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "LogsMetricCreateData",
        required: true,
    },
};
//# sourceMappingURL=LogsMetricCreateRequest.js.map

/***/ }),

/***/ 95980:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsMetricFilter = void 0;
/**
 * The log-based metric filter. Logs matching this filter will be aggregated in this metric.
 */
class LogsMetricFilter {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsMetricFilter.attributeTypeMap;
    }
}
exports.LogsMetricFilter = LogsMetricFilter;
/**
 * @ignore
 */
LogsMetricFilter.attributeTypeMap = {
    query: {
        baseName: "query",
        type: "string",
    },
};
//# sourceMappingURL=LogsMetricFilter.js.map

/***/ }),

/***/ 21776:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsMetricGroupBy = void 0;
/**
 * A group by rule.
 */
class LogsMetricGroupBy {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsMetricGroupBy.attributeTypeMap;
    }
}
exports.LogsMetricGroupBy = LogsMetricGroupBy;
/**
 * @ignore
 */
LogsMetricGroupBy.attributeTypeMap = {
    path: {
        baseName: "path",
        type: "string",
        required: true,
    },
    tagName: {
        baseName: "tag_name",
        type: "string",
    },
};
//# sourceMappingURL=LogsMetricGroupBy.js.map

/***/ }),

/***/ 86871:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsMetricResponse = void 0;
/**
 * The log-based metric object.
 */
class LogsMetricResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsMetricResponse.attributeTypeMap;
    }
}
exports.LogsMetricResponse = LogsMetricResponse;
/**
 * @ignore
 */
LogsMetricResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "LogsMetricResponseData",
    },
};
//# sourceMappingURL=LogsMetricResponse.js.map

/***/ }),

/***/ 94655:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsMetricResponseAttributes = void 0;
/**
 * The object describing a Datadog log-based metric.
 */
class LogsMetricResponseAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsMetricResponseAttributes.attributeTypeMap;
    }
}
exports.LogsMetricResponseAttributes = LogsMetricResponseAttributes;
/**
 * @ignore
 */
LogsMetricResponseAttributes.attributeTypeMap = {
    compute: {
        baseName: "compute",
        type: "LogsMetricResponseCompute",
    },
    filter: {
        baseName: "filter",
        type: "LogsMetricResponseFilter",
    },
    groupBy: {
        baseName: "group_by",
        type: "Array<LogsMetricResponseGroupBy>",
    },
};
//# sourceMappingURL=LogsMetricResponseAttributes.js.map

/***/ }),

/***/ 66641:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsMetricResponseCompute = void 0;
/**
 * The compute rule to compute the log-based metric.
 */
class LogsMetricResponseCompute {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsMetricResponseCompute.attributeTypeMap;
    }
}
exports.LogsMetricResponseCompute = LogsMetricResponseCompute;
/**
 * @ignore
 */
LogsMetricResponseCompute.attributeTypeMap = {
    aggregationType: {
        baseName: "aggregation_type",
        type: "LogsMetricResponseComputeAggregationType",
    },
    includePercentiles: {
        baseName: "include_percentiles",
        type: "boolean",
    },
    path: {
        baseName: "path",
        type: "string",
    },
};
//# sourceMappingURL=LogsMetricResponseCompute.js.map

/***/ }),

/***/ 2519:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsMetricResponseData = void 0;
/**
 * The log-based metric properties.
 */
class LogsMetricResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsMetricResponseData.attributeTypeMap;
    }
}
exports.LogsMetricResponseData = LogsMetricResponseData;
/**
 * @ignore
 */
LogsMetricResponseData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "LogsMetricResponseAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "LogsMetricType",
    },
};
//# sourceMappingURL=LogsMetricResponseData.js.map

/***/ }),

/***/ 37718:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsMetricResponseFilter = void 0;
/**
 * The log-based metric filter. Logs matching this filter will be aggregated in this metric.
 */
class LogsMetricResponseFilter {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsMetricResponseFilter.attributeTypeMap;
    }
}
exports.LogsMetricResponseFilter = LogsMetricResponseFilter;
/**
 * @ignore
 */
LogsMetricResponseFilter.attributeTypeMap = {
    query: {
        baseName: "query",
        type: "string",
    },
};
//# sourceMappingURL=LogsMetricResponseFilter.js.map

/***/ }),

/***/ 83284:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsMetricResponseGroupBy = void 0;
/**
 * A group by rule.
 */
class LogsMetricResponseGroupBy {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsMetricResponseGroupBy.attributeTypeMap;
    }
}
exports.LogsMetricResponseGroupBy = LogsMetricResponseGroupBy;
/**
 * @ignore
 */
LogsMetricResponseGroupBy.attributeTypeMap = {
    path: {
        baseName: "path",
        type: "string",
    },
    tagName: {
        baseName: "tag_name",
        type: "string",
    },
};
//# sourceMappingURL=LogsMetricResponseGroupBy.js.map

/***/ }),

/***/ 43114:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsMetricUpdateAttributes = void 0;
/**
 * The log-based metric properties that will be updated.
 */
class LogsMetricUpdateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsMetricUpdateAttributes.attributeTypeMap;
    }
}
exports.LogsMetricUpdateAttributes = LogsMetricUpdateAttributes;
/**
 * @ignore
 */
LogsMetricUpdateAttributes.attributeTypeMap = {
    compute: {
        baseName: "compute",
        type: "LogsMetricUpdateCompute",
    },
    filter: {
        baseName: "filter",
        type: "LogsMetricFilter",
    },
    groupBy: {
        baseName: "group_by",
        type: "Array<LogsMetricGroupBy>",
    },
};
//# sourceMappingURL=LogsMetricUpdateAttributes.js.map

/***/ }),

/***/ 70970:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsMetricUpdateCompute = void 0;
/**
 * The compute rule to compute the log-based metric.
 */
class LogsMetricUpdateCompute {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsMetricUpdateCompute.attributeTypeMap;
    }
}
exports.LogsMetricUpdateCompute = LogsMetricUpdateCompute;
/**
 * @ignore
 */
LogsMetricUpdateCompute.attributeTypeMap = {
    includePercentiles: {
        baseName: "include_percentiles",
        type: "boolean",
    },
};
//# sourceMappingURL=LogsMetricUpdateCompute.js.map

/***/ }),

/***/ 32319:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsMetricUpdateData = void 0;
/**
 * The new log-based metric properties.
 */
class LogsMetricUpdateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsMetricUpdateData.attributeTypeMap;
    }
}
exports.LogsMetricUpdateData = LogsMetricUpdateData;
/**
 * @ignore
 */
LogsMetricUpdateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "LogsMetricUpdateAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "LogsMetricType",
        required: true,
    },
};
//# sourceMappingURL=LogsMetricUpdateData.js.map

/***/ }),

/***/ 84033:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsMetricUpdateRequest = void 0;
/**
 * The new log-based metric body.
 */
class LogsMetricUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsMetricUpdateRequest.attributeTypeMap;
    }
}
exports.LogsMetricUpdateRequest = LogsMetricUpdateRequest;
/**
 * @ignore
 */
LogsMetricUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "LogsMetricUpdateData",
        required: true,
    },
};
//# sourceMappingURL=LogsMetricUpdateRequest.js.map

/***/ }),

/***/ 57793:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsMetricsResponse = void 0;
/**
 * All the available log-based metric objects.
 */
class LogsMetricsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsMetricsResponse.attributeTypeMap;
    }
}
exports.LogsMetricsResponse = LogsMetricsResponse;
/**
 * @ignore
 */
LogsMetricsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<LogsMetricResponseData>",
    },
};
//# sourceMappingURL=LogsMetricsResponse.js.map

/***/ }),

/***/ 36574:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsQueryFilter = void 0;
/**
 * The search and filter query settings
 */
class LogsQueryFilter {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsQueryFilter.attributeTypeMap;
    }
}
exports.LogsQueryFilter = LogsQueryFilter;
/**
 * @ignore
 */
LogsQueryFilter.attributeTypeMap = {
    from: {
        baseName: "from",
        type: "string",
    },
    indexes: {
        baseName: "indexes",
        type: "Array<string>",
    },
    query: {
        baseName: "query",
        type: "string",
    },
    storageTier: {
        baseName: "storage_tier",
        type: "LogsStorageTier",
    },
    to: {
        baseName: "to",
        type: "string",
    },
};
//# sourceMappingURL=LogsQueryFilter.js.map

/***/ }),

/***/ 75773:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsQueryOptions = void 0;
/**
 * Global query options that are used during the query.
 * Note: You should only supply timezone or time offset but not both otherwise the query will fail.
 */
class LogsQueryOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsQueryOptions.attributeTypeMap;
    }
}
exports.LogsQueryOptions = LogsQueryOptions;
/**
 * @ignore
 */
LogsQueryOptions.attributeTypeMap = {
    timeOffset: {
        baseName: "timeOffset",
        type: "number",
        format: "int64",
    },
    timezone: {
        baseName: "timezone",
        type: "string",
    },
};
//# sourceMappingURL=LogsQueryOptions.js.map

/***/ }),

/***/ 9675:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsResponseMetadata = void 0;
/**
 * The metadata associated with a request
 */
class LogsResponseMetadata {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsResponseMetadata.attributeTypeMap;
    }
}
exports.LogsResponseMetadata = LogsResponseMetadata;
/**
 * @ignore
 */
LogsResponseMetadata.attributeTypeMap = {
    elapsed: {
        baseName: "elapsed",
        type: "number",
        format: "int64",
    },
    page: {
        baseName: "page",
        type: "LogsResponseMetadataPage",
    },
    requestId: {
        baseName: "request_id",
        type: "string",
    },
    status: {
        baseName: "status",
        type: "LogsAggregateResponseStatus",
    },
    warnings: {
        baseName: "warnings",
        type: "Array<LogsWarning>",
    },
};
//# sourceMappingURL=LogsResponseMetadata.js.map

/***/ }),

/***/ 9159:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsResponseMetadataPage = void 0;
/**
 * Paging attributes.
 */
class LogsResponseMetadataPage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsResponseMetadataPage.attributeTypeMap;
    }
}
exports.LogsResponseMetadataPage = LogsResponseMetadataPage;
/**
 * @ignore
 */
LogsResponseMetadataPage.attributeTypeMap = {
    after: {
        baseName: "after",
        type: "string",
    },
};
//# sourceMappingURL=LogsResponseMetadataPage.js.map

/***/ }),

/***/ 32347:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogsWarning = void 0;
/**
 * A warning message indicating something that went wrong with the query
 */
class LogsWarning {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return LogsWarning.attributeTypeMap;
    }
}
exports.LogsWarning = LogsWarning;
/**
 * @ignore
 */
LogsWarning.attributeTypeMap = {
    code: {
        baseName: "code",
        type: "string",
    },
    detail: {
        baseName: "detail",
        type: "string",
    },
    title: {
        baseName: "title",
        type: "string",
    },
};
//# sourceMappingURL=LogsWarning.js.map

/***/ }),

/***/ 81125:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Metric = void 0;
/**
 * Object for a single metric tag configuration.
 */
class Metric {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return Metric.attributeTypeMap;
    }
}
exports.Metric = Metric;
/**
 * @ignore
 */
Metric.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "MetricType",
    },
};
//# sourceMappingURL=Metric.js.map

/***/ }),

/***/ 92059:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricAllTags = void 0;
/**
 * Object for a single metric's indexed tags.
 */
class MetricAllTags {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricAllTags.attributeTypeMap;
    }
}
exports.MetricAllTags = MetricAllTags;
/**
 * @ignore
 */
MetricAllTags.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "MetricAllTagsAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "MetricType",
    },
};
//# sourceMappingURL=MetricAllTags.js.map

/***/ }),

/***/ 5563:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricAllTagsAttributes = void 0;
/**
 * Object containing the definition of a metric's tags.
 */
class MetricAllTagsAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricAllTagsAttributes.attributeTypeMap;
    }
}
exports.MetricAllTagsAttributes = MetricAllTagsAttributes;
/**
 * @ignore
 */
MetricAllTagsAttributes.attributeTypeMap = {
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
};
//# sourceMappingURL=MetricAllTagsAttributes.js.map

/***/ }),

/***/ 72220:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricAllTagsResponse = void 0;
/**
 * Response object that includes a single metric's indexed tags.
 */
class MetricAllTagsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricAllTagsResponse.attributeTypeMap;
    }
}
exports.MetricAllTagsResponse = MetricAllTagsResponse;
/**
 * @ignore
 */
MetricAllTagsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "MetricAllTags",
    },
};
//# sourceMappingURL=MetricAllTagsResponse.js.map

/***/ }),

/***/ 91782:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricBulkTagConfigCreate = void 0;
/**
 * Request object to bulk configure tags for metrics matching the given prefix.
 */
class MetricBulkTagConfigCreate {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricBulkTagConfigCreate.attributeTypeMap;
    }
}
exports.MetricBulkTagConfigCreate = MetricBulkTagConfigCreate;
/**
 * @ignore
 */
MetricBulkTagConfigCreate.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "MetricBulkTagConfigCreateAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "MetricBulkConfigureTagsType",
        required: true,
    },
};
//# sourceMappingURL=MetricBulkTagConfigCreate.js.map

/***/ }),

/***/ 32326:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricBulkTagConfigCreateAttributes = void 0;
/**
 * Optional parameters for bulk creating metric tag configurations.
 */
class MetricBulkTagConfigCreateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricBulkTagConfigCreateAttributes.attributeTypeMap;
    }
}
exports.MetricBulkTagConfigCreateAttributes = MetricBulkTagConfigCreateAttributes;
/**
 * @ignore
 */
MetricBulkTagConfigCreateAttributes.attributeTypeMap = {
    emails: {
        baseName: "emails",
        type: "Array<string>",
        format: "email",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
};
//# sourceMappingURL=MetricBulkTagConfigCreateAttributes.js.map

/***/ }),

/***/ 4270:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricBulkTagConfigCreateRequest = void 0;
/**
 * Wrapper object for a single bulk tag configuration request.
 */
class MetricBulkTagConfigCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricBulkTagConfigCreateRequest.attributeTypeMap;
    }
}
exports.MetricBulkTagConfigCreateRequest = MetricBulkTagConfigCreateRequest;
/**
 * @ignore
 */
MetricBulkTagConfigCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "MetricBulkTagConfigCreate",
        required: true,
    },
};
//# sourceMappingURL=MetricBulkTagConfigCreateRequest.js.map

/***/ }),

/***/ 72280:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricBulkTagConfigDelete = void 0;
/**
 * Request object to bulk delete all tag configurations for metrics matching the given prefix.
 */
class MetricBulkTagConfigDelete {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricBulkTagConfigDelete.attributeTypeMap;
    }
}
exports.MetricBulkTagConfigDelete = MetricBulkTagConfigDelete;
/**
 * @ignore
 */
MetricBulkTagConfigDelete.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "MetricBulkTagConfigDeleteAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "MetricBulkConfigureTagsType",
        required: true,
    },
};
//# sourceMappingURL=MetricBulkTagConfigDelete.js.map

/***/ }),

/***/ 86757:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricBulkTagConfigDeleteAttributes = void 0;
/**
 * Optional parameters for bulk deleting metric tag configurations.
 */
class MetricBulkTagConfigDeleteAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricBulkTagConfigDeleteAttributes.attributeTypeMap;
    }
}
exports.MetricBulkTagConfigDeleteAttributes = MetricBulkTagConfigDeleteAttributes;
/**
 * @ignore
 */
MetricBulkTagConfigDeleteAttributes.attributeTypeMap = {
    emails: {
        baseName: "emails",
        type: "Array<string>",
        format: "email",
    },
};
//# sourceMappingURL=MetricBulkTagConfigDeleteAttributes.js.map

/***/ }),

/***/ 3217:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricBulkTagConfigDeleteRequest = void 0;
/**
 * Wrapper object for a single bulk tag deletion request.
 */
class MetricBulkTagConfigDeleteRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricBulkTagConfigDeleteRequest.attributeTypeMap;
    }
}
exports.MetricBulkTagConfigDeleteRequest = MetricBulkTagConfigDeleteRequest;
/**
 * @ignore
 */
MetricBulkTagConfigDeleteRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "MetricBulkTagConfigDelete",
        required: true,
    },
};
//# sourceMappingURL=MetricBulkTagConfigDeleteRequest.js.map

/***/ }),

/***/ 40953:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricBulkTagConfigResponse = void 0;
/**
 * Wrapper for a single bulk tag configuration status response.
 */
class MetricBulkTagConfigResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricBulkTagConfigResponse.attributeTypeMap;
    }
}
exports.MetricBulkTagConfigResponse = MetricBulkTagConfigResponse;
/**
 * @ignore
 */
MetricBulkTagConfigResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "MetricBulkTagConfigStatus",
    },
};
//# sourceMappingURL=MetricBulkTagConfigResponse.js.map

/***/ }),

/***/ 57682:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricBulkTagConfigStatus = void 0;
/**
 * The status of a request to bulk configure metric tags.
 * It contains the fields from the original request for reference.
 */
class MetricBulkTagConfigStatus {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricBulkTagConfigStatus.attributeTypeMap;
    }
}
exports.MetricBulkTagConfigStatus = MetricBulkTagConfigStatus;
/**
 * @ignore
 */
MetricBulkTagConfigStatus.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "MetricBulkTagConfigStatusAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "MetricBulkConfigureTagsType",
        required: true,
    },
};
//# sourceMappingURL=MetricBulkTagConfigStatus.js.map

/***/ }),

/***/ 82262:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricBulkTagConfigStatusAttributes = void 0;
/**
 * Optional attributes for the status of a bulk tag configuration request.
 */
class MetricBulkTagConfigStatusAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricBulkTagConfigStatusAttributes.attributeTypeMap;
    }
}
exports.MetricBulkTagConfigStatusAttributes = MetricBulkTagConfigStatusAttributes;
/**
 * @ignore
 */
MetricBulkTagConfigStatusAttributes.attributeTypeMap = {
    emails: {
        baseName: "emails",
        type: "Array<string>",
        format: "email",
    },
    status: {
        baseName: "status",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
};
//# sourceMappingURL=MetricBulkTagConfigStatusAttributes.js.map

/***/ }),

/***/ 17484:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricCustomAggregation = void 0;
/**
 * A time and space aggregation combination for use in query.
 */
class MetricCustomAggregation {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricCustomAggregation.attributeTypeMap;
    }
}
exports.MetricCustomAggregation = MetricCustomAggregation;
/**
 * @ignore
 */
MetricCustomAggregation.attributeTypeMap = {
    space: {
        baseName: "space",
        type: "MetricCustomSpaceAggregation",
        required: true,
    },
    time: {
        baseName: "time",
        type: "MetricCustomTimeAggregation",
        required: true,
    },
};
//# sourceMappingURL=MetricCustomAggregation.js.map

/***/ }),

/***/ 85654:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricDistinctVolume = void 0;
/**
 * Object for a single metric's distinct volume.
 */
class MetricDistinctVolume {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricDistinctVolume.attributeTypeMap;
    }
}
exports.MetricDistinctVolume = MetricDistinctVolume;
/**
 * @ignore
 */
MetricDistinctVolume.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "MetricDistinctVolumeAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "MetricDistinctVolumeType",
    },
};
//# sourceMappingURL=MetricDistinctVolume.js.map

/***/ }),

/***/ 23953:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricDistinctVolumeAttributes = void 0;
/**
 * Object containing the definition of a metric's distinct volume.
 */
class MetricDistinctVolumeAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricDistinctVolumeAttributes.attributeTypeMap;
    }
}
exports.MetricDistinctVolumeAttributes = MetricDistinctVolumeAttributes;
/**
 * @ignore
 */
MetricDistinctVolumeAttributes.attributeTypeMap = {
    distinctVolume: {
        baseName: "distinct_volume",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=MetricDistinctVolumeAttributes.js.map

/***/ }),

/***/ 55051:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricEstimate = void 0;
/**
 * Object for a metric cardinality estimate.
 */
class MetricEstimate {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricEstimate.attributeTypeMap;
    }
}
exports.MetricEstimate = MetricEstimate;
/**
 * @ignore
 */
MetricEstimate.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "MetricEstimateAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "MetricEstimateResourceType",
    },
};
//# sourceMappingURL=MetricEstimate.js.map

/***/ }),

/***/ 50065:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricEstimateAttributes = void 0;
/**
 * Object containing the definition of a metric estimate attribute.
 */
class MetricEstimateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricEstimateAttributes.attributeTypeMap;
    }
}
exports.MetricEstimateAttributes = MetricEstimateAttributes;
/**
 * @ignore
 */
MetricEstimateAttributes.attributeTypeMap = {
    estimateType: {
        baseName: "estimate_type",
        type: "MetricEstimateType",
    },
    estimatedAt: {
        baseName: "estimated_at",
        type: "Date",
        format: "date-time",
    },
    estimatedOutputSeries: {
        baseName: "estimated_output_series",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=MetricEstimateAttributes.js.map

/***/ }),

/***/ 65503:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricEstimateResponse = void 0;
/**
 * Response object that includes metric cardinality estimates.
 */
class MetricEstimateResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricEstimateResponse.attributeTypeMap;
    }
}
exports.MetricEstimateResponse = MetricEstimateResponse;
/**
 * @ignore
 */
MetricEstimateResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "MetricEstimate",
    },
};
//# sourceMappingURL=MetricEstimateResponse.js.map

/***/ }),

/***/ 8882:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricIngestedIndexedVolume = void 0;
/**
 * Object for a single metric's ingested and indexed volume.
 */
class MetricIngestedIndexedVolume {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricIngestedIndexedVolume.attributeTypeMap;
    }
}
exports.MetricIngestedIndexedVolume = MetricIngestedIndexedVolume;
/**
 * @ignore
 */
MetricIngestedIndexedVolume.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "MetricIngestedIndexedVolumeAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "MetricIngestedIndexedVolumeType",
    },
};
//# sourceMappingURL=MetricIngestedIndexedVolume.js.map

/***/ }),

/***/ 65551:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricIngestedIndexedVolumeAttributes = void 0;
/**
 * Object containing the definition of a metric's ingested and indexed volume.
 */
class MetricIngestedIndexedVolumeAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricIngestedIndexedVolumeAttributes.attributeTypeMap;
    }
}
exports.MetricIngestedIndexedVolumeAttributes = MetricIngestedIndexedVolumeAttributes;
/**
 * @ignore
 */
MetricIngestedIndexedVolumeAttributes.attributeTypeMap = {
    indexedVolume: {
        baseName: "indexed_volume",
        type: "number",
        format: "int64",
    },
    ingestedVolume: {
        baseName: "ingested_volume",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=MetricIngestedIndexedVolumeAttributes.js.map

/***/ }),

/***/ 92399:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricMetadata = void 0;
/**
 * Metadata for the metric.
 */
class MetricMetadata {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricMetadata.attributeTypeMap;
    }
}
exports.MetricMetadata = MetricMetadata;
/**
 * @ignore
 */
MetricMetadata.attributeTypeMap = {
    origin: {
        baseName: "origin",
        type: "MetricOrigin",
    },
};
//# sourceMappingURL=MetricMetadata.js.map

/***/ }),

/***/ 94810:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricOrigin = void 0;
/**
 * Metric origin information.
 */
class MetricOrigin {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricOrigin.attributeTypeMap;
    }
}
exports.MetricOrigin = MetricOrigin;
/**
 * @ignore
 */
MetricOrigin.attributeTypeMap = {
    metricType: {
        baseName: "metric_type",
        type: "number",
        format: "int32",
    },
    product: {
        baseName: "product",
        type: "number",
        format: "int32",
    },
    service: {
        baseName: "service",
        type: "number",
        format: "int32",
    },
};
//# sourceMappingURL=MetricOrigin.js.map

/***/ }),

/***/ 49429:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricPayload = void 0;
/**
 * The metrics' payload.
 */
class MetricPayload {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricPayload.attributeTypeMap;
    }
}
exports.MetricPayload = MetricPayload;
/**
 * @ignore
 */
MetricPayload.attributeTypeMap = {
    series: {
        baseName: "series",
        type: "Array<MetricSeries>",
        required: true,
    },
};
//# sourceMappingURL=MetricPayload.js.map

/***/ }),

/***/ 71586:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricPoint = void 0;
/**
 * A point object is of the form `{POSIX_timestamp, numeric_value}`.
 */
class MetricPoint {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricPoint.attributeTypeMap;
    }
}
exports.MetricPoint = MetricPoint;
/**
 * @ignore
 */
MetricPoint.attributeTypeMap = {
    timestamp: {
        baseName: "timestamp",
        type: "number",
        format: "int64",
    },
    value: {
        baseName: "value",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=MetricPoint.js.map

/***/ }),

/***/ 85867:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricResource = void 0;
/**
 * Metric resource.
 */
class MetricResource {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricResource.attributeTypeMap;
    }
}
exports.MetricResource = MetricResource;
/**
 * @ignore
 */
MetricResource.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "string",
    },
};
//# sourceMappingURL=MetricResource.js.map

/***/ }),

/***/ 38882:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricSeries = void 0;
/**
 * A metric to submit to Datadog.
 * See [Datadog metrics](https://docs.datadoghq.com/developers/metrics/#custom-metrics-properties).
 */
class MetricSeries {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricSeries.attributeTypeMap;
    }
}
exports.MetricSeries = MetricSeries;
/**
 * @ignore
 */
MetricSeries.attributeTypeMap = {
    interval: {
        baseName: "interval",
        type: "number",
        format: "int64",
    },
    metadata: {
        baseName: "metadata",
        type: "MetricMetadata",
    },
    metric: {
        baseName: "metric",
        type: "string",
        required: true,
    },
    points: {
        baseName: "points",
        type: "Array<MetricPoint>",
        required: true,
    },
    resources: {
        baseName: "resources",
        type: "Array<MetricResource>",
    },
    sourceTypeName: {
        baseName: "source_type_name",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    type: {
        baseName: "type",
        type: "MetricIntakeType",
        format: "int32",
    },
    unit: {
        baseName: "unit",
        type: "string",
    },
};
//# sourceMappingURL=MetricSeries.js.map

/***/ }),

/***/ 48241:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricSuggestedTagsAndAggregations = void 0;
/**
 * Object for a single metric's actively queried tags and aggregations.
 */
class MetricSuggestedTagsAndAggregations {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricSuggestedTagsAndAggregations.attributeTypeMap;
    }
}
exports.MetricSuggestedTagsAndAggregations = MetricSuggestedTagsAndAggregations;
/**
 * @ignore
 */
MetricSuggestedTagsAndAggregations.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "MetricSuggestedTagsAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "MetricActiveConfigurationType",
    },
};
//# sourceMappingURL=MetricSuggestedTagsAndAggregations.js.map

/***/ }),

/***/ 39816:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricSuggestedTagsAndAggregationsResponse = void 0;
/**
 * Response object that includes a single metric's actively queried tags and aggregations.
 */
class MetricSuggestedTagsAndAggregationsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricSuggestedTagsAndAggregationsResponse.attributeTypeMap;
    }
}
exports.MetricSuggestedTagsAndAggregationsResponse = MetricSuggestedTagsAndAggregationsResponse;
/**
 * @ignore
 */
MetricSuggestedTagsAndAggregationsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "MetricSuggestedTagsAndAggregations",
    },
};
//# sourceMappingURL=MetricSuggestedTagsAndAggregationsResponse.js.map

/***/ }),

/***/ 26853:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricSuggestedTagsAttributes = void 0;
/**
 * Object containing the definition of a metric's actively queried tags and aggregations.
 */
class MetricSuggestedTagsAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricSuggestedTagsAttributes.attributeTypeMap;
    }
}
exports.MetricSuggestedTagsAttributes = MetricSuggestedTagsAttributes;
/**
 * @ignore
 */
MetricSuggestedTagsAttributes.attributeTypeMap = {
    activeAggregations: {
        baseName: "active_aggregations",
        type: "Array<MetricCustomAggregation>",
    },
    activeTags: {
        baseName: "active_tags",
        type: "Array<string>",
    },
};
//# sourceMappingURL=MetricSuggestedTagsAttributes.js.map

/***/ }),

/***/ 35857:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricTagConfiguration = void 0;
/**
 * Object for a single metric tag configuration.
 */
class MetricTagConfiguration {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricTagConfiguration.attributeTypeMap;
    }
}
exports.MetricTagConfiguration = MetricTagConfiguration;
/**
 * @ignore
 */
MetricTagConfiguration.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "MetricTagConfigurationAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "MetricTagConfigurationType",
    },
};
//# sourceMappingURL=MetricTagConfiguration.js.map

/***/ }),

/***/ 9851:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricTagConfigurationAttributes = void 0;
/**
 * Object containing the definition of a metric tag configuration attributes.
 */
class MetricTagConfigurationAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricTagConfigurationAttributes.attributeTypeMap;
    }
}
exports.MetricTagConfigurationAttributes = MetricTagConfigurationAttributes;
/**
 * @ignore
 */
MetricTagConfigurationAttributes.attributeTypeMap = {
    aggregations: {
        baseName: "aggregations",
        type: "Array<MetricCustomAggregation>",
    },
    createdAt: {
        baseName: "created_at",
        type: "Date",
        format: "date-time",
    },
    includePercentiles: {
        baseName: "include_percentiles",
        type: "boolean",
    },
    metricType: {
        baseName: "metric_type",
        type: "MetricTagConfigurationMetricTypes",
    },
    modifiedAt: {
        baseName: "modified_at",
        type: "Date",
        format: "date-time",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
};
//# sourceMappingURL=MetricTagConfigurationAttributes.js.map

/***/ }),

/***/ 19186:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricTagConfigurationCreateAttributes = void 0;
/**
 * Object containing the definition of a metric tag configuration to be created.
 */
class MetricTagConfigurationCreateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricTagConfigurationCreateAttributes.attributeTypeMap;
    }
}
exports.MetricTagConfigurationCreateAttributes = MetricTagConfigurationCreateAttributes;
/**
 * @ignore
 */
MetricTagConfigurationCreateAttributes.attributeTypeMap = {
    aggregations: {
        baseName: "aggregations",
        type: "Array<MetricCustomAggregation>",
    },
    includePercentiles: {
        baseName: "include_percentiles",
        type: "boolean",
    },
    metricType: {
        baseName: "metric_type",
        type: "MetricTagConfigurationMetricTypes",
        required: true,
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
        required: true,
    },
};
//# sourceMappingURL=MetricTagConfigurationCreateAttributes.js.map

/***/ }),

/***/ 66135:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricTagConfigurationCreateData = void 0;
/**
 * Object for a single metric to be configure tags on.
 */
class MetricTagConfigurationCreateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricTagConfigurationCreateData.attributeTypeMap;
    }
}
exports.MetricTagConfigurationCreateData = MetricTagConfigurationCreateData;
/**
 * @ignore
 */
MetricTagConfigurationCreateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "MetricTagConfigurationCreateAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "MetricTagConfigurationType",
        required: true,
    },
};
//# sourceMappingURL=MetricTagConfigurationCreateData.js.map

/***/ }),

/***/ 84050:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricTagConfigurationCreateRequest = void 0;
/**
 * Request object that includes the metric that you would like to configure tags for.
 */
class MetricTagConfigurationCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricTagConfigurationCreateRequest.attributeTypeMap;
    }
}
exports.MetricTagConfigurationCreateRequest = MetricTagConfigurationCreateRequest;
/**
 * @ignore
 */
MetricTagConfigurationCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "MetricTagConfigurationCreateData",
        required: true,
    },
};
//# sourceMappingURL=MetricTagConfigurationCreateRequest.js.map

/***/ }),

/***/ 55797:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricTagConfigurationResponse = void 0;
/**
 * Response object which includes a single metric's tag configuration.
 */
class MetricTagConfigurationResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricTagConfigurationResponse.attributeTypeMap;
    }
}
exports.MetricTagConfigurationResponse = MetricTagConfigurationResponse;
/**
 * @ignore
 */
MetricTagConfigurationResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "MetricTagConfiguration",
    },
};
//# sourceMappingURL=MetricTagConfigurationResponse.js.map

/***/ }),

/***/ 19503:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricTagConfigurationUpdateAttributes = void 0;
/**
 * Object containing the definition of a metric tag configuration to be updated.
 */
class MetricTagConfigurationUpdateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricTagConfigurationUpdateAttributes.attributeTypeMap;
    }
}
exports.MetricTagConfigurationUpdateAttributes = MetricTagConfigurationUpdateAttributes;
/**
 * @ignore
 */
MetricTagConfigurationUpdateAttributes.attributeTypeMap = {
    aggregations: {
        baseName: "aggregations",
        type: "Array<MetricCustomAggregation>",
    },
    includePercentiles: {
        baseName: "include_percentiles",
        type: "boolean",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
};
//# sourceMappingURL=MetricTagConfigurationUpdateAttributes.js.map

/***/ }),

/***/ 63194:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricTagConfigurationUpdateData = void 0;
/**
 * Object for a single tag configuration to be edited.
 */
class MetricTagConfigurationUpdateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricTagConfigurationUpdateData.attributeTypeMap;
    }
}
exports.MetricTagConfigurationUpdateData = MetricTagConfigurationUpdateData;
/**
 * @ignore
 */
MetricTagConfigurationUpdateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "MetricTagConfigurationUpdateAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "MetricTagConfigurationType",
        required: true,
    },
};
//# sourceMappingURL=MetricTagConfigurationUpdateData.js.map

/***/ }),

/***/ 19976:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricTagConfigurationUpdateRequest = void 0;
/**
 * Request object that includes the metric that you would like to edit the tag configuration on.
 */
class MetricTagConfigurationUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricTagConfigurationUpdateRequest.attributeTypeMap;
    }
}
exports.MetricTagConfigurationUpdateRequest = MetricTagConfigurationUpdateRequest;
/**
 * @ignore
 */
MetricTagConfigurationUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "MetricTagConfigurationUpdateData",
        required: true,
    },
};
//# sourceMappingURL=MetricTagConfigurationUpdateRequest.js.map

/***/ }),

/***/ 72742:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricVolumesResponse = void 0;
/**
 * Response object which includes a single metric's volume.
 */
class MetricVolumesResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricVolumesResponse.attributeTypeMap;
    }
}
exports.MetricVolumesResponse = MetricVolumesResponse;
/**
 * @ignore
 */
MetricVolumesResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "MetricVolumes",
    },
};
//# sourceMappingURL=MetricVolumesResponse.js.map

/***/ }),

/***/ 43052:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricsAndMetricTagConfigurationsResponse = void 0;
/**
 * Response object that includes metrics and metric tag configurations.
 */
class MetricsAndMetricTagConfigurationsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricsAndMetricTagConfigurationsResponse.attributeTypeMap;
    }
}
exports.MetricsAndMetricTagConfigurationsResponse = MetricsAndMetricTagConfigurationsResponse;
/**
 * @ignore
 */
MetricsAndMetricTagConfigurationsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<MetricsAndMetricTagConfigurations>",
    },
};
//# sourceMappingURL=MetricsAndMetricTagConfigurationsResponse.js.map

/***/ }),

/***/ 49485:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricsScalarQuery = void 0;
/**
 * An individual scalar metrics query.
 */
class MetricsScalarQuery {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricsScalarQuery.attributeTypeMap;
    }
}
exports.MetricsScalarQuery = MetricsScalarQuery;
/**
 * @ignore
 */
MetricsScalarQuery.attributeTypeMap = {
    aggregator: {
        baseName: "aggregator",
        type: "MetricsAggregator",
        required: true,
    },
    dataSource: {
        baseName: "data_source",
        type: "MetricsDataSource",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
    },
    query: {
        baseName: "query",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=MetricsScalarQuery.js.map

/***/ }),

/***/ 39342:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricsTimeseriesQuery = void 0;
/**
 * An individual timeseries metrics query.
 */
class MetricsTimeseriesQuery {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MetricsTimeseriesQuery.attributeTypeMap;
    }
}
exports.MetricsTimeseriesQuery = MetricsTimeseriesQuery;
/**
 * @ignore
 */
MetricsTimeseriesQuery.attributeTypeMap = {
    dataSource: {
        baseName: "data_source",
        type: "MetricsDataSource",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
    },
    query: {
        baseName: "query",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=MetricsTimeseriesQuery.js.map

/***/ }),

/***/ 13129:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorConfigPolicyAttributeCreateRequest = void 0;
/**
 * Policy and policy type for a monitor configuration policy.
 */
class MonitorConfigPolicyAttributeCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorConfigPolicyAttributeCreateRequest.attributeTypeMap;
    }
}
exports.MonitorConfigPolicyAttributeCreateRequest = MonitorConfigPolicyAttributeCreateRequest;
/**
 * @ignore
 */
MonitorConfigPolicyAttributeCreateRequest.attributeTypeMap = {
    policy: {
        baseName: "policy",
        type: "MonitorConfigPolicyPolicyCreateRequest",
        required: true,
    },
    policyType: {
        baseName: "policy_type",
        type: "MonitorConfigPolicyType",
        required: true,
    },
};
//# sourceMappingURL=MonitorConfigPolicyAttributeCreateRequest.js.map

/***/ }),

/***/ 8044:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorConfigPolicyAttributeEditRequest = void 0;
/**
 * Policy and policy type for a monitor configuration policy.
 */
class MonitorConfigPolicyAttributeEditRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorConfigPolicyAttributeEditRequest.attributeTypeMap;
    }
}
exports.MonitorConfigPolicyAttributeEditRequest = MonitorConfigPolicyAttributeEditRequest;
/**
 * @ignore
 */
MonitorConfigPolicyAttributeEditRequest.attributeTypeMap = {
    policy: {
        baseName: "policy",
        type: "MonitorConfigPolicyPolicy",
        required: true,
    },
    policyType: {
        baseName: "policy_type",
        type: "MonitorConfigPolicyType",
        required: true,
    },
};
//# sourceMappingURL=MonitorConfigPolicyAttributeEditRequest.js.map

/***/ }),

/***/ 76229:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorConfigPolicyAttributeResponse = void 0;
/**
 * Policy and policy type for a monitor configuration policy.
 */
class MonitorConfigPolicyAttributeResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorConfigPolicyAttributeResponse.attributeTypeMap;
    }
}
exports.MonitorConfigPolicyAttributeResponse = MonitorConfigPolicyAttributeResponse;
/**
 * @ignore
 */
MonitorConfigPolicyAttributeResponse.attributeTypeMap = {
    policy: {
        baseName: "policy",
        type: "MonitorConfigPolicyPolicy",
    },
    policyType: {
        baseName: "policy_type",
        type: "MonitorConfigPolicyType",
    },
};
//# sourceMappingURL=MonitorConfigPolicyAttributeResponse.js.map

/***/ }),

/***/ 53026:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorConfigPolicyCreateData = void 0;
/**
 * A monitor configuration policy data.
 */
class MonitorConfigPolicyCreateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorConfigPolicyCreateData.attributeTypeMap;
    }
}
exports.MonitorConfigPolicyCreateData = MonitorConfigPolicyCreateData;
/**
 * @ignore
 */
MonitorConfigPolicyCreateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "MonitorConfigPolicyAttributeCreateRequest",
        required: true,
    },
    type: {
        baseName: "type",
        type: "MonitorConfigPolicyResourceType",
        required: true,
    },
};
//# sourceMappingURL=MonitorConfigPolicyCreateData.js.map

/***/ }),

/***/ 41863:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorConfigPolicyCreateRequest = void 0;
/**
 * Request for creating a monitor configuration policy.
 */
class MonitorConfigPolicyCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorConfigPolicyCreateRequest.attributeTypeMap;
    }
}
exports.MonitorConfigPolicyCreateRequest = MonitorConfigPolicyCreateRequest;
/**
 * @ignore
 */
MonitorConfigPolicyCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "MonitorConfigPolicyCreateData",
        required: true,
    },
};
//# sourceMappingURL=MonitorConfigPolicyCreateRequest.js.map

/***/ }),

/***/ 66735:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorConfigPolicyEditData = void 0;
/**
 * A monitor configuration policy data.
 */
class MonitorConfigPolicyEditData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorConfigPolicyEditData.attributeTypeMap;
    }
}
exports.MonitorConfigPolicyEditData = MonitorConfigPolicyEditData;
/**
 * @ignore
 */
MonitorConfigPolicyEditData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "MonitorConfigPolicyAttributeEditRequest",
        required: true,
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "MonitorConfigPolicyResourceType",
        required: true,
    },
};
//# sourceMappingURL=MonitorConfigPolicyEditData.js.map

/***/ }),

/***/ 91060:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorConfigPolicyEditRequest = void 0;
/**
 * Request for editing a monitor configuration policy.
 */
class MonitorConfigPolicyEditRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorConfigPolicyEditRequest.attributeTypeMap;
    }
}
exports.MonitorConfigPolicyEditRequest = MonitorConfigPolicyEditRequest;
/**
 * @ignore
 */
MonitorConfigPolicyEditRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "MonitorConfigPolicyEditData",
        required: true,
    },
};
//# sourceMappingURL=MonitorConfigPolicyEditRequest.js.map

/***/ }),

/***/ 79750:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorConfigPolicyListResponse = void 0;
/**
 * Response for retrieving all monitor configuration policies.
 */
class MonitorConfigPolicyListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorConfigPolicyListResponse.attributeTypeMap;
    }
}
exports.MonitorConfigPolicyListResponse = MonitorConfigPolicyListResponse;
/**
 * @ignore
 */
MonitorConfigPolicyListResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<MonitorConfigPolicyResponseData>",
    },
};
//# sourceMappingURL=MonitorConfigPolicyListResponse.js.map

/***/ }),

/***/ 86660:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorConfigPolicyResponse = void 0;
/**
 * Response for retrieving a monitor configuration policy.
 */
class MonitorConfigPolicyResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorConfigPolicyResponse.attributeTypeMap;
    }
}
exports.MonitorConfigPolicyResponse = MonitorConfigPolicyResponse;
/**
 * @ignore
 */
MonitorConfigPolicyResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "MonitorConfigPolicyResponseData",
    },
};
//# sourceMappingURL=MonitorConfigPolicyResponse.js.map

/***/ }),

/***/ 14042:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorConfigPolicyResponseData = void 0;
/**
 * A monitor configuration policy data.
 */
class MonitorConfigPolicyResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorConfigPolicyResponseData.attributeTypeMap;
    }
}
exports.MonitorConfigPolicyResponseData = MonitorConfigPolicyResponseData;
/**
 * @ignore
 */
MonitorConfigPolicyResponseData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "MonitorConfigPolicyAttributeResponse",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "MonitorConfigPolicyResourceType",
    },
};
//# sourceMappingURL=MonitorConfigPolicyResponseData.js.map

/***/ }),

/***/ 60362:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorConfigPolicyTagPolicy = void 0;
/**
 * Tag attributes of a monitor configuration policy.
 */
class MonitorConfigPolicyTagPolicy {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorConfigPolicyTagPolicy.attributeTypeMap;
    }
}
exports.MonitorConfigPolicyTagPolicy = MonitorConfigPolicyTagPolicy;
/**
 * @ignore
 */
MonitorConfigPolicyTagPolicy.attributeTypeMap = {
    tagKey: {
        baseName: "tag_key",
        type: "string",
    },
    tagKeyRequired: {
        baseName: "tag_key_required",
        type: "boolean",
    },
    validTagValues: {
        baseName: "valid_tag_values",
        type: "Array<string>",
    },
};
//# sourceMappingURL=MonitorConfigPolicyTagPolicy.js.map

/***/ }),

/***/ 40171:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorConfigPolicyTagPolicyCreateRequest = void 0;
/**
 * Tag attributes of a monitor configuration policy.
 */
class MonitorConfigPolicyTagPolicyCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorConfigPolicyTagPolicyCreateRequest.attributeTypeMap;
    }
}
exports.MonitorConfigPolicyTagPolicyCreateRequest = MonitorConfigPolicyTagPolicyCreateRequest;
/**
 * @ignore
 */
MonitorConfigPolicyTagPolicyCreateRequest.attributeTypeMap = {
    tagKey: {
        baseName: "tag_key",
        type: "string",
        required: true,
    },
    tagKeyRequired: {
        baseName: "tag_key_required",
        type: "boolean",
        required: true,
    },
    validTagValues: {
        baseName: "valid_tag_values",
        type: "Array<string>",
        required: true,
    },
};
//# sourceMappingURL=MonitorConfigPolicyTagPolicyCreateRequest.js.map

/***/ }),

/***/ 2743:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonitorType = void 0;
/**
 * Attributes from the monitor that triggered the event.
 */
class MonitorType {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return MonitorType.attributeTypeMap;
    }
}
exports.MonitorType = MonitorType;
/**
 * @ignore
 */
MonitorType.attributeTypeMap = {
    createdAt: {
        baseName: "created_at",
        type: "number",
        format: "int64",
    },
    groupStatus: {
        baseName: "group_status",
        type: "number",
        format: "int32",
    },
    groups: {
        baseName: "groups",
        type: "Array<string>",
    },
    id: {
        baseName: "id",
        type: "number",
        format: "int64",
    },
    message: {
        baseName: "message",
        type: "string",
    },
    modified: {
        baseName: "modified",
        type: "number",
        format: "int64",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    query: {
        baseName: "query",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    templatedName: {
        baseName: "templated_name",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "string",
    },
};
//# sourceMappingURL=MonitorType.js.map

/***/ }),

/***/ 71426:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NullableRelationshipToUser = void 0;
/**
 * Relationship to user.
 */
class NullableRelationshipToUser {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NullableRelationshipToUser.attributeTypeMap;
    }
}
exports.NullableRelationshipToUser = NullableRelationshipToUser;
/**
 * @ignore
 */
NullableRelationshipToUser.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "NullableRelationshipToUserData",
        required: true,
    },
};
//# sourceMappingURL=NullableRelationshipToUser.js.map

/***/ }),

/***/ 16203:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NullableRelationshipToUserData = void 0;
/**
 * Relationship to user object.
 */
class NullableRelationshipToUserData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return NullableRelationshipToUserData.attributeTypeMap;
    }
}
exports.NullableRelationshipToUserData = NullableRelationshipToUserData;
/**
 * @ignore
 */
NullableRelationshipToUserData.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "UsersType",
        required: true,
    },
};
//# sourceMappingURL=NullableRelationshipToUserData.js.map

/***/ }),

/***/ 47805:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ObjectSerializer = void 0;
const APIErrorResponse_1 = __webpack_require__(70205);
const APIKeyCreateAttributes_1 = __webpack_require__(59524);
const APIKeyCreateData_1 = __webpack_require__(18279);
const APIKeyCreateRequest_1 = __webpack_require__(58893);
const APIKeyRelationships_1 = __webpack_require__(54551);
const APIKeyResponse_1 = __webpack_require__(97531);
const APIKeyUpdateAttributes_1 = __webpack_require__(65168);
const APIKeyUpdateData_1 = __webpack_require__(51292);
const APIKeyUpdateRequest_1 = __webpack_require__(20585);
const APIKeysResponse_1 = __webpack_require__(13214);
const ApplicationKeyCreateAttributes_1 = __webpack_require__(71500);
const ApplicationKeyCreateData_1 = __webpack_require__(39673);
const ApplicationKeyCreateRequest_1 = __webpack_require__(89736);
const ApplicationKeyRelationships_1 = __webpack_require__(65634);
const ApplicationKeyResponse_1 = __webpack_require__(73297);
const ApplicationKeyUpdateAttributes_1 = __webpack_require__(38052);
const ApplicationKeyUpdateData_1 = __webpack_require__(3655);
const ApplicationKeyUpdateRequest_1 = __webpack_require__(19103);
const AuditLogsEvent_1 = __webpack_require__(30095);
const AuditLogsEventAttributes_1 = __webpack_require__(52083);
const AuditLogsEventsResponse_1 = __webpack_require__(64297);
const AuditLogsQueryFilter_1 = __webpack_require__(22659);
const AuditLogsQueryOptions_1 = __webpack_require__(68991);
const AuditLogsQueryPageOptions_1 = __webpack_require__(46706);
const AuditLogsResponseLinks_1 = __webpack_require__(67454);
const AuditLogsResponseMetadata_1 = __webpack_require__(41903);
const AuditLogsResponsePage_1 = __webpack_require__(4131);
const AuditLogsSearchEventsRequest_1 = __webpack_require__(52614);
const AuditLogsWarning_1 = __webpack_require__(28817);
const AuthNMapping_1 = __webpack_require__(80723);
const AuthNMappingAttributes_1 = __webpack_require__(70543);
const AuthNMappingCreateAttributes_1 = __webpack_require__(47073);
const AuthNMappingCreateData_1 = __webpack_require__(2847);
const AuthNMappingCreateRelationships_1 = __webpack_require__(20943);
const AuthNMappingCreateRequest_1 = __webpack_require__(32773);
const AuthNMappingRelationships_1 = __webpack_require__(17587);
const AuthNMappingResponse_1 = __webpack_require__(60064);
const AuthNMappingUpdateAttributes_1 = __webpack_require__(61653);
const AuthNMappingUpdateData_1 = __webpack_require__(98430);
const AuthNMappingUpdateRelationships_1 = __webpack_require__(39731);
const AuthNMappingUpdateRequest_1 = __webpack_require__(18093);
const AuthNMappingsResponse_1 = __webpack_require__(18439);
const CIAppAggregateBucketValueTimeseriesPoint_1 = __webpack_require__(86227);
const CIAppAggregateSort_1 = __webpack_require__(13896);
const CIAppCompute_1 = __webpack_require__(5294);
const CIAppEventAttributes_1 = __webpack_require__(5795);
const CIAppGroupByHistogram_1 = __webpack_require__(84337);
const CIAppPipelineEvent_1 = __webpack_require__(92629);
const CIAppPipelineEventsRequest_1 = __webpack_require__(7634);
const CIAppPipelineEventsResponse_1 = __webpack_require__(81393);
const CIAppPipelinesAggregateRequest_1 = __webpack_require__(9879);
const CIAppPipelinesAggregationBucketsResponse_1 = __webpack_require__(48758);
const CIAppPipelinesAnalyticsAggregateResponse_1 = __webpack_require__(92621);
const CIAppPipelinesBucketResponse_1 = __webpack_require__(61408);
const CIAppPipelinesGroupBy_1 = __webpack_require__(89633);
const CIAppPipelinesQueryFilter_1 = __webpack_require__(2272);
const CIAppQueryOptions_1 = __webpack_require__(58517);
const CIAppQueryPageOptions_1 = __webpack_require__(89457);
const CIAppResponseLinks_1 = __webpack_require__(49266);
const CIAppResponseMetadata_1 = __webpack_require__(89609);
const CIAppResponseMetadataWithPagination_1 = __webpack_require__(82475);
const CIAppResponsePage_1 = __webpack_require__(34502);
const CIAppTestEvent_1 = __webpack_require__(38943);
const CIAppTestEventsRequest_1 = __webpack_require__(94731);
const CIAppTestEventsResponse_1 = __webpack_require__(12138);
const CIAppTestsAggregateRequest_1 = __webpack_require__(3854);
const CIAppTestsAggregationBucketsResponse_1 = __webpack_require__(64466);
const CIAppTestsAnalyticsAggregateResponse_1 = __webpack_require__(17669);
const CIAppTestsBucketResponse_1 = __webpack_require__(34463);
const CIAppTestsGroupBy_1 = __webpack_require__(59491);
const CIAppTestsQueryFilter_1 = __webpack_require__(27928);
const CIAppWarning_1 = __webpack_require__(86117);
const ChargebackBreakdown_1 = __webpack_require__(16467);
const CloudConfigurationComplianceRuleOptions_1 = __webpack_require__(38115);
const CloudConfigurationRegoRule_1 = __webpack_require__(7582);
const CloudConfigurationRuleCaseCreate_1 = __webpack_require__(17477);
const CloudConfigurationRuleComplianceSignalOptions_1 = __webpack_require__(11004);
const CloudConfigurationRuleCreatePayload_1 = __webpack_require__(1935);
const CloudConfigurationRuleOptions_1 = __webpack_require__(47654);
const CloudWorkloadSecurityAgentRuleAttributes_1 = __webpack_require__(60792);
const CloudWorkloadSecurityAgentRuleCreateAttributes_1 = __webpack_require__(91982);
const CloudWorkloadSecurityAgentRuleCreateData_1 = __webpack_require__(57506);
const CloudWorkloadSecurityAgentRuleCreateRequest_1 = __webpack_require__(11249);
const CloudWorkloadSecurityAgentRuleCreatorAttributes_1 = __webpack_require__(34366);
const CloudWorkloadSecurityAgentRuleData_1 = __webpack_require__(79526);
const CloudWorkloadSecurityAgentRuleResponse_1 = __webpack_require__(70516);
const CloudWorkloadSecurityAgentRuleUpdateAttributes_1 = __webpack_require__(43319);
const CloudWorkloadSecurityAgentRuleUpdateData_1 = __webpack_require__(92347);
const CloudWorkloadSecurityAgentRuleUpdateRequest_1 = __webpack_require__(96586);
const CloudWorkloadSecurityAgentRuleUpdaterAttributes_1 = __webpack_require__(22606);
const CloudWorkloadSecurityAgentRulesListResponse_1 = __webpack_require__(42739);
const CloudflareAccountCreateRequest_1 = __webpack_require__(85346);
const CloudflareAccountCreateRequestAttributes_1 = __webpack_require__(45414);
const CloudflareAccountCreateRequestData_1 = __webpack_require__(19660);
const CloudflareAccountResponse_1 = __webpack_require__(53134);
const CloudflareAccountResponseAttributes_1 = __webpack_require__(614);
const CloudflareAccountResponseData_1 = __webpack_require__(29339);
const CloudflareAccountUpdateRequest_1 = __webpack_require__(73177);
const CloudflareAccountUpdateRequestAttributes_1 = __webpack_require__(25778);
const CloudflareAccountUpdateRequestData_1 = __webpack_require__(18693);
const CloudflareAccountsResponse_1 = __webpack_require__(25675);
const ConfluentAccountCreateRequest_1 = __webpack_require__(2398);
const ConfluentAccountCreateRequestAttributes_1 = __webpack_require__(28121);
const ConfluentAccountCreateRequestData_1 = __webpack_require__(43932);
const ConfluentAccountResourceAttributes_1 = __webpack_require__(96316);
const ConfluentAccountResponse_1 = __webpack_require__(98659);
const ConfluentAccountResponseAttributes_1 = __webpack_require__(31345);
const ConfluentAccountResponseData_1 = __webpack_require__(43122);
const ConfluentAccountUpdateRequest_1 = __webpack_require__(36313);
const ConfluentAccountUpdateRequestAttributes_1 = __webpack_require__(34989);
const ConfluentAccountUpdateRequestData_1 = __webpack_require__(19026);
const ConfluentAccountsResponse_1 = __webpack_require__(66438);
const ConfluentResourceRequest_1 = __webpack_require__(44539);
const ConfluentResourceRequestAttributes_1 = __webpack_require__(19799);
const ConfluentResourceRequestData_1 = __webpack_require__(40667);
const ConfluentResourceResponse_1 = __webpack_require__(4896);
const ConfluentResourceResponseAttributes_1 = __webpack_require__(32977);
const ConfluentResourceResponseData_1 = __webpack_require__(92723);
const ConfluentResourcesResponse_1 = __webpack_require__(92452);
const CostByOrg_1 = __webpack_require__(62609);
const CostByOrgAttributes_1 = __webpack_require__(268);
const CostByOrgResponse_1 = __webpack_require__(79292);
const Creator_1 = __webpack_require__(81580);
const DashboardListAddItemsRequest_1 = __webpack_require__(1746);
const DashboardListAddItemsResponse_1 = __webpack_require__(97047);
const DashboardListDeleteItemsRequest_1 = __webpack_require__(6487);
const DashboardListDeleteItemsResponse_1 = __webpack_require__(79067);
const DashboardListItem_1 = __webpack_require__(25719);
const DashboardListItemRequest_1 = __webpack_require__(72262);
const DashboardListItemResponse_1 = __webpack_require__(24037);
const DashboardListItems_1 = __webpack_require__(19638);
const DashboardListUpdateItemsRequest_1 = __webpack_require__(88487);
const DashboardListUpdateItemsResponse_1 = __webpack_require__(3644);
const DataScalarColumn_1 = __webpack_require__(83457);
const Event_1 = __webpack_require__(80441);
const EventAttributes_1 = __webpack_require__(54941);
const EventResponse_1 = __webpack_require__(77892);
const EventResponseAttributes_1 = __webpack_require__(90525);
const EventsCompute_1 = __webpack_require__(57394);
const EventsGroupBy_1 = __webpack_require__(96960);
const EventsGroupBySort_1 = __webpack_require__(61256);
const EventsListRequest_1 = __webpack_require__(23754);
const EventsListResponse_1 = __webpack_require__(43236);
const EventsListResponseLinks_1 = __webpack_require__(80820);
const EventsQueryFilter_1 = __webpack_require__(31925);
const EventsQueryOptions_1 = __webpack_require__(64638);
const EventsRequestPage_1 = __webpack_require__(57858);
const EventsResponseMetadata_1 = __webpack_require__(24290);
const EventsResponseMetadataPage_1 = __webpack_require__(90178);
const EventsScalarQuery_1 = __webpack_require__(69968);
const EventsSearch_1 = __webpack_require__(98043);
const EventsTimeseriesQuery_1 = __webpack_require__(55504);
const EventsWarning_1 = __webpack_require__(72766);
const FastlyAccounResponseAttributes_1 = __webpack_require__(99983);
const FastlyAccountCreateRequest_1 = __webpack_require__(25259);
const FastlyAccountCreateRequestAttributes_1 = __webpack_require__(95711);
const FastlyAccountCreateRequestData_1 = __webpack_require__(18422);
const FastlyAccountResponse_1 = __webpack_require__(15310);
const FastlyAccountResponseData_1 = __webpack_require__(4599);
const FastlyAccountUpdateRequest_1 = __webpack_require__(15128);
const FastlyAccountUpdateRequestAttributes_1 = __webpack_require__(30189);
const FastlyAccountUpdateRequestData_1 = __webpack_require__(550);
const FastlyAccountsResponse_1 = __webpack_require__(11681);
const FastlyService_1 = __webpack_require__(8518);
const FastlyServiceAttributes_1 = __webpack_require__(83707);
const FastlyServiceData_1 = __webpack_require__(79404);
const FastlyServiceRequest_1 = __webpack_require__(8366);
const FastlyServiceResponse_1 = __webpack_require__(27210);
const FastlyServicesResponse_1 = __webpack_require__(7220);
const FormulaLimit_1 = __webpack_require__(97118);
const FullAPIKey_1 = __webpack_require__(56159);
const FullAPIKeyAttributes_1 = __webpack_require__(25642);
const FullApplicationKey_1 = __webpack_require__(54147);
const FullApplicationKeyAttributes_1 = __webpack_require__(79380);
const GroupScalarColumn_1 = __webpack_require__(2189);
const HTTPLogError_1 = __webpack_require__(73991);
const HTTPLogErrors_1 = __webpack_require__(18911);
const HTTPLogItem_1 = __webpack_require__(40312);
const HourlyUsage_1 = __webpack_require__(26722);
const HourlyUsageAttributes_1 = __webpack_require__(89886);
const HourlyUsageMeasurement_1 = __webpack_require__(45509);
const HourlyUsageMetadata_1 = __webpack_require__(12821);
const HourlyUsagePagination_1 = __webpack_require__(79406);
const HourlyUsageResponse_1 = __webpack_require__(70015);
const IdPMetadataFormData_1 = __webpack_require__(68145);
const IncidentAttachmentData_1 = __webpack_require__(25208);
const IncidentAttachmentLinkAttributes_1 = __webpack_require__(78737);
const IncidentAttachmentLinkAttributesAttachmentObject_1 = __webpack_require__(12645);
const IncidentAttachmentPostmortemAttributes_1 = __webpack_require__(14721);
const IncidentAttachmentRelationships_1 = __webpack_require__(11967);
const IncidentAttachmentUpdateData_1 = __webpack_require__(36350);
const IncidentAttachmentUpdateRequest_1 = __webpack_require__(72450);
const IncidentAttachmentUpdateResponse_1 = __webpack_require__(23453);
const IncidentAttachmentsPostmortemAttributesAttachmentObject_1 = __webpack_require__(46618);
const IncidentAttachmentsResponse_1 = __webpack_require__(37959);
const IncidentCreateAttributes_1 = __webpack_require__(85021);
const IncidentCreateData_1 = __webpack_require__(33708);
const IncidentCreateRelationships_1 = __webpack_require__(87980);
const IncidentCreateRequest_1 = __webpack_require__(79893);
const IncidentFieldAttributesMultipleValue_1 = __webpack_require__(85167);
const IncidentFieldAttributesSingleValue_1 = __webpack_require__(65717);
const IncidentNotificationHandle_1 = __webpack_require__(64132);
const IncidentResponse_1 = __webpack_require__(85933);
const IncidentResponseAttributes_1 = __webpack_require__(72948);
const IncidentResponseData_1 = __webpack_require__(20274);
const IncidentResponseMeta_1 = __webpack_require__(16729);
const IncidentResponseMetaPagination_1 = __webpack_require__(97345);
const IncidentResponseRelationships_1 = __webpack_require__(88233);
const IncidentSearchResponse_1 = __webpack_require__(89998);
const IncidentSearchResponseAttributes_1 = __webpack_require__(56435);
const IncidentSearchResponseData_1 = __webpack_require__(24443);
const IncidentSearchResponseFacetsData_1 = __webpack_require__(42940);
const IncidentSearchResponseFieldFacetData_1 = __webpack_require__(90951);
const IncidentSearchResponseIncidentsData_1 = __webpack_require__(16704);
const IncidentSearchResponseNumericFacetData_1 = __webpack_require__(15843);
const IncidentSearchResponseNumericFacetDataAggregates_1 = __webpack_require__(9253);
const IncidentSearchResponsePropertyFieldFacetData_1 = __webpack_require__(23290);
const IncidentSearchResponseUserFacetData_1 = __webpack_require__(64690);
const IncidentServiceCreateAttributes_1 = __webpack_require__(81262);
const IncidentServiceCreateData_1 = __webpack_require__(50275);
const IncidentServiceCreateRequest_1 = __webpack_require__(61042);
const IncidentServiceRelationships_1 = __webpack_require__(67742);
const IncidentServiceResponse_1 = __webpack_require__(8010);
const IncidentServiceResponseAttributes_1 = __webpack_require__(64840);
const IncidentServiceResponseData_1 = __webpack_require__(13259);
const IncidentServiceUpdateAttributes_1 = __webpack_require__(2935);
const IncidentServiceUpdateData_1 = __webpack_require__(63215);
const IncidentServiceUpdateRequest_1 = __webpack_require__(97971);
const IncidentServicesResponse_1 = __webpack_require__(67102);
const IncidentTeamCreateAttributes_1 = __webpack_require__(20944);
const IncidentTeamCreateData_1 = __webpack_require__(83456);
const IncidentTeamCreateRequest_1 = __webpack_require__(46712);
const IncidentTeamRelationships_1 = __webpack_require__(31266);
const IncidentTeamResponse_1 = __webpack_require__(88841);
const IncidentTeamResponseAttributes_1 = __webpack_require__(13482);
const IncidentTeamResponseData_1 = __webpack_require__(79651);
const IncidentTeamUpdateAttributes_1 = __webpack_require__(14799);
const IncidentTeamUpdateData_1 = __webpack_require__(41914);
const IncidentTeamUpdateRequest_1 = __webpack_require__(1174);
const IncidentTeamsResponse_1 = __webpack_require__(72162);
const IncidentTimelineCellMarkdownCreateAttributes_1 = __webpack_require__(48212);
const IncidentTimelineCellMarkdownCreateAttributesContent_1 = __webpack_require__(4504);
const IncidentUpdateAttributes_1 = __webpack_require__(87879);
const IncidentUpdateData_1 = __webpack_require__(14695);
const IncidentUpdateRelationships_1 = __webpack_require__(40863);
const IncidentUpdateRequest_1 = __webpack_require__(94252);
const IncidentsResponse_1 = __webpack_require__(84660);
const IntakePayloadAccepted_1 = __webpack_require__(50768);
const ListApplicationKeysResponse_1 = __webpack_require__(33213);
const Log_1 = __webpack_require__(50679);
const LogAttributes_1 = __webpack_require__(82583);
const LogsAggregateBucket_1 = __webpack_require__(48920);
const LogsAggregateBucketValueTimeseriesPoint_1 = __webpack_require__(87989);
const LogsAggregateRequest_1 = __webpack_require__(13619);
const LogsAggregateRequestPage_1 = __webpack_require__(73702);
const LogsAggregateResponse_1 = __webpack_require__(42578);
const LogsAggregateResponseData_1 = __webpack_require__(95647);
const LogsAggregateSort_1 = __webpack_require__(49817);
const LogsArchive_1 = __webpack_require__(15665);
const LogsArchiveAttributes_1 = __webpack_require__(14064);
const LogsArchiveCreateRequest_1 = __webpack_require__(20167);
const LogsArchiveCreateRequestAttributes_1 = __webpack_require__(44357);
const LogsArchiveCreateRequestDefinition_1 = __webpack_require__(41915);
const LogsArchiveDefinition_1 = __webpack_require__(48978);
const LogsArchiveDestinationAzure_1 = __webpack_require__(29038);
const LogsArchiveDestinationGCS_1 = __webpack_require__(71657);
const LogsArchiveDestinationS3_1 = __webpack_require__(87520);
const LogsArchiveIntegrationAzure_1 = __webpack_require__(90187);
const LogsArchiveIntegrationGCS_1 = __webpack_require__(83645);
const LogsArchiveIntegrationS3_1 = __webpack_require__(9681);
const LogsArchiveOrder_1 = __webpack_require__(13220);
const LogsArchiveOrderAttributes_1 = __webpack_require__(33277);
const LogsArchiveOrderDefinition_1 = __webpack_require__(74878);
const LogsArchives_1 = __webpack_require__(16852);
const LogsCompute_1 = __webpack_require__(19236);
const LogsGroupBy_1 = __webpack_require__(21104);
const LogsGroupByHistogram_1 = __webpack_require__(2133);
const LogsListRequest_1 = __webpack_require__(46975);
const LogsListRequestPage_1 = __webpack_require__(92486);
const LogsListResponse_1 = __webpack_require__(62282);
const LogsListResponseLinks_1 = __webpack_require__(79413);
const LogsMetricCompute_1 = __webpack_require__(74170);
const LogsMetricCreateAttributes_1 = __webpack_require__(27156);
const LogsMetricCreateData_1 = __webpack_require__(67578);
const LogsMetricCreateRequest_1 = __webpack_require__(64489);
const LogsMetricFilter_1 = __webpack_require__(95980);
const LogsMetricGroupBy_1 = __webpack_require__(21776);
const LogsMetricResponse_1 = __webpack_require__(86871);
const LogsMetricResponseAttributes_1 = __webpack_require__(94655);
const LogsMetricResponseCompute_1 = __webpack_require__(66641);
const LogsMetricResponseData_1 = __webpack_require__(2519);
const LogsMetricResponseFilter_1 = __webpack_require__(37718);
const LogsMetricResponseGroupBy_1 = __webpack_require__(83284);
const LogsMetricUpdateAttributes_1 = __webpack_require__(43114);
const LogsMetricUpdateCompute_1 = __webpack_require__(70970);
const LogsMetricUpdateData_1 = __webpack_require__(32319);
const LogsMetricUpdateRequest_1 = __webpack_require__(84033);
const LogsMetricsResponse_1 = __webpack_require__(57793);
const LogsQueryFilter_1 = __webpack_require__(36574);
const LogsQueryOptions_1 = __webpack_require__(75773);
const LogsResponseMetadata_1 = __webpack_require__(9675);
const LogsResponseMetadataPage_1 = __webpack_require__(9159);
const LogsWarning_1 = __webpack_require__(32347);
const Metric_1 = __webpack_require__(81125);
const MetricAllTags_1 = __webpack_require__(92059);
const MetricAllTagsAttributes_1 = __webpack_require__(5563);
const MetricAllTagsResponse_1 = __webpack_require__(72220);
const MetricBulkTagConfigCreate_1 = __webpack_require__(91782);
const MetricBulkTagConfigCreateAttributes_1 = __webpack_require__(32326);
const MetricBulkTagConfigCreateRequest_1 = __webpack_require__(4270);
const MetricBulkTagConfigDelete_1 = __webpack_require__(72280);
const MetricBulkTagConfigDeleteAttributes_1 = __webpack_require__(86757);
const MetricBulkTagConfigDeleteRequest_1 = __webpack_require__(3217);
const MetricBulkTagConfigResponse_1 = __webpack_require__(40953);
const MetricBulkTagConfigStatus_1 = __webpack_require__(57682);
const MetricBulkTagConfigStatusAttributes_1 = __webpack_require__(82262);
const MetricCustomAggregation_1 = __webpack_require__(17484);
const MetricDistinctVolume_1 = __webpack_require__(85654);
const MetricDistinctVolumeAttributes_1 = __webpack_require__(23953);
const MetricEstimate_1 = __webpack_require__(55051);
const MetricEstimateAttributes_1 = __webpack_require__(50065);
const MetricEstimateResponse_1 = __webpack_require__(65503);
const MetricIngestedIndexedVolume_1 = __webpack_require__(8882);
const MetricIngestedIndexedVolumeAttributes_1 = __webpack_require__(65551);
const MetricMetadata_1 = __webpack_require__(92399);
const MetricOrigin_1 = __webpack_require__(94810);
const MetricPayload_1 = __webpack_require__(49429);
const MetricPoint_1 = __webpack_require__(71586);
const MetricResource_1 = __webpack_require__(85867);
const MetricSeries_1 = __webpack_require__(38882);
const MetricSuggestedTagsAndAggregations_1 = __webpack_require__(48241);
const MetricSuggestedTagsAndAggregationsResponse_1 = __webpack_require__(39816);
const MetricSuggestedTagsAttributes_1 = __webpack_require__(26853);
const MetricTagConfiguration_1 = __webpack_require__(35857);
const MetricTagConfigurationAttributes_1 = __webpack_require__(9851);
const MetricTagConfigurationCreateAttributes_1 = __webpack_require__(19186);
const MetricTagConfigurationCreateData_1 = __webpack_require__(66135);
const MetricTagConfigurationCreateRequest_1 = __webpack_require__(84050);
const MetricTagConfigurationResponse_1 = __webpack_require__(55797);
const MetricTagConfigurationUpdateAttributes_1 = __webpack_require__(19503);
const MetricTagConfigurationUpdateData_1 = __webpack_require__(63194);
const MetricTagConfigurationUpdateRequest_1 = __webpack_require__(19976);
const MetricVolumesResponse_1 = __webpack_require__(72742);
const MetricsAndMetricTagConfigurationsResponse_1 = __webpack_require__(43052);
const MetricsScalarQuery_1 = __webpack_require__(49485);
const MetricsTimeseriesQuery_1 = __webpack_require__(39342);
const MonitorConfigPolicyAttributeCreateRequest_1 = __webpack_require__(13129);
const MonitorConfigPolicyAttributeEditRequest_1 = __webpack_require__(8044);
const MonitorConfigPolicyAttributeResponse_1 = __webpack_require__(76229);
const MonitorConfigPolicyCreateData_1 = __webpack_require__(53026);
const MonitorConfigPolicyCreateRequest_1 = __webpack_require__(41863);
const MonitorConfigPolicyEditData_1 = __webpack_require__(66735);
const MonitorConfigPolicyEditRequest_1 = __webpack_require__(91060);
const MonitorConfigPolicyListResponse_1 = __webpack_require__(79750);
const MonitorConfigPolicyResponse_1 = __webpack_require__(86660);
const MonitorConfigPolicyResponseData_1 = __webpack_require__(14042);
const MonitorConfigPolicyTagPolicy_1 = __webpack_require__(60362);
const MonitorConfigPolicyTagPolicyCreateRequest_1 = __webpack_require__(40171);
const MonitorType_1 = __webpack_require__(2743);
const NullableRelationshipToUser_1 = __webpack_require__(71426);
const NullableRelationshipToUserData_1 = __webpack_require__(16203);
const OpsgenieServiceCreateAttributes_1 = __webpack_require__(96016);
const OpsgenieServiceCreateData_1 = __webpack_require__(44394);
const OpsgenieServiceCreateRequest_1 = __webpack_require__(641);
const OpsgenieServiceResponse_1 = __webpack_require__(3424);
const OpsgenieServiceResponseAttributes_1 = __webpack_require__(36633);
const OpsgenieServiceResponseData_1 = __webpack_require__(89232);
const OpsgenieServiceUpdateAttributes_1 = __webpack_require__(46808);
const OpsgenieServiceUpdateData_1 = __webpack_require__(89005);
const OpsgenieServiceUpdateRequest_1 = __webpack_require__(52502);
const OpsgenieServicesResponse_1 = __webpack_require__(43059);
const Organization_1 = __webpack_require__(6229);
const OrganizationAttributes_1 = __webpack_require__(77933);
const Pagination_1 = __webpack_require__(35680);
const PartialAPIKey_1 = __webpack_require__(64447);
const PartialAPIKeyAttributes_1 = __webpack_require__(99573);
const PartialApplicationKey_1 = __webpack_require__(67979);
const PartialApplicationKeyAttributes_1 = __webpack_require__(96197);
const PartialApplicationKeyResponse_1 = __webpack_require__(52459);
const Permission_1 = __webpack_require__(50681);
const PermissionAttributes_1 = __webpack_require__(84187);
const PermissionsResponse_1 = __webpack_require__(99426);
const ProcessSummariesMeta_1 = __webpack_require__(30341);
const ProcessSummariesMetaPage_1 = __webpack_require__(88359);
const ProcessSummariesResponse_1 = __webpack_require__(61750);
const ProcessSummary_1 = __webpack_require__(35834);
const ProcessSummaryAttributes_1 = __webpack_require__(81126);
const QueryFormula_1 = __webpack_require__(24419);
const RUMAggregateBucketValueTimeseriesPoint_1 = __webpack_require__(71);
const RUMAggregateRequest_1 = __webpack_require__(98438);
const RUMAggregateSort_1 = __webpack_require__(66861);
const RUMAggregationBucketsResponse_1 = __webpack_require__(50116);
const RUMAnalyticsAggregateResponse_1 = __webpack_require__(9558);
const RUMApplication_1 = __webpack_require__(20447);
const RUMApplicationAttributes_1 = __webpack_require__(5619);
const RUMApplicationCreate_1 = __webpack_require__(7740);
const RUMApplicationCreateAttributes_1 = __webpack_require__(41625);
const RUMApplicationCreateRequest_1 = __webpack_require__(27250);
const RUMApplicationList_1 = __webpack_require__(3318);
const RUMApplicationListAttributes_1 = __webpack_require__(26043);
const RUMApplicationResponse_1 = __webpack_require__(59012);
const RUMApplicationUpdate_1 = __webpack_require__(11541);
const RUMApplicationUpdateAttributes_1 = __webpack_require__(3394);
const RUMApplicationUpdateRequest_1 = __webpack_require__(12932);
const RUMApplicationsResponse_1 = __webpack_require__(62857);
const RUMBucketResponse_1 = __webpack_require__(37302);
const RUMCompute_1 = __webpack_require__(34658);
const RUMEvent_1 = __webpack_require__(44075);
const RUMEventAttributes_1 = __webpack_require__(31323);
const RUMEventsResponse_1 = __webpack_require__(42841);
const RUMGroupBy_1 = __webpack_require__(82421);
const RUMGroupByHistogram_1 = __webpack_require__(27195);
const RUMQueryFilter_1 = __webpack_require__(4455);
const RUMQueryOptions_1 = __webpack_require__(53313);
const RUMQueryPageOptions_1 = __webpack_require__(89982);
const RUMResponseLinks_1 = __webpack_require__(62690);
const RUMResponseMetadata_1 = __webpack_require__(10700);
const RUMResponsePage_1 = __webpack_require__(49457);
const RUMSearchEventsRequest_1 = __webpack_require__(97557);
const RUMWarning_1 = __webpack_require__(66821);
const RelationshipToIncidentAttachment_1 = __webpack_require__(87288);
const RelationshipToIncidentAttachmentData_1 = __webpack_require__(6475);
const RelationshipToIncidentIntegrationMetadataData_1 = __webpack_require__(43443);
const RelationshipToIncidentIntegrationMetadatas_1 = __webpack_require__(91471);
const RelationshipToIncidentPostmortem_1 = __webpack_require__(91589);
const RelationshipToIncidentPostmortemData_1 = __webpack_require__(57515);
const RelationshipToOrganization_1 = __webpack_require__(1786);
const RelationshipToOrganizationData_1 = __webpack_require__(3098);
const RelationshipToOrganizations_1 = __webpack_require__(16352);
const RelationshipToPermission_1 = __webpack_require__(91286);
const RelationshipToPermissionData_1 = __webpack_require__(84713);
const RelationshipToPermissions_1 = __webpack_require__(50913);
const RelationshipToRole_1 = __webpack_require__(38615);
const RelationshipToRoleData_1 = __webpack_require__(30312);
const RelationshipToRoles_1 = __webpack_require__(62595);
const RelationshipToSAMLAssertionAttribute_1 = __webpack_require__(62436);
const RelationshipToSAMLAssertionAttributeData_1 = __webpack_require__(93258);
const RelationshipToUser_1 = __webpack_require__(93801);
const RelationshipToUserData_1 = __webpack_require__(16328);
const RelationshipToUsers_1 = __webpack_require__(51783);
const ResponseMetaAttributes_1 = __webpack_require__(14990);
const Role_1 = __webpack_require__(49248);
const RoleAttributes_1 = __webpack_require__(82581);
const RoleClone_1 = __webpack_require__(96579);
const RoleCloneAttributes_1 = __webpack_require__(34979);
const RoleCloneRequest_1 = __webpack_require__(33124);
const RoleCreateAttributes_1 = __webpack_require__(65979);
const RoleCreateData_1 = __webpack_require__(67319);
const RoleCreateRequest_1 = __webpack_require__(95305);
const RoleCreateResponse_1 = __webpack_require__(87293);
const RoleCreateResponseData_1 = __webpack_require__(72479);
const RoleRelationships_1 = __webpack_require__(71594);
const RoleResponse_1 = __webpack_require__(2524);
const RoleResponseRelationships_1 = __webpack_require__(66950);
const RoleUpdateAttributes_1 = __webpack_require__(84628);
const RoleUpdateData_1 = __webpack_require__(77060);
const RoleUpdateRequest_1 = __webpack_require__(63322);
const RoleUpdateResponse_1 = __webpack_require__(22307);
const RoleUpdateResponseData_1 = __webpack_require__(39190);
const RolesResponse_1 = __webpack_require__(95334);
const SAMLAssertionAttribute_1 = __webpack_require__(98228);
const SAMLAssertionAttributeAttributes_1 = __webpack_require__(73923);
const ScalarFormulaQueryRequest_1 = __webpack_require__(31259);
const ScalarFormulaQueryResponse_1 = __webpack_require__(3057);
const ScalarFormulaRequest_1 = __webpack_require__(84643);
const ScalarFormulaRequestAttributes_1 = __webpack_require__(27526);
const ScalarFormulaResponseAtrributes_1 = __webpack_require__(60572);
const ScalarMeta_1 = __webpack_require__(1470);
const ScalarResponse_1 = __webpack_require__(70331);
const SecurityFilter_1 = __webpack_require__(55447);
const SecurityFilterAttributes_1 = __webpack_require__(98576);
const SecurityFilterCreateAttributes_1 = __webpack_require__(39164);
const SecurityFilterCreateData_1 = __webpack_require__(73922);
const SecurityFilterCreateRequest_1 = __webpack_require__(80376);
const SecurityFilterExclusionFilter_1 = __webpack_require__(70566);
const SecurityFilterExclusionFilterResponse_1 = __webpack_require__(33320);
const SecurityFilterMeta_1 = __webpack_require__(27674);
const SecurityFilterResponse_1 = __webpack_require__(53785);
const SecurityFilterUpdateAttributes_1 = __webpack_require__(70723);
const SecurityFilterUpdateData_1 = __webpack_require__(64889);
const SecurityFilterUpdateRequest_1 = __webpack_require__(67365);
const SecurityFiltersResponse_1 = __webpack_require__(92892);
const SecurityMonitoringFilter_1 = __webpack_require__(24483);
const SecurityMonitoringListRulesResponse_1 = __webpack_require__(73982);
const SecurityMonitoringRuleCase_1 = __webpack_require__(38467);
const SecurityMonitoringRuleCaseCreate_1 = __webpack_require__(50909);
const SecurityMonitoringRuleImpossibleTravelOptions_1 = __webpack_require__(25690);
const SecurityMonitoringRuleNewValueOptions_1 = __webpack_require__(10646);
const SecurityMonitoringRuleOptions_1 = __webpack_require__(41277);
const SecurityMonitoringRuleUpdatePayload_1 = __webpack_require__(21004);
const SecurityMonitoringSignal_1 = __webpack_require__(73354);
const SecurityMonitoringSignalAssigneeUpdateAttributes_1 = __webpack_require__(14090);
const SecurityMonitoringSignalAssigneeUpdateData_1 = __webpack_require__(12839);
const SecurityMonitoringSignalAssigneeUpdateRequest_1 = __webpack_require__(65035);
const SecurityMonitoringSignalAttributes_1 = __webpack_require__(81335);
const SecurityMonitoringSignalIncidentsUpdateAttributes_1 = __webpack_require__(54429);
const SecurityMonitoringSignalIncidentsUpdateData_1 = __webpack_require__(94861);
const SecurityMonitoringSignalIncidentsUpdateRequest_1 = __webpack_require__(54497);
const SecurityMonitoringSignalListRequest_1 = __webpack_require__(13723);
const SecurityMonitoringSignalListRequestFilter_1 = __webpack_require__(75078);
const SecurityMonitoringSignalListRequestPage_1 = __webpack_require__(31123);
const SecurityMonitoringSignalRuleCreatePayload_1 = __webpack_require__(81883);
const SecurityMonitoringSignalRuleQuery_1 = __webpack_require__(93930);
const SecurityMonitoringSignalRuleResponse_1 = __webpack_require__(2788);
const SecurityMonitoringSignalRuleResponseQuery_1 = __webpack_require__(87097);
const SecurityMonitoringSignalStateUpdateAttributes_1 = __webpack_require__(15491);
const SecurityMonitoringSignalStateUpdateData_1 = __webpack_require__(48336);
const SecurityMonitoringSignalStateUpdateRequest_1 = __webpack_require__(42649);
const SecurityMonitoringSignalTriageAttributes_1 = __webpack_require__(38673);
const SecurityMonitoringSignalTriageUpdateData_1 = __webpack_require__(21346);
const SecurityMonitoringSignalTriageUpdateResponse_1 = __webpack_require__(97439);
const SecurityMonitoringSignalsListResponse_1 = __webpack_require__(8869);
const SecurityMonitoringSignalsListResponseLinks_1 = __webpack_require__(53523);
const SecurityMonitoringSignalsListResponseMeta_1 = __webpack_require__(39585);
const SecurityMonitoringSignalsListResponseMetaPage_1 = __webpack_require__(54327);
const SecurityMonitoringStandardRuleCreatePayload_1 = __webpack_require__(29677);
const SecurityMonitoringStandardRuleQuery_1 = __webpack_require__(49427);
const SecurityMonitoringStandardRuleResponse_1 = __webpack_require__(37779);
const SecurityMonitoringTriageUser_1 = __webpack_require__(38314);
const SensitiveDataScannerConfigRequest_1 = __webpack_require__(82462);
const SensitiveDataScannerConfiguration_1 = __webpack_require__(67945);
const SensitiveDataScannerConfigurationData_1 = __webpack_require__(3706);
const SensitiveDataScannerConfigurationRelationships_1 = __webpack_require__(91265);
const SensitiveDataScannerCreateGroupResponse_1 = __webpack_require__(20832);
const SensitiveDataScannerCreateRuleResponse_1 = __webpack_require__(52528);
const SensitiveDataScannerFilter_1 = __webpack_require__(25030);
const SensitiveDataScannerGetConfigResponse_1 = __webpack_require__(28829);
const SensitiveDataScannerGetConfigResponseData_1 = __webpack_require__(54486);
const SensitiveDataScannerGroup_1 = __webpack_require__(84787);
const SensitiveDataScannerGroupAttributes_1 = __webpack_require__(38169);
const SensitiveDataScannerGroupCreate_1 = __webpack_require__(50135);
const SensitiveDataScannerGroupCreateRequest_1 = __webpack_require__(30524);
const SensitiveDataScannerGroupData_1 = __webpack_require__(8282);
const SensitiveDataScannerGroupDeleteRequest_1 = __webpack_require__(6445);
const SensitiveDataScannerGroupDeleteResponse_1 = __webpack_require__(93600);
const SensitiveDataScannerGroupIncludedItem_1 = __webpack_require__(21332);
const SensitiveDataScannerGroupItem_1 = __webpack_require__(32080);
const SensitiveDataScannerGroupList_1 = __webpack_require__(406);
const SensitiveDataScannerGroupRelationships_1 = __webpack_require__(88193);
const SensitiveDataScannerGroupResponse_1 = __webpack_require__(68081);
const SensitiveDataScannerGroupUpdate_1 = __webpack_require__(96818);
const SensitiveDataScannerGroupUpdateRequest_1 = __webpack_require__(25051);
const SensitiveDataScannerGroupUpdateResponse_1 = __webpack_require__(83278);
const SensitiveDataScannerMeta_1 = __webpack_require__(65690);
const SensitiveDataScannerMetaVersionOnly_1 = __webpack_require__(53588);
const SensitiveDataScannerReorderConfig_1 = __webpack_require__(69317);
const SensitiveDataScannerReorderGroupsResponse_1 = __webpack_require__(90270);
const SensitiveDataScannerRule_1 = __webpack_require__(37961);
const SensitiveDataScannerRuleAttributes_1 = __webpack_require__(66455);
const SensitiveDataScannerRuleCreate_1 = __webpack_require__(31674);
const SensitiveDataScannerRuleCreateRequest_1 = __webpack_require__(22917);
const SensitiveDataScannerRuleData_1 = __webpack_require__(81643);
const SensitiveDataScannerRuleDeleteRequest_1 = __webpack_require__(93391);
const SensitiveDataScannerRuleDeleteResponse_1 = __webpack_require__(37715);
const SensitiveDataScannerRuleIncludedItem_1 = __webpack_require__(26218);
const SensitiveDataScannerRuleRelationships_1 = __webpack_require__(14442);
const SensitiveDataScannerRuleResponse_1 = __webpack_require__(33872);
const SensitiveDataScannerRuleUpdate_1 = __webpack_require__(83537);
const SensitiveDataScannerRuleUpdateRequest_1 = __webpack_require__(73584);
const SensitiveDataScannerRuleUpdateResponse_1 = __webpack_require__(89412);
const SensitiveDataScannerStandardPattern_1 = __webpack_require__(17483);
const SensitiveDataScannerStandardPatternAttributes_1 = __webpack_require__(33843);
const SensitiveDataScannerStandardPatternData_1 = __webpack_require__(52824);
const SensitiveDataScannerStandardPatternsResponseData_1 = __webpack_require__(10167);
const SensitiveDataScannerStandardPatternsResponseItem_1 = __webpack_require__(36681);
const SensitiveDataScannerTextReplacement_1 = __webpack_require__(49101);
const ServiceAccountCreateAttributes_1 = __webpack_require__(90326);
const ServiceAccountCreateData_1 = __webpack_require__(62468);
const ServiceAccountCreateRequest_1 = __webpack_require__(5390);
const ServiceDefinitionCreateResponse_1 = __webpack_require__(42713);
const ServiceDefinitionData_1 = __webpack_require__(30060);
const ServiceDefinitionDataAttributes_1 = __webpack_require__(46642);
const ServiceDefinitionGetResponse_1 = __webpack_require__(41368);
const ServiceDefinitionMeta_1 = __webpack_require__(22530);
const ServiceDefinitionV1_1 = __webpack_require__(97979);
const ServiceDefinitionV1Contact_1 = __webpack_require__(95884);
const ServiceDefinitionV1Info_1 = __webpack_require__(78827);
const ServiceDefinitionV1Integrations_1 = __webpack_require__(30350);
const ServiceDefinitionV1Org_1 = __webpack_require__(91764);
const ServiceDefinitionV1Resource_1 = __webpack_require__(78038);
const ServiceDefinitionV2_1 = __webpack_require__(39172);
const ServiceDefinitionV2Doc_1 = __webpack_require__(86073);
const ServiceDefinitionV2Email_1 = __webpack_require__(97378);
const ServiceDefinitionV2Integrations_1 = __webpack_require__(74370);
const ServiceDefinitionV2Link_1 = __webpack_require__(36812);
const ServiceDefinitionV2Opsgenie_1 = __webpack_require__(6735);
const ServiceDefinitionV2Repo_1 = __webpack_require__(81097);
const ServiceDefinitionV2Slack_1 = __webpack_require__(61789);
const ServiceDefinitionsListResponse_1 = __webpack_require__(25597);
const TimeseriesFormulaQueryRequest_1 = __webpack_require__(78461);
const TimeseriesFormulaQueryResponse_1 = __webpack_require__(57031);
const TimeseriesFormulaRequest_1 = __webpack_require__(18358);
const TimeseriesFormulaRequestAttributes_1 = __webpack_require__(30379);
const TimeseriesResponse_1 = __webpack_require__(83296);
const TimeseriesResponseAttributes_1 = __webpack_require__(11229);
const TimeseriesResponseSeries_1 = __webpack_require__(46581);
const Unit_1 = __webpack_require__(31458);
const UsageApplicationSecurityMonitoringResponse_1 = __webpack_require__(87933);
const UsageAttributesObject_1 = __webpack_require__(14031);
const UsageDataObject_1 = __webpack_require__(43595);
const UsageLambdaTracedInvocationsResponse_1 = __webpack_require__(79017);
const UsageObservabilityPipelinesResponse_1 = __webpack_require__(33947);
const UsageTimeSeriesObject_1 = __webpack_require__(11483);
const User_1 = __webpack_require__(47786);
const UserAttributes_1 = __webpack_require__(42432);
const UserCreateAttributes_1 = __webpack_require__(66656);
const UserCreateData_1 = __webpack_require__(66646);
const UserCreateRequest_1 = __webpack_require__(87642);
const UserInvitationData_1 = __webpack_require__(77954);
const UserInvitationDataAttributes_1 = __webpack_require__(3798);
const UserInvitationRelationships_1 = __webpack_require__(18252);
const UserInvitationResponse_1 = __webpack_require__(14586);
const UserInvitationResponseData_1 = __webpack_require__(35653);
const UserInvitationsRequest_1 = __webpack_require__(89585);
const UserInvitationsResponse_1 = __webpack_require__(49353);
const UserRelationships_1 = __webpack_require__(58125);
const UserResponse_1 = __webpack_require__(18779);
const UserResponseRelationships_1 = __webpack_require__(20157);
const UserUpdateAttributes_1 = __webpack_require__(68822);
const UserUpdateData_1 = __webpack_require__(21330);
const UserUpdateRequest_1 = __webpack_require__(59906);
const UsersResponse_1 = __webpack_require__(18577);
const util_1 = __webpack_require__(25009);
const logger_1 = __webpack_require__(1141);
const primitives = [
    "string",
    "boolean",
    "double",
    "integer",
    "long",
    "float",
    "number",
];
const ARRAY_PREFIX = "Array<";
const MAP_PREFIX = "{ [key: string]: ";
const TUPLE_PREFIX = "[";
const supportedMediaTypes = {
    "application/json": Infinity,
    "text/json": 100,
    "application/octet-stream": 0,
};
const enumsMap = {
    APIKeysSort: [
        "created_at",
        "-created_at",
        "last4",
        "-last4",
        "modified_at",
        "-modified_at",
        "name",
        "-name",
    ],
    APIKeysType: ["api_keys"],
    ApplicationKeysSort: [
        "created_at",
        "-created_at",
        "last4",
        "-last4",
        "name",
        "-name",
    ],
    ApplicationKeysType: ["application_keys"],
    AuditLogsEventType: ["audit"],
    AuditLogsResponseStatus: ["done", "timeout"],
    AuditLogsSort: ["timestamp", "-timestamp"],
    AuthNMappingsSort: [
        "created_at",
        "-created_at",
        "role_id",
        "-role_id",
        "saml_assertion_attribute_id",
        "-saml_assertion_attribute_id",
        "role.name",
        "-role.name",
        "saml_assertion_attribute.attribute_key",
        "-saml_assertion_attribute.attribute_key",
        "saml_assertion_attribute.attribute_value",
        "-saml_assertion_attribute.attribute_value",
    ],
    AuthNMappingsType: ["authn_mappings"],
    CIAppAggregateSortType: ["alphabetical", "measure"],
    CIAppAggregationFunction: [
        "count",
        "cardinality",
        "pc75",
        "pc90",
        "pc95",
        "pc98",
        "pc99",
        "sum",
        "min",
        "max",
        "avg",
        "median",
        "latest",
        "earliest",
        "most_frequent",
        "delta",
    ],
    CIAppComputeType: ["timeseries", "total"],
    CIAppPipelineEventTypeName: ["cipipeline"],
    CIAppResponseStatus: ["done", "timeout"],
    CIAppSort: ["timestamp", "-timestamp"],
    CIAppSortOrder: ["asc", "desc"],
    CIAppTestEventTypeName: ["citest"],
    CloudConfigurationRuleType: ["cloud_configuration"],
    CloudWorkloadSecurityAgentRuleType: ["agent_rule"],
    CloudflareAccountType: ["cloudflare-accounts"],
    ConfluentAccountType: ["confluent-cloud-accounts"],
    ConfluentResourceType: ["confluent-cloud-resources"],
    ContentEncoding: ["identity", "gzip", "deflate"],
    CostByOrgType: ["cost_by_org"],
    DashboardType: [
        "custom_timeboard",
        "custom_screenboard",
        "integration_screenboard",
        "integration_timeboard",
        "host_timeboard",
    ],
    EventPriority: ["normal", "low"],
    EventStatusType: [
        "failure",
        "error",
        "warning",
        "info",
        "success",
        "user_update",
        "recommendation",
        "snapshot",
    ],
    EventType: ["event"],
    EventsAggregation: [
        "count",
        "cardinality",
        "pc75",
        "pc90",
        "pc95",
        "pc98",
        "pc99",
        "sum",
        "min",
        "max",
        "avg",
    ],
    EventsDataSource: ["logs"],
    EventsSort: ["timestamp", "-timestamp"],
    EventsSortType: ["alphabetical", "measure"],
    FastlyAccountType: ["fastly-accounts"],
    FastlyServiceType: ["fastly-services"],
    HourlyUsageType: [
        "app_sec_host_count",
        "observability_pipelines_bytes_processed",
        "lambda_traced_invocations_count",
    ],
    IncidentAttachmentAttachmentType: ["link", "postmortem"],
    IncidentAttachmentLinkAttachmentType: ["link"],
    IncidentAttachmentPostmortemAttachmentType: ["postmortem"],
    IncidentAttachmentRelatedObject: ["users"],
    IncidentAttachmentType: ["incident_attachments"],
    IncidentFieldAttributesSingleValueType: ["dropdown", "textbox"],
    IncidentFieldAttributesValueType: [
        "multiselect",
        "textarray",
        "metrictag",
        "autocomplete",
    ],
    IncidentIntegrationMetadataType: ["incident_integrations"],
    IncidentPostmortemType: ["incident_postmortems"],
    IncidentRelatedObject: ["users", "attachments"],
    IncidentSearchResultsType: ["incidents_search_results"],
    IncidentSearchSortOrder: ["created", "-created"],
    IncidentServiceType: ["services"],
    IncidentTeamType: ["teams"],
    IncidentTimelineCellMarkdownContentType: ["markdown"],
    IncidentType: ["incidents"],
    LogType: ["log"],
    LogsAggregateResponseStatus: ["done", "timeout"],
    LogsAggregateSortType: ["alphabetical", "measure"],
    LogsAggregationFunction: [
        "count",
        "cardinality",
        "pc75",
        "pc90",
        "pc95",
        "pc98",
        "pc99",
        "sum",
        "min",
        "max",
        "avg",
        "median",
    ],
    LogsArchiveDestinationAzureType: ["azure"],
    LogsArchiveDestinationGCSType: ["gcs"],
    LogsArchiveDestinationS3Type: ["s3"],
    LogsArchiveOrderDefinitionType: ["archive_order"],
    LogsArchiveState: ["UNKNOWN", "WORKING", "FAILING", "WORKING_AUTH_LEGACY"],
    LogsComputeType: ["timeseries", "total"],
    LogsMetricComputeAggregationType: ["count", "distribution"],
    LogsMetricResponseComputeAggregationType: ["count", "distribution"],
    LogsMetricType: ["logs_metrics"],
    LogsSort: ["timestamp", "-timestamp"],
    LogsSortOrder: ["asc", "desc"],
    LogsStorageTier: ["indexes", "online-archives"],
    MetricActiveConfigurationType: ["actively_queried_configurations"],
    MetricBulkConfigureTagsType: ["metric_bulk_configure_tags"],
    MetricContentEncoding: ["deflate", "zstd1", "gzip"],
    MetricCustomSpaceAggregation: ["avg", "max", "min", "sum"],
    MetricCustomTimeAggregation: ["avg", "count", "max", "min", "sum"],
    MetricDistinctVolumeType: ["distinct_metric_volumes"],
    MetricEstimateResourceType: ["metric_cardinality_estimate"],
    MetricEstimateType: ["count_or_gauge", "distribution", "percentile"],
    MetricIngestedIndexedVolumeType: ["metric_volumes"],
    MetricIntakeType: [0, 1, 2, 3],
    MetricTagConfigurationMetricTypes: ["gauge", "count", "rate", "distribution"],
    MetricTagConfigurationType: ["manage_tags"],
    MetricType: ["metrics"],
    MetricsAggregator: ["avg", "min", "max", "sum", "last"],
    MetricsDataSource: ["metrics"],
    MonitorConfigPolicyResourceType: ["monitor-config-policy"],
    MonitorConfigPolicyType: ["tag"],
    OpsgenieServiceRegionType: ["us", "eu", "custom"],
    OpsgenieServiceType: ["opsgenie-service"],
    OrganizationsType: ["orgs"],
    PermissionsType: ["permissions"],
    ProcessSummaryType: ["process"],
    QuerySortOrder: ["asc", "desc"],
    RUMAggregateSortType: ["alphabetical", "measure"],
    RUMAggregationFunction: [
        "count",
        "cardinality",
        "pc75",
        "pc90",
        "pc95",
        "pc98",
        "pc99",
        "sum",
        "min",
        "max",
        "avg",
        "median",
    ],
    RUMApplicationCreateType: ["rum_application_create"],
    RUMApplicationListType: ["rum_application"],
    RUMApplicationType: ["rum_application"],
    RUMApplicationUpdateType: ["rum_application_update"],
    RUMComputeType: ["timeseries", "total"],
    RUMEventType: ["rum"],
    RUMResponseStatus: ["done", "timeout"],
    RUMSort: ["timestamp", "-timestamp"],
    RUMSortOrder: ["asc", "desc"],
    RolesSort: [
        "name",
        "-name",
        "modified_at",
        "-modified_at",
        "user_count",
        "-user_count",
    ],
    RolesType: ["roles"],
    SAMLAssertionAttributesType: ["saml_assertion_attributes"],
    ScalarFormulaRequestType: ["scalar_request"],
    ScalarFormulaResponseType: ["scalar_response"],
    SecurityFilterFilteredDataType: ["logs"],
    SecurityFilterType: ["security_filters"],
    SecurityMonitoringFilterAction: ["require", "suppress"],
    SecurityMonitoringRuleDetectionMethod: [
        "threshold",
        "new_value",
        "anomaly_detection",
        "impossible_travel",
        "hardcoded",
        "third_party",
    ],
    SecurityMonitoringRuleEvaluationWindow: [
        0, 60, 300, 600, 900, 1800, 3600, 7200,
    ],
    SecurityMonitoringRuleHardcodedEvaluatorType: ["log4shell"],
    SecurityMonitoringRuleKeepAlive: [
        0, 60, 300, 600, 900, 1800, 3600, 7200, 10800, 21600,
    ],
    SecurityMonitoringRuleMaxSignalDuration: [
        0, 60, 300, 600, 900, 1800, 3600, 7200, 10800, 21600, 43200, 86400,
    ],
    SecurityMonitoringRuleNewValueOptionsForgetAfter: [1, 2, 7, 14, 21, 28],
    SecurityMonitoringRuleNewValueOptionsLearningDuration: [0, 1, 7],
    SecurityMonitoringRuleNewValueOptionsLearningMethod: [
        "duration",
        "threshold",
    ],
    SecurityMonitoringRuleNewValueOptionsLearningThreshold: [0, 1],
    SecurityMonitoringRuleQueryAggregation: [
        "count",
        "cardinality",
        "sum",
        "max",
        "new_value",
        "geo_data",
        "event_count",
        "none",
    ],
    SecurityMonitoringRuleSeverity: ["info", "low", "medium", "high", "critical"],
    SecurityMonitoringRuleTypeCreate: ["log_detection", "workload_security"],
    SecurityMonitoringRuleTypeRead: [
        "log_detection",
        "infrastructure_configuration",
        "workload_security",
        "cloud_configuration",
    ],
    SecurityMonitoringSignalArchiveReason: [
        "none",
        "false_positive",
        "testing_or_maintenance",
        "other",
    ],
    SecurityMonitoringSignalRuleType: ["signal_correlation"],
    SecurityMonitoringSignalState: ["open", "archived", "under_review"],
    SecurityMonitoringSignalType: ["signal"],
    SecurityMonitoringSignalsSort: ["timestamp", "-timestamp"],
    SensitiveDataScannerConfigurationType: [
        "sensitive_data_scanner_configuration",
    ],
    SensitiveDataScannerGroupType: ["sensitive_data_scanner_group"],
    SensitiveDataScannerProduct: ["logs", "rum", "events", "apm"],
    SensitiveDataScannerRuleType: ["sensitive_data_scanner_rule"],
    SensitiveDataScannerStandardPatternType: [
        "sensitive_data_scanner_standard_pattern",
    ],
    SensitiveDataScannerTextReplacementType: [
        "none",
        "hash",
        "replacement_string",
        "partial_replacement_from_beginning",
        "partial_replacement_from_end",
    ],
    ServiceDefinitionV1ResourceType: [
        "doc",
        "wiki",
        "runbook",
        "url",
        "repo",
        "dashboard",
        "oncall",
        "code",
        "link",
    ],
    ServiceDefinitionV1Version: ["v1"],
    ServiceDefinitionV2EmailType: ["email"],
    ServiceDefinitionV2LinkType: [
        "doc",
        "wiki",
        "runbook",
        "url",
        "repo",
        "dashboard",
        "oncall",
        "code",
        "link",
    ],
    ServiceDefinitionV2OpsgenieRegion: ["US", "EU"],
    ServiceDefinitionV2SlackType: ["slack"],
    ServiceDefinitionV2Version: ["v2"],
    TimeseriesFormulaRequestType: ["timeseries_request"],
    TimeseriesFormulaResponseType: ["timeseries_response"],
    UsageTimeSeriesType: ["usage_timeseries"],
    UserInvitationsType: ["user_invitations"],
    UsersType: ["users"],
};
const typeMap = {
    APIErrorResponse: APIErrorResponse_1.APIErrorResponse,
    APIKeyCreateAttributes: APIKeyCreateAttributes_1.APIKeyCreateAttributes,
    APIKeyCreateData: APIKeyCreateData_1.APIKeyCreateData,
    APIKeyCreateRequest: APIKeyCreateRequest_1.APIKeyCreateRequest,
    APIKeyRelationships: APIKeyRelationships_1.APIKeyRelationships,
    APIKeyResponse: APIKeyResponse_1.APIKeyResponse,
    APIKeyUpdateAttributes: APIKeyUpdateAttributes_1.APIKeyUpdateAttributes,
    APIKeyUpdateData: APIKeyUpdateData_1.APIKeyUpdateData,
    APIKeyUpdateRequest: APIKeyUpdateRequest_1.APIKeyUpdateRequest,
    APIKeysResponse: APIKeysResponse_1.APIKeysResponse,
    ApplicationKeyCreateAttributes: ApplicationKeyCreateAttributes_1.ApplicationKeyCreateAttributes,
    ApplicationKeyCreateData: ApplicationKeyCreateData_1.ApplicationKeyCreateData,
    ApplicationKeyCreateRequest: ApplicationKeyCreateRequest_1.ApplicationKeyCreateRequest,
    ApplicationKeyRelationships: ApplicationKeyRelationships_1.ApplicationKeyRelationships,
    ApplicationKeyResponse: ApplicationKeyResponse_1.ApplicationKeyResponse,
    ApplicationKeyUpdateAttributes: ApplicationKeyUpdateAttributes_1.ApplicationKeyUpdateAttributes,
    ApplicationKeyUpdateData: ApplicationKeyUpdateData_1.ApplicationKeyUpdateData,
    ApplicationKeyUpdateRequest: ApplicationKeyUpdateRequest_1.ApplicationKeyUpdateRequest,
    AuditLogsEvent: AuditLogsEvent_1.AuditLogsEvent,
    AuditLogsEventAttributes: AuditLogsEventAttributes_1.AuditLogsEventAttributes,
    AuditLogsEventsResponse: AuditLogsEventsResponse_1.AuditLogsEventsResponse,
    AuditLogsQueryFilter: AuditLogsQueryFilter_1.AuditLogsQueryFilter,
    AuditLogsQueryOptions: AuditLogsQueryOptions_1.AuditLogsQueryOptions,
    AuditLogsQueryPageOptions: AuditLogsQueryPageOptions_1.AuditLogsQueryPageOptions,
    AuditLogsResponseLinks: AuditLogsResponseLinks_1.AuditLogsResponseLinks,
    AuditLogsResponseMetadata: AuditLogsResponseMetadata_1.AuditLogsResponseMetadata,
    AuditLogsResponsePage: AuditLogsResponsePage_1.AuditLogsResponsePage,
    AuditLogsSearchEventsRequest: AuditLogsSearchEventsRequest_1.AuditLogsSearchEventsRequest,
    AuditLogsWarning: AuditLogsWarning_1.AuditLogsWarning,
    AuthNMapping: AuthNMapping_1.AuthNMapping,
    AuthNMappingAttributes: AuthNMappingAttributes_1.AuthNMappingAttributes,
    AuthNMappingCreateAttributes: AuthNMappingCreateAttributes_1.AuthNMappingCreateAttributes,
    AuthNMappingCreateData: AuthNMappingCreateData_1.AuthNMappingCreateData,
    AuthNMappingCreateRelationships: AuthNMappingCreateRelationships_1.AuthNMappingCreateRelationships,
    AuthNMappingCreateRequest: AuthNMappingCreateRequest_1.AuthNMappingCreateRequest,
    AuthNMappingRelationships: AuthNMappingRelationships_1.AuthNMappingRelationships,
    AuthNMappingResponse: AuthNMappingResponse_1.AuthNMappingResponse,
    AuthNMappingUpdateAttributes: AuthNMappingUpdateAttributes_1.AuthNMappingUpdateAttributes,
    AuthNMappingUpdateData: AuthNMappingUpdateData_1.AuthNMappingUpdateData,
    AuthNMappingUpdateRelationships: AuthNMappingUpdateRelationships_1.AuthNMappingUpdateRelationships,
    AuthNMappingUpdateRequest: AuthNMappingUpdateRequest_1.AuthNMappingUpdateRequest,
    AuthNMappingsResponse: AuthNMappingsResponse_1.AuthNMappingsResponse,
    CIAppAggregateBucketValueTimeseriesPoint: CIAppAggregateBucketValueTimeseriesPoint_1.CIAppAggregateBucketValueTimeseriesPoint,
    CIAppAggregateSort: CIAppAggregateSort_1.CIAppAggregateSort,
    CIAppCompute: CIAppCompute_1.CIAppCompute,
    CIAppEventAttributes: CIAppEventAttributes_1.CIAppEventAttributes,
    CIAppGroupByHistogram: CIAppGroupByHistogram_1.CIAppGroupByHistogram,
    CIAppPipelineEvent: CIAppPipelineEvent_1.CIAppPipelineEvent,
    CIAppPipelineEventsRequest: CIAppPipelineEventsRequest_1.CIAppPipelineEventsRequest,
    CIAppPipelineEventsResponse: CIAppPipelineEventsResponse_1.CIAppPipelineEventsResponse,
    CIAppPipelinesAggregateRequest: CIAppPipelinesAggregateRequest_1.CIAppPipelinesAggregateRequest,
    CIAppPipelinesAggregationBucketsResponse: CIAppPipelinesAggregationBucketsResponse_1.CIAppPipelinesAggregationBucketsResponse,
    CIAppPipelinesAnalyticsAggregateResponse: CIAppPipelinesAnalyticsAggregateResponse_1.CIAppPipelinesAnalyticsAggregateResponse,
    CIAppPipelinesBucketResponse: CIAppPipelinesBucketResponse_1.CIAppPipelinesBucketResponse,
    CIAppPipelinesGroupBy: CIAppPipelinesGroupBy_1.CIAppPipelinesGroupBy,
    CIAppPipelinesQueryFilter: CIAppPipelinesQueryFilter_1.CIAppPipelinesQueryFilter,
    CIAppQueryOptions: CIAppQueryOptions_1.CIAppQueryOptions,
    CIAppQueryPageOptions: CIAppQueryPageOptions_1.CIAppQueryPageOptions,
    CIAppResponseLinks: CIAppResponseLinks_1.CIAppResponseLinks,
    CIAppResponseMetadata: CIAppResponseMetadata_1.CIAppResponseMetadata,
    CIAppResponseMetadataWithPagination: CIAppResponseMetadataWithPagination_1.CIAppResponseMetadataWithPagination,
    CIAppResponsePage: CIAppResponsePage_1.CIAppResponsePage,
    CIAppTestEvent: CIAppTestEvent_1.CIAppTestEvent,
    CIAppTestEventsRequest: CIAppTestEventsRequest_1.CIAppTestEventsRequest,
    CIAppTestEventsResponse: CIAppTestEventsResponse_1.CIAppTestEventsResponse,
    CIAppTestsAggregateRequest: CIAppTestsAggregateRequest_1.CIAppTestsAggregateRequest,
    CIAppTestsAggregationBucketsResponse: CIAppTestsAggregationBucketsResponse_1.CIAppTestsAggregationBucketsResponse,
    CIAppTestsAnalyticsAggregateResponse: CIAppTestsAnalyticsAggregateResponse_1.CIAppTestsAnalyticsAggregateResponse,
    CIAppTestsBucketResponse: CIAppTestsBucketResponse_1.CIAppTestsBucketResponse,
    CIAppTestsGroupBy: CIAppTestsGroupBy_1.CIAppTestsGroupBy,
    CIAppTestsQueryFilter: CIAppTestsQueryFilter_1.CIAppTestsQueryFilter,
    CIAppWarning: CIAppWarning_1.CIAppWarning,
    ChargebackBreakdown: ChargebackBreakdown_1.ChargebackBreakdown,
    CloudConfigurationComplianceRuleOptions: CloudConfigurationComplianceRuleOptions_1.CloudConfigurationComplianceRuleOptions,
    CloudConfigurationRegoRule: CloudConfigurationRegoRule_1.CloudConfigurationRegoRule,
    CloudConfigurationRuleCaseCreate: CloudConfigurationRuleCaseCreate_1.CloudConfigurationRuleCaseCreate,
    CloudConfigurationRuleComplianceSignalOptions: CloudConfigurationRuleComplianceSignalOptions_1.CloudConfigurationRuleComplianceSignalOptions,
    CloudConfigurationRuleCreatePayload: CloudConfigurationRuleCreatePayload_1.CloudConfigurationRuleCreatePayload,
    CloudConfigurationRuleOptions: CloudConfigurationRuleOptions_1.CloudConfigurationRuleOptions,
    CloudWorkloadSecurityAgentRuleAttributes: CloudWorkloadSecurityAgentRuleAttributes_1.CloudWorkloadSecurityAgentRuleAttributes,
    CloudWorkloadSecurityAgentRuleCreateAttributes: CloudWorkloadSecurityAgentRuleCreateAttributes_1.CloudWorkloadSecurityAgentRuleCreateAttributes,
    CloudWorkloadSecurityAgentRuleCreateData: CloudWorkloadSecurityAgentRuleCreateData_1.CloudWorkloadSecurityAgentRuleCreateData,
    CloudWorkloadSecurityAgentRuleCreateRequest: CloudWorkloadSecurityAgentRuleCreateRequest_1.CloudWorkloadSecurityAgentRuleCreateRequest,
    CloudWorkloadSecurityAgentRuleCreatorAttributes: CloudWorkloadSecurityAgentRuleCreatorAttributes_1.CloudWorkloadSecurityAgentRuleCreatorAttributes,
    CloudWorkloadSecurityAgentRuleData: CloudWorkloadSecurityAgentRuleData_1.CloudWorkloadSecurityAgentRuleData,
    CloudWorkloadSecurityAgentRuleResponse: CloudWorkloadSecurityAgentRuleResponse_1.CloudWorkloadSecurityAgentRuleResponse,
    CloudWorkloadSecurityAgentRuleUpdateAttributes: CloudWorkloadSecurityAgentRuleUpdateAttributes_1.CloudWorkloadSecurityAgentRuleUpdateAttributes,
    CloudWorkloadSecurityAgentRuleUpdateData: CloudWorkloadSecurityAgentRuleUpdateData_1.CloudWorkloadSecurityAgentRuleUpdateData,
    CloudWorkloadSecurityAgentRuleUpdateRequest: CloudWorkloadSecurityAgentRuleUpdateRequest_1.CloudWorkloadSecurityAgentRuleUpdateRequest,
    CloudWorkloadSecurityAgentRuleUpdaterAttributes: CloudWorkloadSecurityAgentRuleUpdaterAttributes_1.CloudWorkloadSecurityAgentRuleUpdaterAttributes,
    CloudWorkloadSecurityAgentRulesListResponse: CloudWorkloadSecurityAgentRulesListResponse_1.CloudWorkloadSecurityAgentRulesListResponse,
    CloudflareAccountCreateRequest: CloudflareAccountCreateRequest_1.CloudflareAccountCreateRequest,
    CloudflareAccountCreateRequestAttributes: CloudflareAccountCreateRequestAttributes_1.CloudflareAccountCreateRequestAttributes,
    CloudflareAccountCreateRequestData: CloudflareAccountCreateRequestData_1.CloudflareAccountCreateRequestData,
    CloudflareAccountResponse: CloudflareAccountResponse_1.CloudflareAccountResponse,
    CloudflareAccountResponseAttributes: CloudflareAccountResponseAttributes_1.CloudflareAccountResponseAttributes,
    CloudflareAccountResponseData: CloudflareAccountResponseData_1.CloudflareAccountResponseData,
    CloudflareAccountUpdateRequest: CloudflareAccountUpdateRequest_1.CloudflareAccountUpdateRequest,
    CloudflareAccountUpdateRequestAttributes: CloudflareAccountUpdateRequestAttributes_1.CloudflareAccountUpdateRequestAttributes,
    CloudflareAccountUpdateRequestData: CloudflareAccountUpdateRequestData_1.CloudflareAccountUpdateRequestData,
    CloudflareAccountsResponse: CloudflareAccountsResponse_1.CloudflareAccountsResponse,
    ConfluentAccountCreateRequest: ConfluentAccountCreateRequest_1.ConfluentAccountCreateRequest,
    ConfluentAccountCreateRequestAttributes: ConfluentAccountCreateRequestAttributes_1.ConfluentAccountCreateRequestAttributes,
    ConfluentAccountCreateRequestData: ConfluentAccountCreateRequestData_1.ConfluentAccountCreateRequestData,
    ConfluentAccountResourceAttributes: ConfluentAccountResourceAttributes_1.ConfluentAccountResourceAttributes,
    ConfluentAccountResponse: ConfluentAccountResponse_1.ConfluentAccountResponse,
    ConfluentAccountResponseAttributes: ConfluentAccountResponseAttributes_1.ConfluentAccountResponseAttributes,
    ConfluentAccountResponseData: ConfluentAccountResponseData_1.ConfluentAccountResponseData,
    ConfluentAccountUpdateRequest: ConfluentAccountUpdateRequest_1.ConfluentAccountUpdateRequest,
    ConfluentAccountUpdateRequestAttributes: ConfluentAccountUpdateRequestAttributes_1.ConfluentAccountUpdateRequestAttributes,
    ConfluentAccountUpdateRequestData: ConfluentAccountUpdateRequestData_1.ConfluentAccountUpdateRequestData,
    ConfluentAccountsResponse: ConfluentAccountsResponse_1.ConfluentAccountsResponse,
    ConfluentResourceRequest: ConfluentResourceRequest_1.ConfluentResourceRequest,
    ConfluentResourceRequestAttributes: ConfluentResourceRequestAttributes_1.ConfluentResourceRequestAttributes,
    ConfluentResourceRequestData: ConfluentResourceRequestData_1.ConfluentResourceRequestData,
    ConfluentResourceResponse: ConfluentResourceResponse_1.ConfluentResourceResponse,
    ConfluentResourceResponseAttributes: ConfluentResourceResponseAttributes_1.ConfluentResourceResponseAttributes,
    ConfluentResourceResponseData: ConfluentResourceResponseData_1.ConfluentResourceResponseData,
    ConfluentResourcesResponse: ConfluentResourcesResponse_1.ConfluentResourcesResponse,
    CostByOrg: CostByOrg_1.CostByOrg,
    CostByOrgAttributes: CostByOrgAttributes_1.CostByOrgAttributes,
    CostByOrgResponse: CostByOrgResponse_1.CostByOrgResponse,
    Creator: Creator_1.Creator,
    DashboardListAddItemsRequest: DashboardListAddItemsRequest_1.DashboardListAddItemsRequest,
    DashboardListAddItemsResponse: DashboardListAddItemsResponse_1.DashboardListAddItemsResponse,
    DashboardListDeleteItemsRequest: DashboardListDeleteItemsRequest_1.DashboardListDeleteItemsRequest,
    DashboardListDeleteItemsResponse: DashboardListDeleteItemsResponse_1.DashboardListDeleteItemsResponse,
    DashboardListItem: DashboardListItem_1.DashboardListItem,
    DashboardListItemRequest: DashboardListItemRequest_1.DashboardListItemRequest,
    DashboardListItemResponse: DashboardListItemResponse_1.DashboardListItemResponse,
    DashboardListItems: DashboardListItems_1.DashboardListItems,
    DashboardListUpdateItemsRequest: DashboardListUpdateItemsRequest_1.DashboardListUpdateItemsRequest,
    DashboardListUpdateItemsResponse: DashboardListUpdateItemsResponse_1.DashboardListUpdateItemsResponse,
    DataScalarColumn: DataScalarColumn_1.DataScalarColumn,
    Event: Event_1.Event,
    EventAttributes: EventAttributes_1.EventAttributes,
    EventResponse: EventResponse_1.EventResponse,
    EventResponseAttributes: EventResponseAttributes_1.EventResponseAttributes,
    EventsCompute: EventsCompute_1.EventsCompute,
    EventsGroupBy: EventsGroupBy_1.EventsGroupBy,
    EventsGroupBySort: EventsGroupBySort_1.EventsGroupBySort,
    EventsListRequest: EventsListRequest_1.EventsListRequest,
    EventsListResponse: EventsListResponse_1.EventsListResponse,
    EventsListResponseLinks: EventsListResponseLinks_1.EventsListResponseLinks,
    EventsQueryFilter: EventsQueryFilter_1.EventsQueryFilter,
    EventsQueryOptions: EventsQueryOptions_1.EventsQueryOptions,
    EventsRequestPage: EventsRequestPage_1.EventsRequestPage,
    EventsResponseMetadata: EventsResponseMetadata_1.EventsResponseMetadata,
    EventsResponseMetadataPage: EventsResponseMetadataPage_1.EventsResponseMetadataPage,
    EventsScalarQuery: EventsScalarQuery_1.EventsScalarQuery,
    EventsSearch: EventsSearch_1.EventsSearch,
    EventsTimeseriesQuery: EventsTimeseriesQuery_1.EventsTimeseriesQuery,
    EventsWarning: EventsWarning_1.EventsWarning,
    FastlyAccounResponseAttributes: FastlyAccounResponseAttributes_1.FastlyAccounResponseAttributes,
    FastlyAccountCreateRequest: FastlyAccountCreateRequest_1.FastlyAccountCreateRequest,
    FastlyAccountCreateRequestAttributes: FastlyAccountCreateRequestAttributes_1.FastlyAccountCreateRequestAttributes,
    FastlyAccountCreateRequestData: FastlyAccountCreateRequestData_1.FastlyAccountCreateRequestData,
    FastlyAccountResponse: FastlyAccountResponse_1.FastlyAccountResponse,
    FastlyAccountResponseData: FastlyAccountResponseData_1.FastlyAccountResponseData,
    FastlyAccountUpdateRequest: FastlyAccountUpdateRequest_1.FastlyAccountUpdateRequest,
    FastlyAccountUpdateRequestAttributes: FastlyAccountUpdateRequestAttributes_1.FastlyAccountUpdateRequestAttributes,
    FastlyAccountUpdateRequestData: FastlyAccountUpdateRequestData_1.FastlyAccountUpdateRequestData,
    FastlyAccountsResponse: FastlyAccountsResponse_1.FastlyAccountsResponse,
    FastlyService: FastlyService_1.FastlyService,
    FastlyServiceAttributes: FastlyServiceAttributes_1.FastlyServiceAttributes,
    FastlyServiceData: FastlyServiceData_1.FastlyServiceData,
    FastlyServiceRequest: FastlyServiceRequest_1.FastlyServiceRequest,
    FastlyServiceResponse: FastlyServiceResponse_1.FastlyServiceResponse,
    FastlyServicesResponse: FastlyServicesResponse_1.FastlyServicesResponse,
    FormulaLimit: FormulaLimit_1.FormulaLimit,
    FullAPIKey: FullAPIKey_1.FullAPIKey,
    FullAPIKeyAttributes: FullAPIKeyAttributes_1.FullAPIKeyAttributes,
    FullApplicationKey: FullApplicationKey_1.FullApplicationKey,
    FullApplicationKeyAttributes: FullApplicationKeyAttributes_1.FullApplicationKeyAttributes,
    GroupScalarColumn: GroupScalarColumn_1.GroupScalarColumn,
    HTTPLogError: HTTPLogError_1.HTTPLogError,
    HTTPLogErrors: HTTPLogErrors_1.HTTPLogErrors,
    HTTPLogItem: HTTPLogItem_1.HTTPLogItem,
    HourlyUsage: HourlyUsage_1.HourlyUsage,
    HourlyUsageAttributes: HourlyUsageAttributes_1.HourlyUsageAttributes,
    HourlyUsageMeasurement: HourlyUsageMeasurement_1.HourlyUsageMeasurement,
    HourlyUsageMetadata: HourlyUsageMetadata_1.HourlyUsageMetadata,
    HourlyUsagePagination: HourlyUsagePagination_1.HourlyUsagePagination,
    HourlyUsageResponse: HourlyUsageResponse_1.HourlyUsageResponse,
    IdPMetadataFormData: IdPMetadataFormData_1.IdPMetadataFormData,
    IncidentAttachmentData: IncidentAttachmentData_1.IncidentAttachmentData,
    IncidentAttachmentLinkAttributes: IncidentAttachmentLinkAttributes_1.IncidentAttachmentLinkAttributes,
    IncidentAttachmentLinkAttributesAttachmentObject: IncidentAttachmentLinkAttributesAttachmentObject_1.IncidentAttachmentLinkAttributesAttachmentObject,
    IncidentAttachmentPostmortemAttributes: IncidentAttachmentPostmortemAttributes_1.IncidentAttachmentPostmortemAttributes,
    IncidentAttachmentRelationships: IncidentAttachmentRelationships_1.IncidentAttachmentRelationships,
    IncidentAttachmentUpdateData: IncidentAttachmentUpdateData_1.IncidentAttachmentUpdateData,
    IncidentAttachmentUpdateRequest: IncidentAttachmentUpdateRequest_1.IncidentAttachmentUpdateRequest,
    IncidentAttachmentUpdateResponse: IncidentAttachmentUpdateResponse_1.IncidentAttachmentUpdateResponse,
    IncidentAttachmentsPostmortemAttributesAttachmentObject: IncidentAttachmentsPostmortemAttributesAttachmentObject_1.IncidentAttachmentsPostmortemAttributesAttachmentObject,
    IncidentAttachmentsResponse: IncidentAttachmentsResponse_1.IncidentAttachmentsResponse,
    IncidentCreateAttributes: IncidentCreateAttributes_1.IncidentCreateAttributes,
    IncidentCreateData: IncidentCreateData_1.IncidentCreateData,
    IncidentCreateRelationships: IncidentCreateRelationships_1.IncidentCreateRelationships,
    IncidentCreateRequest: IncidentCreateRequest_1.IncidentCreateRequest,
    IncidentFieldAttributesMultipleValue: IncidentFieldAttributesMultipleValue_1.IncidentFieldAttributesMultipleValue,
    IncidentFieldAttributesSingleValue: IncidentFieldAttributesSingleValue_1.IncidentFieldAttributesSingleValue,
    IncidentNotificationHandle: IncidentNotificationHandle_1.IncidentNotificationHandle,
    IncidentResponse: IncidentResponse_1.IncidentResponse,
    IncidentResponseAttributes: IncidentResponseAttributes_1.IncidentResponseAttributes,
    IncidentResponseData: IncidentResponseData_1.IncidentResponseData,
    IncidentResponseMeta: IncidentResponseMeta_1.IncidentResponseMeta,
    IncidentResponseMetaPagination: IncidentResponseMetaPagination_1.IncidentResponseMetaPagination,
    IncidentResponseRelationships: IncidentResponseRelationships_1.IncidentResponseRelationships,
    IncidentSearchResponse: IncidentSearchResponse_1.IncidentSearchResponse,
    IncidentSearchResponseAttributes: IncidentSearchResponseAttributes_1.IncidentSearchResponseAttributes,
    IncidentSearchResponseData: IncidentSearchResponseData_1.IncidentSearchResponseData,
    IncidentSearchResponseFacetsData: IncidentSearchResponseFacetsData_1.IncidentSearchResponseFacetsData,
    IncidentSearchResponseFieldFacetData: IncidentSearchResponseFieldFacetData_1.IncidentSearchResponseFieldFacetData,
    IncidentSearchResponseIncidentsData: IncidentSearchResponseIncidentsData_1.IncidentSearchResponseIncidentsData,
    IncidentSearchResponseNumericFacetData: IncidentSearchResponseNumericFacetData_1.IncidentSearchResponseNumericFacetData,
    IncidentSearchResponseNumericFacetDataAggregates: IncidentSearchResponseNumericFacetDataAggregates_1.IncidentSearchResponseNumericFacetDataAggregates,
    IncidentSearchResponsePropertyFieldFacetData: IncidentSearchResponsePropertyFieldFacetData_1.IncidentSearchResponsePropertyFieldFacetData,
    IncidentSearchResponseUserFacetData: IncidentSearchResponseUserFacetData_1.IncidentSearchResponseUserFacetData,
    IncidentServiceCreateAttributes: IncidentServiceCreateAttributes_1.IncidentServiceCreateAttributes,
    IncidentServiceCreateData: IncidentServiceCreateData_1.IncidentServiceCreateData,
    IncidentServiceCreateRequest: IncidentServiceCreateRequest_1.IncidentServiceCreateRequest,
    IncidentServiceRelationships: IncidentServiceRelationships_1.IncidentServiceRelationships,
    IncidentServiceResponse: IncidentServiceResponse_1.IncidentServiceResponse,
    IncidentServiceResponseAttributes: IncidentServiceResponseAttributes_1.IncidentServiceResponseAttributes,
    IncidentServiceResponseData: IncidentServiceResponseData_1.IncidentServiceResponseData,
    IncidentServiceUpdateAttributes: IncidentServiceUpdateAttributes_1.IncidentServiceUpdateAttributes,
    IncidentServiceUpdateData: IncidentServiceUpdateData_1.IncidentServiceUpdateData,
    IncidentServiceUpdateRequest: IncidentServiceUpdateRequest_1.IncidentServiceUpdateRequest,
    IncidentServicesResponse: IncidentServicesResponse_1.IncidentServicesResponse,
    IncidentTeamCreateAttributes: IncidentTeamCreateAttributes_1.IncidentTeamCreateAttributes,
    IncidentTeamCreateData: IncidentTeamCreateData_1.IncidentTeamCreateData,
    IncidentTeamCreateRequest: IncidentTeamCreateRequest_1.IncidentTeamCreateRequest,
    IncidentTeamRelationships: IncidentTeamRelationships_1.IncidentTeamRelationships,
    IncidentTeamResponse: IncidentTeamResponse_1.IncidentTeamResponse,
    IncidentTeamResponseAttributes: IncidentTeamResponseAttributes_1.IncidentTeamResponseAttributes,
    IncidentTeamResponseData: IncidentTeamResponseData_1.IncidentTeamResponseData,
    IncidentTeamUpdateAttributes: IncidentTeamUpdateAttributes_1.IncidentTeamUpdateAttributes,
    IncidentTeamUpdateData: IncidentTeamUpdateData_1.IncidentTeamUpdateData,
    IncidentTeamUpdateRequest: IncidentTeamUpdateRequest_1.IncidentTeamUpdateRequest,
    IncidentTeamsResponse: IncidentTeamsResponse_1.IncidentTeamsResponse,
    IncidentTimelineCellMarkdownCreateAttributes: IncidentTimelineCellMarkdownCreateAttributes_1.IncidentTimelineCellMarkdownCreateAttributes,
    IncidentTimelineCellMarkdownCreateAttributesContent: IncidentTimelineCellMarkdownCreateAttributesContent_1.IncidentTimelineCellMarkdownCreateAttributesContent,
    IncidentUpdateAttributes: IncidentUpdateAttributes_1.IncidentUpdateAttributes,
    IncidentUpdateData: IncidentUpdateData_1.IncidentUpdateData,
    IncidentUpdateRelationships: IncidentUpdateRelationships_1.IncidentUpdateRelationships,
    IncidentUpdateRequest: IncidentUpdateRequest_1.IncidentUpdateRequest,
    IncidentsResponse: IncidentsResponse_1.IncidentsResponse,
    IntakePayloadAccepted: IntakePayloadAccepted_1.IntakePayloadAccepted,
    ListApplicationKeysResponse: ListApplicationKeysResponse_1.ListApplicationKeysResponse,
    Log: Log_1.Log,
    LogAttributes: LogAttributes_1.LogAttributes,
    LogsAggregateBucket: LogsAggregateBucket_1.LogsAggregateBucket,
    LogsAggregateBucketValueTimeseriesPoint: LogsAggregateBucketValueTimeseriesPoint_1.LogsAggregateBucketValueTimeseriesPoint,
    LogsAggregateRequest: LogsAggregateRequest_1.LogsAggregateRequest,
    LogsAggregateRequestPage: LogsAggregateRequestPage_1.LogsAggregateRequestPage,
    LogsAggregateResponse: LogsAggregateResponse_1.LogsAggregateResponse,
    LogsAggregateResponseData: LogsAggregateResponseData_1.LogsAggregateResponseData,
    LogsAggregateSort: LogsAggregateSort_1.LogsAggregateSort,
    LogsArchive: LogsArchive_1.LogsArchive,
    LogsArchiveAttributes: LogsArchiveAttributes_1.LogsArchiveAttributes,
    LogsArchiveCreateRequest: LogsArchiveCreateRequest_1.LogsArchiveCreateRequest,
    LogsArchiveCreateRequestAttributes: LogsArchiveCreateRequestAttributes_1.LogsArchiveCreateRequestAttributes,
    LogsArchiveCreateRequestDefinition: LogsArchiveCreateRequestDefinition_1.LogsArchiveCreateRequestDefinition,
    LogsArchiveDefinition: LogsArchiveDefinition_1.LogsArchiveDefinition,
    LogsArchiveDestinationAzure: LogsArchiveDestinationAzure_1.LogsArchiveDestinationAzure,
    LogsArchiveDestinationGCS: LogsArchiveDestinationGCS_1.LogsArchiveDestinationGCS,
    LogsArchiveDestinationS3: LogsArchiveDestinationS3_1.LogsArchiveDestinationS3,
    LogsArchiveIntegrationAzure: LogsArchiveIntegrationAzure_1.LogsArchiveIntegrationAzure,
    LogsArchiveIntegrationGCS: LogsArchiveIntegrationGCS_1.LogsArchiveIntegrationGCS,
    LogsArchiveIntegrationS3: LogsArchiveIntegrationS3_1.LogsArchiveIntegrationS3,
    LogsArchiveOrder: LogsArchiveOrder_1.LogsArchiveOrder,
    LogsArchiveOrderAttributes: LogsArchiveOrderAttributes_1.LogsArchiveOrderAttributes,
    LogsArchiveOrderDefinition: LogsArchiveOrderDefinition_1.LogsArchiveOrderDefinition,
    LogsArchives: LogsArchives_1.LogsArchives,
    LogsCompute: LogsCompute_1.LogsCompute,
    LogsGroupBy: LogsGroupBy_1.LogsGroupBy,
    LogsGroupByHistogram: LogsGroupByHistogram_1.LogsGroupByHistogram,
    LogsListRequest: LogsListRequest_1.LogsListRequest,
    LogsListRequestPage: LogsListRequestPage_1.LogsListRequestPage,
    LogsListResponse: LogsListResponse_1.LogsListResponse,
    LogsListResponseLinks: LogsListResponseLinks_1.LogsListResponseLinks,
    LogsMetricCompute: LogsMetricCompute_1.LogsMetricCompute,
    LogsMetricCreateAttributes: LogsMetricCreateAttributes_1.LogsMetricCreateAttributes,
    LogsMetricCreateData: LogsMetricCreateData_1.LogsMetricCreateData,
    LogsMetricCreateRequest: LogsMetricCreateRequest_1.LogsMetricCreateRequest,
    LogsMetricFilter: LogsMetricFilter_1.LogsMetricFilter,
    LogsMetricGroupBy: LogsMetricGroupBy_1.LogsMetricGroupBy,
    LogsMetricResponse: LogsMetricResponse_1.LogsMetricResponse,
    LogsMetricResponseAttributes: LogsMetricResponseAttributes_1.LogsMetricResponseAttributes,
    LogsMetricResponseCompute: LogsMetricResponseCompute_1.LogsMetricResponseCompute,
    LogsMetricResponseData: LogsMetricResponseData_1.LogsMetricResponseData,
    LogsMetricResponseFilter: LogsMetricResponseFilter_1.LogsMetricResponseFilter,
    LogsMetricResponseGroupBy: LogsMetricResponseGroupBy_1.LogsMetricResponseGroupBy,
    LogsMetricUpdateAttributes: LogsMetricUpdateAttributes_1.LogsMetricUpdateAttributes,
    LogsMetricUpdateCompute: LogsMetricUpdateCompute_1.LogsMetricUpdateCompute,
    LogsMetricUpdateData: LogsMetricUpdateData_1.LogsMetricUpdateData,
    LogsMetricUpdateRequest: LogsMetricUpdateRequest_1.LogsMetricUpdateRequest,
    LogsMetricsResponse: LogsMetricsResponse_1.LogsMetricsResponse,
    LogsQueryFilter: LogsQueryFilter_1.LogsQueryFilter,
    LogsQueryOptions: LogsQueryOptions_1.LogsQueryOptions,
    LogsResponseMetadata: LogsResponseMetadata_1.LogsResponseMetadata,
    LogsResponseMetadataPage: LogsResponseMetadataPage_1.LogsResponseMetadataPage,
    LogsWarning: LogsWarning_1.LogsWarning,
    Metric: Metric_1.Metric,
    MetricAllTags: MetricAllTags_1.MetricAllTags,
    MetricAllTagsAttributes: MetricAllTagsAttributes_1.MetricAllTagsAttributes,
    MetricAllTagsResponse: MetricAllTagsResponse_1.MetricAllTagsResponse,
    MetricBulkTagConfigCreate: MetricBulkTagConfigCreate_1.MetricBulkTagConfigCreate,
    MetricBulkTagConfigCreateAttributes: MetricBulkTagConfigCreateAttributes_1.MetricBulkTagConfigCreateAttributes,
    MetricBulkTagConfigCreateRequest: MetricBulkTagConfigCreateRequest_1.MetricBulkTagConfigCreateRequest,
    MetricBulkTagConfigDelete: MetricBulkTagConfigDelete_1.MetricBulkTagConfigDelete,
    MetricBulkTagConfigDeleteAttributes: MetricBulkTagConfigDeleteAttributes_1.MetricBulkTagConfigDeleteAttributes,
    MetricBulkTagConfigDeleteRequest: MetricBulkTagConfigDeleteRequest_1.MetricBulkTagConfigDeleteRequest,
    MetricBulkTagConfigResponse: MetricBulkTagConfigResponse_1.MetricBulkTagConfigResponse,
    MetricBulkTagConfigStatus: MetricBulkTagConfigStatus_1.MetricBulkTagConfigStatus,
    MetricBulkTagConfigStatusAttributes: MetricBulkTagConfigStatusAttributes_1.MetricBulkTagConfigStatusAttributes,
    MetricCustomAggregation: MetricCustomAggregation_1.MetricCustomAggregation,
    MetricDistinctVolume: MetricDistinctVolume_1.MetricDistinctVolume,
    MetricDistinctVolumeAttributes: MetricDistinctVolumeAttributes_1.MetricDistinctVolumeAttributes,
    MetricEstimate: MetricEstimate_1.MetricEstimate,
    MetricEstimateAttributes: MetricEstimateAttributes_1.MetricEstimateAttributes,
    MetricEstimateResponse: MetricEstimateResponse_1.MetricEstimateResponse,
    MetricIngestedIndexedVolume: MetricIngestedIndexedVolume_1.MetricIngestedIndexedVolume,
    MetricIngestedIndexedVolumeAttributes: MetricIngestedIndexedVolumeAttributes_1.MetricIngestedIndexedVolumeAttributes,
    MetricMetadata: MetricMetadata_1.MetricMetadata,
    MetricOrigin: MetricOrigin_1.MetricOrigin,
    MetricPayload: MetricPayload_1.MetricPayload,
    MetricPoint: MetricPoint_1.MetricPoint,
    MetricResource: MetricResource_1.MetricResource,
    MetricSeries: MetricSeries_1.MetricSeries,
    MetricSuggestedTagsAndAggregations: MetricSuggestedTagsAndAggregations_1.MetricSuggestedTagsAndAggregations,
    MetricSuggestedTagsAndAggregationsResponse: MetricSuggestedTagsAndAggregationsResponse_1.MetricSuggestedTagsAndAggregationsResponse,
    MetricSuggestedTagsAttributes: MetricSuggestedTagsAttributes_1.MetricSuggestedTagsAttributes,
    MetricTagConfiguration: MetricTagConfiguration_1.MetricTagConfiguration,
    MetricTagConfigurationAttributes: MetricTagConfigurationAttributes_1.MetricTagConfigurationAttributes,
    MetricTagConfigurationCreateAttributes: MetricTagConfigurationCreateAttributes_1.MetricTagConfigurationCreateAttributes,
    MetricTagConfigurationCreateData: MetricTagConfigurationCreateData_1.MetricTagConfigurationCreateData,
    MetricTagConfigurationCreateRequest: MetricTagConfigurationCreateRequest_1.MetricTagConfigurationCreateRequest,
    MetricTagConfigurationResponse: MetricTagConfigurationResponse_1.MetricTagConfigurationResponse,
    MetricTagConfigurationUpdateAttributes: MetricTagConfigurationUpdateAttributes_1.MetricTagConfigurationUpdateAttributes,
    MetricTagConfigurationUpdateData: MetricTagConfigurationUpdateData_1.MetricTagConfigurationUpdateData,
    MetricTagConfigurationUpdateRequest: MetricTagConfigurationUpdateRequest_1.MetricTagConfigurationUpdateRequest,
    MetricVolumesResponse: MetricVolumesResponse_1.MetricVolumesResponse,
    MetricsAndMetricTagConfigurationsResponse: MetricsAndMetricTagConfigurationsResponse_1.MetricsAndMetricTagConfigurationsResponse,
    MetricsScalarQuery: MetricsScalarQuery_1.MetricsScalarQuery,
    MetricsTimeseriesQuery: MetricsTimeseriesQuery_1.MetricsTimeseriesQuery,
    MonitorConfigPolicyAttributeCreateRequest: MonitorConfigPolicyAttributeCreateRequest_1.MonitorConfigPolicyAttributeCreateRequest,
    MonitorConfigPolicyAttributeEditRequest: MonitorConfigPolicyAttributeEditRequest_1.MonitorConfigPolicyAttributeEditRequest,
    MonitorConfigPolicyAttributeResponse: MonitorConfigPolicyAttributeResponse_1.MonitorConfigPolicyAttributeResponse,
    MonitorConfigPolicyCreateData: MonitorConfigPolicyCreateData_1.MonitorConfigPolicyCreateData,
    MonitorConfigPolicyCreateRequest: MonitorConfigPolicyCreateRequest_1.MonitorConfigPolicyCreateRequest,
    MonitorConfigPolicyEditData: MonitorConfigPolicyEditData_1.MonitorConfigPolicyEditData,
    MonitorConfigPolicyEditRequest: MonitorConfigPolicyEditRequest_1.MonitorConfigPolicyEditRequest,
    MonitorConfigPolicyListResponse: MonitorConfigPolicyListResponse_1.MonitorConfigPolicyListResponse,
    MonitorConfigPolicyResponse: MonitorConfigPolicyResponse_1.MonitorConfigPolicyResponse,
    MonitorConfigPolicyResponseData: MonitorConfigPolicyResponseData_1.MonitorConfigPolicyResponseData,
    MonitorConfigPolicyTagPolicy: MonitorConfigPolicyTagPolicy_1.MonitorConfigPolicyTagPolicy,
    MonitorConfigPolicyTagPolicyCreateRequest: MonitorConfigPolicyTagPolicyCreateRequest_1.MonitorConfigPolicyTagPolicyCreateRequest,
    MonitorType: MonitorType_1.MonitorType,
    NullableRelationshipToUser: NullableRelationshipToUser_1.NullableRelationshipToUser,
    NullableRelationshipToUserData: NullableRelationshipToUserData_1.NullableRelationshipToUserData,
    OpsgenieServiceCreateAttributes: OpsgenieServiceCreateAttributes_1.OpsgenieServiceCreateAttributes,
    OpsgenieServiceCreateData: OpsgenieServiceCreateData_1.OpsgenieServiceCreateData,
    OpsgenieServiceCreateRequest: OpsgenieServiceCreateRequest_1.OpsgenieServiceCreateRequest,
    OpsgenieServiceResponse: OpsgenieServiceResponse_1.OpsgenieServiceResponse,
    OpsgenieServiceResponseAttributes: OpsgenieServiceResponseAttributes_1.OpsgenieServiceResponseAttributes,
    OpsgenieServiceResponseData: OpsgenieServiceResponseData_1.OpsgenieServiceResponseData,
    OpsgenieServiceUpdateAttributes: OpsgenieServiceUpdateAttributes_1.OpsgenieServiceUpdateAttributes,
    OpsgenieServiceUpdateData: OpsgenieServiceUpdateData_1.OpsgenieServiceUpdateData,
    OpsgenieServiceUpdateRequest: OpsgenieServiceUpdateRequest_1.OpsgenieServiceUpdateRequest,
    OpsgenieServicesResponse: OpsgenieServicesResponse_1.OpsgenieServicesResponse,
    Organization: Organization_1.Organization,
    OrganizationAttributes: OrganizationAttributes_1.OrganizationAttributes,
    Pagination: Pagination_1.Pagination,
    PartialAPIKey: PartialAPIKey_1.PartialAPIKey,
    PartialAPIKeyAttributes: PartialAPIKeyAttributes_1.PartialAPIKeyAttributes,
    PartialApplicationKey: PartialApplicationKey_1.PartialApplicationKey,
    PartialApplicationKeyAttributes: PartialApplicationKeyAttributes_1.PartialApplicationKeyAttributes,
    PartialApplicationKeyResponse: PartialApplicationKeyResponse_1.PartialApplicationKeyResponse,
    Permission: Permission_1.Permission,
    PermissionAttributes: PermissionAttributes_1.PermissionAttributes,
    PermissionsResponse: PermissionsResponse_1.PermissionsResponse,
    ProcessSummariesMeta: ProcessSummariesMeta_1.ProcessSummariesMeta,
    ProcessSummariesMetaPage: ProcessSummariesMetaPage_1.ProcessSummariesMetaPage,
    ProcessSummariesResponse: ProcessSummariesResponse_1.ProcessSummariesResponse,
    ProcessSummary: ProcessSummary_1.ProcessSummary,
    ProcessSummaryAttributes: ProcessSummaryAttributes_1.ProcessSummaryAttributes,
    QueryFormula: QueryFormula_1.QueryFormula,
    RUMAggregateBucketValueTimeseriesPoint: RUMAggregateBucketValueTimeseriesPoint_1.RUMAggregateBucketValueTimeseriesPoint,
    RUMAggregateRequest: RUMAggregateRequest_1.RUMAggregateRequest,
    RUMAggregateSort: RUMAggregateSort_1.RUMAggregateSort,
    RUMAggregationBucketsResponse: RUMAggregationBucketsResponse_1.RUMAggregationBucketsResponse,
    RUMAnalyticsAggregateResponse: RUMAnalyticsAggregateResponse_1.RUMAnalyticsAggregateResponse,
    RUMApplication: RUMApplication_1.RUMApplication,
    RUMApplicationAttributes: RUMApplicationAttributes_1.RUMApplicationAttributes,
    RUMApplicationCreate: RUMApplicationCreate_1.RUMApplicationCreate,
    RUMApplicationCreateAttributes: RUMApplicationCreateAttributes_1.RUMApplicationCreateAttributes,
    RUMApplicationCreateRequest: RUMApplicationCreateRequest_1.RUMApplicationCreateRequest,
    RUMApplicationList: RUMApplicationList_1.RUMApplicationList,
    RUMApplicationListAttributes: RUMApplicationListAttributes_1.RUMApplicationListAttributes,
    RUMApplicationResponse: RUMApplicationResponse_1.RUMApplicationResponse,
    RUMApplicationUpdate: RUMApplicationUpdate_1.RUMApplicationUpdate,
    RUMApplicationUpdateAttributes: RUMApplicationUpdateAttributes_1.RUMApplicationUpdateAttributes,
    RUMApplicationUpdateRequest: RUMApplicationUpdateRequest_1.RUMApplicationUpdateRequest,
    RUMApplicationsResponse: RUMApplicationsResponse_1.RUMApplicationsResponse,
    RUMBucketResponse: RUMBucketResponse_1.RUMBucketResponse,
    RUMCompute: RUMCompute_1.RUMCompute,
    RUMEvent: RUMEvent_1.RUMEvent,
    RUMEventAttributes: RUMEventAttributes_1.RUMEventAttributes,
    RUMEventsResponse: RUMEventsResponse_1.RUMEventsResponse,
    RUMGroupBy: RUMGroupBy_1.RUMGroupBy,
    RUMGroupByHistogram: RUMGroupByHistogram_1.RUMGroupByHistogram,
    RUMQueryFilter: RUMQueryFilter_1.RUMQueryFilter,
    RUMQueryOptions: RUMQueryOptions_1.RUMQueryOptions,
    RUMQueryPageOptions: RUMQueryPageOptions_1.RUMQueryPageOptions,
    RUMResponseLinks: RUMResponseLinks_1.RUMResponseLinks,
    RUMResponseMetadata: RUMResponseMetadata_1.RUMResponseMetadata,
    RUMResponsePage: RUMResponsePage_1.RUMResponsePage,
    RUMSearchEventsRequest: RUMSearchEventsRequest_1.RUMSearchEventsRequest,
    RUMWarning: RUMWarning_1.RUMWarning,
    RelationshipToIncidentAttachment: RelationshipToIncidentAttachment_1.RelationshipToIncidentAttachment,
    RelationshipToIncidentAttachmentData: RelationshipToIncidentAttachmentData_1.RelationshipToIncidentAttachmentData,
    RelationshipToIncidentIntegrationMetadataData: RelationshipToIncidentIntegrationMetadataData_1.RelationshipToIncidentIntegrationMetadataData,
    RelationshipToIncidentIntegrationMetadatas: RelationshipToIncidentIntegrationMetadatas_1.RelationshipToIncidentIntegrationMetadatas,
    RelationshipToIncidentPostmortem: RelationshipToIncidentPostmortem_1.RelationshipToIncidentPostmortem,
    RelationshipToIncidentPostmortemData: RelationshipToIncidentPostmortemData_1.RelationshipToIncidentPostmortemData,
    RelationshipToOrganization: RelationshipToOrganization_1.RelationshipToOrganization,
    RelationshipToOrganizationData: RelationshipToOrganizationData_1.RelationshipToOrganizationData,
    RelationshipToOrganizations: RelationshipToOrganizations_1.RelationshipToOrganizations,
    RelationshipToPermission: RelationshipToPermission_1.RelationshipToPermission,
    RelationshipToPermissionData: RelationshipToPermissionData_1.RelationshipToPermissionData,
    RelationshipToPermissions: RelationshipToPermissions_1.RelationshipToPermissions,
    RelationshipToRole: RelationshipToRole_1.RelationshipToRole,
    RelationshipToRoleData: RelationshipToRoleData_1.RelationshipToRoleData,
    RelationshipToRoles: RelationshipToRoles_1.RelationshipToRoles,
    RelationshipToSAMLAssertionAttribute: RelationshipToSAMLAssertionAttribute_1.RelationshipToSAMLAssertionAttribute,
    RelationshipToSAMLAssertionAttributeData: RelationshipToSAMLAssertionAttributeData_1.RelationshipToSAMLAssertionAttributeData,
    RelationshipToUser: RelationshipToUser_1.RelationshipToUser,
    RelationshipToUserData: RelationshipToUserData_1.RelationshipToUserData,
    RelationshipToUsers: RelationshipToUsers_1.RelationshipToUsers,
    ResponseMetaAttributes: ResponseMetaAttributes_1.ResponseMetaAttributes,
    Role: Role_1.Role,
    RoleAttributes: RoleAttributes_1.RoleAttributes,
    RoleClone: RoleClone_1.RoleClone,
    RoleCloneAttributes: RoleCloneAttributes_1.RoleCloneAttributes,
    RoleCloneRequest: RoleCloneRequest_1.RoleCloneRequest,
    RoleCreateAttributes: RoleCreateAttributes_1.RoleCreateAttributes,
    RoleCreateData: RoleCreateData_1.RoleCreateData,
    RoleCreateRequest: RoleCreateRequest_1.RoleCreateRequest,
    RoleCreateResponse: RoleCreateResponse_1.RoleCreateResponse,
    RoleCreateResponseData: RoleCreateResponseData_1.RoleCreateResponseData,
    RoleRelationships: RoleRelationships_1.RoleRelationships,
    RoleResponse: RoleResponse_1.RoleResponse,
    RoleResponseRelationships: RoleResponseRelationships_1.RoleResponseRelationships,
    RoleUpdateAttributes: RoleUpdateAttributes_1.RoleUpdateAttributes,
    RoleUpdateData: RoleUpdateData_1.RoleUpdateData,
    RoleUpdateRequest: RoleUpdateRequest_1.RoleUpdateRequest,
    RoleUpdateResponse: RoleUpdateResponse_1.RoleUpdateResponse,
    RoleUpdateResponseData: RoleUpdateResponseData_1.RoleUpdateResponseData,
    RolesResponse: RolesResponse_1.RolesResponse,
    SAMLAssertionAttribute: SAMLAssertionAttribute_1.SAMLAssertionAttribute,
    SAMLAssertionAttributeAttributes: SAMLAssertionAttributeAttributes_1.SAMLAssertionAttributeAttributes,
    ScalarFormulaQueryRequest: ScalarFormulaQueryRequest_1.ScalarFormulaQueryRequest,
    ScalarFormulaQueryResponse: ScalarFormulaQueryResponse_1.ScalarFormulaQueryResponse,
    ScalarFormulaRequest: ScalarFormulaRequest_1.ScalarFormulaRequest,
    ScalarFormulaRequestAttributes: ScalarFormulaRequestAttributes_1.ScalarFormulaRequestAttributes,
    ScalarFormulaResponseAtrributes: ScalarFormulaResponseAtrributes_1.ScalarFormulaResponseAtrributes,
    ScalarMeta: ScalarMeta_1.ScalarMeta,
    ScalarResponse: ScalarResponse_1.ScalarResponse,
    SecurityFilter: SecurityFilter_1.SecurityFilter,
    SecurityFilterAttributes: SecurityFilterAttributes_1.SecurityFilterAttributes,
    SecurityFilterCreateAttributes: SecurityFilterCreateAttributes_1.SecurityFilterCreateAttributes,
    SecurityFilterCreateData: SecurityFilterCreateData_1.SecurityFilterCreateData,
    SecurityFilterCreateRequest: SecurityFilterCreateRequest_1.SecurityFilterCreateRequest,
    SecurityFilterExclusionFilter: SecurityFilterExclusionFilter_1.SecurityFilterExclusionFilter,
    SecurityFilterExclusionFilterResponse: SecurityFilterExclusionFilterResponse_1.SecurityFilterExclusionFilterResponse,
    SecurityFilterMeta: SecurityFilterMeta_1.SecurityFilterMeta,
    SecurityFilterResponse: SecurityFilterResponse_1.SecurityFilterResponse,
    SecurityFilterUpdateAttributes: SecurityFilterUpdateAttributes_1.SecurityFilterUpdateAttributes,
    SecurityFilterUpdateData: SecurityFilterUpdateData_1.SecurityFilterUpdateData,
    SecurityFilterUpdateRequest: SecurityFilterUpdateRequest_1.SecurityFilterUpdateRequest,
    SecurityFiltersResponse: SecurityFiltersResponse_1.SecurityFiltersResponse,
    SecurityMonitoringFilter: SecurityMonitoringFilter_1.SecurityMonitoringFilter,
    SecurityMonitoringListRulesResponse: SecurityMonitoringListRulesResponse_1.SecurityMonitoringListRulesResponse,
    SecurityMonitoringRuleCase: SecurityMonitoringRuleCase_1.SecurityMonitoringRuleCase,
    SecurityMonitoringRuleCaseCreate: SecurityMonitoringRuleCaseCreate_1.SecurityMonitoringRuleCaseCreate,
    SecurityMonitoringRuleImpossibleTravelOptions: SecurityMonitoringRuleImpossibleTravelOptions_1.SecurityMonitoringRuleImpossibleTravelOptions,
    SecurityMonitoringRuleNewValueOptions: SecurityMonitoringRuleNewValueOptions_1.SecurityMonitoringRuleNewValueOptions,
    SecurityMonitoringRuleOptions: SecurityMonitoringRuleOptions_1.SecurityMonitoringRuleOptions,
    SecurityMonitoringRuleUpdatePayload: SecurityMonitoringRuleUpdatePayload_1.SecurityMonitoringRuleUpdatePayload,
    SecurityMonitoringSignal: SecurityMonitoringSignal_1.SecurityMonitoringSignal,
    SecurityMonitoringSignalAssigneeUpdateAttributes: SecurityMonitoringSignalAssigneeUpdateAttributes_1.SecurityMonitoringSignalAssigneeUpdateAttributes,
    SecurityMonitoringSignalAssigneeUpdateData: SecurityMonitoringSignalAssigneeUpdateData_1.SecurityMonitoringSignalAssigneeUpdateData,
    SecurityMonitoringSignalAssigneeUpdateRequest: SecurityMonitoringSignalAssigneeUpdateRequest_1.SecurityMonitoringSignalAssigneeUpdateRequest,
    SecurityMonitoringSignalAttributes: SecurityMonitoringSignalAttributes_1.SecurityMonitoringSignalAttributes,
    SecurityMonitoringSignalIncidentsUpdateAttributes: SecurityMonitoringSignalIncidentsUpdateAttributes_1.SecurityMonitoringSignalIncidentsUpdateAttributes,
    SecurityMonitoringSignalIncidentsUpdateData: SecurityMonitoringSignalIncidentsUpdateData_1.SecurityMonitoringSignalIncidentsUpdateData,
    SecurityMonitoringSignalIncidentsUpdateRequest: SecurityMonitoringSignalIncidentsUpdateRequest_1.SecurityMonitoringSignalIncidentsUpdateRequest,
    SecurityMonitoringSignalListRequest: SecurityMonitoringSignalListRequest_1.SecurityMonitoringSignalListRequest,
    SecurityMonitoringSignalListRequestFilter: SecurityMonitoringSignalListRequestFilter_1.SecurityMonitoringSignalListRequestFilter,
    SecurityMonitoringSignalListRequestPage: SecurityMonitoringSignalListRequestPage_1.SecurityMonitoringSignalListRequestPage,
    SecurityMonitoringSignalRuleCreatePayload: SecurityMonitoringSignalRuleCreatePayload_1.SecurityMonitoringSignalRuleCreatePayload,
    SecurityMonitoringSignalRuleQuery: SecurityMonitoringSignalRuleQuery_1.SecurityMonitoringSignalRuleQuery,
    SecurityMonitoringSignalRuleResponse: SecurityMonitoringSignalRuleResponse_1.SecurityMonitoringSignalRuleResponse,
    SecurityMonitoringSignalRuleResponseQuery: SecurityMonitoringSignalRuleResponseQuery_1.SecurityMonitoringSignalRuleResponseQuery,
    SecurityMonitoringSignalStateUpdateAttributes: SecurityMonitoringSignalStateUpdateAttributes_1.SecurityMonitoringSignalStateUpdateAttributes,
    SecurityMonitoringSignalStateUpdateData: SecurityMonitoringSignalStateUpdateData_1.SecurityMonitoringSignalStateUpdateData,
    SecurityMonitoringSignalStateUpdateRequest: SecurityMonitoringSignalStateUpdateRequest_1.SecurityMonitoringSignalStateUpdateRequest,
    SecurityMonitoringSignalTriageAttributes: SecurityMonitoringSignalTriageAttributes_1.SecurityMonitoringSignalTriageAttributes,
    SecurityMonitoringSignalTriageUpdateData: SecurityMonitoringSignalTriageUpdateData_1.SecurityMonitoringSignalTriageUpdateData,
    SecurityMonitoringSignalTriageUpdateResponse: SecurityMonitoringSignalTriageUpdateResponse_1.SecurityMonitoringSignalTriageUpdateResponse,
    SecurityMonitoringSignalsListResponse: SecurityMonitoringSignalsListResponse_1.SecurityMonitoringSignalsListResponse,
    SecurityMonitoringSignalsListResponseLinks: SecurityMonitoringSignalsListResponseLinks_1.SecurityMonitoringSignalsListResponseLinks,
    SecurityMonitoringSignalsListResponseMeta: SecurityMonitoringSignalsListResponseMeta_1.SecurityMonitoringSignalsListResponseMeta,
    SecurityMonitoringSignalsListResponseMetaPage: SecurityMonitoringSignalsListResponseMetaPage_1.SecurityMonitoringSignalsListResponseMetaPage,
    SecurityMonitoringStandardRuleCreatePayload: SecurityMonitoringStandardRuleCreatePayload_1.SecurityMonitoringStandardRuleCreatePayload,
    SecurityMonitoringStandardRuleQuery: SecurityMonitoringStandardRuleQuery_1.SecurityMonitoringStandardRuleQuery,
    SecurityMonitoringStandardRuleResponse: SecurityMonitoringStandardRuleResponse_1.SecurityMonitoringStandardRuleResponse,
    SecurityMonitoringTriageUser: SecurityMonitoringTriageUser_1.SecurityMonitoringTriageUser,
    SensitiveDataScannerConfigRequest: SensitiveDataScannerConfigRequest_1.SensitiveDataScannerConfigRequest,
    SensitiveDataScannerConfiguration: SensitiveDataScannerConfiguration_1.SensitiveDataScannerConfiguration,
    SensitiveDataScannerConfigurationData: SensitiveDataScannerConfigurationData_1.SensitiveDataScannerConfigurationData,
    SensitiveDataScannerConfigurationRelationships: SensitiveDataScannerConfigurationRelationships_1.SensitiveDataScannerConfigurationRelationships,
    SensitiveDataScannerCreateGroupResponse: SensitiveDataScannerCreateGroupResponse_1.SensitiveDataScannerCreateGroupResponse,
    SensitiveDataScannerCreateRuleResponse: SensitiveDataScannerCreateRuleResponse_1.SensitiveDataScannerCreateRuleResponse,
    SensitiveDataScannerFilter: SensitiveDataScannerFilter_1.SensitiveDataScannerFilter,
    SensitiveDataScannerGetConfigResponse: SensitiveDataScannerGetConfigResponse_1.SensitiveDataScannerGetConfigResponse,
    SensitiveDataScannerGetConfigResponseData: SensitiveDataScannerGetConfigResponseData_1.SensitiveDataScannerGetConfigResponseData,
    SensitiveDataScannerGroup: SensitiveDataScannerGroup_1.SensitiveDataScannerGroup,
    SensitiveDataScannerGroupAttributes: SensitiveDataScannerGroupAttributes_1.SensitiveDataScannerGroupAttributes,
    SensitiveDataScannerGroupCreate: SensitiveDataScannerGroupCreate_1.SensitiveDataScannerGroupCreate,
    SensitiveDataScannerGroupCreateRequest: SensitiveDataScannerGroupCreateRequest_1.SensitiveDataScannerGroupCreateRequest,
    SensitiveDataScannerGroupData: SensitiveDataScannerGroupData_1.SensitiveDataScannerGroupData,
    SensitiveDataScannerGroupDeleteRequest: SensitiveDataScannerGroupDeleteRequest_1.SensitiveDataScannerGroupDeleteRequest,
    SensitiveDataScannerGroupDeleteResponse: SensitiveDataScannerGroupDeleteResponse_1.SensitiveDataScannerGroupDeleteResponse,
    SensitiveDataScannerGroupIncludedItem: SensitiveDataScannerGroupIncludedItem_1.SensitiveDataScannerGroupIncludedItem,
    SensitiveDataScannerGroupItem: SensitiveDataScannerGroupItem_1.SensitiveDataScannerGroupItem,
    SensitiveDataScannerGroupList: SensitiveDataScannerGroupList_1.SensitiveDataScannerGroupList,
    SensitiveDataScannerGroupRelationships: SensitiveDataScannerGroupRelationships_1.SensitiveDataScannerGroupRelationships,
    SensitiveDataScannerGroupResponse: SensitiveDataScannerGroupResponse_1.SensitiveDataScannerGroupResponse,
    SensitiveDataScannerGroupUpdate: SensitiveDataScannerGroupUpdate_1.SensitiveDataScannerGroupUpdate,
    SensitiveDataScannerGroupUpdateRequest: SensitiveDataScannerGroupUpdateRequest_1.SensitiveDataScannerGroupUpdateRequest,
    SensitiveDataScannerGroupUpdateResponse: SensitiveDataScannerGroupUpdateResponse_1.SensitiveDataScannerGroupUpdateResponse,
    SensitiveDataScannerMeta: SensitiveDataScannerMeta_1.SensitiveDataScannerMeta,
    SensitiveDataScannerMetaVersionOnly: SensitiveDataScannerMetaVersionOnly_1.SensitiveDataScannerMetaVersionOnly,
    SensitiveDataScannerReorderConfig: SensitiveDataScannerReorderConfig_1.SensitiveDataScannerReorderConfig,
    SensitiveDataScannerReorderGroupsResponse: SensitiveDataScannerReorderGroupsResponse_1.SensitiveDataScannerReorderGroupsResponse,
    SensitiveDataScannerRule: SensitiveDataScannerRule_1.SensitiveDataScannerRule,
    SensitiveDataScannerRuleAttributes: SensitiveDataScannerRuleAttributes_1.SensitiveDataScannerRuleAttributes,
    SensitiveDataScannerRuleCreate: SensitiveDataScannerRuleCreate_1.SensitiveDataScannerRuleCreate,
    SensitiveDataScannerRuleCreateRequest: SensitiveDataScannerRuleCreateRequest_1.SensitiveDataScannerRuleCreateRequest,
    SensitiveDataScannerRuleData: SensitiveDataScannerRuleData_1.SensitiveDataScannerRuleData,
    SensitiveDataScannerRuleDeleteRequest: SensitiveDataScannerRuleDeleteRequest_1.SensitiveDataScannerRuleDeleteRequest,
    SensitiveDataScannerRuleDeleteResponse: SensitiveDataScannerRuleDeleteResponse_1.SensitiveDataScannerRuleDeleteResponse,
    SensitiveDataScannerRuleIncludedItem: SensitiveDataScannerRuleIncludedItem_1.SensitiveDataScannerRuleIncludedItem,
    SensitiveDataScannerRuleRelationships: SensitiveDataScannerRuleRelationships_1.SensitiveDataScannerRuleRelationships,
    SensitiveDataScannerRuleResponse: SensitiveDataScannerRuleResponse_1.SensitiveDataScannerRuleResponse,
    SensitiveDataScannerRuleUpdate: SensitiveDataScannerRuleUpdate_1.SensitiveDataScannerRuleUpdate,
    SensitiveDataScannerRuleUpdateRequest: SensitiveDataScannerRuleUpdateRequest_1.SensitiveDataScannerRuleUpdateRequest,
    SensitiveDataScannerRuleUpdateResponse: SensitiveDataScannerRuleUpdateResponse_1.SensitiveDataScannerRuleUpdateResponse,
    SensitiveDataScannerStandardPattern: SensitiveDataScannerStandardPattern_1.SensitiveDataScannerStandardPattern,
    SensitiveDataScannerStandardPatternAttributes: SensitiveDataScannerStandardPatternAttributes_1.SensitiveDataScannerStandardPatternAttributes,
    SensitiveDataScannerStandardPatternData: SensitiveDataScannerStandardPatternData_1.SensitiveDataScannerStandardPatternData,
    SensitiveDataScannerStandardPatternsResponseData: SensitiveDataScannerStandardPatternsResponseData_1.SensitiveDataScannerStandardPatternsResponseData,
    SensitiveDataScannerStandardPatternsResponseItem: SensitiveDataScannerStandardPatternsResponseItem_1.SensitiveDataScannerStandardPatternsResponseItem,
    SensitiveDataScannerTextReplacement: SensitiveDataScannerTextReplacement_1.SensitiveDataScannerTextReplacement,
    ServiceAccountCreateAttributes: ServiceAccountCreateAttributes_1.ServiceAccountCreateAttributes,
    ServiceAccountCreateData: ServiceAccountCreateData_1.ServiceAccountCreateData,
    ServiceAccountCreateRequest: ServiceAccountCreateRequest_1.ServiceAccountCreateRequest,
    ServiceDefinitionCreateResponse: ServiceDefinitionCreateResponse_1.ServiceDefinitionCreateResponse,
    ServiceDefinitionData: ServiceDefinitionData_1.ServiceDefinitionData,
    ServiceDefinitionDataAttributes: ServiceDefinitionDataAttributes_1.ServiceDefinitionDataAttributes,
    ServiceDefinitionGetResponse: ServiceDefinitionGetResponse_1.ServiceDefinitionGetResponse,
    ServiceDefinitionMeta: ServiceDefinitionMeta_1.ServiceDefinitionMeta,
    ServiceDefinitionV1: ServiceDefinitionV1_1.ServiceDefinitionV1,
    ServiceDefinitionV1Contact: ServiceDefinitionV1Contact_1.ServiceDefinitionV1Contact,
    ServiceDefinitionV1Info: ServiceDefinitionV1Info_1.ServiceDefinitionV1Info,
    ServiceDefinitionV1Integrations: ServiceDefinitionV1Integrations_1.ServiceDefinitionV1Integrations,
    ServiceDefinitionV1Org: ServiceDefinitionV1Org_1.ServiceDefinitionV1Org,
    ServiceDefinitionV1Resource: ServiceDefinitionV1Resource_1.ServiceDefinitionV1Resource,
    ServiceDefinitionV2: ServiceDefinitionV2_1.ServiceDefinitionV2,
    ServiceDefinitionV2Doc: ServiceDefinitionV2Doc_1.ServiceDefinitionV2Doc,
    ServiceDefinitionV2Email: ServiceDefinitionV2Email_1.ServiceDefinitionV2Email,
    ServiceDefinitionV2Integrations: ServiceDefinitionV2Integrations_1.ServiceDefinitionV2Integrations,
    ServiceDefinitionV2Link: ServiceDefinitionV2Link_1.ServiceDefinitionV2Link,
    ServiceDefinitionV2Opsgenie: ServiceDefinitionV2Opsgenie_1.ServiceDefinitionV2Opsgenie,
    ServiceDefinitionV2Repo: ServiceDefinitionV2Repo_1.ServiceDefinitionV2Repo,
    ServiceDefinitionV2Slack: ServiceDefinitionV2Slack_1.ServiceDefinitionV2Slack,
    ServiceDefinitionsListResponse: ServiceDefinitionsListResponse_1.ServiceDefinitionsListResponse,
    TimeseriesFormulaQueryRequest: TimeseriesFormulaQueryRequest_1.TimeseriesFormulaQueryRequest,
    TimeseriesFormulaQueryResponse: TimeseriesFormulaQueryResponse_1.TimeseriesFormulaQueryResponse,
    TimeseriesFormulaRequest: TimeseriesFormulaRequest_1.TimeseriesFormulaRequest,
    TimeseriesFormulaRequestAttributes: TimeseriesFormulaRequestAttributes_1.TimeseriesFormulaRequestAttributes,
    TimeseriesResponse: TimeseriesResponse_1.TimeseriesResponse,
    TimeseriesResponseAttributes: TimeseriesResponseAttributes_1.TimeseriesResponseAttributes,
    TimeseriesResponseSeries: TimeseriesResponseSeries_1.TimeseriesResponseSeries,
    Unit: Unit_1.Unit,
    UsageApplicationSecurityMonitoringResponse: UsageApplicationSecurityMonitoringResponse_1.UsageApplicationSecurityMonitoringResponse,
    UsageAttributesObject: UsageAttributesObject_1.UsageAttributesObject,
    UsageDataObject: UsageDataObject_1.UsageDataObject,
    UsageLambdaTracedInvocationsResponse: UsageLambdaTracedInvocationsResponse_1.UsageLambdaTracedInvocationsResponse,
    UsageObservabilityPipelinesResponse: UsageObservabilityPipelinesResponse_1.UsageObservabilityPipelinesResponse,
    UsageTimeSeriesObject: UsageTimeSeriesObject_1.UsageTimeSeriesObject,
    User: User_1.User,
    UserAttributes: UserAttributes_1.UserAttributes,
    UserCreateAttributes: UserCreateAttributes_1.UserCreateAttributes,
    UserCreateData: UserCreateData_1.UserCreateData,
    UserCreateRequest: UserCreateRequest_1.UserCreateRequest,
    UserInvitationData: UserInvitationData_1.UserInvitationData,
    UserInvitationDataAttributes: UserInvitationDataAttributes_1.UserInvitationDataAttributes,
    UserInvitationRelationships: UserInvitationRelationships_1.UserInvitationRelationships,
    UserInvitationResponse: UserInvitationResponse_1.UserInvitationResponse,
    UserInvitationResponseData: UserInvitationResponseData_1.UserInvitationResponseData,
    UserInvitationsRequest: UserInvitationsRequest_1.UserInvitationsRequest,
    UserInvitationsResponse: UserInvitationsResponse_1.UserInvitationsResponse,
    UserRelationships: UserRelationships_1.UserRelationships,
    UserResponse: UserResponse_1.UserResponse,
    UserResponseRelationships: UserResponseRelationships_1.UserResponseRelationships,
    UserUpdateAttributes: UserUpdateAttributes_1.UserUpdateAttributes,
    UserUpdateData: UserUpdateData_1.UserUpdateData,
    UserUpdateRequest: UserUpdateRequest_1.UserUpdateRequest,
    UsersResponse: UsersResponse_1.UsersResponse,
};
const oneOfMap = {
    APIKeyResponseIncludedItem: ["User"],
    ApplicationKeyResponseIncludedItem: ["User", "Role"],
    AuthNMappingIncluded: ["SAMLAssertionAttribute", "Role"],
    CIAppAggregateBucketValue: [
        "string",
        "number",
        "Array<CIAppAggregateBucketValueTimeseriesPoint>",
    ],
    CIAppGroupByMissing: ["string", "number"],
    CIAppGroupByTotal: ["boolean", "string", "number"],
    IncidentAttachmentAttributes: [
        "IncidentAttachmentPostmortemAttributes",
        "IncidentAttachmentLinkAttributes",
    ],
    IncidentAttachmentUpdateAttributes: [
        "IncidentAttachmentPostmortemAttributes",
        "IncidentAttachmentLinkAttributes",
    ],
    IncidentAttachmentsResponseIncludedItem: ["User"],
    IncidentFieldAttributes: [
        "IncidentFieldAttributesSingleValue",
        "IncidentFieldAttributesMultipleValue",
    ],
    IncidentResponseIncludedItem: ["User", "IncidentAttachmentData"],
    IncidentServiceIncludedItems: ["User"],
    IncidentTeamIncludedItems: ["User"],
    IncidentTimelineCellCreateAttributes: [
        "IncidentTimelineCellMarkdownCreateAttributes",
    ],
    LogsAggregateBucketValue: [
        "string",
        "number",
        "Array<LogsAggregateBucketValueTimeseriesPoint>",
    ],
    LogsArchiveCreateRequestDestination: [
        "LogsArchiveDestinationAzure",
        "LogsArchiveDestinationGCS",
        "LogsArchiveDestinationS3",
    ],
    LogsArchiveDestination: [
        "LogsArchiveDestinationAzure",
        "LogsArchiveDestinationGCS",
        "LogsArchiveDestinationS3",
    ],
    LogsGroupByMissing: ["string", "number"],
    LogsGroupByTotal: ["boolean", "string", "number"],
    MetricVolumes: ["MetricDistinctVolume", "MetricIngestedIndexedVolume"],
    MetricsAndMetricTagConfigurations: ["Metric", "MetricTagConfiguration"],
    MonitorConfigPolicyPolicy: ["MonitorConfigPolicyTagPolicy"],
    MonitorConfigPolicyPolicyCreateRequest: [
        "MonitorConfigPolicyTagPolicyCreateRequest",
    ],
    RUMAggregateBucketValue: [
        "string",
        "number",
        "Array<RUMAggregateBucketValueTimeseriesPoint>",
    ],
    RUMGroupByMissing: ["string", "number"],
    RUMGroupByTotal: ["boolean", "string", "number"],
    ScalarColumn: ["GroupScalarColumn", "DataScalarColumn"],
    ScalarQuery: ["MetricsScalarQuery", "EventsScalarQuery"],
    SecurityMonitoringRuleCreatePayload: [
        "SecurityMonitoringStandardRuleCreatePayload",
        "SecurityMonitoringSignalRuleCreatePayload",
        "CloudConfigurationRuleCreatePayload",
    ],
    SecurityMonitoringRuleQuery: [
        "SecurityMonitoringStandardRuleQuery",
        "SecurityMonitoringSignalRuleQuery",
    ],
    SecurityMonitoringRuleResponse: [
        "SecurityMonitoringStandardRuleResponse",
        "SecurityMonitoringSignalRuleResponse",
    ],
    SensitiveDataScannerGetConfigIncludedItem: [
        "SensitiveDataScannerRuleIncludedItem",
        "SensitiveDataScannerGroupIncludedItem",
    ],
    ServiceDefinitionSchema: ["ServiceDefinitionV1", "ServiceDefinitionV2"],
    ServiceDefinitionV2Contact: [
        "ServiceDefinitionV2Email",
        "ServiceDefinitionV2Slack",
    ],
    ServiceDefinitionsCreateRequest: ["ServiceDefinitionV2", "string"],
    TimeseriesQuery: ["MetricsTimeseriesQuery", "EventsTimeseriesQuery"],
    UserResponseIncludedItem: ["Organization", "Permission", "Role"],
};
class ObjectSerializer {
    static serialize(data, type, format) {
        if (data == undefined || type == "any") {
            return data;
        }
        else if (data instanceof util_1.UnparsedObject) {
            return data._data;
        }
        else if (primitives.includes(type.toLowerCase()) &&
            typeof data == type.toLowerCase()) {
            return data;
        }
        else if (type.startsWith(ARRAY_PREFIX)) {
            if (!Array.isArray(data)) {
                throw new TypeError(`mismatch types '${data}' and '${type}'`);
            }
            // Array<Type> => Type
            const subType = type.substring(ARRAY_PREFIX.length, type.length - 1);
            const transformedData = [];
            for (const element of data) {
                transformedData.push(ObjectSerializer.serialize(element, subType, format));
            }
            return transformedData;
        }
        else if (type.startsWith(TUPLE_PREFIX)) {
            // We only support homegeneus tuples
            const subType = type
                .substring(TUPLE_PREFIX.length, type.length - 1)
                .split(", ")[0];
            const transformedData = [];
            for (const element of data) {
                transformedData.push(ObjectSerializer.serialize(element, subType, format));
            }
            return transformedData;
        }
        else if (type.startsWith(MAP_PREFIX)) {
            // { [key: string]: Type; } => Type
            const subType = type.substring(MAP_PREFIX.length, type.length - 3);
            const transformedData = {};
            for (const key in data) {
                transformedData[key] = ObjectSerializer.serialize(data[key], subType, format);
            }
            return transformedData;
        }
        else if (type === "Date") {
            if ("string" == typeof data) {
                return data;
            }
            if (format == "date" || format == "date-time") {
                return (0, util_1.dateToRFC3339String)(data);
            }
            else {
                return data.toISOString();
            }
        }
        else {
            if (enumsMap[type]) {
                if (enumsMap[type].includes(data)) {
                    return data;
                }
                throw new TypeError(`unknown enum value '${data}'`);
            }
            if (oneOfMap[type]) {
                const oneOfs = [];
                for (const oneOf of oneOfMap[type]) {
                    try {
                        oneOfs.push(ObjectSerializer.serialize(data, oneOf, format));
                    }
                    catch (e) {
                        logger_1.logger.debug(`could not serialize ${oneOf} (${e})`);
                    }
                }
                if (oneOfs.length > 1) {
                    throw new TypeError(`${data} matches multiple types from ${oneOfMap[type]} ${oneOfs}`);
                }
                if (oneOfs.length == 0) {
                    throw new TypeError(`${data} doesn't match any type from ${oneOfMap[type]} ${oneOfs}`);
                }
                return oneOfs[0];
            }
            if (!typeMap[type]) {
                // dont know the type
                throw new TypeError(`unknown type '${type}'`);
            }
            // get the map for the correct type.
            const attributesMap = typeMap[type].getAttributeTypeMap();
            const instance = {};
            for (const attributeName in attributesMap) {
                const attributeObj = attributesMap[attributeName];
                if (attributeName == "additionalProperties") {
                    if (data.additionalProperties) {
                        for (const key in data.additionalProperties) {
                            instance[key] = ObjectSerializer.serialize(data.additionalProperties[key], attributeObj.type, attributeObj.format);
                        }
                    }
                    continue;
                }
                instance[attributeObj.baseName] = ObjectSerializer.serialize(data[attributeName], attributeObj.type, attributeObj.format);
                // check for required properties
                if ((attributeObj === null || attributeObj === void 0 ? void 0 : attributeObj.required) &&
                    instance[attributeObj.baseName] === undefined) {
                    throw new Error(`missing required property '${attributeObj.baseName}'`);
                }
            }
            return instance;
        }
    }
    static deserialize(data, type, format = "") {
        var _a;
        if (data == undefined || type == "any") {
            return data;
        }
        else if (primitives.includes(type.toLowerCase()) &&
            typeof data == type.toLowerCase()) {
            return data;
        }
        else if (type.startsWith(ARRAY_PREFIX)) {
            // Assert the passed data is Array type
            if (!Array.isArray(data)) {
                throw new TypeError(`mismatch types '${data}' and '${type}'`);
            }
            // Array<Type> => Type
            const subType = type.substring(ARRAY_PREFIX.length, type.length - 1);
            const transformedData = [];
            for (const element of data) {
                transformedData.push(ObjectSerializer.deserialize(element, subType, format));
            }
            return transformedData;
        }
        else if (type.startsWith(TUPLE_PREFIX)) {
            // [Type,...] => Type
            const subType = type
                .substring(TUPLE_PREFIX.length, type.length - 1)
                .split(", ")[0];
            const transformedData = [];
            for (const element of data) {
                transformedData.push(ObjectSerializer.deserialize(element, subType, format));
            }
            return transformedData;
        }
        else if (type.startsWith(MAP_PREFIX)) {
            // { [key: string]: Type; } => Type
            const subType = type.substring(MAP_PREFIX.length, type.length - 3);
            const transformedData = {};
            for (const key in data) {
                transformedData[key] = ObjectSerializer.deserialize(data[key], subType, format);
            }
            return transformedData;
        }
        else if (type === "Date") {
            return (0, util_1.dateFromRFC3339String)(data);
        }
        else {
            if (enumsMap[type]) {
                if (enumsMap[type].includes(data)) {
                    return data;
                }
                return new util_1.UnparsedObject(data);
            }
            if (oneOfMap[type]) {
                const oneOfs = [];
                for (const oneOf of oneOfMap[type]) {
                    try {
                        const d = ObjectSerializer.deserialize(data, oneOf, format);
                        if (!(d === null || d === void 0 ? void 0 : d._unparsed)) {
                            oneOfs.push(d);
                        }
                    }
                    catch (e) {
                        logger_1.logger.debug(`could not deserialize ${oneOf} (${e})`);
                    }
                }
                if (oneOfs.length != 1) {
                    return new util_1.UnparsedObject(data);
                }
                return oneOfs[0];
            }
            if (!typeMap[type]) {
                // dont know the type
                throw new TypeError(`unknown type '${type}'`);
            }
            const instance = new typeMap[type]();
            const attributesMap = typeMap[type].getAttributeTypeMap();
            let extraAttributes = [];
            if ("additionalProperties" in attributesMap) {
                const attributesBaseNames = Object.keys(attributesMap).reduce((o, key) => Object.assign(o, { [attributesMap[key].baseName]: "" }), {});
                extraAttributes = Object.keys(data).filter((key) => !Object.prototype.hasOwnProperty.call(attributesBaseNames, key));
            }
            for (const attributeName in attributesMap) {
                const attributeObj = attributesMap[attributeName];
                if (attributeName == "additionalProperties") {
                    if (extraAttributes.length > 0) {
                        if (!instance.additionalProperties) {
                            instance.additionalProperties = {};
                        }
                        for (const key in extraAttributes) {
                            instance.additionalProperties[extraAttributes[key]] =
                                ObjectSerializer.deserialize(data[extraAttributes[key]], attributeObj.type, attributeObj.format);
                        }
                    }
                    continue;
                }
                instance[attributeName] = ObjectSerializer.deserialize(data[attributeObj.baseName], attributeObj.type, attributeObj.format);
                // check for required properties
                if ((attributeObj === null || attributeObj === void 0 ? void 0 : attributeObj.required) && instance[attributeName] === undefined) {
                    throw new Error(`missing required property '${attributeName}'`);
                }
                if (instance[attributeName] instanceof util_1.UnparsedObject ||
                    ((_a = instance[attributeName]) === null || _a === void 0 ? void 0 : _a._unparsed)) {
                    instance._unparsed = true;
                }
                if (Array.isArray(instance[attributeName])) {
                    for (const d of instance[attributeName]) {
                        if (d instanceof util_1.UnparsedObject || (d === null || d === void 0 ? void 0 : d._unparsed)) {
                            instance._unparsed = true;
                            break;
                        }
                    }
                }
            }
            return instance;
        }
    }
    /**
     * Normalize media type
     *
     * We currently do not handle any media types attributes, i.e. anything
     * after a semicolon. All content is assumed to be UTF-8 compatible.
     */
    static normalizeMediaType(mediaType) {
        if (mediaType === undefined) {
            return undefined;
        }
        return mediaType.split(";")[0].trim().toLowerCase();
    }
    /**
     * From a list of possible media types, choose the one we can handle best.
     *
     * The order of the given media types does not have any impact on the choice
     * made.
     */
    static getPreferredMediaType(mediaTypes) {
        /** According to OAS 3 we should default to json */
        if (!mediaTypes) {
            return "application/json";
        }
        const normalMediaTypes = mediaTypes.map(this.normalizeMediaType);
        let selectedMediaType = undefined;
        let selectedRank = -Infinity;
        for (const mediaType of normalMediaTypes) {
            if (mediaType === undefined) {
                continue;
            }
            const supported = supportedMediaTypes[mediaType];
            if (supported !== undefined && supported > selectedRank) {
                selectedMediaType = mediaType;
                selectedRank = supported;
            }
        }
        if (selectedMediaType === undefined) {
            throw new Error("None of the given media types are supported: " + mediaTypes.join(", "));
        }
        return selectedMediaType;
    }
    /**
     * Convert data to a string according the given media type
     */
    static stringify(data, mediaType) {
        if (mediaType === "application/json" || mediaType === "text/json") {
            return JSON.stringify(data);
        }
        throw new Error("The mediaType " +
            mediaType +
            " is not supported by ObjectSerializer.stringify.");
    }
    /**
     * Parse data from a string according to the given media type
     */
    static parse(rawData, mediaType) {
        try {
            return JSON.parse(rawData);
        }
        catch (error) {
            logger_1.logger.debug(`could not parse ${mediaType}: ${error}`);
            return rawData;
        }
    }
}
exports.ObjectSerializer = ObjectSerializer;
//# sourceMappingURL=ObjectSerializer.js.map

/***/ }),

/***/ 96016:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OpsgenieServiceCreateAttributes = void 0;
/**
 * The Opsgenie service attributes for a create request.
 */
class OpsgenieServiceCreateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OpsgenieServiceCreateAttributes.attributeTypeMap;
    }
}
exports.OpsgenieServiceCreateAttributes = OpsgenieServiceCreateAttributes;
/**
 * @ignore
 */
OpsgenieServiceCreateAttributes.attributeTypeMap = {
    customUrl: {
        baseName: "custom_url",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    opsgenieApiKey: {
        baseName: "opsgenie_api_key",
        type: "string",
        required: true,
    },
    region: {
        baseName: "region",
        type: "OpsgenieServiceRegionType",
        required: true,
    },
};
//# sourceMappingURL=OpsgenieServiceCreateAttributes.js.map

/***/ }),

/***/ 44394:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OpsgenieServiceCreateData = void 0;
/**
 * Opsgenie service data for a create request.
 */
class OpsgenieServiceCreateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OpsgenieServiceCreateData.attributeTypeMap;
    }
}
exports.OpsgenieServiceCreateData = OpsgenieServiceCreateData;
/**
 * @ignore
 */
OpsgenieServiceCreateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "OpsgenieServiceCreateAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "OpsgenieServiceType",
        required: true,
    },
};
//# sourceMappingURL=OpsgenieServiceCreateData.js.map

/***/ }),

/***/ 641:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OpsgenieServiceCreateRequest = void 0;
/**
 * Create request for an Opsgenie service.
 */
class OpsgenieServiceCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OpsgenieServiceCreateRequest.attributeTypeMap;
    }
}
exports.OpsgenieServiceCreateRequest = OpsgenieServiceCreateRequest;
/**
 * @ignore
 */
OpsgenieServiceCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "OpsgenieServiceCreateData",
        required: true,
    },
};
//# sourceMappingURL=OpsgenieServiceCreateRequest.js.map

/***/ }),

/***/ 3424:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OpsgenieServiceResponse = void 0;
/**
 * Response of an Opsgenie service.
 */
class OpsgenieServiceResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OpsgenieServiceResponse.attributeTypeMap;
    }
}
exports.OpsgenieServiceResponse = OpsgenieServiceResponse;
/**
 * @ignore
 */
OpsgenieServiceResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "OpsgenieServiceResponseData",
        required: true,
    },
};
//# sourceMappingURL=OpsgenieServiceResponse.js.map

/***/ }),

/***/ 36633:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OpsgenieServiceResponseAttributes = void 0;
/**
 * The attributes from an Opsgenie service response.
 */
class OpsgenieServiceResponseAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OpsgenieServiceResponseAttributes.attributeTypeMap;
    }
}
exports.OpsgenieServiceResponseAttributes = OpsgenieServiceResponseAttributes;
/**
 * @ignore
 */
OpsgenieServiceResponseAttributes.attributeTypeMap = {
    customUrl: {
        baseName: "custom_url",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    region: {
        baseName: "region",
        type: "OpsgenieServiceRegionType",
    },
};
//# sourceMappingURL=OpsgenieServiceResponseAttributes.js.map

/***/ }),

/***/ 89232:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OpsgenieServiceResponseData = void 0;
/**
 * Opsgenie service data from a response.
 */
class OpsgenieServiceResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OpsgenieServiceResponseData.attributeTypeMap;
    }
}
exports.OpsgenieServiceResponseData = OpsgenieServiceResponseData;
/**
 * @ignore
 */
OpsgenieServiceResponseData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "OpsgenieServiceResponseAttributes",
        required: true,
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "OpsgenieServiceType",
        required: true,
    },
};
//# sourceMappingURL=OpsgenieServiceResponseData.js.map

/***/ }),

/***/ 46808:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OpsgenieServiceUpdateAttributes = void 0;
/**
 * The Opsgenie service attributes for an update request.
 */
class OpsgenieServiceUpdateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OpsgenieServiceUpdateAttributes.attributeTypeMap;
    }
}
exports.OpsgenieServiceUpdateAttributes = OpsgenieServiceUpdateAttributes;
/**
 * @ignore
 */
OpsgenieServiceUpdateAttributes.attributeTypeMap = {
    customUrl: {
        baseName: "custom_url",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    opsgenieApiKey: {
        baseName: "opsgenie_api_key",
        type: "string",
    },
    region: {
        baseName: "region",
        type: "OpsgenieServiceRegionType",
    },
};
//# sourceMappingURL=OpsgenieServiceUpdateAttributes.js.map

/***/ }),

/***/ 89005:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OpsgenieServiceUpdateData = void 0;
/**
 * Opsgenie service for an update request.
 */
class OpsgenieServiceUpdateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OpsgenieServiceUpdateData.attributeTypeMap;
    }
}
exports.OpsgenieServiceUpdateData = OpsgenieServiceUpdateData;
/**
 * @ignore
 */
OpsgenieServiceUpdateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "OpsgenieServiceUpdateAttributes",
        required: true,
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "OpsgenieServiceType",
        required: true,
    },
};
//# sourceMappingURL=OpsgenieServiceUpdateData.js.map

/***/ }),

/***/ 52502:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OpsgenieServiceUpdateRequest = void 0;
/**
 * Update request for an Opsgenie service.
 */
class OpsgenieServiceUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OpsgenieServiceUpdateRequest.attributeTypeMap;
    }
}
exports.OpsgenieServiceUpdateRequest = OpsgenieServiceUpdateRequest;
/**
 * @ignore
 */
OpsgenieServiceUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "OpsgenieServiceUpdateData",
        required: true,
    },
};
//# sourceMappingURL=OpsgenieServiceUpdateRequest.js.map

/***/ }),

/***/ 43059:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OpsgenieServicesResponse = void 0;
/**
 * Response with a list of Opsgenie services.
 */
class OpsgenieServicesResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OpsgenieServicesResponse.attributeTypeMap;
    }
}
exports.OpsgenieServicesResponse = OpsgenieServicesResponse;
/**
 * @ignore
 */
OpsgenieServicesResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<OpsgenieServiceResponseData>",
        required: true,
    },
};
//# sourceMappingURL=OpsgenieServicesResponse.js.map

/***/ }),

/***/ 6229:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Organization = void 0;
/**
 * Organization object.
 */
class Organization {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return Organization.attributeTypeMap;
    }
}
exports.Organization = Organization;
/**
 * @ignore
 */
Organization.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "OrganizationAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "OrganizationsType",
        required: true,
    },
};
//# sourceMappingURL=Organization.js.map

/***/ }),

/***/ 77933:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OrganizationAttributes = void 0;
/**
 * Attributes of the organization.
 */
class OrganizationAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return OrganizationAttributes.attributeTypeMap;
    }
}
exports.OrganizationAttributes = OrganizationAttributes;
/**
 * @ignore
 */
OrganizationAttributes.attributeTypeMap = {
    createdAt: {
        baseName: "created_at",
        type: "Date",
        format: "date-time",
    },
    description: {
        baseName: "description",
        type: "string",
    },
    disabled: {
        baseName: "disabled",
        type: "boolean",
    },
    modifiedAt: {
        baseName: "modified_at",
        type: "Date",
        format: "date-time",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    sharing: {
        baseName: "sharing",
        type: "string",
    },
    url: {
        baseName: "url",
        type: "string",
    },
};
//# sourceMappingURL=OrganizationAttributes.js.map

/***/ }),

/***/ 35680:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pagination = void 0;
/**
 * Pagination object.
 */
class Pagination {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return Pagination.attributeTypeMap;
    }
}
exports.Pagination = Pagination;
/**
 * @ignore
 */
Pagination.attributeTypeMap = {
    totalCount: {
        baseName: "total_count",
        type: "number",
        format: "int64",
    },
    totalFilteredCount: {
        baseName: "total_filtered_count",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=Pagination.js.map

/***/ }),

/***/ 64447:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PartialAPIKey = void 0;
/**
 * Partial Datadog API key.
 */
class PartialAPIKey {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return PartialAPIKey.attributeTypeMap;
    }
}
exports.PartialAPIKey = PartialAPIKey;
/**
 * @ignore
 */
PartialAPIKey.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "PartialAPIKeyAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    relationships: {
        baseName: "relationships",
        type: "APIKeyRelationships",
    },
    type: {
        baseName: "type",
        type: "APIKeysType",
    },
};
//# sourceMappingURL=PartialAPIKey.js.map

/***/ }),

/***/ 99573:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PartialAPIKeyAttributes = void 0;
/**
 * Attributes of a partial API key.
 */
class PartialAPIKeyAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return PartialAPIKeyAttributes.attributeTypeMap;
    }
}
exports.PartialAPIKeyAttributes = PartialAPIKeyAttributes;
/**
 * @ignore
 */
PartialAPIKeyAttributes.attributeTypeMap = {
    createdAt: {
        baseName: "created_at",
        type: "string",
    },
    last4: {
        baseName: "last4",
        type: "string",
    },
    modifiedAt: {
        baseName: "modified_at",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=PartialAPIKeyAttributes.js.map

/***/ }),

/***/ 67979:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PartialApplicationKey = void 0;
/**
 * Partial Datadog application key.
 */
class PartialApplicationKey {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return PartialApplicationKey.attributeTypeMap;
    }
}
exports.PartialApplicationKey = PartialApplicationKey;
/**
 * @ignore
 */
PartialApplicationKey.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "PartialApplicationKeyAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    relationships: {
        baseName: "relationships",
        type: "ApplicationKeyRelationships",
    },
    type: {
        baseName: "type",
        type: "ApplicationKeysType",
    },
};
//# sourceMappingURL=PartialApplicationKey.js.map

/***/ }),

/***/ 96197:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PartialApplicationKeyAttributes = void 0;
/**
 * Attributes of a partial application key.
 */
class PartialApplicationKeyAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return PartialApplicationKeyAttributes.attributeTypeMap;
    }
}
exports.PartialApplicationKeyAttributes = PartialApplicationKeyAttributes;
/**
 * @ignore
 */
PartialApplicationKeyAttributes.attributeTypeMap = {
    createdAt: {
        baseName: "created_at",
        type: "string",
    },
    last4: {
        baseName: "last4",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    scopes: {
        baseName: "scopes",
        type: "Array<string>",
    },
};
//# sourceMappingURL=PartialApplicationKeyAttributes.js.map

/***/ }),

/***/ 52459:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PartialApplicationKeyResponse = void 0;
/**
 * Response for retrieving a partial application key.
 */
class PartialApplicationKeyResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return PartialApplicationKeyResponse.attributeTypeMap;
    }
}
exports.PartialApplicationKeyResponse = PartialApplicationKeyResponse;
/**
 * @ignore
 */
PartialApplicationKeyResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "PartialApplicationKey",
    },
    included: {
        baseName: "included",
        type: "Array<ApplicationKeyResponseIncludedItem>",
    },
};
//# sourceMappingURL=PartialApplicationKeyResponse.js.map

/***/ }),

/***/ 50681:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Permission = void 0;
/**
 * Permission object.
 */
class Permission {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return Permission.attributeTypeMap;
    }
}
exports.Permission = Permission;
/**
 * @ignore
 */
Permission.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "PermissionAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "PermissionsType",
        required: true,
    },
};
//# sourceMappingURL=Permission.js.map

/***/ }),

/***/ 84187:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PermissionAttributes = void 0;
/**
 * Attributes of a permission.
 */
class PermissionAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return PermissionAttributes.attributeTypeMap;
    }
}
exports.PermissionAttributes = PermissionAttributes;
/**
 * @ignore
 */
PermissionAttributes.attributeTypeMap = {
    created: {
        baseName: "created",
        type: "Date",
        format: "date-time",
    },
    description: {
        baseName: "description",
        type: "string",
    },
    displayName: {
        baseName: "display_name",
        type: "string",
    },
    displayType: {
        baseName: "display_type",
        type: "string",
    },
    groupName: {
        baseName: "group_name",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    restricted: {
        baseName: "restricted",
        type: "boolean",
    },
};
//# sourceMappingURL=PermissionAttributes.js.map

/***/ }),

/***/ 99426:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PermissionsResponse = void 0;
/**
 * Payload with API-returned permissions.
 */
class PermissionsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return PermissionsResponse.attributeTypeMap;
    }
}
exports.PermissionsResponse = PermissionsResponse;
/**
 * @ignore
 */
PermissionsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<Permission>",
    },
};
//# sourceMappingURL=PermissionsResponse.js.map

/***/ }),

/***/ 30341:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProcessSummariesMeta = void 0;
/**
 * Response metadata object.
 */
class ProcessSummariesMeta {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ProcessSummariesMeta.attributeTypeMap;
    }
}
exports.ProcessSummariesMeta = ProcessSummariesMeta;
/**
 * @ignore
 */
ProcessSummariesMeta.attributeTypeMap = {
    page: {
        baseName: "page",
        type: "ProcessSummariesMetaPage",
    },
};
//# sourceMappingURL=ProcessSummariesMeta.js.map

/***/ }),

/***/ 88359:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProcessSummariesMetaPage = void 0;
/**
 * Paging attributes.
 */
class ProcessSummariesMetaPage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ProcessSummariesMetaPage.attributeTypeMap;
    }
}
exports.ProcessSummariesMetaPage = ProcessSummariesMetaPage;
/**
 * @ignore
 */
ProcessSummariesMetaPage.attributeTypeMap = {
    after: {
        baseName: "after",
        type: "string",
    },
    size: {
        baseName: "size",
        type: "number",
        format: "int32",
    },
};
//# sourceMappingURL=ProcessSummariesMetaPage.js.map

/***/ }),

/***/ 61750:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProcessSummariesResponse = void 0;
/**
 * List of process summaries.
 */
class ProcessSummariesResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ProcessSummariesResponse.attributeTypeMap;
    }
}
exports.ProcessSummariesResponse = ProcessSummariesResponse;
/**
 * @ignore
 */
ProcessSummariesResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<ProcessSummary>",
    },
    meta: {
        baseName: "meta",
        type: "ProcessSummariesMeta",
    },
};
//# sourceMappingURL=ProcessSummariesResponse.js.map

/***/ }),

/***/ 35834:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProcessSummary = void 0;
/**
 * Process summary object.
 */
class ProcessSummary {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ProcessSummary.attributeTypeMap;
    }
}
exports.ProcessSummary = ProcessSummary;
/**
 * @ignore
 */
ProcessSummary.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "ProcessSummaryAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "ProcessSummaryType",
    },
};
//# sourceMappingURL=ProcessSummary.js.map

/***/ }),

/***/ 81126:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProcessSummaryAttributes = void 0;
/**
 * Attributes for a process summary.
 */
class ProcessSummaryAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ProcessSummaryAttributes.attributeTypeMap;
    }
}
exports.ProcessSummaryAttributes = ProcessSummaryAttributes;
/**
 * @ignore
 */
ProcessSummaryAttributes.attributeTypeMap = {
    cmdline: {
        baseName: "cmdline",
        type: "string",
    },
    host: {
        baseName: "host",
        type: "string",
    },
    pid: {
        baseName: "pid",
        type: "number",
        format: "int64",
    },
    ppid: {
        baseName: "ppid",
        type: "number",
        format: "int64",
    },
    start: {
        baseName: "start",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    timestamp: {
        baseName: "timestamp",
        type: "string",
    },
    user: {
        baseName: "user",
        type: "string",
    },
};
//# sourceMappingURL=ProcessSummaryAttributes.js.map

/***/ }),

/***/ 24419:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QueryFormula = void 0;
/**
 * A formula for calculation based on one or more queries.
 */
class QueryFormula {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return QueryFormula.attributeTypeMap;
    }
}
exports.QueryFormula = QueryFormula;
/**
 * @ignore
 */
QueryFormula.attributeTypeMap = {
    formula: {
        baseName: "formula",
        type: "string",
        required: true,
    },
    limit: {
        baseName: "limit",
        type: "FormulaLimit",
    },
};
//# sourceMappingURL=QueryFormula.js.map

/***/ }),

/***/ 71:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMAggregateBucketValueTimeseriesPoint = void 0;
/**
 * A timeseries point.
 */
class RUMAggregateBucketValueTimeseriesPoint {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMAggregateBucketValueTimeseriesPoint.attributeTypeMap;
    }
}
exports.RUMAggregateBucketValueTimeseriesPoint = RUMAggregateBucketValueTimeseriesPoint;
/**
 * @ignore
 */
RUMAggregateBucketValueTimeseriesPoint.attributeTypeMap = {
    time: {
        baseName: "time",
        type: "Date",
        format: "date-time",
    },
    value: {
        baseName: "value",
        type: "number",
        format: "double",
    },
};
//# sourceMappingURL=RUMAggregateBucketValueTimeseriesPoint.js.map

/***/ }),

/***/ 98438:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMAggregateRequest = void 0;
/**
 * The object sent with the request to retrieve aggregation buckets of RUM events from your organization.
 */
class RUMAggregateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMAggregateRequest.attributeTypeMap;
    }
}
exports.RUMAggregateRequest = RUMAggregateRequest;
/**
 * @ignore
 */
RUMAggregateRequest.attributeTypeMap = {
    compute: {
        baseName: "compute",
        type: "Array<RUMCompute>",
    },
    filter: {
        baseName: "filter",
        type: "RUMQueryFilter",
    },
    groupBy: {
        baseName: "group_by",
        type: "Array<RUMGroupBy>",
    },
    options: {
        baseName: "options",
        type: "RUMQueryOptions",
    },
    page: {
        baseName: "page",
        type: "RUMQueryPageOptions",
    },
};
//# sourceMappingURL=RUMAggregateRequest.js.map

/***/ }),

/***/ 66861:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMAggregateSort = void 0;
/**
 * A sort rule.
 */
class RUMAggregateSort {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMAggregateSort.attributeTypeMap;
    }
}
exports.RUMAggregateSort = RUMAggregateSort;
/**
 * @ignore
 */
RUMAggregateSort.attributeTypeMap = {
    aggregation: {
        baseName: "aggregation",
        type: "RUMAggregationFunction",
    },
    metric: {
        baseName: "metric",
        type: "string",
    },
    order: {
        baseName: "order",
        type: "RUMSortOrder",
    },
    type: {
        baseName: "type",
        type: "RUMAggregateSortType",
    },
};
//# sourceMappingURL=RUMAggregateSort.js.map

/***/ }),

/***/ 50116:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMAggregationBucketsResponse = void 0;
/**
 * The query results.
 */
class RUMAggregationBucketsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMAggregationBucketsResponse.attributeTypeMap;
    }
}
exports.RUMAggregationBucketsResponse = RUMAggregationBucketsResponse;
/**
 * @ignore
 */
RUMAggregationBucketsResponse.attributeTypeMap = {
    buckets: {
        baseName: "buckets",
        type: "Array<RUMBucketResponse>",
    },
};
//# sourceMappingURL=RUMAggregationBucketsResponse.js.map

/***/ }),

/***/ 9558:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMAnalyticsAggregateResponse = void 0;
/**
 * The response object for the RUM events aggregate API endpoint.
 */
class RUMAnalyticsAggregateResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMAnalyticsAggregateResponse.attributeTypeMap;
    }
}
exports.RUMAnalyticsAggregateResponse = RUMAnalyticsAggregateResponse;
/**
 * @ignore
 */
RUMAnalyticsAggregateResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "RUMAggregationBucketsResponse",
    },
    links: {
        baseName: "links",
        type: "RUMResponseLinks",
    },
    meta: {
        baseName: "meta",
        type: "RUMResponseMetadata",
    },
};
//# sourceMappingURL=RUMAnalyticsAggregateResponse.js.map

/***/ }),

/***/ 20447:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMApplication = void 0;
/**
 * RUM application.
 */
class RUMApplication {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMApplication.attributeTypeMap;
    }
}
exports.RUMApplication = RUMApplication;
/**
 * @ignore
 */
RUMApplication.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "RUMApplicationAttributes",
        required: true,
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "RUMApplicationType",
        required: true,
    },
};
//# sourceMappingURL=RUMApplication.js.map

/***/ }),

/***/ 5619:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMApplicationAttributes = void 0;
/**
 * RUM application attributes.
 */
class RUMApplicationAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMApplicationAttributes.attributeTypeMap;
    }
}
exports.RUMApplicationAttributes = RUMApplicationAttributes;
/**
 * @ignore
 */
RUMApplicationAttributes.attributeTypeMap = {
    applicationId: {
        baseName: "application_id",
        type: "string",
        required: true,
    },
    clientToken: {
        baseName: "client_token",
        type: "string",
        required: true,
    },
    createdAt: {
        baseName: "created_at",
        type: "number",
        required: true,
        format: "int64",
    },
    createdByHandle: {
        baseName: "created_by_handle",
        type: "string",
        required: true,
    },
    hash: {
        baseName: "hash",
        type: "string",
    },
    isActive: {
        baseName: "is_active",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    orgId: {
        baseName: "org_id",
        type: "number",
        required: true,
        format: "int32",
    },
    type: {
        baseName: "type",
        type: "string",
        required: true,
    },
    updatedAt: {
        baseName: "updated_at",
        type: "number",
        required: true,
        format: "int64",
    },
    updatedByHandle: {
        baseName: "updated_by_handle",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=RUMApplicationAttributes.js.map

/***/ }),

/***/ 7740:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMApplicationCreate = void 0;
/**
 * RUM application creation.
 */
class RUMApplicationCreate {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMApplicationCreate.attributeTypeMap;
    }
}
exports.RUMApplicationCreate = RUMApplicationCreate;
/**
 * @ignore
 */
RUMApplicationCreate.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "RUMApplicationCreateAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "RUMApplicationCreateType",
        required: true,
    },
};
//# sourceMappingURL=RUMApplicationCreate.js.map

/***/ }),

/***/ 41625:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMApplicationCreateAttributes = void 0;
/**
 * RUM application creation attributes.
 */
class RUMApplicationCreateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMApplicationCreateAttributes.attributeTypeMap;
    }
}
exports.RUMApplicationCreateAttributes = RUMApplicationCreateAttributes;
/**
 * @ignore
 */
RUMApplicationCreateAttributes.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "string",
    },
};
//# sourceMappingURL=RUMApplicationCreateAttributes.js.map

/***/ }),

/***/ 27250:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMApplicationCreateRequest = void 0;
/**
 * RUM application creation request attributes.
 */
class RUMApplicationCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMApplicationCreateRequest.attributeTypeMap;
    }
}
exports.RUMApplicationCreateRequest = RUMApplicationCreateRequest;
/**
 * @ignore
 */
RUMApplicationCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "RUMApplicationCreate",
        required: true,
    },
};
//# sourceMappingURL=RUMApplicationCreateRequest.js.map

/***/ }),

/***/ 3318:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMApplicationList = void 0;
/**
 * RUM application list.
 */
class RUMApplicationList {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMApplicationList.attributeTypeMap;
    }
}
exports.RUMApplicationList = RUMApplicationList;
/**
 * @ignore
 */
RUMApplicationList.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "RUMApplicationListAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "RUMApplicationListType",
        required: true,
    },
};
//# sourceMappingURL=RUMApplicationList.js.map

/***/ }),

/***/ 26043:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMApplicationListAttributes = void 0;
/**
 * RUM application list attributes.
 */
class RUMApplicationListAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMApplicationListAttributes.attributeTypeMap;
    }
}
exports.RUMApplicationListAttributes = RUMApplicationListAttributes;
/**
 * @ignore
 */
RUMApplicationListAttributes.attributeTypeMap = {
    applicationId: {
        baseName: "application_id",
        type: "string",
        required: true,
    },
    createdAt: {
        baseName: "created_at",
        type: "number",
        required: true,
        format: "int64",
    },
    createdByHandle: {
        baseName: "created_by_handle",
        type: "string",
        required: true,
    },
    hash: {
        baseName: "hash",
        type: "string",
    },
    isActive: {
        baseName: "is_active",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    orgId: {
        baseName: "org_id",
        type: "number",
        required: true,
        format: "int32",
    },
    type: {
        baseName: "type",
        type: "string",
        required: true,
    },
    updatedAt: {
        baseName: "updated_at",
        type: "number",
        required: true,
        format: "int64",
    },
    updatedByHandle: {
        baseName: "updated_by_handle",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=RUMApplicationListAttributes.js.map

/***/ }),

/***/ 59012:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMApplicationResponse = void 0;
/**
 * RUM application response.
 */
class RUMApplicationResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMApplicationResponse.attributeTypeMap;
    }
}
exports.RUMApplicationResponse = RUMApplicationResponse;
/**
 * @ignore
 */
RUMApplicationResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "RUMApplication",
    },
};
//# sourceMappingURL=RUMApplicationResponse.js.map

/***/ }),

/***/ 11541:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMApplicationUpdate = void 0;
/**
 * RUM application update.
 */
class RUMApplicationUpdate {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMApplicationUpdate.attributeTypeMap;
    }
}
exports.RUMApplicationUpdate = RUMApplicationUpdate;
/**
 * @ignore
 */
RUMApplicationUpdate.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "RUMApplicationUpdateAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "RUMApplicationUpdateType",
        required: true,
    },
};
//# sourceMappingURL=RUMApplicationUpdate.js.map

/***/ }),

/***/ 3394:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMApplicationUpdateAttributes = void 0;
/**
 * RUM application update attributes.
 */
class RUMApplicationUpdateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMApplicationUpdateAttributes.attributeTypeMap;
    }
}
exports.RUMApplicationUpdateAttributes = RUMApplicationUpdateAttributes;
/**
 * @ignore
 */
RUMApplicationUpdateAttributes.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "string",
    },
};
//# sourceMappingURL=RUMApplicationUpdateAttributes.js.map

/***/ }),

/***/ 12932:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMApplicationUpdateRequest = void 0;
/**
 * RUM application update request.
 */
class RUMApplicationUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMApplicationUpdateRequest.attributeTypeMap;
    }
}
exports.RUMApplicationUpdateRequest = RUMApplicationUpdateRequest;
/**
 * @ignore
 */
RUMApplicationUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "RUMApplicationUpdate",
        required: true,
    },
};
//# sourceMappingURL=RUMApplicationUpdateRequest.js.map

/***/ }),

/***/ 62857:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMApplicationsResponse = void 0;
/**
 * RUM applications response.
 */
class RUMApplicationsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMApplicationsResponse.attributeTypeMap;
    }
}
exports.RUMApplicationsResponse = RUMApplicationsResponse;
/**
 * @ignore
 */
RUMApplicationsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<RUMApplicationList>",
    },
};
//# sourceMappingURL=RUMApplicationsResponse.js.map

/***/ }),

/***/ 37302:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMBucketResponse = void 0;
/**
 * Bucket values.
 */
class RUMBucketResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMBucketResponse.attributeTypeMap;
    }
}
exports.RUMBucketResponse = RUMBucketResponse;
/**
 * @ignore
 */
RUMBucketResponse.attributeTypeMap = {
    by: {
        baseName: "by",
        type: "{ [key: string]: string; }",
    },
    computes: {
        baseName: "computes",
        type: "{ [key: string]: RUMAggregateBucketValue; }",
    },
};
//# sourceMappingURL=RUMBucketResponse.js.map

/***/ }),

/***/ 34658:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMCompute = void 0;
/**
 * A compute rule to compute metrics or timeseries.
 */
class RUMCompute {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMCompute.attributeTypeMap;
    }
}
exports.RUMCompute = RUMCompute;
/**
 * @ignore
 */
RUMCompute.attributeTypeMap = {
    aggregation: {
        baseName: "aggregation",
        type: "RUMAggregationFunction",
        required: true,
    },
    interval: {
        baseName: "interval",
        type: "string",
    },
    metric: {
        baseName: "metric",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "RUMComputeType",
    },
};
//# sourceMappingURL=RUMCompute.js.map

/***/ }),

/***/ 44075:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMEvent = void 0;
/**
 * Object description of a RUM event after being processed and stored by Datadog.
 */
class RUMEvent {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMEvent.attributeTypeMap;
    }
}
exports.RUMEvent = RUMEvent;
/**
 * @ignore
 */
RUMEvent.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "RUMEventAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "RUMEventType",
    },
};
//# sourceMappingURL=RUMEvent.js.map

/***/ }),

/***/ 31323:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMEventAttributes = void 0;
/**
 * JSON object containing all event attributes and their associated values.
 */
class RUMEventAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMEventAttributes.attributeTypeMap;
    }
}
exports.RUMEventAttributes = RUMEventAttributes;
/**
 * @ignore
 */
RUMEventAttributes.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "{ [key: string]: any; }",
    },
    service: {
        baseName: "service",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    timestamp: {
        baseName: "timestamp",
        type: "Date",
        format: "date-time",
    },
};
//# sourceMappingURL=RUMEventAttributes.js.map

/***/ }),

/***/ 42841:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMEventsResponse = void 0;
/**
 * Response object with all events matching the request and pagination information.
 */
class RUMEventsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMEventsResponse.attributeTypeMap;
    }
}
exports.RUMEventsResponse = RUMEventsResponse;
/**
 * @ignore
 */
RUMEventsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<RUMEvent>",
    },
    links: {
        baseName: "links",
        type: "RUMResponseLinks",
    },
    meta: {
        baseName: "meta",
        type: "RUMResponseMetadata",
    },
};
//# sourceMappingURL=RUMEventsResponse.js.map

/***/ }),

/***/ 82421:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMGroupBy = void 0;
/**
 * A group-by rule.
 */
class RUMGroupBy {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMGroupBy.attributeTypeMap;
    }
}
exports.RUMGroupBy = RUMGroupBy;
/**
 * @ignore
 */
RUMGroupBy.attributeTypeMap = {
    facet: {
        baseName: "facet",
        type: "string",
        required: true,
    },
    histogram: {
        baseName: "histogram",
        type: "RUMGroupByHistogram",
    },
    limit: {
        baseName: "limit",
        type: "number",
        format: "int64",
    },
    missing: {
        baseName: "missing",
        type: "RUMGroupByMissing",
    },
    sort: {
        baseName: "sort",
        type: "RUMAggregateSort",
    },
    total: {
        baseName: "total",
        type: "RUMGroupByTotal",
    },
};
//# sourceMappingURL=RUMGroupBy.js.map

/***/ }),

/***/ 27195:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMGroupByHistogram = void 0;
/**
 * Used to perform a histogram computation (only for measure facets).
 * Note: At most 100 buckets are allowed, the number of buckets is (max - min)/interval.
 */
class RUMGroupByHistogram {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMGroupByHistogram.attributeTypeMap;
    }
}
exports.RUMGroupByHistogram = RUMGroupByHistogram;
/**
 * @ignore
 */
RUMGroupByHistogram.attributeTypeMap = {
    interval: {
        baseName: "interval",
        type: "number",
        required: true,
        format: "double",
    },
    max: {
        baseName: "max",
        type: "number",
        required: true,
        format: "double",
    },
    min: {
        baseName: "min",
        type: "number",
        required: true,
        format: "double",
    },
};
//# sourceMappingURL=RUMGroupByHistogram.js.map

/***/ }),

/***/ 4455:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMQueryFilter = void 0;
/**
 * The search and filter query settings.
 */
class RUMQueryFilter {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMQueryFilter.attributeTypeMap;
    }
}
exports.RUMQueryFilter = RUMQueryFilter;
/**
 * @ignore
 */
RUMQueryFilter.attributeTypeMap = {
    from: {
        baseName: "from",
        type: "string",
    },
    query: {
        baseName: "query",
        type: "string",
    },
    to: {
        baseName: "to",
        type: "string",
    },
};
//# sourceMappingURL=RUMQueryFilter.js.map

/***/ }),

/***/ 53313:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMQueryOptions = void 0;
/**
 * Global query options that are used during the query.
 * Note: Only supply timezone or time offset, not both. Otherwise, the query fails.
 */
class RUMQueryOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMQueryOptions.attributeTypeMap;
    }
}
exports.RUMQueryOptions = RUMQueryOptions;
/**
 * @ignore
 */
RUMQueryOptions.attributeTypeMap = {
    timeOffset: {
        baseName: "time_offset",
        type: "number",
        format: "int64",
    },
    timezone: {
        baseName: "timezone",
        type: "string",
    },
};
//# sourceMappingURL=RUMQueryOptions.js.map

/***/ }),

/***/ 89982:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMQueryPageOptions = void 0;
/**
 * Paging attributes for listing events.
 */
class RUMQueryPageOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMQueryPageOptions.attributeTypeMap;
    }
}
exports.RUMQueryPageOptions = RUMQueryPageOptions;
/**
 * @ignore
 */
RUMQueryPageOptions.attributeTypeMap = {
    cursor: {
        baseName: "cursor",
        type: "string",
    },
    limit: {
        baseName: "limit",
        type: "number",
        format: "int32",
    },
};
//# sourceMappingURL=RUMQueryPageOptions.js.map

/***/ }),

/***/ 62690:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMResponseLinks = void 0;
/**
 * Links attributes.
 */
class RUMResponseLinks {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMResponseLinks.attributeTypeMap;
    }
}
exports.RUMResponseLinks = RUMResponseLinks;
/**
 * @ignore
 */
RUMResponseLinks.attributeTypeMap = {
    next: {
        baseName: "next",
        type: "string",
    },
};
//# sourceMappingURL=RUMResponseLinks.js.map

/***/ }),

/***/ 10700:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMResponseMetadata = void 0;
/**
 * The metadata associated with a request.
 */
class RUMResponseMetadata {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMResponseMetadata.attributeTypeMap;
    }
}
exports.RUMResponseMetadata = RUMResponseMetadata;
/**
 * @ignore
 */
RUMResponseMetadata.attributeTypeMap = {
    elapsed: {
        baseName: "elapsed",
        type: "number",
        format: "int64",
    },
    page: {
        baseName: "page",
        type: "RUMResponsePage",
    },
    requestId: {
        baseName: "request_id",
        type: "string",
    },
    status: {
        baseName: "status",
        type: "RUMResponseStatus",
    },
    warnings: {
        baseName: "warnings",
        type: "Array<RUMWarning>",
    },
};
//# sourceMappingURL=RUMResponseMetadata.js.map

/***/ }),

/***/ 49457:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMResponsePage = void 0;
/**
 * Paging attributes.
 */
class RUMResponsePage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMResponsePage.attributeTypeMap;
    }
}
exports.RUMResponsePage = RUMResponsePage;
/**
 * @ignore
 */
RUMResponsePage.attributeTypeMap = {
    after: {
        baseName: "after",
        type: "string",
    },
};
//# sourceMappingURL=RUMResponsePage.js.map

/***/ }),

/***/ 97557:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMSearchEventsRequest = void 0;
/**
 * The request for a RUM events list.
 */
class RUMSearchEventsRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMSearchEventsRequest.attributeTypeMap;
    }
}
exports.RUMSearchEventsRequest = RUMSearchEventsRequest;
/**
 * @ignore
 */
RUMSearchEventsRequest.attributeTypeMap = {
    filter: {
        baseName: "filter",
        type: "RUMQueryFilter",
    },
    options: {
        baseName: "options",
        type: "RUMQueryOptions",
    },
    page: {
        baseName: "page",
        type: "RUMQueryPageOptions",
    },
    sort: {
        baseName: "sort",
        type: "RUMSort",
    },
};
//# sourceMappingURL=RUMSearchEventsRequest.js.map

/***/ }),

/***/ 66821:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RUMWarning = void 0;
/**
 * A warning message indicating something that went wrong with the query.
 */
class RUMWarning {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RUMWarning.attributeTypeMap;
    }
}
exports.RUMWarning = RUMWarning;
/**
 * @ignore
 */
RUMWarning.attributeTypeMap = {
    code: {
        baseName: "code",
        type: "string",
    },
    detail: {
        baseName: "detail",
        type: "string",
    },
    title: {
        baseName: "title",
        type: "string",
    },
};
//# sourceMappingURL=RUMWarning.js.map

/***/ }),

/***/ 87288:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelationshipToIncidentAttachment = void 0;
/**
 * A relationship reference for attachments.
 */
class RelationshipToIncidentAttachment {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RelationshipToIncidentAttachment.attributeTypeMap;
    }
}
exports.RelationshipToIncidentAttachment = RelationshipToIncidentAttachment;
/**
 * @ignore
 */
RelationshipToIncidentAttachment.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<RelationshipToIncidentAttachmentData>",
        required: true,
    },
};
//# sourceMappingURL=RelationshipToIncidentAttachment.js.map

/***/ }),

/***/ 6475:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelationshipToIncidentAttachmentData = void 0;
/**
 * The attachment relationship data.
 */
class RelationshipToIncidentAttachmentData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RelationshipToIncidentAttachmentData.attributeTypeMap;
    }
}
exports.RelationshipToIncidentAttachmentData = RelationshipToIncidentAttachmentData;
/**
 * @ignore
 */
RelationshipToIncidentAttachmentData.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "IncidentAttachmentType",
        required: true,
    },
};
//# sourceMappingURL=RelationshipToIncidentAttachmentData.js.map

/***/ }),

/***/ 43443:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelationshipToIncidentIntegrationMetadataData = void 0;
/**
 * A relationship reference for an integration metadata object.
 */
class RelationshipToIncidentIntegrationMetadataData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RelationshipToIncidentIntegrationMetadataData.attributeTypeMap;
    }
}
exports.RelationshipToIncidentIntegrationMetadataData = RelationshipToIncidentIntegrationMetadataData;
/**
 * @ignore
 */
RelationshipToIncidentIntegrationMetadataData.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "IncidentIntegrationMetadataType",
        required: true,
    },
};
//# sourceMappingURL=RelationshipToIncidentIntegrationMetadataData.js.map

/***/ }),

/***/ 91471:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelationshipToIncidentIntegrationMetadatas = void 0;
/**
 * A relationship reference for multiple integration metadata objects.
 */
class RelationshipToIncidentIntegrationMetadatas {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RelationshipToIncidentIntegrationMetadatas.attributeTypeMap;
    }
}
exports.RelationshipToIncidentIntegrationMetadatas = RelationshipToIncidentIntegrationMetadatas;
/**
 * @ignore
 */
RelationshipToIncidentIntegrationMetadatas.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<RelationshipToIncidentIntegrationMetadataData>",
        required: true,
    },
};
//# sourceMappingURL=RelationshipToIncidentIntegrationMetadatas.js.map

/***/ }),

/***/ 91589:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelationshipToIncidentPostmortem = void 0;
/**
 * A relationship reference for postmortems.
 */
class RelationshipToIncidentPostmortem {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RelationshipToIncidentPostmortem.attributeTypeMap;
    }
}
exports.RelationshipToIncidentPostmortem = RelationshipToIncidentPostmortem;
/**
 * @ignore
 */
RelationshipToIncidentPostmortem.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "RelationshipToIncidentPostmortemData",
        required: true,
    },
};
//# sourceMappingURL=RelationshipToIncidentPostmortem.js.map

/***/ }),

/***/ 57515:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelationshipToIncidentPostmortemData = void 0;
/**
 * The postmortem relationship data.
 */
class RelationshipToIncidentPostmortemData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RelationshipToIncidentPostmortemData.attributeTypeMap;
    }
}
exports.RelationshipToIncidentPostmortemData = RelationshipToIncidentPostmortemData;
/**
 * @ignore
 */
RelationshipToIncidentPostmortemData.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "IncidentPostmortemType",
        required: true,
    },
};
//# sourceMappingURL=RelationshipToIncidentPostmortemData.js.map

/***/ }),

/***/ 1786:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelationshipToOrganization = void 0;
/**
 * Relationship to an organization.
 */
class RelationshipToOrganization {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RelationshipToOrganization.attributeTypeMap;
    }
}
exports.RelationshipToOrganization = RelationshipToOrganization;
/**
 * @ignore
 */
RelationshipToOrganization.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "RelationshipToOrganizationData",
        required: true,
    },
};
//# sourceMappingURL=RelationshipToOrganization.js.map

/***/ }),

/***/ 3098:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelationshipToOrganizationData = void 0;
/**
 * Relationship to organization object.
 */
class RelationshipToOrganizationData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RelationshipToOrganizationData.attributeTypeMap;
    }
}
exports.RelationshipToOrganizationData = RelationshipToOrganizationData;
/**
 * @ignore
 */
RelationshipToOrganizationData.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "OrganizationsType",
        required: true,
    },
};
//# sourceMappingURL=RelationshipToOrganizationData.js.map

/***/ }),

/***/ 16352:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelationshipToOrganizations = void 0;
/**
 * Relationship to organizations.
 */
class RelationshipToOrganizations {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RelationshipToOrganizations.attributeTypeMap;
    }
}
exports.RelationshipToOrganizations = RelationshipToOrganizations;
/**
 * @ignore
 */
RelationshipToOrganizations.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<RelationshipToOrganizationData>",
        required: true,
    },
};
//# sourceMappingURL=RelationshipToOrganizations.js.map

/***/ }),

/***/ 91286:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelationshipToPermission = void 0;
/**
 * Relationship to a permissions object.
 */
class RelationshipToPermission {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RelationshipToPermission.attributeTypeMap;
    }
}
exports.RelationshipToPermission = RelationshipToPermission;
/**
 * @ignore
 */
RelationshipToPermission.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "RelationshipToPermissionData",
    },
};
//# sourceMappingURL=RelationshipToPermission.js.map

/***/ }),

/***/ 84713:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelationshipToPermissionData = void 0;
/**
 * Relationship to permission object.
 */
class RelationshipToPermissionData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RelationshipToPermissionData.attributeTypeMap;
    }
}
exports.RelationshipToPermissionData = RelationshipToPermissionData;
/**
 * @ignore
 */
RelationshipToPermissionData.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "PermissionsType",
    },
};
//# sourceMappingURL=RelationshipToPermissionData.js.map

/***/ }),

/***/ 50913:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelationshipToPermissions = void 0;
/**
 * Relationship to multiple permissions objects.
 */
class RelationshipToPermissions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RelationshipToPermissions.attributeTypeMap;
    }
}
exports.RelationshipToPermissions = RelationshipToPermissions;
/**
 * @ignore
 */
RelationshipToPermissions.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<RelationshipToPermissionData>",
    },
};
//# sourceMappingURL=RelationshipToPermissions.js.map

/***/ }),

/***/ 38615:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelationshipToRole = void 0;
/**
 * Relationship to role.
 */
class RelationshipToRole {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RelationshipToRole.attributeTypeMap;
    }
}
exports.RelationshipToRole = RelationshipToRole;
/**
 * @ignore
 */
RelationshipToRole.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "RelationshipToRoleData",
    },
};
//# sourceMappingURL=RelationshipToRole.js.map

/***/ }),

/***/ 30312:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelationshipToRoleData = void 0;
/**
 * Relationship to role object.
 */
class RelationshipToRoleData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RelationshipToRoleData.attributeTypeMap;
    }
}
exports.RelationshipToRoleData = RelationshipToRoleData;
/**
 * @ignore
 */
RelationshipToRoleData.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "RolesType",
    },
};
//# sourceMappingURL=RelationshipToRoleData.js.map

/***/ }),

/***/ 62595:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelationshipToRoles = void 0;
/**
 * Relationship to roles.
 */
class RelationshipToRoles {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RelationshipToRoles.attributeTypeMap;
    }
}
exports.RelationshipToRoles = RelationshipToRoles;
/**
 * @ignore
 */
RelationshipToRoles.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<RelationshipToRoleData>",
    },
};
//# sourceMappingURL=RelationshipToRoles.js.map

/***/ }),

/***/ 62436:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelationshipToSAMLAssertionAttribute = void 0;
/**
 * AuthN Mapping relationship to SAML Assertion Attribute.
 */
class RelationshipToSAMLAssertionAttribute {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RelationshipToSAMLAssertionAttribute.attributeTypeMap;
    }
}
exports.RelationshipToSAMLAssertionAttribute = RelationshipToSAMLAssertionAttribute;
/**
 * @ignore
 */
RelationshipToSAMLAssertionAttribute.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "RelationshipToSAMLAssertionAttributeData",
        required: true,
    },
};
//# sourceMappingURL=RelationshipToSAMLAssertionAttribute.js.map

/***/ }),

/***/ 93258:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelationshipToSAMLAssertionAttributeData = void 0;
/**
 * Data of AuthN Mapping relationship to SAML Assertion Attribute.
 */
class RelationshipToSAMLAssertionAttributeData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RelationshipToSAMLAssertionAttributeData.attributeTypeMap;
    }
}
exports.RelationshipToSAMLAssertionAttributeData = RelationshipToSAMLAssertionAttributeData;
/**
 * @ignore
 */
RelationshipToSAMLAssertionAttributeData.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "SAMLAssertionAttributesType",
        required: true,
    },
};
//# sourceMappingURL=RelationshipToSAMLAssertionAttributeData.js.map

/***/ }),

/***/ 93801:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelationshipToUser = void 0;
/**
 * Relationship to user.
 */
class RelationshipToUser {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RelationshipToUser.attributeTypeMap;
    }
}
exports.RelationshipToUser = RelationshipToUser;
/**
 * @ignore
 */
RelationshipToUser.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "RelationshipToUserData",
        required: true,
    },
};
//# sourceMappingURL=RelationshipToUser.js.map

/***/ }),

/***/ 16328:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelationshipToUserData = void 0;
/**
 * Relationship to user object.
 */
class RelationshipToUserData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RelationshipToUserData.attributeTypeMap;
    }
}
exports.RelationshipToUserData = RelationshipToUserData;
/**
 * @ignore
 */
RelationshipToUserData.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "UsersType",
        required: true,
    },
};
//# sourceMappingURL=RelationshipToUserData.js.map

/***/ }),

/***/ 51783:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelationshipToUsers = void 0;
/**
 * Relationship to users.
 */
class RelationshipToUsers {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RelationshipToUsers.attributeTypeMap;
    }
}
exports.RelationshipToUsers = RelationshipToUsers;
/**
 * @ignore
 */
RelationshipToUsers.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<RelationshipToUserData>",
        required: true,
    },
};
//# sourceMappingURL=RelationshipToUsers.js.map

/***/ }),

/***/ 14990:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ResponseMetaAttributes = void 0;
/**
 * Object describing meta attributes of response.
 */
class ResponseMetaAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ResponseMetaAttributes.attributeTypeMap;
    }
}
exports.ResponseMetaAttributes = ResponseMetaAttributes;
/**
 * @ignore
 */
ResponseMetaAttributes.attributeTypeMap = {
    page: {
        baseName: "page",
        type: "Pagination",
    },
};
//# sourceMappingURL=ResponseMetaAttributes.js.map

/***/ }),

/***/ 49248:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Role = void 0;
/**
 * Role object returned by the API.
 */
class Role {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return Role.attributeTypeMap;
    }
}
exports.Role = Role;
/**
 * @ignore
 */
Role.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "RoleAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    relationships: {
        baseName: "relationships",
        type: "RoleResponseRelationships",
    },
    type: {
        baseName: "type",
        type: "RolesType",
        required: true,
    },
};
//# sourceMappingURL=Role.js.map

/***/ }),

/***/ 82581:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoleAttributes = void 0;
/**
 * Attributes of the role.
 */
class RoleAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RoleAttributes.attributeTypeMap;
    }
}
exports.RoleAttributes = RoleAttributes;
/**
 * @ignore
 */
RoleAttributes.attributeTypeMap = {
    createdAt: {
        baseName: "created_at",
        type: "Date",
        format: "date-time",
    },
    modifiedAt: {
        baseName: "modified_at",
        type: "Date",
        format: "date-time",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    userCount: {
        baseName: "user_count",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=RoleAttributes.js.map

/***/ }),

/***/ 96579:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoleClone = void 0;
/**
 * Data for the clone role request.
 */
class RoleClone {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RoleClone.attributeTypeMap;
    }
}
exports.RoleClone = RoleClone;
/**
 * @ignore
 */
RoleClone.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "RoleCloneAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "RolesType",
        required: true,
    },
};
//# sourceMappingURL=RoleClone.js.map

/***/ }),

/***/ 34979:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoleCloneAttributes = void 0;
/**
 * Attributes required to create a new role by cloning an existing one.
 */
class RoleCloneAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RoleCloneAttributes.attributeTypeMap;
    }
}
exports.RoleCloneAttributes = RoleCloneAttributes;
/**
 * @ignore
 */
RoleCloneAttributes.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=RoleCloneAttributes.js.map

/***/ }),

/***/ 33124:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoleCloneRequest = void 0;
/**
 * Request to create a role by cloning an existing role.
 */
class RoleCloneRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RoleCloneRequest.attributeTypeMap;
    }
}
exports.RoleCloneRequest = RoleCloneRequest;
/**
 * @ignore
 */
RoleCloneRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "RoleClone",
        required: true,
    },
};
//# sourceMappingURL=RoleCloneRequest.js.map

/***/ }),

/***/ 65979:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoleCreateAttributes = void 0;
/**
 * Attributes of the created role.
 */
class RoleCreateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RoleCreateAttributes.attributeTypeMap;
    }
}
exports.RoleCreateAttributes = RoleCreateAttributes;
/**
 * @ignore
 */
RoleCreateAttributes.attributeTypeMap = {
    createdAt: {
        baseName: "created_at",
        type: "Date",
        format: "date-time",
    },
    modifiedAt: {
        baseName: "modified_at",
        type: "Date",
        format: "date-time",
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=RoleCreateAttributes.js.map

/***/ }),

/***/ 67319:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoleCreateData = void 0;
/**
 * Data related to the creation of a role.
 */
class RoleCreateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RoleCreateData.attributeTypeMap;
    }
}
exports.RoleCreateData = RoleCreateData;
/**
 * @ignore
 */
RoleCreateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "RoleCreateAttributes",
        required: true,
    },
    relationships: {
        baseName: "relationships",
        type: "RoleRelationships",
    },
    type: {
        baseName: "type",
        type: "RolesType",
    },
};
//# sourceMappingURL=RoleCreateData.js.map

/***/ }),

/***/ 95305:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoleCreateRequest = void 0;
/**
 * Create a role.
 */
class RoleCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RoleCreateRequest.attributeTypeMap;
    }
}
exports.RoleCreateRequest = RoleCreateRequest;
/**
 * @ignore
 */
RoleCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "RoleCreateData",
        required: true,
    },
};
//# sourceMappingURL=RoleCreateRequest.js.map

/***/ }),

/***/ 87293:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoleCreateResponse = void 0;
/**
 * Response containing information about a created role.
 */
class RoleCreateResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RoleCreateResponse.attributeTypeMap;
    }
}
exports.RoleCreateResponse = RoleCreateResponse;
/**
 * @ignore
 */
RoleCreateResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "RoleCreateResponseData",
    },
};
//# sourceMappingURL=RoleCreateResponse.js.map

/***/ }),

/***/ 72479:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoleCreateResponseData = void 0;
/**
 * Role object returned by the API.
 */
class RoleCreateResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RoleCreateResponseData.attributeTypeMap;
    }
}
exports.RoleCreateResponseData = RoleCreateResponseData;
/**
 * @ignore
 */
RoleCreateResponseData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "RoleCreateAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    relationships: {
        baseName: "relationships",
        type: "RoleResponseRelationships",
    },
    type: {
        baseName: "type",
        type: "RolesType",
        required: true,
    },
};
//# sourceMappingURL=RoleCreateResponseData.js.map

/***/ }),

/***/ 71594:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoleRelationships = void 0;
/**
 * Relationships of the role object.
 */
class RoleRelationships {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RoleRelationships.attributeTypeMap;
    }
}
exports.RoleRelationships = RoleRelationships;
/**
 * @ignore
 */
RoleRelationships.attributeTypeMap = {
    permissions: {
        baseName: "permissions",
        type: "RelationshipToPermissions",
    },
    users: {
        baseName: "users",
        type: "RelationshipToUsers",
    },
};
//# sourceMappingURL=RoleRelationships.js.map

/***/ }),

/***/ 2524:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoleResponse = void 0;
/**
 * Response containing information about a single role.
 */
class RoleResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RoleResponse.attributeTypeMap;
    }
}
exports.RoleResponse = RoleResponse;
/**
 * @ignore
 */
RoleResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Role",
    },
};
//# sourceMappingURL=RoleResponse.js.map

/***/ }),

/***/ 66950:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoleResponseRelationships = void 0;
/**
 * Relationships of the role object returned by the API.
 */
class RoleResponseRelationships {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RoleResponseRelationships.attributeTypeMap;
    }
}
exports.RoleResponseRelationships = RoleResponseRelationships;
/**
 * @ignore
 */
RoleResponseRelationships.attributeTypeMap = {
    permissions: {
        baseName: "permissions",
        type: "RelationshipToPermissions",
    },
};
//# sourceMappingURL=RoleResponseRelationships.js.map

/***/ }),

/***/ 84628:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoleUpdateAttributes = void 0;
/**
 * Attributes of the role.
 */
class RoleUpdateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RoleUpdateAttributes.attributeTypeMap;
    }
}
exports.RoleUpdateAttributes = RoleUpdateAttributes;
/**
 * @ignore
 */
RoleUpdateAttributes.attributeTypeMap = {
    createdAt: {
        baseName: "created_at",
        type: "Date",
        format: "date-time",
    },
    modifiedAt: {
        baseName: "modified_at",
        type: "Date",
        format: "date-time",
    },
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=RoleUpdateAttributes.js.map

/***/ }),

/***/ 77060:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoleUpdateData = void 0;
/**
 * Data related to the update of a role.
 */
class RoleUpdateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RoleUpdateData.attributeTypeMap;
    }
}
exports.RoleUpdateData = RoleUpdateData;
/**
 * @ignore
 */
RoleUpdateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "RoleUpdateAttributes",
        required: true,
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    relationships: {
        baseName: "relationships",
        type: "RoleRelationships",
    },
    type: {
        baseName: "type",
        type: "RolesType",
        required: true,
    },
};
//# sourceMappingURL=RoleUpdateData.js.map

/***/ }),

/***/ 63322:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoleUpdateRequest = void 0;
/**
 * Update a role.
 */
class RoleUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RoleUpdateRequest.attributeTypeMap;
    }
}
exports.RoleUpdateRequest = RoleUpdateRequest;
/**
 * @ignore
 */
RoleUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "RoleUpdateData",
        required: true,
    },
};
//# sourceMappingURL=RoleUpdateRequest.js.map

/***/ }),

/***/ 22307:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoleUpdateResponse = void 0;
/**
 * Response containing information about an updated role.
 */
class RoleUpdateResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RoleUpdateResponse.attributeTypeMap;
    }
}
exports.RoleUpdateResponse = RoleUpdateResponse;
/**
 * @ignore
 */
RoleUpdateResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "RoleUpdateResponseData",
    },
};
//# sourceMappingURL=RoleUpdateResponse.js.map

/***/ }),

/***/ 39190:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RoleUpdateResponseData = void 0;
/**
 * Role object returned by the API.
 */
class RoleUpdateResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RoleUpdateResponseData.attributeTypeMap;
    }
}
exports.RoleUpdateResponseData = RoleUpdateResponseData;
/**
 * @ignore
 */
RoleUpdateResponseData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "RoleUpdateAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    relationships: {
        baseName: "relationships",
        type: "RoleResponseRelationships",
    },
    type: {
        baseName: "type",
        type: "RolesType",
        required: true,
    },
};
//# sourceMappingURL=RoleUpdateResponseData.js.map

/***/ }),

/***/ 95334:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RolesResponse = void 0;
/**
 * Response containing information about multiple roles.
 */
class RolesResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return RolesResponse.attributeTypeMap;
    }
}
exports.RolesResponse = RolesResponse;
/**
 * @ignore
 */
RolesResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<Role>",
    },
    meta: {
        baseName: "meta",
        type: "ResponseMetaAttributes",
    },
};
//# sourceMappingURL=RolesResponse.js.map

/***/ }),

/***/ 98228:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SAMLAssertionAttribute = void 0;
/**
 * SAML assertion attribute.
 */
class SAMLAssertionAttribute {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SAMLAssertionAttribute.attributeTypeMap;
    }
}
exports.SAMLAssertionAttribute = SAMLAssertionAttribute;
/**
 * @ignore
 */
SAMLAssertionAttribute.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SAMLAssertionAttributeAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "SAMLAssertionAttributesType",
        required: true,
    },
};
//# sourceMappingURL=SAMLAssertionAttribute.js.map

/***/ }),

/***/ 73923:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SAMLAssertionAttributeAttributes = void 0;
/**
 * Key/Value pair of attributes used in SAML assertion attributes.
 */
class SAMLAssertionAttributeAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SAMLAssertionAttributeAttributes.attributeTypeMap;
    }
}
exports.SAMLAssertionAttributeAttributes = SAMLAssertionAttributeAttributes;
/**
 * @ignore
 */
SAMLAssertionAttributeAttributes.attributeTypeMap = {
    attributeKey: {
        baseName: "attribute_key",
        type: "string",
    },
    attributeValue: {
        baseName: "attribute_value",
        type: "string",
    },
};
//# sourceMappingURL=SAMLAssertionAttributeAttributes.js.map

/***/ }),

/***/ 31259:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScalarFormulaQueryRequest = void 0;
/**
 * A wrapper request around one scalar query to be executed.
 */
class ScalarFormulaQueryRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ScalarFormulaQueryRequest.attributeTypeMap;
    }
}
exports.ScalarFormulaQueryRequest = ScalarFormulaQueryRequest;
/**
 * @ignore
 */
ScalarFormulaQueryRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "ScalarFormulaRequest",
        required: true,
    },
};
//# sourceMappingURL=ScalarFormulaQueryRequest.js.map

/***/ }),

/***/ 3057:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScalarFormulaQueryResponse = void 0;
/**
 * A message containing one or more responses to scalar queries.
 */
class ScalarFormulaQueryResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ScalarFormulaQueryResponse.attributeTypeMap;
    }
}
exports.ScalarFormulaQueryResponse = ScalarFormulaQueryResponse;
/**
 * @ignore
 */
ScalarFormulaQueryResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "ScalarResponse",
    },
    errors: {
        baseName: "errors",
        type: "string",
    },
};
//# sourceMappingURL=ScalarFormulaQueryResponse.js.map

/***/ }),

/***/ 84643:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScalarFormulaRequest = void 0;
/**
 * A single scalar query to be executed.
 */
class ScalarFormulaRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ScalarFormulaRequest.attributeTypeMap;
    }
}
exports.ScalarFormulaRequest = ScalarFormulaRequest;
/**
 * @ignore
 */
ScalarFormulaRequest.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "ScalarFormulaRequestAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "ScalarFormulaRequestType",
        required: true,
    },
};
//# sourceMappingURL=ScalarFormulaRequest.js.map

/***/ }),

/***/ 27526:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScalarFormulaRequestAttributes = void 0;
/**
 * The object describing a scalar formula request.
 */
class ScalarFormulaRequestAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ScalarFormulaRequestAttributes.attributeTypeMap;
    }
}
exports.ScalarFormulaRequestAttributes = ScalarFormulaRequestAttributes;
/**
 * @ignore
 */
ScalarFormulaRequestAttributes.attributeTypeMap = {
    formulas: {
        baseName: "formulas",
        type: "Array<QueryFormula>",
    },
    from: {
        baseName: "from",
        type: "number",
        required: true,
        format: "int64",
    },
    queries: {
        baseName: "queries",
        type: "Array<ScalarQuery>",
        required: true,
    },
    to: {
        baseName: "to",
        type: "number",
        required: true,
        format: "int64",
    },
};
//# sourceMappingURL=ScalarFormulaRequestAttributes.js.map

/***/ }),

/***/ 60572:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScalarFormulaResponseAtrributes = void 0;
/**
 * The object describing a scalar response.
 */
class ScalarFormulaResponseAtrributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ScalarFormulaResponseAtrributes.attributeTypeMap;
    }
}
exports.ScalarFormulaResponseAtrributes = ScalarFormulaResponseAtrributes;
/**
 * @ignore
 */
ScalarFormulaResponseAtrributes.attributeTypeMap = {
    columns: {
        baseName: "columns",
        type: "Array<ScalarColumn>",
    },
};
//# sourceMappingURL=ScalarFormulaResponseAtrributes.js.map

/***/ }),

/***/ 1470:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScalarMeta = void 0;
/**
 * Metadata for the resulting numerical values.
 */
class ScalarMeta {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ScalarMeta.attributeTypeMap;
    }
}
exports.ScalarMeta = ScalarMeta;
/**
 * @ignore
 */
ScalarMeta.attributeTypeMap = {
    unit: {
        baseName: "unit",
        type: "Array<Unit>",
    },
};
//# sourceMappingURL=ScalarMeta.js.map

/***/ }),

/***/ 70331:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScalarResponse = void 0;
/**
 * A message containing the response to a scalar query.
 */
class ScalarResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ScalarResponse.attributeTypeMap;
    }
}
exports.ScalarResponse = ScalarResponse;
/**
 * @ignore
 */
ScalarResponse.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "ScalarFormulaResponseAtrributes",
    },
    type: {
        baseName: "type",
        type: "ScalarFormulaResponseType",
    },
};
//# sourceMappingURL=ScalarResponse.js.map

/***/ }),

/***/ 55447:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityFilter = void 0;
/**
 * The security filter's properties.
 */
class SecurityFilter {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityFilter.attributeTypeMap;
    }
}
exports.SecurityFilter = SecurityFilter;
/**
 * @ignore
 */
SecurityFilter.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SecurityFilterAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "SecurityFilterType",
    },
};
//# sourceMappingURL=SecurityFilter.js.map

/***/ }),

/***/ 98576:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityFilterAttributes = void 0;
/**
 * The object describing a security filter.
 */
class SecurityFilterAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityFilterAttributes.attributeTypeMap;
    }
}
exports.SecurityFilterAttributes = SecurityFilterAttributes;
/**
 * @ignore
 */
SecurityFilterAttributes.attributeTypeMap = {
    exclusionFilters: {
        baseName: "exclusion_filters",
        type: "Array<SecurityFilterExclusionFilterResponse>",
    },
    filteredDataType: {
        baseName: "filtered_data_type",
        type: "SecurityFilterFilteredDataType",
    },
    isBuiltin: {
        baseName: "is_builtin",
        type: "boolean",
    },
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    query: {
        baseName: "query",
        type: "string",
    },
    version: {
        baseName: "version",
        type: "number",
        format: "int32",
    },
};
//# sourceMappingURL=SecurityFilterAttributes.js.map

/***/ }),

/***/ 39164:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityFilterCreateAttributes = void 0;
/**
 * Object containing the attributes of the security filter to be created.
 */
class SecurityFilterCreateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityFilterCreateAttributes.attributeTypeMap;
    }
}
exports.SecurityFilterCreateAttributes = SecurityFilterCreateAttributes;
/**
 * @ignore
 */
SecurityFilterCreateAttributes.attributeTypeMap = {
    exclusionFilters: {
        baseName: "exclusion_filters",
        type: "Array<SecurityFilterExclusionFilter>",
        required: true,
    },
    filteredDataType: {
        baseName: "filtered_data_type",
        type: "SecurityFilterFilteredDataType",
        required: true,
    },
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    query: {
        baseName: "query",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=SecurityFilterCreateAttributes.js.map

/***/ }),

/***/ 73922:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityFilterCreateData = void 0;
/**
 * Object for a single security filter.
 */
class SecurityFilterCreateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityFilterCreateData.attributeTypeMap;
    }
}
exports.SecurityFilterCreateData = SecurityFilterCreateData;
/**
 * @ignore
 */
SecurityFilterCreateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SecurityFilterCreateAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "SecurityFilterType",
        required: true,
    },
};
//# sourceMappingURL=SecurityFilterCreateData.js.map

/***/ }),

/***/ 80376:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityFilterCreateRequest = void 0;
/**
 * Request object that includes the security filter that you would like to create.
 */
class SecurityFilterCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityFilterCreateRequest.attributeTypeMap;
    }
}
exports.SecurityFilterCreateRequest = SecurityFilterCreateRequest;
/**
 * @ignore
 */
SecurityFilterCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SecurityFilterCreateData",
        required: true,
    },
};
//# sourceMappingURL=SecurityFilterCreateRequest.js.map

/***/ }),

/***/ 70566:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityFilterExclusionFilter = void 0;
/**
 * Exclusion filter for the security filter.
 */
class SecurityFilterExclusionFilter {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityFilterExclusionFilter.attributeTypeMap;
    }
}
exports.SecurityFilterExclusionFilter = SecurityFilterExclusionFilter;
/**
 * @ignore
 */
SecurityFilterExclusionFilter.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    query: {
        baseName: "query",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=SecurityFilterExclusionFilter.js.map

/***/ }),

/***/ 33320:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityFilterExclusionFilterResponse = void 0;
/**
 * A single exclusion filter.
 */
class SecurityFilterExclusionFilterResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityFilterExclusionFilterResponse.attributeTypeMap;
    }
}
exports.SecurityFilterExclusionFilterResponse = SecurityFilterExclusionFilterResponse;
/**
 * @ignore
 */
SecurityFilterExclusionFilterResponse.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
    },
    query: {
        baseName: "query",
        type: "string",
    },
};
//# sourceMappingURL=SecurityFilterExclusionFilterResponse.js.map

/***/ }),

/***/ 27674:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityFilterMeta = void 0;
/**
 * Optional metadata associated to the response.
 */
class SecurityFilterMeta {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityFilterMeta.attributeTypeMap;
    }
}
exports.SecurityFilterMeta = SecurityFilterMeta;
/**
 * @ignore
 */
SecurityFilterMeta.attributeTypeMap = {
    warning: {
        baseName: "warning",
        type: "string",
    },
};
//# sourceMappingURL=SecurityFilterMeta.js.map

/***/ }),

/***/ 53785:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityFilterResponse = void 0;
/**
 * Response object which includes a single security filter.
 */
class SecurityFilterResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityFilterResponse.attributeTypeMap;
    }
}
exports.SecurityFilterResponse = SecurityFilterResponse;
/**
 * @ignore
 */
SecurityFilterResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SecurityFilter",
    },
    meta: {
        baseName: "meta",
        type: "SecurityFilterMeta",
    },
};
//# sourceMappingURL=SecurityFilterResponse.js.map

/***/ }),

/***/ 70723:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityFilterUpdateAttributes = void 0;
/**
 * The security filters properties to be updated.
 */
class SecurityFilterUpdateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityFilterUpdateAttributes.attributeTypeMap;
    }
}
exports.SecurityFilterUpdateAttributes = SecurityFilterUpdateAttributes;
/**
 * @ignore
 */
SecurityFilterUpdateAttributes.attributeTypeMap = {
    exclusionFilters: {
        baseName: "exclusion_filters",
        type: "Array<SecurityFilterExclusionFilter>",
    },
    filteredDataType: {
        baseName: "filtered_data_type",
        type: "SecurityFilterFilteredDataType",
    },
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    query: {
        baseName: "query",
        type: "string",
    },
    version: {
        baseName: "version",
        type: "number",
        format: "int32",
    },
};
//# sourceMappingURL=SecurityFilterUpdateAttributes.js.map

/***/ }),

/***/ 64889:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityFilterUpdateData = void 0;
/**
 * The new security filter properties.
 */
class SecurityFilterUpdateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityFilterUpdateData.attributeTypeMap;
    }
}
exports.SecurityFilterUpdateData = SecurityFilterUpdateData;
/**
 * @ignore
 */
SecurityFilterUpdateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SecurityFilterUpdateAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "SecurityFilterType",
        required: true,
    },
};
//# sourceMappingURL=SecurityFilterUpdateData.js.map

/***/ }),

/***/ 67365:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityFilterUpdateRequest = void 0;
/**
 * The new security filter body.
 */
class SecurityFilterUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityFilterUpdateRequest.attributeTypeMap;
    }
}
exports.SecurityFilterUpdateRequest = SecurityFilterUpdateRequest;
/**
 * @ignore
 */
SecurityFilterUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SecurityFilterUpdateData",
        required: true,
    },
};
//# sourceMappingURL=SecurityFilterUpdateRequest.js.map

/***/ }),

/***/ 92892:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityFiltersResponse = void 0;
/**
 * All the available security filters objects.
 */
class SecurityFiltersResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityFiltersResponse.attributeTypeMap;
    }
}
exports.SecurityFiltersResponse = SecurityFiltersResponse;
/**
 * @ignore
 */
SecurityFiltersResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<SecurityFilter>",
    },
    meta: {
        baseName: "meta",
        type: "SecurityFilterMeta",
    },
};
//# sourceMappingURL=SecurityFiltersResponse.js.map

/***/ }),

/***/ 24483:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringFilter = void 0;
/**
 * The rule's suppression filter.
 */
class SecurityMonitoringFilter {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringFilter.attributeTypeMap;
    }
}
exports.SecurityMonitoringFilter = SecurityMonitoringFilter;
/**
 * @ignore
 */
SecurityMonitoringFilter.attributeTypeMap = {
    action: {
        baseName: "action",
        type: "SecurityMonitoringFilterAction",
    },
    query: {
        baseName: "query",
        type: "string",
    },
};
//# sourceMappingURL=SecurityMonitoringFilter.js.map

/***/ }),

/***/ 73982:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringListRulesResponse = void 0;
/**
 * List of rules.
 */
class SecurityMonitoringListRulesResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringListRulesResponse.attributeTypeMap;
    }
}
exports.SecurityMonitoringListRulesResponse = SecurityMonitoringListRulesResponse;
/**
 * @ignore
 */
SecurityMonitoringListRulesResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<SecurityMonitoringRuleResponse>",
    },
    meta: {
        baseName: "meta",
        type: "ResponseMetaAttributes",
    },
};
//# sourceMappingURL=SecurityMonitoringListRulesResponse.js.map

/***/ }),

/***/ 38467:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringRuleCase = void 0;
/**
 * Case when signal is generated.
 */
class SecurityMonitoringRuleCase {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringRuleCase.attributeTypeMap;
    }
}
exports.SecurityMonitoringRuleCase = SecurityMonitoringRuleCase;
/**
 * @ignore
 */
SecurityMonitoringRuleCase.attributeTypeMap = {
    condition: {
        baseName: "condition",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    notifications: {
        baseName: "notifications",
        type: "Array<string>",
    },
    status: {
        baseName: "status",
        type: "SecurityMonitoringRuleSeverity",
    },
};
//# sourceMappingURL=SecurityMonitoringRuleCase.js.map

/***/ }),

/***/ 50909:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringRuleCaseCreate = void 0;
/**
 * Case when signal is generated.
 */
class SecurityMonitoringRuleCaseCreate {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringRuleCaseCreate.attributeTypeMap;
    }
}
exports.SecurityMonitoringRuleCaseCreate = SecurityMonitoringRuleCaseCreate;
/**
 * @ignore
 */
SecurityMonitoringRuleCaseCreate.attributeTypeMap = {
    condition: {
        baseName: "condition",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    notifications: {
        baseName: "notifications",
        type: "Array<string>",
    },
    status: {
        baseName: "status",
        type: "SecurityMonitoringRuleSeverity",
        required: true,
    },
};
//# sourceMappingURL=SecurityMonitoringRuleCaseCreate.js.map

/***/ }),

/***/ 25690:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringRuleImpossibleTravelOptions = void 0;
/**
 * Options on impossible travel rules.
 */
class SecurityMonitoringRuleImpossibleTravelOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringRuleImpossibleTravelOptions.attributeTypeMap;
    }
}
exports.SecurityMonitoringRuleImpossibleTravelOptions = SecurityMonitoringRuleImpossibleTravelOptions;
/**
 * @ignore
 */
SecurityMonitoringRuleImpossibleTravelOptions.attributeTypeMap = {
    baselineUserLocations: {
        baseName: "baselineUserLocations",
        type: "boolean",
    },
};
//# sourceMappingURL=SecurityMonitoringRuleImpossibleTravelOptions.js.map

/***/ }),

/***/ 10646:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringRuleNewValueOptions = void 0;
/**
 * Options on new value rules.
 */
class SecurityMonitoringRuleNewValueOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringRuleNewValueOptions.attributeTypeMap;
    }
}
exports.SecurityMonitoringRuleNewValueOptions = SecurityMonitoringRuleNewValueOptions;
/**
 * @ignore
 */
SecurityMonitoringRuleNewValueOptions.attributeTypeMap = {
    forgetAfter: {
        baseName: "forgetAfter",
        type: "SecurityMonitoringRuleNewValueOptionsForgetAfter",
        format: "int32",
    },
    learningDuration: {
        baseName: "learningDuration",
        type: "SecurityMonitoringRuleNewValueOptionsLearningDuration",
        format: "int32",
    },
    learningMethod: {
        baseName: "learningMethod",
        type: "SecurityMonitoringRuleNewValueOptionsLearningMethod",
    },
    learningThreshold: {
        baseName: "learningThreshold",
        type: "SecurityMonitoringRuleNewValueOptionsLearningThreshold",
        format: "int32",
    },
};
//# sourceMappingURL=SecurityMonitoringRuleNewValueOptions.js.map

/***/ }),

/***/ 41277:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringRuleOptions = void 0;
/**
 * Options on rules.
 */
class SecurityMonitoringRuleOptions {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringRuleOptions.attributeTypeMap;
    }
}
exports.SecurityMonitoringRuleOptions = SecurityMonitoringRuleOptions;
/**
 * @ignore
 */
SecurityMonitoringRuleOptions.attributeTypeMap = {
    complianceRuleOptions: {
        baseName: "complianceRuleOptions",
        type: "CloudConfigurationComplianceRuleOptions",
    },
    decreaseCriticalityBasedOnEnv: {
        baseName: "decreaseCriticalityBasedOnEnv",
        type: "boolean",
    },
    detectionMethod: {
        baseName: "detectionMethod",
        type: "SecurityMonitoringRuleDetectionMethod",
    },
    evaluationWindow: {
        baseName: "evaluationWindow",
        type: "SecurityMonitoringRuleEvaluationWindow",
        format: "int32",
    },
    hardcodedEvaluatorType: {
        baseName: "hardcodedEvaluatorType",
        type: "SecurityMonitoringRuleHardcodedEvaluatorType",
    },
    impossibleTravelOptions: {
        baseName: "impossibleTravelOptions",
        type: "SecurityMonitoringRuleImpossibleTravelOptions",
    },
    keepAlive: {
        baseName: "keepAlive",
        type: "SecurityMonitoringRuleKeepAlive",
        format: "int32",
    },
    maxSignalDuration: {
        baseName: "maxSignalDuration",
        type: "SecurityMonitoringRuleMaxSignalDuration",
        format: "int32",
    },
    newValueOptions: {
        baseName: "newValueOptions",
        type: "SecurityMonitoringRuleNewValueOptions",
    },
};
//# sourceMappingURL=SecurityMonitoringRuleOptions.js.map

/***/ }),

/***/ 21004:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringRuleUpdatePayload = void 0;
/**
 * Update an existing rule.
 */
class SecurityMonitoringRuleUpdatePayload {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringRuleUpdatePayload.attributeTypeMap;
    }
}
exports.SecurityMonitoringRuleUpdatePayload = SecurityMonitoringRuleUpdatePayload;
/**
 * @ignore
 */
SecurityMonitoringRuleUpdatePayload.attributeTypeMap = {
    cases: {
        baseName: "cases",
        type: "Array<SecurityMonitoringRuleCase>",
    },
    complianceSignalOptions: {
        baseName: "complianceSignalOptions",
        type: "CloudConfigurationRuleComplianceSignalOptions",
    },
    filters: {
        baseName: "filters",
        type: "Array<SecurityMonitoringFilter>",
    },
    hasExtendedTitle: {
        baseName: "hasExtendedTitle",
        type: "boolean",
    },
    isEnabled: {
        baseName: "isEnabled",
        type: "boolean",
    },
    message: {
        baseName: "message",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    options: {
        baseName: "options",
        type: "SecurityMonitoringRuleOptions",
    },
    queries: {
        baseName: "queries",
        type: "Array<SecurityMonitoringRuleQuery>",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    version: {
        baseName: "version",
        type: "number",
        format: "int32",
    },
};
//# sourceMappingURL=SecurityMonitoringRuleUpdatePayload.js.map

/***/ }),

/***/ 73354:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignal = void 0;
/**
 * Object description of a security signal.
 */
class SecurityMonitoringSignal {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignal.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignal = SecurityMonitoringSignal;
/**
 * @ignore
 */
SecurityMonitoringSignal.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SecurityMonitoringSignalAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "SecurityMonitoringSignalType",
    },
};
//# sourceMappingURL=SecurityMonitoringSignal.js.map

/***/ }),

/***/ 14090:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalAssigneeUpdateAttributes = void 0;
/**
 * Attributes describing the new assignee of a security signal.
 */
class SecurityMonitoringSignalAssigneeUpdateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalAssigneeUpdateAttributes.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalAssigneeUpdateAttributes = SecurityMonitoringSignalAssigneeUpdateAttributes;
/**
 * @ignore
 */
SecurityMonitoringSignalAssigneeUpdateAttributes.attributeTypeMap = {
    assignee: {
        baseName: "assignee",
        type: "SecurityMonitoringTriageUser",
        required: true,
    },
    version: {
        baseName: "version",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=SecurityMonitoringSignalAssigneeUpdateAttributes.js.map

/***/ }),

/***/ 12839:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalAssigneeUpdateData = void 0;
/**
 * Data containing the patch for changing the assignee of a signal.
 */
class SecurityMonitoringSignalAssigneeUpdateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalAssigneeUpdateData.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalAssigneeUpdateData = SecurityMonitoringSignalAssigneeUpdateData;
/**
 * @ignore
 */
SecurityMonitoringSignalAssigneeUpdateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SecurityMonitoringSignalAssigneeUpdateAttributes",
        required: true,
    },
};
//# sourceMappingURL=SecurityMonitoringSignalAssigneeUpdateData.js.map

/***/ }),

/***/ 65035:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalAssigneeUpdateRequest = void 0;
/**
 * Request body for changing the assignee of a given security monitoring signal.
 */
class SecurityMonitoringSignalAssigneeUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalAssigneeUpdateRequest.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalAssigneeUpdateRequest = SecurityMonitoringSignalAssigneeUpdateRequest;
/**
 * @ignore
 */
SecurityMonitoringSignalAssigneeUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SecurityMonitoringSignalAssigneeUpdateData",
        required: true,
    },
};
//# sourceMappingURL=SecurityMonitoringSignalAssigneeUpdateRequest.js.map

/***/ }),

/***/ 81335:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalAttributes = void 0;
/**
 * The object containing all signal attributes and their
 * associated values.
 */
class SecurityMonitoringSignalAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalAttributes.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalAttributes = SecurityMonitoringSignalAttributes;
/**
 * @ignore
 */
SecurityMonitoringSignalAttributes.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "{ [key: string]: any; }",
    },
    message: {
        baseName: "message",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    timestamp: {
        baseName: "timestamp",
        type: "Date",
        format: "date-time",
    },
};
//# sourceMappingURL=SecurityMonitoringSignalAttributes.js.map

/***/ }),

/***/ 54429:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalIncidentsUpdateAttributes = void 0;
/**
 * Attributes describing the new list of related signals for a security signal.
 */
class SecurityMonitoringSignalIncidentsUpdateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalIncidentsUpdateAttributes.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalIncidentsUpdateAttributes = SecurityMonitoringSignalIncidentsUpdateAttributes;
/**
 * @ignore
 */
SecurityMonitoringSignalIncidentsUpdateAttributes.attributeTypeMap = {
    incidentIds: {
        baseName: "incident_ids",
        type: "Array<number>",
        required: true,
        format: "int64",
    },
    version: {
        baseName: "version",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=SecurityMonitoringSignalIncidentsUpdateAttributes.js.map

/***/ }),

/***/ 94861:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalIncidentsUpdateData = void 0;
/**
 * Data containing the patch for changing the related incidents of a signal.
 */
class SecurityMonitoringSignalIncidentsUpdateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalIncidentsUpdateData.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalIncidentsUpdateData = SecurityMonitoringSignalIncidentsUpdateData;
/**
 * @ignore
 */
SecurityMonitoringSignalIncidentsUpdateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SecurityMonitoringSignalIncidentsUpdateAttributes",
        required: true,
    },
};
//# sourceMappingURL=SecurityMonitoringSignalIncidentsUpdateData.js.map

/***/ }),

/***/ 54497:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalIncidentsUpdateRequest = void 0;
/**
 * Request body for changing the related incidents of a given security monitoring signal.
 */
class SecurityMonitoringSignalIncidentsUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalIncidentsUpdateRequest.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalIncidentsUpdateRequest = SecurityMonitoringSignalIncidentsUpdateRequest;
/**
 * @ignore
 */
SecurityMonitoringSignalIncidentsUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SecurityMonitoringSignalIncidentsUpdateData",
        required: true,
    },
};
//# sourceMappingURL=SecurityMonitoringSignalIncidentsUpdateRequest.js.map

/***/ }),

/***/ 13723:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalListRequest = void 0;
/**
 * The request for a security signal list.
 */
class SecurityMonitoringSignalListRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalListRequest.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalListRequest = SecurityMonitoringSignalListRequest;
/**
 * @ignore
 */
SecurityMonitoringSignalListRequest.attributeTypeMap = {
    filter: {
        baseName: "filter",
        type: "SecurityMonitoringSignalListRequestFilter",
    },
    page: {
        baseName: "page",
        type: "SecurityMonitoringSignalListRequestPage",
    },
    sort: {
        baseName: "sort",
        type: "SecurityMonitoringSignalsSort",
    },
};
//# sourceMappingURL=SecurityMonitoringSignalListRequest.js.map

/***/ }),

/***/ 75078:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalListRequestFilter = void 0;
/**
 * Search filters for listing security signals.
 */
class SecurityMonitoringSignalListRequestFilter {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalListRequestFilter.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalListRequestFilter = SecurityMonitoringSignalListRequestFilter;
/**
 * @ignore
 */
SecurityMonitoringSignalListRequestFilter.attributeTypeMap = {
    from: {
        baseName: "from",
        type: "Date",
        format: "date-time",
    },
    query: {
        baseName: "query",
        type: "string",
    },
    to: {
        baseName: "to",
        type: "Date",
        format: "date-time",
    },
};
//# sourceMappingURL=SecurityMonitoringSignalListRequestFilter.js.map

/***/ }),

/***/ 31123:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalListRequestPage = void 0;
/**
 * The paging attributes for listing security signals.
 */
class SecurityMonitoringSignalListRequestPage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalListRequestPage.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalListRequestPage = SecurityMonitoringSignalListRequestPage;
/**
 * @ignore
 */
SecurityMonitoringSignalListRequestPage.attributeTypeMap = {
    cursor: {
        baseName: "cursor",
        type: "string",
    },
    limit: {
        baseName: "limit",
        type: "number",
        format: "int32",
    },
};
//# sourceMappingURL=SecurityMonitoringSignalListRequestPage.js.map

/***/ }),

/***/ 81883:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalRuleCreatePayload = void 0;
/**
 * Create a new signal correlation rule.
 */
class SecurityMonitoringSignalRuleCreatePayload {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalRuleCreatePayload.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalRuleCreatePayload = SecurityMonitoringSignalRuleCreatePayload;
/**
 * @ignore
 */
SecurityMonitoringSignalRuleCreatePayload.attributeTypeMap = {
    cases: {
        baseName: "cases",
        type: "Array<SecurityMonitoringRuleCaseCreate>",
        required: true,
    },
    filters: {
        baseName: "filters",
        type: "Array<SecurityMonitoringFilter>",
    },
    hasExtendedTitle: {
        baseName: "hasExtendedTitle",
        type: "boolean",
    },
    isEnabled: {
        baseName: "isEnabled",
        type: "boolean",
        required: true,
    },
    message: {
        baseName: "message",
        type: "string",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    options: {
        baseName: "options",
        type: "SecurityMonitoringRuleOptions",
        required: true,
    },
    queries: {
        baseName: "queries",
        type: "Array<SecurityMonitoringSignalRuleQuery>",
        required: true,
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    type: {
        baseName: "type",
        type: "SecurityMonitoringSignalRuleType",
    },
};
//# sourceMappingURL=SecurityMonitoringSignalRuleCreatePayload.js.map

/***/ }),

/***/ 93930:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalRuleQuery = void 0;
/**
 * Query for matching rule on signals.
 */
class SecurityMonitoringSignalRuleQuery {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalRuleQuery.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalRuleQuery = SecurityMonitoringSignalRuleQuery;
/**
 * @ignore
 */
SecurityMonitoringSignalRuleQuery.attributeTypeMap = {
    aggregation: {
        baseName: "aggregation",
        type: "SecurityMonitoringRuleQueryAggregation",
    },
    correlatedByFields: {
        baseName: "correlatedByFields",
        type: "Array<string>",
    },
    correlatedQueryIndex: {
        baseName: "correlatedQueryIndex",
        type: "number",
        format: "int32",
    },
    metrics: {
        baseName: "metrics",
        type: "Array<string>",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    ruleId: {
        baseName: "ruleId",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=SecurityMonitoringSignalRuleQuery.js.map

/***/ }),

/***/ 2788:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalRuleResponse = void 0;
/**
 * Rule.
 */
class SecurityMonitoringSignalRuleResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalRuleResponse.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalRuleResponse = SecurityMonitoringSignalRuleResponse;
/**
 * @ignore
 */
SecurityMonitoringSignalRuleResponse.attributeTypeMap = {
    cases: {
        baseName: "cases",
        type: "Array<SecurityMonitoringRuleCase>",
    },
    createdAt: {
        baseName: "createdAt",
        type: "number",
        format: "int64",
    },
    creationAuthorId: {
        baseName: "creationAuthorId",
        type: "number",
        format: "int64",
    },
    deprecationDate: {
        baseName: "deprecationDate",
        type: "number",
        format: "int64",
    },
    filters: {
        baseName: "filters",
        type: "Array<SecurityMonitoringFilter>",
    },
    hasExtendedTitle: {
        baseName: "hasExtendedTitle",
        type: "boolean",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    isDefault: {
        baseName: "isDefault",
        type: "boolean",
    },
    isDeleted: {
        baseName: "isDeleted",
        type: "boolean",
    },
    isEnabled: {
        baseName: "isEnabled",
        type: "boolean",
    },
    message: {
        baseName: "message",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    options: {
        baseName: "options",
        type: "SecurityMonitoringRuleOptions",
    },
    queries: {
        baseName: "queries",
        type: "Array<SecurityMonitoringSignalRuleResponseQuery>",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    type: {
        baseName: "type",
        type: "SecurityMonitoringSignalRuleType",
    },
    updateAuthorId: {
        baseName: "updateAuthorId",
        type: "number",
        format: "int64",
    },
    version: {
        baseName: "version",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=SecurityMonitoringSignalRuleResponse.js.map

/***/ }),

/***/ 87097:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalRuleResponseQuery = void 0;
/**
 * Query for matching rule on signals.
 */
class SecurityMonitoringSignalRuleResponseQuery {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalRuleResponseQuery.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalRuleResponseQuery = SecurityMonitoringSignalRuleResponseQuery;
/**
 * @ignore
 */
SecurityMonitoringSignalRuleResponseQuery.attributeTypeMap = {
    aggregation: {
        baseName: "aggregation",
        type: "SecurityMonitoringRuleQueryAggregation",
    },
    correlatedByFields: {
        baseName: "correlatedByFields",
        type: "Array<string>",
    },
    correlatedQueryIndex: {
        baseName: "correlatedQueryIndex",
        type: "number",
        format: "int32",
    },
    defaultRuleId: {
        baseName: "defaultRuleId",
        type: "string",
    },
    metrics: {
        baseName: "metrics",
        type: "Array<string>",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    ruleId: {
        baseName: "ruleId",
        type: "string",
    },
};
//# sourceMappingURL=SecurityMonitoringSignalRuleResponseQuery.js.map

/***/ }),

/***/ 15491:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalStateUpdateAttributes = void 0;
/**
 * Attributes describing the change of state of a security signal.
 */
class SecurityMonitoringSignalStateUpdateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalStateUpdateAttributes.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalStateUpdateAttributes = SecurityMonitoringSignalStateUpdateAttributes;
/**
 * @ignore
 */
SecurityMonitoringSignalStateUpdateAttributes.attributeTypeMap = {
    archiveComment: {
        baseName: "archive_comment",
        type: "string",
    },
    archiveReason: {
        baseName: "archive_reason",
        type: "SecurityMonitoringSignalArchiveReason",
    },
    state: {
        baseName: "state",
        type: "SecurityMonitoringSignalState",
        required: true,
    },
    version: {
        baseName: "version",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=SecurityMonitoringSignalStateUpdateAttributes.js.map

/***/ }),

/***/ 48336:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalStateUpdateData = void 0;
/**
 * Data containing the patch for changing the state of a signal.
 */
class SecurityMonitoringSignalStateUpdateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalStateUpdateData.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalStateUpdateData = SecurityMonitoringSignalStateUpdateData;
/**
 * @ignore
 */
SecurityMonitoringSignalStateUpdateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SecurityMonitoringSignalStateUpdateAttributes",
        required: true,
    },
};
//# sourceMappingURL=SecurityMonitoringSignalStateUpdateData.js.map

/***/ }),

/***/ 42649:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalStateUpdateRequest = void 0;
/**
 * Request body for changing the state of a given security monitoring signal.
 */
class SecurityMonitoringSignalStateUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalStateUpdateRequest.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalStateUpdateRequest = SecurityMonitoringSignalStateUpdateRequest;
/**
 * @ignore
 */
SecurityMonitoringSignalStateUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SecurityMonitoringSignalStateUpdateData",
        required: true,
    },
};
//# sourceMappingURL=SecurityMonitoringSignalStateUpdateRequest.js.map

/***/ }),

/***/ 38673:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalTriageAttributes = void 0;
/**
 * Attributes describing a triage state update operation over a security signal.
 */
class SecurityMonitoringSignalTriageAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalTriageAttributes.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalTriageAttributes = SecurityMonitoringSignalTriageAttributes;
/**
 * @ignore
 */
SecurityMonitoringSignalTriageAttributes.attributeTypeMap = {
    archiveComment: {
        baseName: "archive_comment",
        type: "string",
    },
    archiveCommentTimestamp: {
        baseName: "archive_comment_timestamp",
        type: "number",
        format: "int64",
    },
    archiveCommentUser: {
        baseName: "archive_comment_user",
        type: "SecurityMonitoringTriageUser",
    },
    archiveReason: {
        baseName: "archive_reason",
        type: "SecurityMonitoringSignalArchiveReason",
    },
    assignee: {
        baseName: "assignee",
        type: "SecurityMonitoringTriageUser",
        required: true,
    },
    incidentIds: {
        baseName: "incident_ids",
        type: "Array<number>",
        required: true,
        format: "int64",
    },
    state: {
        baseName: "state",
        type: "SecurityMonitoringSignalState",
        required: true,
    },
    stateUpdateTimestamp: {
        baseName: "state_update_timestamp",
        type: "number",
        format: "int64",
    },
    stateUpdateUser: {
        baseName: "state_update_user",
        type: "SecurityMonitoringTriageUser",
    },
};
//# sourceMappingURL=SecurityMonitoringSignalTriageAttributes.js.map

/***/ }),

/***/ 21346:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalTriageUpdateData = void 0;
/**
 * Data containing the updated triage attributes of the signal.
 */
class SecurityMonitoringSignalTriageUpdateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalTriageUpdateData.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalTriageUpdateData = SecurityMonitoringSignalTriageUpdateData;
/**
 * @ignore
 */
SecurityMonitoringSignalTriageUpdateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SecurityMonitoringSignalTriageAttributes",
    },
};
//# sourceMappingURL=SecurityMonitoringSignalTriageUpdateData.js.map

/***/ }),

/***/ 97439:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalTriageUpdateResponse = void 0;
/**
 * The response returned after all triage operations, containing the updated signal triage data.
 */
class SecurityMonitoringSignalTriageUpdateResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalTriageUpdateResponse.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalTriageUpdateResponse = SecurityMonitoringSignalTriageUpdateResponse;
/**
 * @ignore
 */
SecurityMonitoringSignalTriageUpdateResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SecurityMonitoringSignalTriageUpdateData",
        required: true,
    },
};
//# sourceMappingURL=SecurityMonitoringSignalTriageUpdateResponse.js.map

/***/ }),

/***/ 8869:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalsListResponse = void 0;
/**
 * The response object with all security signals matching the request
 * and pagination information.
 */
class SecurityMonitoringSignalsListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalsListResponse.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalsListResponse = SecurityMonitoringSignalsListResponse;
/**
 * @ignore
 */
SecurityMonitoringSignalsListResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<SecurityMonitoringSignal>",
    },
    links: {
        baseName: "links",
        type: "SecurityMonitoringSignalsListResponseLinks",
    },
    meta: {
        baseName: "meta",
        type: "SecurityMonitoringSignalsListResponseMeta",
    },
};
//# sourceMappingURL=SecurityMonitoringSignalsListResponse.js.map

/***/ }),

/***/ 53523:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalsListResponseLinks = void 0;
/**
 * Links attributes.
 */
class SecurityMonitoringSignalsListResponseLinks {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalsListResponseLinks.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalsListResponseLinks = SecurityMonitoringSignalsListResponseLinks;
/**
 * @ignore
 */
SecurityMonitoringSignalsListResponseLinks.attributeTypeMap = {
    next: {
        baseName: "next",
        type: "string",
    },
};
//# sourceMappingURL=SecurityMonitoringSignalsListResponseLinks.js.map

/***/ }),

/***/ 39585:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalsListResponseMeta = void 0;
/**
 * Meta attributes.
 */
class SecurityMonitoringSignalsListResponseMeta {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalsListResponseMeta.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalsListResponseMeta = SecurityMonitoringSignalsListResponseMeta;
/**
 * @ignore
 */
SecurityMonitoringSignalsListResponseMeta.attributeTypeMap = {
    page: {
        baseName: "page",
        type: "SecurityMonitoringSignalsListResponseMetaPage",
    },
};
//# sourceMappingURL=SecurityMonitoringSignalsListResponseMeta.js.map

/***/ }),

/***/ 54327:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringSignalsListResponseMetaPage = void 0;
/**
 * Paging attributes.
 */
class SecurityMonitoringSignalsListResponseMetaPage {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringSignalsListResponseMetaPage.attributeTypeMap;
    }
}
exports.SecurityMonitoringSignalsListResponseMetaPage = SecurityMonitoringSignalsListResponseMetaPage;
/**
 * @ignore
 */
SecurityMonitoringSignalsListResponseMetaPage.attributeTypeMap = {
    after: {
        baseName: "after",
        type: "string",
    },
};
//# sourceMappingURL=SecurityMonitoringSignalsListResponseMetaPage.js.map

/***/ }),

/***/ 29677:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringStandardRuleCreatePayload = void 0;
/**
 * Create a new rule.
 */
class SecurityMonitoringStandardRuleCreatePayload {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringStandardRuleCreatePayload.attributeTypeMap;
    }
}
exports.SecurityMonitoringStandardRuleCreatePayload = SecurityMonitoringStandardRuleCreatePayload;
/**
 * @ignore
 */
SecurityMonitoringStandardRuleCreatePayload.attributeTypeMap = {
    cases: {
        baseName: "cases",
        type: "Array<SecurityMonitoringRuleCaseCreate>",
        required: true,
    },
    filters: {
        baseName: "filters",
        type: "Array<SecurityMonitoringFilter>",
    },
    hasExtendedTitle: {
        baseName: "hasExtendedTitle",
        type: "boolean",
    },
    isEnabled: {
        baseName: "isEnabled",
        type: "boolean",
        required: true,
    },
    message: {
        baseName: "message",
        type: "string",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    options: {
        baseName: "options",
        type: "SecurityMonitoringRuleOptions",
        required: true,
    },
    queries: {
        baseName: "queries",
        type: "Array<SecurityMonitoringStandardRuleQuery>",
        required: true,
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    type: {
        baseName: "type",
        type: "SecurityMonitoringRuleTypeCreate",
    },
};
//# sourceMappingURL=SecurityMonitoringStandardRuleCreatePayload.js.map

/***/ }),

/***/ 49427:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringStandardRuleQuery = void 0;
/**
 * Query for matching rule.
 */
class SecurityMonitoringStandardRuleQuery {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringStandardRuleQuery.attributeTypeMap;
    }
}
exports.SecurityMonitoringStandardRuleQuery = SecurityMonitoringStandardRuleQuery;
/**
 * @ignore
 */
SecurityMonitoringStandardRuleQuery.attributeTypeMap = {
    aggregation: {
        baseName: "aggregation",
        type: "SecurityMonitoringRuleQueryAggregation",
    },
    distinctFields: {
        baseName: "distinctFields",
        type: "Array<string>",
    },
    groupByFields: {
        baseName: "groupByFields",
        type: "Array<string>",
    },
    metric: {
        baseName: "metric",
        type: "string",
    },
    metrics: {
        baseName: "metrics",
        type: "Array<string>",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    query: {
        baseName: "query",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=SecurityMonitoringStandardRuleQuery.js.map

/***/ }),

/***/ 37779:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringStandardRuleResponse = void 0;
/**
 * Rule.
 */
class SecurityMonitoringStandardRuleResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringStandardRuleResponse.attributeTypeMap;
    }
}
exports.SecurityMonitoringStandardRuleResponse = SecurityMonitoringStandardRuleResponse;
/**
 * @ignore
 */
SecurityMonitoringStandardRuleResponse.attributeTypeMap = {
    cases: {
        baseName: "cases",
        type: "Array<SecurityMonitoringRuleCase>",
    },
    complianceSignalOptions: {
        baseName: "complianceSignalOptions",
        type: "CloudConfigurationRuleComplianceSignalOptions",
    },
    createdAt: {
        baseName: "createdAt",
        type: "number",
        format: "int64",
    },
    creationAuthorId: {
        baseName: "creationAuthorId",
        type: "number",
        format: "int64",
    },
    deprecationDate: {
        baseName: "deprecationDate",
        type: "number",
        format: "int64",
    },
    filters: {
        baseName: "filters",
        type: "Array<SecurityMonitoringFilter>",
    },
    hasExtendedTitle: {
        baseName: "hasExtendedTitle",
        type: "boolean",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    isDefault: {
        baseName: "isDefault",
        type: "boolean",
    },
    isDeleted: {
        baseName: "isDeleted",
        type: "boolean",
    },
    isEnabled: {
        baseName: "isEnabled",
        type: "boolean",
    },
    message: {
        baseName: "message",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    options: {
        baseName: "options",
        type: "SecurityMonitoringRuleOptions",
    },
    queries: {
        baseName: "queries",
        type: "Array<SecurityMonitoringStandardRuleQuery>",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    type: {
        baseName: "type",
        type: "SecurityMonitoringRuleTypeRead",
    },
    updateAuthorId: {
        baseName: "updateAuthorId",
        type: "number",
        format: "int64",
    },
    version: {
        baseName: "version",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=SecurityMonitoringStandardRuleResponse.js.map

/***/ }),

/***/ 38314:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecurityMonitoringTriageUser = void 0;
/**
 * Object representing a given user entity.
 */
class SecurityMonitoringTriageUser {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SecurityMonitoringTriageUser.attributeTypeMap;
    }
}
exports.SecurityMonitoringTriageUser = SecurityMonitoringTriageUser;
/**
 * @ignore
 */
SecurityMonitoringTriageUser.attributeTypeMap = {
    handle: {
        baseName: "handle",
        type: "string",
    },
    id: {
        baseName: "id",
        type: "number",
        format: "int64",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    uuid: {
        baseName: "uuid",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=SecurityMonitoringTriageUser.js.map

/***/ }),

/***/ 82462:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerConfigRequest = void 0;
/**
 * Group reorder request.
 */
class SensitiveDataScannerConfigRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerConfigRequest.attributeTypeMap;
    }
}
exports.SensitiveDataScannerConfigRequest = SensitiveDataScannerConfigRequest;
/**
 * @ignore
 */
SensitiveDataScannerConfigRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SensitiveDataScannerReorderConfig",
        required: true,
    },
    meta: {
        baseName: "meta",
        type: "SensitiveDataScannerMetaVersionOnly",
        required: true,
    },
};
//# sourceMappingURL=SensitiveDataScannerConfigRequest.js.map

/***/ }),

/***/ 67945:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerConfiguration = void 0;
/**
 * A Sensitive Data Scanner configuration.
 */
class SensitiveDataScannerConfiguration {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerConfiguration.attributeTypeMap;
    }
}
exports.SensitiveDataScannerConfiguration = SensitiveDataScannerConfiguration;
/**
 * @ignore
 */
SensitiveDataScannerConfiguration.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "SensitiveDataScannerConfigurationType",
    },
};
//# sourceMappingURL=SensitiveDataScannerConfiguration.js.map

/***/ }),

/***/ 3706:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerConfigurationData = void 0;
/**
 * A Sensitive Data Scanner configuration data.
 */
class SensitiveDataScannerConfigurationData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerConfigurationData.attributeTypeMap;
    }
}
exports.SensitiveDataScannerConfigurationData = SensitiveDataScannerConfigurationData;
/**
 * @ignore
 */
SensitiveDataScannerConfigurationData.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SensitiveDataScannerConfiguration",
    },
};
//# sourceMappingURL=SensitiveDataScannerConfigurationData.js.map

/***/ }),

/***/ 91265:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerConfigurationRelationships = void 0;
/**
 * Relationships of the configuration.
 */
class SensitiveDataScannerConfigurationRelationships {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerConfigurationRelationships.attributeTypeMap;
    }
}
exports.SensitiveDataScannerConfigurationRelationships = SensitiveDataScannerConfigurationRelationships;
/**
 * @ignore
 */
SensitiveDataScannerConfigurationRelationships.attributeTypeMap = {
    groups: {
        baseName: "groups",
        type: "SensitiveDataScannerGroupList",
    },
};
//# sourceMappingURL=SensitiveDataScannerConfigurationRelationships.js.map

/***/ }),

/***/ 20832:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerCreateGroupResponse = void 0;
/**
 * Create group response.
 */
class SensitiveDataScannerCreateGroupResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerCreateGroupResponse.attributeTypeMap;
    }
}
exports.SensitiveDataScannerCreateGroupResponse = SensitiveDataScannerCreateGroupResponse;
/**
 * @ignore
 */
SensitiveDataScannerCreateGroupResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SensitiveDataScannerGroupResponse",
    },
    meta: {
        baseName: "meta",
        type: "SensitiveDataScannerMetaVersionOnly",
    },
};
//# sourceMappingURL=SensitiveDataScannerCreateGroupResponse.js.map

/***/ }),

/***/ 52528:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerCreateRuleResponse = void 0;
/**
 * Create rule response.
 */
class SensitiveDataScannerCreateRuleResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerCreateRuleResponse.attributeTypeMap;
    }
}
exports.SensitiveDataScannerCreateRuleResponse = SensitiveDataScannerCreateRuleResponse;
/**
 * @ignore
 */
SensitiveDataScannerCreateRuleResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SensitiveDataScannerRuleResponse",
    },
    meta: {
        baseName: "meta",
        type: "SensitiveDataScannerMetaVersionOnly",
    },
};
//# sourceMappingURL=SensitiveDataScannerCreateRuleResponse.js.map

/***/ }),

/***/ 25030:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerFilter = void 0;
/**
 * Filter for the Scanning Group.
 */
class SensitiveDataScannerFilter {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerFilter.attributeTypeMap;
    }
}
exports.SensitiveDataScannerFilter = SensitiveDataScannerFilter;
/**
 * @ignore
 */
SensitiveDataScannerFilter.attributeTypeMap = {
    query: {
        baseName: "query",
        type: "string",
    },
};
//# sourceMappingURL=SensitiveDataScannerFilter.js.map

/***/ }),

/***/ 28829:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerGetConfigResponse = void 0;
/**
 * Get all groups response.
 */
class SensitiveDataScannerGetConfigResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerGetConfigResponse.attributeTypeMap;
    }
}
exports.SensitiveDataScannerGetConfigResponse = SensitiveDataScannerGetConfigResponse;
/**
 * @ignore
 */
SensitiveDataScannerGetConfigResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SensitiveDataScannerGetConfigResponseData",
    },
    included: {
        baseName: "included",
        type: "Array<SensitiveDataScannerGetConfigIncludedItem>",
    },
    meta: {
        baseName: "meta",
        type: "SensitiveDataScannerMeta",
    },
};
//# sourceMappingURL=SensitiveDataScannerGetConfigResponse.js.map

/***/ }),

/***/ 54486:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerGetConfigResponseData = void 0;
/**
 * Response data related to the scanning groups.
 */
class SensitiveDataScannerGetConfigResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerGetConfigResponseData.attributeTypeMap;
    }
}
exports.SensitiveDataScannerGetConfigResponseData = SensitiveDataScannerGetConfigResponseData;
/**
 * @ignore
 */
SensitiveDataScannerGetConfigResponseData.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
    },
    relationships: {
        baseName: "relationships",
        type: "SensitiveDataScannerConfigurationRelationships",
    },
    type: {
        baseName: "type",
        type: "SensitiveDataScannerConfigurationType",
    },
};
//# sourceMappingURL=SensitiveDataScannerGetConfigResponseData.js.map

/***/ }),

/***/ 84787:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerGroup = void 0;
/**
 * A scanning group.
 */
class SensitiveDataScannerGroup {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerGroup.attributeTypeMap;
    }
}
exports.SensitiveDataScannerGroup = SensitiveDataScannerGroup;
/**
 * @ignore
 */
SensitiveDataScannerGroup.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "SensitiveDataScannerGroupType",
    },
};
//# sourceMappingURL=SensitiveDataScannerGroup.js.map

/***/ }),

/***/ 38169:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerGroupAttributes = void 0;
/**
 * Attributes of the Sensitive Data Scanner group.
 */
class SensitiveDataScannerGroupAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerGroupAttributes.attributeTypeMap;
    }
}
exports.SensitiveDataScannerGroupAttributes = SensitiveDataScannerGroupAttributes;
/**
 * @ignore
 */
SensitiveDataScannerGroupAttributes.attributeTypeMap = {
    description: {
        baseName: "description",
        type: "string",
    },
    filter: {
        baseName: "filter",
        type: "SensitiveDataScannerFilter",
    },
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    productList: {
        baseName: "product_list",
        type: "Array<SensitiveDataScannerProduct>",
    },
};
//# sourceMappingURL=SensitiveDataScannerGroupAttributes.js.map

/***/ }),

/***/ 50135:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerGroupCreate = void 0;
/**
 * Data related to the creation of a group.
 */
class SensitiveDataScannerGroupCreate {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerGroupCreate.attributeTypeMap;
    }
}
exports.SensitiveDataScannerGroupCreate = SensitiveDataScannerGroupCreate;
/**
 * @ignore
 */
SensitiveDataScannerGroupCreate.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SensitiveDataScannerGroupAttributes",
        required: true,
    },
    relationships: {
        baseName: "relationships",
        type: "SensitiveDataScannerGroupRelationships",
    },
    type: {
        baseName: "type",
        type: "SensitiveDataScannerGroupType",
        required: true,
    },
};
//# sourceMappingURL=SensitiveDataScannerGroupCreate.js.map

/***/ }),

/***/ 30524:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerGroupCreateRequest = void 0;
/**
 * Create group request.
 */
class SensitiveDataScannerGroupCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerGroupCreateRequest.attributeTypeMap;
    }
}
exports.SensitiveDataScannerGroupCreateRequest = SensitiveDataScannerGroupCreateRequest;
/**
 * @ignore
 */
SensitiveDataScannerGroupCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SensitiveDataScannerGroupCreate",
    },
    meta: {
        baseName: "meta",
        type: "SensitiveDataScannerMetaVersionOnly",
    },
};
//# sourceMappingURL=SensitiveDataScannerGroupCreateRequest.js.map

/***/ }),

/***/ 8282:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerGroupData = void 0;
/**
 * A scanning group data.
 */
class SensitiveDataScannerGroupData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerGroupData.attributeTypeMap;
    }
}
exports.SensitiveDataScannerGroupData = SensitiveDataScannerGroupData;
/**
 * @ignore
 */
SensitiveDataScannerGroupData.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SensitiveDataScannerGroup",
    },
};
//# sourceMappingURL=SensitiveDataScannerGroupData.js.map

/***/ }),

/***/ 6445:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerGroupDeleteRequest = void 0;
/**
 * Delete group request.
 */
class SensitiveDataScannerGroupDeleteRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerGroupDeleteRequest.attributeTypeMap;
    }
}
exports.SensitiveDataScannerGroupDeleteRequest = SensitiveDataScannerGroupDeleteRequest;
/**
 * @ignore
 */
SensitiveDataScannerGroupDeleteRequest.attributeTypeMap = {
    meta: {
        baseName: "meta",
        type: "SensitiveDataScannerMetaVersionOnly",
        required: true,
    },
};
//# sourceMappingURL=SensitiveDataScannerGroupDeleteRequest.js.map

/***/ }),

/***/ 93600:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerGroupDeleteResponse = void 0;
/**
 * Delete group response.
 */
class SensitiveDataScannerGroupDeleteResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerGroupDeleteResponse.attributeTypeMap;
    }
}
exports.SensitiveDataScannerGroupDeleteResponse = SensitiveDataScannerGroupDeleteResponse;
/**
 * @ignore
 */
SensitiveDataScannerGroupDeleteResponse.attributeTypeMap = {
    meta: {
        baseName: "meta",
        type: "SensitiveDataScannerMetaVersionOnly",
    },
};
//# sourceMappingURL=SensitiveDataScannerGroupDeleteResponse.js.map

/***/ }),

/***/ 21332:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerGroupIncludedItem = void 0;
/**
 * A Scanning Group included item.
 */
class SensitiveDataScannerGroupIncludedItem {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerGroupIncludedItem.attributeTypeMap;
    }
}
exports.SensitiveDataScannerGroupIncludedItem = SensitiveDataScannerGroupIncludedItem;
/**
 * @ignore
 */
SensitiveDataScannerGroupIncludedItem.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SensitiveDataScannerGroupAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    relationships: {
        baseName: "relationships",
        type: "SensitiveDataScannerGroupRelationships",
    },
    type: {
        baseName: "type",
        type: "SensitiveDataScannerGroupType",
    },
};
//# sourceMappingURL=SensitiveDataScannerGroupIncludedItem.js.map

/***/ }),

/***/ 32080:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerGroupItem = void 0;
/**
 * Data related to a Sensitive Data Scanner Group.
 */
class SensitiveDataScannerGroupItem {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerGroupItem.attributeTypeMap;
    }
}
exports.SensitiveDataScannerGroupItem = SensitiveDataScannerGroupItem;
/**
 * @ignore
 */
SensitiveDataScannerGroupItem.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "SensitiveDataScannerGroupType",
    },
};
//# sourceMappingURL=SensitiveDataScannerGroupItem.js.map

/***/ }),

/***/ 406:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerGroupList = void 0;
/**
 * List of groups, ordered.
 */
class SensitiveDataScannerGroupList {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerGroupList.attributeTypeMap;
    }
}
exports.SensitiveDataScannerGroupList = SensitiveDataScannerGroupList;
/**
 * @ignore
 */
SensitiveDataScannerGroupList.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<SensitiveDataScannerGroupItem>",
    },
};
//# sourceMappingURL=SensitiveDataScannerGroupList.js.map

/***/ }),

/***/ 88193:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerGroupRelationships = void 0;
/**
 * Relationships of the group.
 */
class SensitiveDataScannerGroupRelationships {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerGroupRelationships.attributeTypeMap;
    }
}
exports.SensitiveDataScannerGroupRelationships = SensitiveDataScannerGroupRelationships;
/**
 * @ignore
 */
SensitiveDataScannerGroupRelationships.attributeTypeMap = {
    configuration: {
        baseName: "configuration",
        type: "SensitiveDataScannerConfigurationData",
    },
    rules: {
        baseName: "rules",
        type: "SensitiveDataScannerRuleData",
    },
};
//# sourceMappingURL=SensitiveDataScannerGroupRelationships.js.map

/***/ }),

/***/ 68081:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerGroupResponse = void 0;
/**
 * Response data related to the creation of a group.
 */
class SensitiveDataScannerGroupResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerGroupResponse.attributeTypeMap;
    }
}
exports.SensitiveDataScannerGroupResponse = SensitiveDataScannerGroupResponse;
/**
 * @ignore
 */
SensitiveDataScannerGroupResponse.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SensitiveDataScannerGroupAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    relationships: {
        baseName: "relationships",
        type: "SensitiveDataScannerGroupRelationships",
    },
    type: {
        baseName: "type",
        type: "SensitiveDataScannerGroupType",
    },
};
//# sourceMappingURL=SensitiveDataScannerGroupResponse.js.map

/***/ }),

/***/ 96818:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerGroupUpdate = void 0;
/**
 * Data related to the update of a group.
 */
class SensitiveDataScannerGroupUpdate {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerGroupUpdate.attributeTypeMap;
    }
}
exports.SensitiveDataScannerGroupUpdate = SensitiveDataScannerGroupUpdate;
/**
 * @ignore
 */
SensitiveDataScannerGroupUpdate.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SensitiveDataScannerGroupAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    relationships: {
        baseName: "relationships",
        type: "SensitiveDataScannerGroupRelationships",
    },
    type: {
        baseName: "type",
        type: "SensitiveDataScannerGroupType",
    },
};
//# sourceMappingURL=SensitiveDataScannerGroupUpdate.js.map

/***/ }),

/***/ 25051:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerGroupUpdateRequest = void 0;
/**
 * Update group request.
 */
class SensitiveDataScannerGroupUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerGroupUpdateRequest.attributeTypeMap;
    }
}
exports.SensitiveDataScannerGroupUpdateRequest = SensitiveDataScannerGroupUpdateRequest;
/**
 * @ignore
 */
SensitiveDataScannerGroupUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SensitiveDataScannerGroupUpdate",
        required: true,
    },
    meta: {
        baseName: "meta",
        type: "SensitiveDataScannerMetaVersionOnly",
        required: true,
    },
};
//# sourceMappingURL=SensitiveDataScannerGroupUpdateRequest.js.map

/***/ }),

/***/ 83278:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerGroupUpdateResponse = void 0;
/**
 * Update group response.
 */
class SensitiveDataScannerGroupUpdateResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerGroupUpdateResponse.attributeTypeMap;
    }
}
exports.SensitiveDataScannerGroupUpdateResponse = SensitiveDataScannerGroupUpdateResponse;
/**
 * @ignore
 */
SensitiveDataScannerGroupUpdateResponse.attributeTypeMap = {
    meta: {
        baseName: "meta",
        type: "SensitiveDataScannerMetaVersionOnly",
    },
};
//# sourceMappingURL=SensitiveDataScannerGroupUpdateResponse.js.map

/***/ }),

/***/ 65690:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerMeta = void 0;
/**
 * Meta response containing information about the API.
 */
class SensitiveDataScannerMeta {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerMeta.attributeTypeMap;
    }
}
exports.SensitiveDataScannerMeta = SensitiveDataScannerMeta;
/**
 * @ignore
 */
SensitiveDataScannerMeta.attributeTypeMap = {
    countLimit: {
        baseName: "count_limit",
        type: "number",
        format: "int64",
    },
    groupCountLimit: {
        baseName: "group_count_limit",
        type: "number",
        format: "int64",
    },
    hasHighlightEnabled: {
        baseName: "has_highlight_enabled",
        type: "boolean",
    },
    isPciCompliant: {
        baseName: "is_pci_compliant",
        type: "boolean",
    },
    version: {
        baseName: "version",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=SensitiveDataScannerMeta.js.map

/***/ }),

/***/ 53588:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerMetaVersionOnly = void 0;
/**
 * Meta payload containing information about the API.
 */
class SensitiveDataScannerMetaVersionOnly {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerMetaVersionOnly.attributeTypeMap;
    }
}
exports.SensitiveDataScannerMetaVersionOnly = SensitiveDataScannerMetaVersionOnly;
/**
 * @ignore
 */
SensitiveDataScannerMetaVersionOnly.attributeTypeMap = {
    version: {
        baseName: "version",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=SensitiveDataScannerMetaVersionOnly.js.map

/***/ }),

/***/ 69317:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerReorderConfig = void 0;
/**
 * Data related to the reordering of scanning groups.
 */
class SensitiveDataScannerReorderConfig {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerReorderConfig.attributeTypeMap;
    }
}
exports.SensitiveDataScannerReorderConfig = SensitiveDataScannerReorderConfig;
/**
 * @ignore
 */
SensitiveDataScannerReorderConfig.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
    },
    relationships: {
        baseName: "relationships",
        type: "SensitiveDataScannerConfigurationRelationships",
    },
    type: {
        baseName: "type",
        type: "SensitiveDataScannerConfigurationType",
    },
};
//# sourceMappingURL=SensitiveDataScannerReorderConfig.js.map

/***/ }),

/***/ 90270:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerReorderGroupsResponse = void 0;
/**
 * Group reorder response.
 */
class SensitiveDataScannerReorderGroupsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerReorderGroupsResponse.attributeTypeMap;
    }
}
exports.SensitiveDataScannerReorderGroupsResponse = SensitiveDataScannerReorderGroupsResponse;
/**
 * @ignore
 */
SensitiveDataScannerReorderGroupsResponse.attributeTypeMap = {
    meta: {
        baseName: "meta",
        type: "SensitiveDataScannerMeta",
    },
};
//# sourceMappingURL=SensitiveDataScannerReorderGroupsResponse.js.map

/***/ }),

/***/ 37961:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerRule = void 0;
/**
 * Rule item included in the group.
 */
class SensitiveDataScannerRule {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerRule.attributeTypeMap;
    }
}
exports.SensitiveDataScannerRule = SensitiveDataScannerRule;
/**
 * @ignore
 */
SensitiveDataScannerRule.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "SensitiveDataScannerRuleType",
    },
};
//# sourceMappingURL=SensitiveDataScannerRule.js.map

/***/ }),

/***/ 66455:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerRuleAttributes = void 0;
/**
 * Attributes of the Sensitive Data Scanner rule.
 */
class SensitiveDataScannerRuleAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerRuleAttributes.attributeTypeMap;
    }
}
exports.SensitiveDataScannerRuleAttributes = SensitiveDataScannerRuleAttributes;
/**
 * @ignore
 */
SensitiveDataScannerRuleAttributes.attributeTypeMap = {
    description: {
        baseName: "description",
        type: "string",
    },
    excludedNamespaces: {
        baseName: "excluded_namespaces",
        type: "Array<string>",
    },
    isEnabled: {
        baseName: "is_enabled",
        type: "boolean",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    namespaces: {
        baseName: "namespaces",
        type: "Array<string>",
    },
    pattern: {
        baseName: "pattern",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    textReplacement: {
        baseName: "text_replacement",
        type: "SensitiveDataScannerTextReplacement",
    },
};
//# sourceMappingURL=SensitiveDataScannerRuleAttributes.js.map

/***/ }),

/***/ 31674:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerRuleCreate = void 0;
/**
 * Data related to the creation of a rule.
 */
class SensitiveDataScannerRuleCreate {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerRuleCreate.attributeTypeMap;
    }
}
exports.SensitiveDataScannerRuleCreate = SensitiveDataScannerRuleCreate;
/**
 * @ignore
 */
SensitiveDataScannerRuleCreate.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SensitiveDataScannerRuleAttributes",
        required: true,
    },
    relationships: {
        baseName: "relationships",
        type: "SensitiveDataScannerRuleRelationships",
        required: true,
    },
    type: {
        baseName: "type",
        type: "SensitiveDataScannerRuleType",
        required: true,
    },
};
//# sourceMappingURL=SensitiveDataScannerRuleCreate.js.map

/***/ }),

/***/ 22917:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerRuleCreateRequest = void 0;
/**
 * Create rule request.
 */
class SensitiveDataScannerRuleCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerRuleCreateRequest.attributeTypeMap;
    }
}
exports.SensitiveDataScannerRuleCreateRequest = SensitiveDataScannerRuleCreateRequest;
/**
 * @ignore
 */
SensitiveDataScannerRuleCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SensitiveDataScannerRuleCreate",
        required: true,
    },
    meta: {
        baseName: "meta",
        type: "SensitiveDataScannerMetaVersionOnly",
        required: true,
    },
};
//# sourceMappingURL=SensitiveDataScannerRuleCreateRequest.js.map

/***/ }),

/***/ 81643:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerRuleData = void 0;
/**
 * Rules included in the group.
 */
class SensitiveDataScannerRuleData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerRuleData.attributeTypeMap;
    }
}
exports.SensitiveDataScannerRuleData = SensitiveDataScannerRuleData;
/**
 * @ignore
 */
SensitiveDataScannerRuleData.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<SensitiveDataScannerRule>",
    },
};
//# sourceMappingURL=SensitiveDataScannerRuleData.js.map

/***/ }),

/***/ 93391:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerRuleDeleteRequest = void 0;
/**
 * Delete rule request.
 */
class SensitiveDataScannerRuleDeleteRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerRuleDeleteRequest.attributeTypeMap;
    }
}
exports.SensitiveDataScannerRuleDeleteRequest = SensitiveDataScannerRuleDeleteRequest;
/**
 * @ignore
 */
SensitiveDataScannerRuleDeleteRequest.attributeTypeMap = {
    meta: {
        baseName: "meta",
        type: "SensitiveDataScannerMetaVersionOnly",
        required: true,
    },
};
//# sourceMappingURL=SensitiveDataScannerRuleDeleteRequest.js.map

/***/ }),

/***/ 37715:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerRuleDeleteResponse = void 0;
/**
 * Delete rule response.
 */
class SensitiveDataScannerRuleDeleteResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerRuleDeleteResponse.attributeTypeMap;
    }
}
exports.SensitiveDataScannerRuleDeleteResponse = SensitiveDataScannerRuleDeleteResponse;
/**
 * @ignore
 */
SensitiveDataScannerRuleDeleteResponse.attributeTypeMap = {
    meta: {
        baseName: "meta",
        type: "SensitiveDataScannerMetaVersionOnly",
    },
};
//# sourceMappingURL=SensitiveDataScannerRuleDeleteResponse.js.map

/***/ }),

/***/ 26218:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerRuleIncludedItem = void 0;
/**
 * A Scanning Rule included item.
 */
class SensitiveDataScannerRuleIncludedItem {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerRuleIncludedItem.attributeTypeMap;
    }
}
exports.SensitiveDataScannerRuleIncludedItem = SensitiveDataScannerRuleIncludedItem;
/**
 * @ignore
 */
SensitiveDataScannerRuleIncludedItem.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SensitiveDataScannerRuleAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    relationships: {
        baseName: "relationships",
        type: "SensitiveDataScannerRuleRelationships",
    },
    type: {
        baseName: "type",
        type: "SensitiveDataScannerRuleType",
    },
};
//# sourceMappingURL=SensitiveDataScannerRuleIncludedItem.js.map

/***/ }),

/***/ 14442:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerRuleRelationships = void 0;
/**
 * Relationships of a scanning rule.
 */
class SensitiveDataScannerRuleRelationships {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerRuleRelationships.attributeTypeMap;
    }
}
exports.SensitiveDataScannerRuleRelationships = SensitiveDataScannerRuleRelationships;
/**
 * @ignore
 */
SensitiveDataScannerRuleRelationships.attributeTypeMap = {
    group: {
        baseName: "group",
        type: "SensitiveDataScannerGroupData",
    },
    standardPattern: {
        baseName: "standard_pattern",
        type: "SensitiveDataScannerStandardPatternData",
    },
};
//# sourceMappingURL=SensitiveDataScannerRuleRelationships.js.map

/***/ }),

/***/ 33872:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerRuleResponse = void 0;
/**
 * Response data related to the creation of a rule.
 */
class SensitiveDataScannerRuleResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerRuleResponse.attributeTypeMap;
    }
}
exports.SensitiveDataScannerRuleResponse = SensitiveDataScannerRuleResponse;
/**
 * @ignore
 */
SensitiveDataScannerRuleResponse.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SensitiveDataScannerRuleAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    relationships: {
        baseName: "relationships",
        type: "SensitiveDataScannerRuleRelationships",
    },
    type: {
        baseName: "type",
        type: "SensitiveDataScannerRuleType",
    },
};
//# sourceMappingURL=SensitiveDataScannerRuleResponse.js.map

/***/ }),

/***/ 83537:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerRuleUpdate = void 0;
/**
 * Data related to the update of a rule.
 */
class SensitiveDataScannerRuleUpdate {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerRuleUpdate.attributeTypeMap;
    }
}
exports.SensitiveDataScannerRuleUpdate = SensitiveDataScannerRuleUpdate;
/**
 * @ignore
 */
SensitiveDataScannerRuleUpdate.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SensitiveDataScannerRuleAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    relationships: {
        baseName: "relationships",
        type: "SensitiveDataScannerRuleRelationships",
    },
    type: {
        baseName: "type",
        type: "SensitiveDataScannerRuleType",
    },
};
//# sourceMappingURL=SensitiveDataScannerRuleUpdate.js.map

/***/ }),

/***/ 73584:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerRuleUpdateRequest = void 0;
/**
 * Update rule request.
 */
class SensitiveDataScannerRuleUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerRuleUpdateRequest.attributeTypeMap;
    }
}
exports.SensitiveDataScannerRuleUpdateRequest = SensitiveDataScannerRuleUpdateRequest;
/**
 * @ignore
 */
SensitiveDataScannerRuleUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SensitiveDataScannerRuleUpdate",
        required: true,
    },
    meta: {
        baseName: "meta",
        type: "SensitiveDataScannerMetaVersionOnly",
        required: true,
    },
};
//# sourceMappingURL=SensitiveDataScannerRuleUpdateRequest.js.map

/***/ }),

/***/ 89412:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerRuleUpdateResponse = void 0;
/**
 * Update rule response.
 */
class SensitiveDataScannerRuleUpdateResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerRuleUpdateResponse.attributeTypeMap;
    }
}
exports.SensitiveDataScannerRuleUpdateResponse = SensitiveDataScannerRuleUpdateResponse;
/**
 * @ignore
 */
SensitiveDataScannerRuleUpdateResponse.attributeTypeMap = {
    meta: {
        baseName: "meta",
        type: "SensitiveDataScannerMetaVersionOnly",
    },
};
//# sourceMappingURL=SensitiveDataScannerRuleUpdateResponse.js.map

/***/ }),

/***/ 17483:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerStandardPattern = void 0;
/**
 * Data containing the standard pattern id.
 */
class SensitiveDataScannerStandardPattern {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerStandardPattern.attributeTypeMap;
    }
}
exports.SensitiveDataScannerStandardPattern = SensitiveDataScannerStandardPattern;
/**
 * @ignore
 */
SensitiveDataScannerStandardPattern.attributeTypeMap = {
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "SensitiveDataScannerStandardPatternType",
    },
};
//# sourceMappingURL=SensitiveDataScannerStandardPattern.js.map

/***/ }),

/***/ 33843:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerStandardPatternAttributes = void 0;
/**
 * Attributes of the Sensitive Data Scanner standard pattern.
 */
class SensitiveDataScannerStandardPatternAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerStandardPatternAttributes.attributeTypeMap;
    }
}
exports.SensitiveDataScannerStandardPatternAttributes = SensitiveDataScannerStandardPatternAttributes;
/**
 * @ignore
 */
SensitiveDataScannerStandardPatternAttributes.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
    },
    pattern: {
        baseName: "pattern",
        type: "string",
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
};
//# sourceMappingURL=SensitiveDataScannerStandardPatternAttributes.js.map

/***/ }),

/***/ 52824:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerStandardPatternData = void 0;
/**
 * A standard pattern.
 */
class SensitiveDataScannerStandardPatternData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerStandardPatternData.attributeTypeMap;
    }
}
exports.SensitiveDataScannerStandardPatternData = SensitiveDataScannerStandardPatternData;
/**
 * @ignore
 */
SensitiveDataScannerStandardPatternData.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "SensitiveDataScannerStandardPattern",
    },
};
//# sourceMappingURL=SensitiveDataScannerStandardPatternData.js.map

/***/ }),

/***/ 10167:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerStandardPatternsResponseData = void 0;
/**
 * List Standard patterns response data.
 */
class SensitiveDataScannerStandardPatternsResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerStandardPatternsResponseData.attributeTypeMap;
    }
}
exports.SensitiveDataScannerStandardPatternsResponseData = SensitiveDataScannerStandardPatternsResponseData;
/**
 * @ignore
 */
SensitiveDataScannerStandardPatternsResponseData.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<SensitiveDataScannerStandardPatternsResponseItem>",
    },
};
//# sourceMappingURL=SensitiveDataScannerStandardPatternsResponseData.js.map

/***/ }),

/***/ 36681:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerStandardPatternsResponseItem = void 0;
/**
 * Standard pattern item.
 */
class SensitiveDataScannerStandardPatternsResponseItem {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerStandardPatternsResponseItem.attributeTypeMap;
    }
}
exports.SensitiveDataScannerStandardPatternsResponseItem = SensitiveDataScannerStandardPatternsResponseItem;
/**
 * @ignore
 */
SensitiveDataScannerStandardPatternsResponseItem.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "SensitiveDataScannerStandardPatternAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "SensitiveDataScannerStandardPatternType",
    },
};
//# sourceMappingURL=SensitiveDataScannerStandardPatternsResponseItem.js.map

/***/ }),

/***/ 49101:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SensitiveDataScannerTextReplacement = void 0;
/**
 * Object describing how the scanned event will be replaced.
 */
class SensitiveDataScannerTextReplacement {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return SensitiveDataScannerTextReplacement.attributeTypeMap;
    }
}
exports.SensitiveDataScannerTextReplacement = SensitiveDataScannerTextReplacement;
/**
 * @ignore
 */
SensitiveDataScannerTextReplacement.attributeTypeMap = {
    numberOfChars: {
        baseName: "number_of_chars",
        type: "number",
        format: "int64",
    },
    replacementString: {
        baseName: "replacement_string",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "SensitiveDataScannerTextReplacementType",
    },
};
//# sourceMappingURL=SensitiveDataScannerTextReplacement.js.map

/***/ }),

/***/ 90326:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceAccountCreateAttributes = void 0;
/**
 * Attributes of the created user.
 */
class ServiceAccountCreateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceAccountCreateAttributes.attributeTypeMap;
    }
}
exports.ServiceAccountCreateAttributes = ServiceAccountCreateAttributes;
/**
 * @ignore
 */
ServiceAccountCreateAttributes.attributeTypeMap = {
    email: {
        baseName: "email",
        type: "string",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
    },
    serviceAccount: {
        baseName: "service_account",
        type: "boolean",
        required: true,
    },
    title: {
        baseName: "title",
        type: "string",
    },
};
//# sourceMappingURL=ServiceAccountCreateAttributes.js.map

/***/ }),

/***/ 62468:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceAccountCreateData = void 0;
/**
 * Object to create a service account User.
 */
class ServiceAccountCreateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceAccountCreateData.attributeTypeMap;
    }
}
exports.ServiceAccountCreateData = ServiceAccountCreateData;
/**
 * @ignore
 */
ServiceAccountCreateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "ServiceAccountCreateAttributes",
        required: true,
    },
    relationships: {
        baseName: "relationships",
        type: "UserRelationships",
    },
    type: {
        baseName: "type",
        type: "UsersType",
        required: true,
    },
};
//# sourceMappingURL=ServiceAccountCreateData.js.map

/***/ }),

/***/ 5390:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceAccountCreateRequest = void 0;
/**
 * Create a service account.
 */
class ServiceAccountCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceAccountCreateRequest.attributeTypeMap;
    }
}
exports.ServiceAccountCreateRequest = ServiceAccountCreateRequest;
/**
 * @ignore
 */
ServiceAccountCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "ServiceAccountCreateData",
        required: true,
    },
};
//# sourceMappingURL=ServiceAccountCreateRequest.js.map

/***/ }),

/***/ 42713:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionCreateResponse = void 0;
/**
 * Create service definitions response.
 */
class ServiceDefinitionCreateResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceDefinitionCreateResponse.attributeTypeMap;
    }
}
exports.ServiceDefinitionCreateResponse = ServiceDefinitionCreateResponse;
/**
 * @ignore
 */
ServiceDefinitionCreateResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<ServiceDefinitionData>",
    },
};
//# sourceMappingURL=ServiceDefinitionCreateResponse.js.map

/***/ }),

/***/ 30060:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionData = void 0;
/**
 * Service definition data.
 */
class ServiceDefinitionData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceDefinitionData.attributeTypeMap;
    }
}
exports.ServiceDefinitionData = ServiceDefinitionData;
/**
 * @ignore
 */
ServiceDefinitionData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "ServiceDefinitionDataAttributes",
    },
    type: {
        baseName: "type",
        type: "string",
    },
};
//# sourceMappingURL=ServiceDefinitionData.js.map

/***/ }),

/***/ 46642:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionDataAttributes = void 0;
/**
 * Service definition attributes.
 */
class ServiceDefinitionDataAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceDefinitionDataAttributes.attributeTypeMap;
    }
}
exports.ServiceDefinitionDataAttributes = ServiceDefinitionDataAttributes;
/**
 * @ignore
 */
ServiceDefinitionDataAttributes.attributeTypeMap = {
    meta: {
        baseName: "meta",
        type: "ServiceDefinitionMeta",
    },
    schema: {
        baseName: "schema",
        type: "ServiceDefinitionSchema",
    },
};
//# sourceMappingURL=ServiceDefinitionDataAttributes.js.map

/***/ }),

/***/ 41368:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionGetResponse = void 0;
/**
 * Get service definition response.
 */
class ServiceDefinitionGetResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceDefinitionGetResponse.attributeTypeMap;
    }
}
exports.ServiceDefinitionGetResponse = ServiceDefinitionGetResponse;
/**
 * @ignore
 */
ServiceDefinitionGetResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "ServiceDefinitionData",
    },
};
//# sourceMappingURL=ServiceDefinitionGetResponse.js.map

/***/ }),

/***/ 22530:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionMeta = void 0;
/**
 * Metadata about a service definition.
 */
class ServiceDefinitionMeta {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceDefinitionMeta.attributeTypeMap;
    }
}
exports.ServiceDefinitionMeta = ServiceDefinitionMeta;
/**
 * @ignore
 */
ServiceDefinitionMeta.attributeTypeMap = {
    githubHtmlUrl: {
        baseName: "github-html-url",
        type: "string",
    },
    ingestedSchemaVersion: {
        baseName: "ingested-schema-version",
        type: "string",
    },
    ingestionSource: {
        baseName: "ingestion-source",
        type: "string",
    },
    lastModifiedTime: {
        baseName: "last-modified-time",
        type: "string",
    },
};
//# sourceMappingURL=ServiceDefinitionMeta.js.map

/***/ }),

/***/ 97979:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionV1 = void 0;
/**
 * Deprecated - Service definition V1 for providing additional service metadata and integrations.
 */
class ServiceDefinitionV1 {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceDefinitionV1.attributeTypeMap;
    }
}
exports.ServiceDefinitionV1 = ServiceDefinitionV1;
/**
 * @ignore
 */
ServiceDefinitionV1.attributeTypeMap = {
    contact: {
        baseName: "contact",
        type: "ServiceDefinitionV1Contact",
    },
    extensions: {
        baseName: "extensions",
        type: "{ [key: string]: any; }",
    },
    externalResources: {
        baseName: "external-resources",
        type: "Array<ServiceDefinitionV1Resource>",
    },
    info: {
        baseName: "info",
        type: "ServiceDefinitionV1Info",
        required: true,
    },
    integrations: {
        baseName: "integrations",
        type: "ServiceDefinitionV1Integrations",
    },
    org: {
        baseName: "org",
        type: "ServiceDefinitionV1Org",
    },
    schemaVersion: {
        baseName: "schema-version",
        type: "ServiceDefinitionV1Version",
        required: true,
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
};
//# sourceMappingURL=ServiceDefinitionV1.js.map

/***/ }),

/***/ 95884:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionV1Contact = void 0;
/**
 * Contact information about the service.
 */
class ServiceDefinitionV1Contact {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceDefinitionV1Contact.attributeTypeMap;
    }
}
exports.ServiceDefinitionV1Contact = ServiceDefinitionV1Contact;
/**
 * @ignore
 */
ServiceDefinitionV1Contact.attributeTypeMap = {
    email: {
        baseName: "email",
        type: "string",
        format: "email",
    },
    slack: {
        baseName: "slack",
        type: "string",
    },
};
//# sourceMappingURL=ServiceDefinitionV1Contact.js.map

/***/ }),

/***/ 78827:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionV1Info = void 0;
/**
 * Basic information about a service.
 */
class ServiceDefinitionV1Info {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceDefinitionV1Info.attributeTypeMap;
    }
}
exports.ServiceDefinitionV1Info = ServiceDefinitionV1Info;
/**
 * @ignore
 */
ServiceDefinitionV1Info.attributeTypeMap = {
    ddService: {
        baseName: "dd-service",
        type: "string",
        required: true,
    },
    description: {
        baseName: "description",
        type: "string",
    },
    displayName: {
        baseName: "display-name",
        type: "string",
    },
    serviceTier: {
        baseName: "service-tier",
        type: "string",
    },
};
//# sourceMappingURL=ServiceDefinitionV1Info.js.map

/***/ }),

/***/ 30350:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionV1Integrations = void 0;
/**
 * Third party integrations that Datadog supports.
 */
class ServiceDefinitionV1Integrations {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceDefinitionV1Integrations.attributeTypeMap;
    }
}
exports.ServiceDefinitionV1Integrations = ServiceDefinitionV1Integrations;
/**
 * @ignore
 */
ServiceDefinitionV1Integrations.attributeTypeMap = {
    pagerduty: {
        baseName: "pagerduty",
        type: "string",
    },
};
//# sourceMappingURL=ServiceDefinitionV1Integrations.js.map

/***/ }),

/***/ 91764:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionV1Org = void 0;
/**
 * Org related information about the service.
 */
class ServiceDefinitionV1Org {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceDefinitionV1Org.attributeTypeMap;
    }
}
exports.ServiceDefinitionV1Org = ServiceDefinitionV1Org;
/**
 * @ignore
 */
ServiceDefinitionV1Org.attributeTypeMap = {
    application: {
        baseName: "application",
        type: "string",
    },
    team: {
        baseName: "team",
        type: "string",
    },
};
//# sourceMappingURL=ServiceDefinitionV1Org.js.map

/***/ }),

/***/ 78038:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionV1Resource = void 0;
/**
 * Service's external links.
 */
class ServiceDefinitionV1Resource {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceDefinitionV1Resource.attributeTypeMap;
    }
}
exports.ServiceDefinitionV1Resource = ServiceDefinitionV1Resource;
/**
 * @ignore
 */
ServiceDefinitionV1Resource.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "ServiceDefinitionV1ResourceType",
        required: true,
    },
    url: {
        baseName: "url",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=ServiceDefinitionV1Resource.js.map

/***/ }),

/***/ 39172:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionV2 = void 0;
/**
 * Service definition V2 for providing service metadata and integrations.
 */
class ServiceDefinitionV2 {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceDefinitionV2.attributeTypeMap;
    }
}
exports.ServiceDefinitionV2 = ServiceDefinitionV2;
/**
 * @ignore
 */
ServiceDefinitionV2.attributeTypeMap = {
    contacts: {
        baseName: "contacts",
        type: "Array<ServiceDefinitionV2Contact>",
    },
    ddService: {
        baseName: "dd-service",
        type: "string",
        required: true,
    },
    ddTeam: {
        baseName: "dd-team",
        type: "string",
    },
    docs: {
        baseName: "docs",
        type: "Array<ServiceDefinitionV2Doc>",
    },
    extensions: {
        baseName: "extensions",
        type: "{ [key: string]: any; }",
    },
    integrations: {
        baseName: "integrations",
        type: "ServiceDefinitionV2Integrations",
    },
    links: {
        baseName: "links",
        type: "Array<ServiceDefinitionV2Link>",
    },
    repos: {
        baseName: "repos",
        type: "Array<ServiceDefinitionV2Repo>",
    },
    schemaVersion: {
        baseName: "schema-version",
        type: "ServiceDefinitionV2Version",
        required: true,
    },
    tags: {
        baseName: "tags",
        type: "Array<string>",
    },
    team: {
        baseName: "team",
        type: "string",
    },
};
//# sourceMappingURL=ServiceDefinitionV2.js.map

/***/ }),

/***/ 86073:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionV2Doc = void 0;
/**
 * Service documents.
 */
class ServiceDefinitionV2Doc {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceDefinitionV2Doc.attributeTypeMap;
    }
}
exports.ServiceDefinitionV2Doc = ServiceDefinitionV2Doc;
/**
 * @ignore
 */
ServiceDefinitionV2Doc.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    provider: {
        baseName: "provider",
        type: "string",
    },
    url: {
        baseName: "url",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=ServiceDefinitionV2Doc.js.map

/***/ }),

/***/ 97378:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionV2Email = void 0;
/**
 * Service owner's email.
 */
class ServiceDefinitionV2Email {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceDefinitionV2Email.attributeTypeMap;
    }
}
exports.ServiceDefinitionV2Email = ServiceDefinitionV2Email;
/**
 * @ignore
 */
ServiceDefinitionV2Email.attributeTypeMap = {
    contact: {
        baseName: "contact",
        type: "string",
        required: true,
        format: "email",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "ServiceDefinitionV2EmailType",
        required: true,
    },
};
//# sourceMappingURL=ServiceDefinitionV2Email.js.map

/***/ }),

/***/ 74370:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionV2Integrations = void 0;
/**
 * Third party integrations that Datadog supports.
 */
class ServiceDefinitionV2Integrations {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceDefinitionV2Integrations.attributeTypeMap;
    }
}
exports.ServiceDefinitionV2Integrations = ServiceDefinitionV2Integrations;
/**
 * @ignore
 */
ServiceDefinitionV2Integrations.attributeTypeMap = {
    opsgenie: {
        baseName: "opsgenie",
        type: "ServiceDefinitionV2Opsgenie",
    },
    pagerduty: {
        baseName: "pagerduty",
        type: "string",
    },
};
//# sourceMappingURL=ServiceDefinitionV2Integrations.js.map

/***/ }),

/***/ 36812:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionV2Link = void 0;
/**
 * Service's external links.
 */
class ServiceDefinitionV2Link {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceDefinitionV2Link.attributeTypeMap;
    }
}
exports.ServiceDefinitionV2Link = ServiceDefinitionV2Link;
/**
 * @ignore
 */
ServiceDefinitionV2Link.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "ServiceDefinitionV2LinkType",
        required: true,
    },
    url: {
        baseName: "url",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=ServiceDefinitionV2Link.js.map

/***/ }),

/***/ 6735:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionV2Opsgenie = void 0;
/**
 * Opsgenie integration for the service.
 */
class ServiceDefinitionV2Opsgenie {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceDefinitionV2Opsgenie.attributeTypeMap;
    }
}
exports.ServiceDefinitionV2Opsgenie = ServiceDefinitionV2Opsgenie;
/**
 * @ignore
 */
ServiceDefinitionV2Opsgenie.attributeTypeMap = {
    region: {
        baseName: "region",
        type: "ServiceDefinitionV2OpsgenieRegion",
    },
    serviceUrl: {
        baseName: "service-url",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=ServiceDefinitionV2Opsgenie.js.map

/***/ }),

/***/ 81097:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionV2Repo = void 0;
/**
 * Service code repositories.
 */
class ServiceDefinitionV2Repo {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceDefinitionV2Repo.attributeTypeMap;
    }
}
exports.ServiceDefinitionV2Repo = ServiceDefinitionV2Repo;
/**
 * @ignore
 */
ServiceDefinitionV2Repo.attributeTypeMap = {
    name: {
        baseName: "name",
        type: "string",
        required: true,
    },
    provider: {
        baseName: "provider",
        type: "string",
    },
    url: {
        baseName: "url",
        type: "string",
        required: true,
    },
};
//# sourceMappingURL=ServiceDefinitionV2Repo.js.map

/***/ }),

/***/ 61789:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionV2Slack = void 0;
/**
 * Service owner's Slack channel.
 */
class ServiceDefinitionV2Slack {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceDefinitionV2Slack.attributeTypeMap;
    }
}
exports.ServiceDefinitionV2Slack = ServiceDefinitionV2Slack;
/**
 * @ignore
 */
ServiceDefinitionV2Slack.attributeTypeMap = {
    contact: {
        baseName: "contact",
        type: "string",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "ServiceDefinitionV2SlackType",
        required: true,
    },
};
//# sourceMappingURL=ServiceDefinitionV2Slack.js.map

/***/ }),

/***/ 25597:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinitionsListResponse = void 0;
/**
 * Create service definitions response.
 */
class ServiceDefinitionsListResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return ServiceDefinitionsListResponse.attributeTypeMap;
    }
}
exports.ServiceDefinitionsListResponse = ServiceDefinitionsListResponse;
/**
 * @ignore
 */
ServiceDefinitionsListResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<ServiceDefinitionData>",
    },
};
//# sourceMappingURL=ServiceDefinitionsListResponse.js.map

/***/ }),

/***/ 78461:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeseriesFormulaQueryRequest = void 0;
/**
 * A request wrapper around a single timeseries query to be executed.
 */
class TimeseriesFormulaQueryRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return TimeseriesFormulaQueryRequest.attributeTypeMap;
    }
}
exports.TimeseriesFormulaQueryRequest = TimeseriesFormulaQueryRequest;
/**
 * @ignore
 */
TimeseriesFormulaQueryRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "TimeseriesFormulaRequest",
        required: true,
    },
};
//# sourceMappingURL=TimeseriesFormulaQueryRequest.js.map

/***/ }),

/***/ 57031:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeseriesFormulaQueryResponse = void 0;
/**
 * A message containing one response to a timeseries query made with timeseries formula query request.
 */
class TimeseriesFormulaQueryResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return TimeseriesFormulaQueryResponse.attributeTypeMap;
    }
}
exports.TimeseriesFormulaQueryResponse = TimeseriesFormulaQueryResponse;
/**
 * @ignore
 */
TimeseriesFormulaQueryResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "TimeseriesResponse",
    },
    errors: {
        baseName: "errors",
        type: "string",
    },
};
//# sourceMappingURL=TimeseriesFormulaQueryResponse.js.map

/***/ }),

/***/ 18358:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeseriesFormulaRequest = void 0;
/**
 * A single timeseries query to be executed.
 */
class TimeseriesFormulaRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return TimeseriesFormulaRequest.attributeTypeMap;
    }
}
exports.TimeseriesFormulaRequest = TimeseriesFormulaRequest;
/**
 * @ignore
 */
TimeseriesFormulaRequest.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "TimeseriesFormulaRequestAttributes",
        required: true,
    },
    type: {
        baseName: "type",
        type: "TimeseriesFormulaRequestType",
        required: true,
    },
};
//# sourceMappingURL=TimeseriesFormulaRequest.js.map

/***/ }),

/***/ 30379:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeseriesFormulaRequestAttributes = void 0;
/**
 * The object describing a timeseries formula request.
 */
class TimeseriesFormulaRequestAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return TimeseriesFormulaRequestAttributes.attributeTypeMap;
    }
}
exports.TimeseriesFormulaRequestAttributes = TimeseriesFormulaRequestAttributes;
/**
 * @ignore
 */
TimeseriesFormulaRequestAttributes.attributeTypeMap = {
    formulas: {
        baseName: "formulas",
        type: "Array<QueryFormula>",
    },
    from: {
        baseName: "from",
        type: "number",
        required: true,
        format: "int64",
    },
    interval: {
        baseName: "interval",
        type: "number",
        format: "int64",
    },
    queries: {
        baseName: "queries",
        type: "Array<TimeseriesQuery>",
        required: true,
    },
    to: {
        baseName: "to",
        type: "number",
        required: true,
        format: "int64",
    },
};
//# sourceMappingURL=TimeseriesFormulaRequestAttributes.js.map

/***/ }),

/***/ 83296:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeseriesResponse = void 0;
/**
 * A message containing the response to a timeseries query.
 */
class TimeseriesResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return TimeseriesResponse.attributeTypeMap;
    }
}
exports.TimeseriesResponse = TimeseriesResponse;
/**
 * @ignore
 */
TimeseriesResponse.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "TimeseriesResponseAttributes",
    },
    type: {
        baseName: "type",
        type: "TimeseriesFormulaResponseType",
    },
};
//# sourceMappingURL=TimeseriesResponse.js.map

/***/ }),

/***/ 11229:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeseriesResponseAttributes = void 0;
/**
 * The object describing a timeseries response.
 */
class TimeseriesResponseAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return TimeseriesResponseAttributes.attributeTypeMap;
    }
}
exports.TimeseriesResponseAttributes = TimeseriesResponseAttributes;
/**
 * @ignore
 */
TimeseriesResponseAttributes.attributeTypeMap = {
    series: {
        baseName: "series",
        type: "Array<TimeseriesResponseSeries>",
    },
    times: {
        baseName: "times",
        type: "Array<number>",
        format: "int64",
    },
    values: {
        baseName: "values",
        type: "Array<Array<number>>",
        format: "double",
    },
};
//# sourceMappingURL=TimeseriesResponseAttributes.js.map

/***/ }),

/***/ 46581:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeseriesResponseSeries = void 0;
/**

*/
class TimeseriesResponseSeries {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return TimeseriesResponseSeries.attributeTypeMap;
    }
}
exports.TimeseriesResponseSeries = TimeseriesResponseSeries;
/**
 * @ignore
 */
TimeseriesResponseSeries.attributeTypeMap = {
    groupTags: {
        baseName: "group_tags",
        type: "Array<string>",
    },
    queryIndex: {
        baseName: "query_index",
        type: "number",
        format: "int32",
    },
    unit: {
        baseName: "unit",
        type: "Array<Unit>",
    },
};
//# sourceMappingURL=TimeseriesResponseSeries.js.map

/***/ }),

/***/ 31458:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Unit = void 0;
/**
 * Object containing the metric unit family, scale factor, name, and short name.
 */
class Unit {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return Unit.attributeTypeMap;
    }
}
exports.Unit = Unit;
/**
 * @ignore
 */
Unit.attributeTypeMap = {
    family: {
        baseName: "family",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    plural: {
        baseName: "plural",
        type: "string",
    },
    scaleFactor: {
        baseName: "scale_factor",
        type: "number",
        format: "double",
    },
    shortName: {
        baseName: "short_name",
        type: "string",
    },
};
//# sourceMappingURL=Unit.js.map

/***/ }),

/***/ 87933:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageApplicationSecurityMonitoringResponse = void 0;
/**
 * Application Security Monitoring usage response.
 */
class UsageApplicationSecurityMonitoringResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageApplicationSecurityMonitoringResponse.attributeTypeMap;
    }
}
exports.UsageApplicationSecurityMonitoringResponse = UsageApplicationSecurityMonitoringResponse;
/**
 * @ignore
 */
UsageApplicationSecurityMonitoringResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<UsageDataObject>",
    },
};
//# sourceMappingURL=UsageApplicationSecurityMonitoringResponse.js.map

/***/ }),

/***/ 14031:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageAttributesObject = void 0;
/**
 * Usage attributes data.
 */
class UsageAttributesObject {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageAttributesObject.attributeTypeMap;
    }
}
exports.UsageAttributesObject = UsageAttributesObject;
/**
 * @ignore
 */
UsageAttributesObject.attributeTypeMap = {
    orgName: {
        baseName: "org_name",
        type: "string",
    },
    productFamily: {
        baseName: "product_family",
        type: "string",
    },
    publicId: {
        baseName: "public_id",
        type: "string",
    },
    timeseries: {
        baseName: "timeseries",
        type: "Array<UsageTimeSeriesObject>",
    },
    usageType: {
        baseName: "usage_type",
        type: "HourlyUsageType",
    },
};
//# sourceMappingURL=UsageAttributesObject.js.map

/***/ }),

/***/ 43595:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageDataObject = void 0;
/**
 * Usage data.
 */
class UsageDataObject {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageDataObject.attributeTypeMap;
    }
}
exports.UsageDataObject = UsageDataObject;
/**
 * @ignore
 */
UsageDataObject.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "UsageAttributesObject",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "UsageTimeSeriesType",
    },
};
//# sourceMappingURL=UsageDataObject.js.map

/***/ }),

/***/ 79017:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageLambdaTracedInvocationsResponse = void 0;
/**
 * Lambda Traced Invocations usage response.
 */
class UsageLambdaTracedInvocationsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageLambdaTracedInvocationsResponse.attributeTypeMap;
    }
}
exports.UsageLambdaTracedInvocationsResponse = UsageLambdaTracedInvocationsResponse;
/**
 * @ignore
 */
UsageLambdaTracedInvocationsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<UsageDataObject>",
    },
};
//# sourceMappingURL=UsageLambdaTracedInvocationsResponse.js.map

/***/ }),

/***/ 33947:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageObservabilityPipelinesResponse = void 0;
/**
 * Observability Pipelines usage response.
 */
class UsageObservabilityPipelinesResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageObservabilityPipelinesResponse.attributeTypeMap;
    }
}
exports.UsageObservabilityPipelinesResponse = UsageObservabilityPipelinesResponse;
/**
 * @ignore
 */
UsageObservabilityPipelinesResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<UsageDataObject>",
    },
};
//# sourceMappingURL=UsageObservabilityPipelinesResponse.js.map

/***/ }),

/***/ 11483:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsageTimeSeriesObject = void 0;
/**
 * Usage timeseries data.
 */
class UsageTimeSeriesObject {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsageTimeSeriesObject.attributeTypeMap;
    }
}
exports.UsageTimeSeriesObject = UsageTimeSeriesObject;
/**
 * @ignore
 */
UsageTimeSeriesObject.attributeTypeMap = {
    timestamp: {
        baseName: "timestamp",
        type: "Date",
        format: "date-time",
    },
    value: {
        baseName: "value",
        type: "number",
        format: "int64",
    },
};
//# sourceMappingURL=UsageTimeSeriesObject.js.map

/***/ }),

/***/ 47786:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.User = void 0;
/**
 * User object returned by the API.
 */
class User {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return User.attributeTypeMap;
    }
}
exports.User = User;
/**
 * @ignore
 */
User.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "UserAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    relationships: {
        baseName: "relationships",
        type: "UserResponseRelationships",
    },
    type: {
        baseName: "type",
        type: "UsersType",
    },
};
//# sourceMappingURL=User.js.map

/***/ }),

/***/ 42432:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserAttributes = void 0;
/**
 * Attributes of user object returned by the API.
 */
class UserAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UserAttributes.attributeTypeMap;
    }
}
exports.UserAttributes = UserAttributes;
/**
 * @ignore
 */
UserAttributes.attributeTypeMap = {
    createdAt: {
        baseName: "created_at",
        type: "Date",
        format: "date-time",
    },
    disabled: {
        baseName: "disabled",
        type: "boolean",
    },
    email: {
        baseName: "email",
        type: "string",
    },
    handle: {
        baseName: "handle",
        type: "string",
    },
    icon: {
        baseName: "icon",
        type: "string",
    },
    modifiedAt: {
        baseName: "modified_at",
        type: "Date",
        format: "date-time",
    },
    name: {
        baseName: "name",
        type: "string",
    },
    serviceAccount: {
        baseName: "service_account",
        type: "boolean",
    },
    status: {
        baseName: "status",
        type: "string",
    },
    title: {
        baseName: "title",
        type: "string",
    },
    verified: {
        baseName: "verified",
        type: "boolean",
    },
};
//# sourceMappingURL=UserAttributes.js.map

/***/ }),

/***/ 66656:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserCreateAttributes = void 0;
/**
 * Attributes of the created user.
 */
class UserCreateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UserCreateAttributes.attributeTypeMap;
    }
}
exports.UserCreateAttributes = UserCreateAttributes;
/**
 * @ignore
 */
UserCreateAttributes.attributeTypeMap = {
    email: {
        baseName: "email",
        type: "string",
        required: true,
    },
    name: {
        baseName: "name",
        type: "string",
    },
    title: {
        baseName: "title",
        type: "string",
    },
};
//# sourceMappingURL=UserCreateAttributes.js.map

/***/ }),

/***/ 66646:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserCreateData = void 0;
/**
 * Object to create a user.
 */
class UserCreateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UserCreateData.attributeTypeMap;
    }
}
exports.UserCreateData = UserCreateData;
/**
 * @ignore
 */
UserCreateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "UserCreateAttributes",
        required: true,
    },
    relationships: {
        baseName: "relationships",
        type: "UserRelationships",
    },
    type: {
        baseName: "type",
        type: "UsersType",
        required: true,
    },
};
//# sourceMappingURL=UserCreateData.js.map

/***/ }),

/***/ 87642:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserCreateRequest = void 0;
/**
 * Create a user.
 */
class UserCreateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UserCreateRequest.attributeTypeMap;
    }
}
exports.UserCreateRequest = UserCreateRequest;
/**
 * @ignore
 */
UserCreateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "UserCreateData",
        required: true,
    },
};
//# sourceMappingURL=UserCreateRequest.js.map

/***/ }),

/***/ 77954:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserInvitationData = void 0;
/**
 * Object to create a user invitation.
 */
class UserInvitationData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UserInvitationData.attributeTypeMap;
    }
}
exports.UserInvitationData = UserInvitationData;
/**
 * @ignore
 */
UserInvitationData.attributeTypeMap = {
    relationships: {
        baseName: "relationships",
        type: "UserInvitationRelationships",
        required: true,
    },
    type: {
        baseName: "type",
        type: "UserInvitationsType",
        required: true,
    },
};
//# sourceMappingURL=UserInvitationData.js.map

/***/ }),

/***/ 3798:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserInvitationDataAttributes = void 0;
/**
 * Attributes of a user invitation.
 */
class UserInvitationDataAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UserInvitationDataAttributes.attributeTypeMap;
    }
}
exports.UserInvitationDataAttributes = UserInvitationDataAttributes;
/**
 * @ignore
 */
UserInvitationDataAttributes.attributeTypeMap = {
    createdAt: {
        baseName: "created_at",
        type: "Date",
        format: "date-time",
    },
    expiresAt: {
        baseName: "expires_at",
        type: "Date",
        format: "date-time",
    },
    inviteType: {
        baseName: "invite_type",
        type: "string",
    },
    uuid: {
        baseName: "uuid",
        type: "string",
    },
};
//# sourceMappingURL=UserInvitationDataAttributes.js.map

/***/ }),

/***/ 18252:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserInvitationRelationships = void 0;
/**
 * Relationships data for user invitation.
 */
class UserInvitationRelationships {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UserInvitationRelationships.attributeTypeMap;
    }
}
exports.UserInvitationRelationships = UserInvitationRelationships;
/**
 * @ignore
 */
UserInvitationRelationships.attributeTypeMap = {
    user: {
        baseName: "user",
        type: "RelationshipToUser",
        required: true,
    },
};
//# sourceMappingURL=UserInvitationRelationships.js.map

/***/ }),

/***/ 14586:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserInvitationResponse = void 0;
/**
 * User invitation as returned by the API.
 */
class UserInvitationResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UserInvitationResponse.attributeTypeMap;
    }
}
exports.UserInvitationResponse = UserInvitationResponse;
/**
 * @ignore
 */
UserInvitationResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "UserInvitationResponseData",
    },
};
//# sourceMappingURL=UserInvitationResponse.js.map

/***/ }),

/***/ 35653:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserInvitationResponseData = void 0;
/**
 * Object of a user invitation returned by the API.
 */
class UserInvitationResponseData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UserInvitationResponseData.attributeTypeMap;
    }
}
exports.UserInvitationResponseData = UserInvitationResponseData;
/**
 * @ignore
 */
UserInvitationResponseData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "UserInvitationDataAttributes",
    },
    id: {
        baseName: "id",
        type: "string",
    },
    type: {
        baseName: "type",
        type: "UserInvitationsType",
    },
};
//# sourceMappingURL=UserInvitationResponseData.js.map

/***/ }),

/***/ 89585:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserInvitationsRequest = void 0;
/**
 * Object to invite users to join the organization.
 */
class UserInvitationsRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UserInvitationsRequest.attributeTypeMap;
    }
}
exports.UserInvitationsRequest = UserInvitationsRequest;
/**
 * @ignore
 */
UserInvitationsRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<UserInvitationData>",
        required: true,
    },
};
//# sourceMappingURL=UserInvitationsRequest.js.map

/***/ }),

/***/ 49353:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserInvitationsResponse = void 0;
/**
 * User invitations as returned by the API.
 */
class UserInvitationsResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UserInvitationsResponse.attributeTypeMap;
    }
}
exports.UserInvitationsResponse = UserInvitationsResponse;
/**
 * @ignore
 */
UserInvitationsResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<UserInvitationResponseData>",
    },
};
//# sourceMappingURL=UserInvitationsResponse.js.map

/***/ }),

/***/ 58125:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserRelationships = void 0;
/**
 * Relationships of the user object.
 */
class UserRelationships {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UserRelationships.attributeTypeMap;
    }
}
exports.UserRelationships = UserRelationships;
/**
 * @ignore
 */
UserRelationships.attributeTypeMap = {
    roles: {
        baseName: "roles",
        type: "RelationshipToRoles",
    },
};
//# sourceMappingURL=UserRelationships.js.map

/***/ }),

/***/ 18779:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserResponse = void 0;
/**
 * Response containing information about a single user.
 */
class UserResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UserResponse.attributeTypeMap;
    }
}
exports.UserResponse = UserResponse;
/**
 * @ignore
 */
UserResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "User",
    },
    included: {
        baseName: "included",
        type: "Array<UserResponseIncludedItem>",
    },
};
//# sourceMappingURL=UserResponse.js.map

/***/ }),

/***/ 20157:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserResponseRelationships = void 0;
/**
 * Relationships of the user object returned by the API.
 */
class UserResponseRelationships {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UserResponseRelationships.attributeTypeMap;
    }
}
exports.UserResponseRelationships = UserResponseRelationships;
/**
 * @ignore
 */
UserResponseRelationships.attributeTypeMap = {
    org: {
        baseName: "org",
        type: "RelationshipToOrganization",
    },
    otherOrgs: {
        baseName: "other_orgs",
        type: "RelationshipToOrganizations",
    },
    otherUsers: {
        baseName: "other_users",
        type: "RelationshipToUsers",
    },
    roles: {
        baseName: "roles",
        type: "RelationshipToRoles",
    },
};
//# sourceMappingURL=UserResponseRelationships.js.map

/***/ }),

/***/ 68822:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2020-Present Datadog, Inc.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserUpdateAttributes = void 0;
/**
 * Attributes of the edited user.
 */
class UserUpdateAttributes {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UserUpdateAttributes.attributeTypeMap;
    }
}
exports.UserUpdateAttributes = UserUpdateAttributes;
/**
 * @ignore
 */
UserUpdateAttributes.attributeTypeMap = {
    disabled: {
        baseName: "disabled",
        type: "boolean",
    },
    email: {
        baseName: "email",
        type: "string",
    },
    name: {
        baseName: "name",
        type: "string",
    },
};
//# sourceMappingURL=UserUpdateAttributes.js.map

/***/ }),

/***/ 21330:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserUpdateData = void 0;
/**
 * Object to update a user.
 */
class UserUpdateData {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UserUpdateData.attributeTypeMap;
    }
}
exports.UserUpdateData = UserUpdateData;
/**
 * @ignore
 */
UserUpdateData.attributeTypeMap = {
    attributes: {
        baseName: "attributes",
        type: "UserUpdateAttributes",
        required: true,
    },
    id: {
        baseName: "id",
        type: "string",
        required: true,
    },
    type: {
        baseName: "type",
        type: "UsersType",
        required: true,
    },
};
//# sourceMappingURL=UserUpdateData.js.map

/***/ }),

/***/ 59906:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserUpdateRequest = void 0;
/**
 * Update a user.
 */
class UserUpdateRequest {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UserUpdateRequest.attributeTypeMap;
    }
}
exports.UserUpdateRequest = UserUpdateRequest;
/**
 * @ignore
 */
UserUpdateRequest.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "UserUpdateData",
        required: true,
    },
};
//# sourceMappingURL=UserUpdateRequest.js.map

/***/ }),

/***/ 18577:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersResponse = void 0;
/**
 * Response containing information about multiple users.
 */
class UsersResponse {
    constructor() { }
    /**
     * @ignore
     */
    static getAttributeTypeMap() {
        return UsersResponse.attributeTypeMap;
    }
}
exports.UsersResponse = UsersResponse;
/**
 * @ignore
 */
UsersResponse.attributeTypeMap = {
    data: {
        baseName: "data",
        type: "Array<User>",
    },
    included: {
        baseName: "included",
        type: "Array<UserResponseIncludedItem>",
    },
    meta: {
        baseName: "meta",
        type: "ResponseMetaAttributes",
    },
};
//# sourceMappingURL=UsersResponse.js.map

/***/ }),

/***/ 55180:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.userAgent = void 0;
const version_1 = __webpack_require__(87920);
if (typeof process !== 'undefined' && process.release && process.release.name === 'node') {
    exports.userAgent = `datadog-api-client-typescript/${version_1.version} (node ${process.versions.node}; os ${process.platform}; arch ${process.arch})`;
}
else if (typeof window !== "undefined" && typeof window.document !== "undefined") {
    // we don't set user-agent headers in browsers
}
else {
    exports.userAgent = `datadog-api-client-typescript/${version_1.version} (runtime unknown)`;
}
//# sourceMappingURL=userAgent.js.map

/***/ }),

/***/ 87920:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = "1.9.0";
//# sourceMappingURL=version.js.map

/***/ }),

/***/ 93018:
/***/ ((module) => {

/* eslint-disable node/no-deprecated-api */

var toString = Object.prototype.toString

var isModern = (
  typeof Buffer !== 'undefined' &&
  typeof Buffer.alloc === 'function' &&
  typeof Buffer.allocUnsafe === 'function' &&
  typeof Buffer.from === 'function'
)

function isArrayBuffer (input) {
  return toString.call(input).slice(8, -1) === 'ArrayBuffer'
}

function fromArrayBuffer (obj, byteOffset, length) {
  byteOffset >>>= 0

  var maxLength = obj.byteLength - byteOffset

  if (maxLength < 0) {
    throw new RangeError("'offset' is out of bounds")
  }

  if (length === undefined) {
    length = maxLength
  } else {
    length >>>= 0

    if (length > maxLength) {
      throw new RangeError("'length' is out of bounds")
    }
  }

  return isModern
    ? Buffer.from(obj.slice(byteOffset, byteOffset + length))
    : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)))
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  return isModern
    ? Buffer.from(string, encoding)
    : new Buffer(string, encoding)
}

function bufferFrom (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return isModern
    ? Buffer.from(value)
    : new Buffer(value)
}

module.exports = bufferFrom


/***/ }),

/***/ 64334:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var CombinedStream = __webpack_require__(85443);
var util = __webpack_require__(73837);
var path = __webpack_require__(71017);
var http = __webpack_require__(13685);
var https = __webpack_require__(95687);
var parseUrl = (__webpack_require__(57310).parse);
var fs = __webpack_require__(57147);
var mime = __webpack_require__(43583);
var asynckit = __webpack_require__(14812);
var populate = __webpack_require__(17142);

// Public API
module.exports = FormData;

// make it a Stream
util.inherits(FormData, CombinedStream);

/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
 */
function FormData(options) {
  if (!(this instanceof FormData)) {
    return new FormData(options);
  }

  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];

  CombinedStream.call(this);

  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}

FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

FormData.prototype.append = function(field, value, options) {

  options = options || {};

  // allow filename as single option
  if (typeof options == 'string') {
    options = {filename: options};
  }

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value == 'number') {
    value = '' + value;
  }

  // https://github.com/felixge/node-form-data/issues/38
  if (util.isArray(value)) {
    // Please convert your array into string
    // the way web server expects it
    this._error(new Error('Arrays are not supported.'));
    return;
  }

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;

  // used w/ getLengthSync(), when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header) +
    FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response
  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {
    return;
  }

  // no need to bother with the length
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};

FormData.prototype._lengthRetriever = function(value, callback) {

  if (value.hasOwnProperty('fd')) {

    // take read range into a account
    // `end` = Infinity > read file till the end
    //
    // TODO: Looks like there is bug in Node fs.createReadStream
    // it doesn't respect `end` options without `start` options
    // Fix it when node fixes it.
    // https://github.com/joyent/node/issues/7819
    if (value.end != undefined && value.end != Infinity && value.start != undefined) {

      // when end specified
      // no need to calculate range
      // inclusive, starts with 0
      callback(null, value.end + 1 - (value.start ? value.start : 0));

    // not that fast snoopy
    } else {
      // still need to fetch file size from fs
      fs.stat(value.path, function(err, stat) {

        var fileSize;

        if (err) {
          callback(err);
          return;
        }

        // update final size based on the range options
        fileSize = stat.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }

  // or http response
  } else if (value.hasOwnProperty('httpVersion')) {
    callback(null, +value.headers['content-length']);

  // or request stream http://github.com/mikeal/request
  } else if (value.hasOwnProperty('httpModule')) {
    // wait till response come back
    value.on('response', function(response) {
      value.pause();
      callback(null, +response.headers['content-length']);
    });
    value.resume();

  // something else
  } else {
    callback('Unknown stream');
  }
};

FormData.prototype._multiPartHeader = function(field, value, options) {
  // custom header specified (as string)?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers)
  if (typeof options.header == 'string') {
    return options.header;
  }

  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);

  var contents = '';
  var headers  = {
    // add custom disposition as third element or keep it two elements if not
    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
    // if no content type. allow it to be empty array
    'Content-Type': [].concat(contentType || [])
  };

  // allow custom headers.
  if (typeof options.header == 'object') {
    populate(headers, options.header);
  }

  var header;
  for (var prop in headers) {
    if (!headers.hasOwnProperty(prop)) continue;
    header = headers[prop];

    // skip nullish headers.
    if (header == null) {
      continue;
    }

    // convert all headers to arrays.
    if (!Array.isArray(header)) {
      header = [header];
    }

    // add non-empty headers.
    if (header.length) {
      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
    }
  }

  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};

FormData.prototype._getContentDisposition = function(value, options) {

  var filename
    , contentDisposition
    ;

  if (typeof options.filepath === 'string') {
    // custom filepath for relative paths
    filename = path.normalize(options.filepath).replace(/\\/g, '/');
  } else if (options.filename || value.name || value.path) {
    // custom filename take precedence
    // formidable and the browser add a name property
    // fs- and request- streams have path property
    filename = path.basename(options.filename || value.name || value.path);
  } else if (value.readable && value.hasOwnProperty('httpVersion')) {
    // or try http response
    filename = path.basename(value.client._httpMessage.path || '');
  }

  if (filename) {
    contentDisposition = 'filename="' + filename + '"';
  }

  return contentDisposition;
};

FormData.prototype._getContentType = function(value, options) {

  // use custom content-type above all
  var contentType = options.contentType;

  // or try `name` from formidable, browser
  if (!contentType && value.name) {
    contentType = mime.lookup(value.name);
  }

  // or try `path` from fs-, request- streams
  if (!contentType && value.path) {
    contentType = mime.lookup(value.path);
  }

  // or if it's http-reponse
  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {
    contentType = value.headers['content-type'];
  }

  // or guess it from the filepath or filename
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename);
  }

  // fallback to the default content type if `value` is not simple value
  if (!contentType && typeof value == 'object') {
    contentType = FormData.DEFAULT_CONTENT_TYPE;
  }

  return contentType;
};

FormData.prototype._multiPartFooter = function() {
  return function(next) {
    var footer = FormData.LINE_BREAK;

    var lastPart = (this._streams.length === 0);
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function() {
  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};

FormData.prototype.getHeaders = function(userHeaders) {
  var header;
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (header in userHeaders) {
    if (userHeaders.hasOwnProperty(header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }

  return formHeaders;
};

FormData.prototype.setBoundary = function(boundary) {
  this._boundary = boundary;
};

FormData.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData.prototype.getBuffer = function() {
  var dataBuffer = new Buffer.alloc( 0 );
  var boundary = this.getBoundary();

  // Create the form content. Add Line breaks to the end of data.
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== 'function') {

      // Add content to the buffer.
      if(Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);
      }else {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);
      }

      // Add break after content.
      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );
      }
    }
  }

  // Add the footer and return the Buffer object.
  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );
};

FormData.prototype._generateBoundary = function() {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually
// and add it as knownLength option
FormData.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;

  // Don't get confused, there are 3 "internal" streams for each keyval pair
  // so it basically checks if there is any value added to the form
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  // https://github.com/form-data/form-data/issues/40
  if (!this.hasKnownLength()) {
    // Some async length retrievers are present
    // therefore synchronous length calculation is false.
    // Please use getLength(callback) to get proper length
    this._error(new Error('Cannot calculate proper length in synchronous way.'));
  }

  return knownLength;
};

// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function() {
  var hasKnownLength = true;

  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }

  return hasKnownLength;
};

FormData.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function(length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData.prototype.submit = function(params, cb) {
  var request
    , options
    , defaults = {method: 'post'}
    ;

  // parse provided url if it's string
  // or treat it as options object
  if (typeof params == 'string') {

    params = parseUrl(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults);

  // use custom params
  } else {

    options = populate(params, defaults);
    // if no port provided use default one
    if (!options.port) {
      options.port = options.protocol == 'https:' ? 443 : 80;
    }
  }

  // put that good code in getHeaders to some use
  options.headers = this.getHeaders(params.headers);

  // https if specified, fallback to http in any other case
  if (options.protocol == 'https:') {
    request = https.request(options);
  } else {
    request = http.request(options);
  }

  // get content length and fire away
  this.getLength(function(err, length) {
    if (err) {
      this._error(err);
      return;
    }

    // add content length
    request.setHeader('Content-Length', length);

    this.pipe(request);
    if (cb) {
      var onResponse;

      var callback = function (error, responce) {
        request.removeListener('error', callback);
        request.removeListener('response', onResponse);

        return cb.call(this, error, responce);
      };

      onResponse = callback.bind(this, null);

      request.on('error', callback);
      request.on('response', onResponse);
    }
  }.bind(this));

  return request;
};

FormData.prototype._error = function(err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit('error', err);
  }
};

FormData.prototype.toString = function () {
  return '[object FormData]';
};


/***/ }),

/***/ 17142:
/***/ ((module) => {

// populates missing values
module.exports = function(dst, src) {

  Object.keys(src).forEach(function(prop)
  {
    dst[prop] = dst[prop] || src[prop];
  });

  return dst;
};


/***/ }),

/***/ 78063:
/***/ (function(module) {

/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (typeof define === 'function' && define.amd) {
        define(definition);
    } else if ( true && module.exports) {
        module.exports = definition();
    } else {
        root.log = definition();
    }
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      defaultLevel = defaultLevel == null ? "WARN" : defaultLevel;

      var storageKey = "loglevel";
      if (typeof name === "string") {
        storageKey += ":" + name;
      } else if (typeof name === "symbol") {
        storageKey = undefined;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType || !storageKey) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType || !storageKey) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey) return;

          // Use localStorage if available
          try {
              window.localStorage.removeItem(storageKey);
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {}
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          defaultLevel = level;
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.resetLevel = function () {
          self.setLevel(defaultLevel, false);
          clearPersistedLevel();
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if ((typeof name !== "symbol" && typeof name !== "string") || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    // ES6 default export, for compatibility
    defaultLogger['default'] = defaultLogger;

    return defaultLogger;
}));


/***/ }),

/***/ 31726:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Top level file is just a mixin of submodules & constants


const { Deflate, deflate, deflateRaw, gzip } = __webpack_require__(17265);

const { Inflate, inflate, inflateRaw, ungzip } = __webpack_require__(96522);

const constants = __webpack_require__(58282);

module.exports.Deflate = Deflate;
module.exports.deflate = deflate;
module.exports.deflateRaw = deflateRaw;
module.exports.gzip = gzip;
module.exports.Inflate = Inflate;
module.exports.inflate = inflate;
module.exports.inflateRaw = inflateRaw;
module.exports.ungzip = ungzip;
module.exports.constants = constants;


/***/ }),

/***/ 17265:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



const zlib_deflate = __webpack_require__(70978);
const utils        = __webpack_require__(5483);
const strings      = __webpack_require__(42380);
const msg          = __webpack_require__(1890);
const ZStream      = __webpack_require__(86442);

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED
} = __webpack_require__(58282);

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});

  let opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  let status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    let dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must
 * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
 * buffers and call [[Deflate#onEnd]].
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;

  if (this.ended) { return false; }

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    // Make sure avail_out > 6 to avoid repeating markers
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    status = zlib_deflate.deflate(strm, _flush_mode);

    // Ended => flush and finish
    if (status === Z_STREAM_END) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }

    // Flush if out buffer full
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }

    // Flush if requested and has data
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array): output data.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    this.result = utils.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  const deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


module.exports.Deflate = Deflate;
module.exports.deflate = deflate;
module.exports.deflateRaw = deflateRaw;
module.exports.gzip = gzip;
module.exports.constants = __webpack_require__(58282);


/***/ }),

/***/ 96522:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";



const zlib_inflate = __webpack_require__(90409);
const utils        = __webpack_require__(5483);
const strings      = __webpack_require__(42380);
const msg          = __webpack_require__(1890);
const ZStream      = __webpack_require__(86442);
const GZheader     = __webpack_require__(35105);

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR
} = __webpack_require__(58282);

/* ===========================================================================*/


/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  this.options = utils.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ''
  }, options || {});

  const opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  let status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer): input data
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
 *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
 *   `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. If end of stream detected,
 * [[Inflate#onEnd]] will be called.
 *
 * `flush_mode` is not needed for normal operation, because end of stream
 * detected automatically. You may try to use it for advanced things, but
 * this functionality was not tested.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;

  if (this.ended) return false;

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, _flush_mode);

    if (status === Z_NEED_DICT && dictionary) {
      status = zlib_inflate.inflateSetDictionary(strm, dictionary);

      if (status === Z_OK) {
        status = zlib_inflate.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        // Replace code with more verbose
        status = Z_NEED_DICT;
      }
    }

    // Skip snyc markers if more data follows and not raw mode
    while (strm.avail_in > 0 &&
           status === Z_STREAM_END &&
           strm.state.wrap > 0 &&
           data[strm.next_in] !== 0)
    {
      zlib_inflate.inflateReset(strm);
      status = zlib_inflate.inflate(strm, _flush_mode);
    }

    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }

    // Remember real `avail_out` value, because we may patch out buffer content
    // to align utf8 strings boundaries.
    last_avail_out = strm.avail_out;

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {

        if (this.options.to === 'string') {

          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail & realign counters
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

          this.onData(utf8str);

        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }

    // Must repeat iteration if out buffer is full
    if (status === Z_OK && last_avail_out === 0) continue;

    // Finalize if end of stream reached.
    if (status === Z_STREAM_END) {
      status = zlib_inflate.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|String): output data. When string output requested,
 *   each chunk will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako');
 * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
 * let output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err) {
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  const inflator = new Inflate(options);

  inflator.push(input);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) throw inflator.msg || msg[inflator.err];

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


module.exports.Inflate = Inflate;
module.exports.inflate = inflate;
module.exports.inflateRaw = inflateRaw;
module.exports.ungzip = inflate;
module.exports.constants = __webpack_require__(58282);


/***/ }),

/***/ 5483:
/***/ ((module) => {

"use strict";



const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

module.exports.assign = function (obj /*from1, from2, from3, ...*/) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// Join array of chunks to single array.
module.exports.flattenChunks = (chunks) => {
  // calculate data length
  let len = 0;

  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  const result = new Uint8Array(len);

  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }

  return result;
};


/***/ }),

/***/ 42380:
/***/ ((module) => {

"use strict";
// String encode/decode helpers



// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
let STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
module.exports.string2buf = (str) => {
  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }

  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new Uint8Array(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper
const buf2binstring = (buf, len) => {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }

  let result = '';
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};


// convert array to string
module.exports.buf2string = (buf, max) => {
  const len = max || buf.length;

  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }

  let i, out;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  const utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    let c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    let c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
module.exports.utf8border = (buf, max) => {

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};


/***/ }),

/***/ 86924:
/***/ ((module) => {

"use strict";


// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32 = (adler, buf, len, pos) => {
  let s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
};


module.exports = adler32;


/***/ }),

/***/ 58282:
/***/ ((module) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  Z_MEM_ERROR:       -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};


/***/ }),

/***/ 87242:
/***/ ((module) => {

"use strict";


// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
const makeTable = () => {
  let c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
};

// Create table on load. Just 255 signed longs. Not a problem.
const crcTable = new Uint32Array(makeTable());


const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;

  crc ^= -1;

  for (let i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
};


module.exports = crc32;


/***/ }),

/***/ 70978:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = __webpack_require__(78754);
const adler32 = __webpack_require__(86924);
const crc32   = __webpack_require__(87242);
const msg     = __webpack_require__(1890);

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_PARTIAL_FLUSH, Z_FULL_FLUSH, Z_FINISH, Z_BLOCK,
  Z_OK, Z_STREAM_END, Z_STREAM_ERROR, Z_DATA_ERROR, Z_BUF_ERROR,
  Z_DEFAULT_COMPRESSION,
  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY,
  Z_UNKNOWN,
  Z_DEFLATED
} = __webpack_require__(58282);

/*============================================================================*/


const MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_MEM_LEVEL = 8;


const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
const LITERALS      = 256;
/* number of literal bytes 0..255 */
const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
const D_CODES       = 30;
/* number of distance codes */
const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
const MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

const PRESET_DICT = 0x20;

const INIT_STATE    =  42;    /* zlib header -> BUSY_STATE */
//#ifdef GZIP
const GZIP_STATE    =  57;    /* gzip header -> BUSY_STATE | EXTRA_STATE */
//#endif
const EXTRA_STATE   =  69;    /* gzip extra block -> NAME_STATE */
const NAME_STATE    =  73;    /* gzip file name -> COMMENT_STATE */
const COMMENT_STATE =  91;    /* gzip comment -> HCRC_STATE */
const HCRC_STATE    = 103;    /* gzip header CRC -> BUSY_STATE */
const BUSY_STATE    = 113;    /* deflate -> FINISH_STATE */
const FINISH_STATE  = 666;    /* stream complete */

const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
const BS_BLOCK_DONE     = 2; /* block flush performed */
const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

const err = (strm, errorCode) => {
  strm.msg = msg[errorCode];
  return errorCode;
};

const rank = (f) => {
  return ((f) * 2) - ((f) > 4 ? 9 : 0);
};

const zero = (buf) => {
  let len = buf.length; while (--len >= 0) { buf[len] = 0; }
};

/* ===========================================================================
 * Slide the hash table when sliding the window down (could be avoided with 32
 * bit values at the expense of memory usage). We slide even when level == 0 to
 * keep the hash table consistent if we switch back to level > 0 later.
 */
const slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;

  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = (m >= wsize ? m - wsize : 0);
  } while (--n);
  n = wsize;
//#ifndef FASTEST
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = (m >= wsize ? m - wsize : 0);
    /* If n is not on any hash chain, prev[n] is garbage but
     * its value will never be used.
     */
  } while (--n);
//#endif
};

/* eslint-disable new-cap */
let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;
// This hash causes less collisions, https://github.com/nodeca/pako/issues/135
// But breaks binary compatibility
//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
let HASH = HASH_ZLIB;


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output, except for
 * some deflate_stored() output, goes through this function so some
 * applications may wish to modify it to avoid allocating a large
 * strm->next_out buffer and copying into it. (See also read_buf()).
 */
const flush_pending = (strm) => {
  const s = strm.state;

  //_tr_flush_bits(s);
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out  += len;
  s.pending_out  += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending      -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};


const flush_block_only = (s, last) => {
  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};


const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
const putShortMSB = (s, b) => {

  //  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
};


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
const read_buf = (strm, buf, start, size) => {

  let len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
};


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
const longest_match = (s, cur_match) => {

  let chain_length = s.max_chain_length;      /* max hash chain length */
  let scan = s.strstart; /* current string */
  let match;                       /* matched string */
  let len;                           /* length of current match */
  let best_len = s.prev_length;              /* best match length so far */
  let nice_match = s.nice_match;             /* stop if match long enough */
  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  const _win = s.window; // shortcut

  const wmask = s.w_mask;
  const prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  const strend = s.strstart + MAX_MATCH;
  let scan_end1  = _win[scan + best_len - 1];
  let scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
const fill_window = (s) => {

  const _w_size = s.w_size;
  let n, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    const curr = s.strstart + s.lookahead;
//    let init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
};

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 *
 * In case deflateParams() is used to later switch to a non-zero compression
 * level, s->matches (otherwise unused when storing) keeps track of the number
 * of hash table slides to perform. If s->matches is 1, then one hash table
 * slide will be done when switching. If s->matches is 2, the maximum value
 * allowed here, then the hash table will be cleared, since two or more slides
 * is the same as a clear.
 *
 * deflate_stored() is written to minimize the number of times an input byte is
 * copied. It is most efficient with large input and output buffers, which
 * maximizes the opportunites to have a single copy from next_in to next_out.
 */
const deflate_stored = (s, flush) => {

  /* Smallest worthy block size when not flushing or finishing. By default
   * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
   * large input and output buffers, the stored block size will be larger.
   */
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;

  /* Copy as many min_block or larger stored blocks directly to next_out as
   * possible. If flushing, copy the remaining available input to next_out as
   * stored blocks, if there is enough space.
   */
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    /* Set len to the maximum size block that we can copy directly with the
     * available input data and output space. Set left to how much of that
     * would be copied from what's left in the window.
     */
    len = 65535/* MAX_STORED */;     /* maximum deflate stored block length */
    have = (s.bi_valid + 42) >> 3;     /* number of header bytes */
    if (s.strm.avail_out < have) {         /* need room for header */
      break;
    }
      /* maximum stored block length that will fit in avail_out: */
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;  /* bytes left in window */
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;   /* limit len to the input */
    }
    if (len > have) {
      len = have;             /* limit len to the output */
    }

    /* If the stored block would be less than min_block in length, or if
     * unable to copy all of the available input when flushing, then try
     * copying to the window and the pending buffer instead. Also don't
     * write an empty block when flushing -- deflate() does that.
     */
    if (len < min_block && ((len === 0 && flush !== Z_FINISH) ||
                        flush === Z_NO_FLUSH ||
                        len !== left + s.strm.avail_in)) {
      break;
    }

    /* Make a dummy stored block in pending to get the header bytes,
     * including any pending bits. This also updates the debugging counts.
     */
    last = flush === Z_FINISH && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);

    /* Replace the lengths in the dummy stored block with len. */
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;

    /* Write the stored block header bytes. */
    flush_pending(s.strm);

//#ifdef ZLIB_DEBUG
//    /* Update debugging counts for the data about to be copied. */
//    s->compressed_len += len << 3;
//    s->bits_sent += len << 3;
//#endif

    /* Copy uncompressed bytes from the window to next_out. */
    if (left) {
      if (left > len) {
        left = len;
      }
      //zmemcpy(s->strm->next_out, s->window + s->block_start, left);
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }

    /* Copy uncompressed bytes directly from next_in to next_out, updating
     * the check value.
     */
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);

  /* Update the sliding window with the last s->w_size bytes of the copied
   * data, or append all of the copied data to the existing window if less
   * than s->w_size bytes were copied. Also update the number of bytes to
   * insert in the hash tables, in the event that deflateParams() switches to
   * a non-zero compression level.
   */
  used -= s.strm.avail_in;    /* number of input bytes directly copied */
  if (used) {
    /* If any input was used, then no unused input remains in the window,
     * therefore s->block_start == s->strstart.
     */
    if (used >= s.w_size) {  /* supplant the previous history */
      s.matches = 2;     /* clear hash */
      //zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    }
    else {
      if (s.window_size - s.strstart <= used) {
        /* Slide the window down. */
        s.strstart -= s.w_size;
        //zmemcpy(s->window, s->window + s->w_size, s->strstart);
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;   /* add a pending slide_hash() */
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      //zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }

  /* If the last block was written to next_out, then done. */
  if (last) {
    return BS_FINISH_DONE;
  }

  /* If flushing and all input has been consumed, then done. */
  if (flush !== Z_NO_FLUSH && flush !== Z_FINISH &&
    s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }

  /* Fill the window with any remaining input. */
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    /* Slide the window down. */
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    //zmemcpy(s->window, s->window + s->w_size, s->strstart);
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;       /* add a pending slide_hash() */
    }
    have += s.w_size;      /* more space now */
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }

  /* There was not enough avail_out to write a complete worthy or flushed
   * stored block to next_out. Write a stored block to pending instead, if we
   * have enough input for a worthy block, or if flushing and there is enough
   * room for the remaining input as a stored block in the pending buffer.
   */
  have = (s.bi_valid + 42) >> 3;     /* number of header bytes */
    /* maximum stored block length that will fit in pending: */
  have = s.pending_buf_size - have > 65535/* MAX_STORED */ ? 65535/* MAX_STORED */ : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block ||
     ((left || flush === Z_FINISH) && flush !== Z_NO_FLUSH &&
     s.strm.avail_in === 0 && left <= have)) {
    len = left > have ? have : left;
    last = flush === Z_FINISH && s.strm.avail_in === 0 &&
         len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }

  /* We've done all we can with the available input and output. */
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};


/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
const deflate_fast = (s, flush) => {

  let hash_head;        /* head of the hash chain */
  let bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
const deflate_slow = (s, flush) => {

  let hash_head;          /* head of hash chain */
  let bflush;              /* set if current block must be flushed */

  let max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
};


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
const deflate_rle = (s, flush) => {

  let bflush;            /* set if current block must be flushed */
  let prev;              /* byte at distance one to match */
  let scan, strend;      /* scan goes up to strend for length of run */

  const _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
const deflate_huff = (s, flush) => {

  let bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {

  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
const lm_init = (s) => {

  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.sym_buf = 0;        /* buffer for distances and literals/lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.sym_next = 0;      /* running index in sym_buf */
  this.sym_end = 0;       /* symbol table full when sym_next reaches this */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


/* =========================================================================
 * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
 */
const deflateStateCheck = (strm) => {

  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || (s.status !== INIT_STATE &&
//#ifdef GZIP
                                s.status !== GZIP_STATE &&
//#endif
                                s.status !== EXTRA_STATE &&
                                s.status !== NAME_STATE &&
                                s.status !== COMMENT_STATE &&
                                s.status !== HCRC_STATE &&
                                s.status !== BUSY_STATE &&
                                s.status !== FINISH_STATE)) {
    return 1;
  }
  return 0;
};


const deflateResetKeep = (strm) => {

  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status =
//#ifdef GZIP
    s.wrap === 2 ? GZIP_STATE :
//#endif
    s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK;
};


const deflateReset = (strm) => {

  const ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
};


const deflateSetHeader = (strm, head) => {

  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR;
  }
  strm.state.gzhead = head;
  return Z_OK;
};


const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {

  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  let wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED || (windowBits === 8 && wrap !== 1)) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  const s = new DeflateState();

  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;     /* to pass state test in deflateReset() */

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  /* We overlay pending_buf and sym_buf. This works since the average size
   * for length/distance pairs over any compressed block is assured to be 31
   * bits or less.
   *
   * Analysis: The longest fixed codes are a length code of 8 bits plus 5
   * extra bits, for lengths 131 to 257. The longest fixed distance codes are
   * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest
   * possible fixed-codes length/distance pair is then 31 bits total.
   *
   * sym_buf starts one-fourth of the way into pending_buf. So there are
   * three bytes in sym_buf for every four bytes in pending_buf. Each symbol
   * in sym_buf is three bytes -- two for the distance and one for the
   * literal/length. As each symbol is consumed, the pointer to the next
   * sym_buf value to read moves forward three bytes. From that symbol, up to
   * 31 bits are written to pending_buf. The closest the written pending_buf
   * bits gets to the next sym_buf symbol to read is just before the last
   * code is written. At that time, 31*(n-2) bits have been written, just
   * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at
   * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1
   * symbols are written.) The closest the writing gets to what is unread is
   * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and
   * can range from 128 to 32768.
   *
   * Therefore, at a minimum, there are 142 bits of space between what is
   * written and what is read in the overlain buffers, so the symbols cannot
   * be overwritten by the compressed data. That space is actually 139 bits,
   * due to the three-bit fixed-code block header.
   *
   * That covers the case where either Z_FIXED is specified, forcing fixed
   * codes, or when the use of fixed codes is chosen, because that choice
   * results in a smaller compressed block than dynamic codes. That latter
   * condition then assures that the above analysis also covers all dynamic
   * blocks. A dynamic-code block will only be chosen to be emitted if it has
   * fewer bits than a fixed-code block would for the same set of symbols.
   * Therefore its average symbol length is assured to be less than 31. So
   * the compressed data for a dynamic block also cannot overwrite the
   * symbols from which it is being constructed.
   */

  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->sym_buf = s->pending_buf + s->lit_bufsize;
  s.sym_buf = s.lit_bufsize;

  //s->sym_end = (s->lit_bufsize - 1) * 3;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  /* We avoid equality with lit_bufsize*3 because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
};

const deflateInit = (strm, level) => {

  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
};


/* ========================================================================= */
const deflate = (strm, flush) => {

  if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  const s = strm.state;

  if (!strm.output ||
      (strm.avail_in !== 0 && !strm.input) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  const old_flush = s.last_flush;
  s.last_flush = flush;

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Write the header */
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    /* zlib header */
    let header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
    let level_flags = -1;

    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= (level_flags << 6);
    if (s.strstart !== 0) { header |= PRESET_DICT; }
    header += 31 - (header % 31);

    putShortMSB(s, header);

    /* Save the adler32 of the preset dictionary: */
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 0xffff);
    }
    strm.adler = 1; // adler32(0L, Z_NULL, 0);
    s.status = BUSY_STATE;

    /* Compression must start with an empty pending buffer */
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK;
    }
  }
//#ifdef GZIP
  if (s.status === GZIP_STATE) {
    /* gzip header */
    strm.adler = 0;  //crc32(0L, Z_NULL, 0);
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) { // s->gzhead == Z_NULL
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 :
                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                   4 : 0));
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;

      /* Compression must start with an empty pending buffer */
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK;
      }
    }
    else {
      put_byte(s, (s.gzhead.text ? 1 : 0) +
                  (s.gzhead.hcrc ? 2 : 0) +
                  (!s.gzhead.extra ? 0 : 4) +
                  (!s.gzhead.name ? 0 : 8) +
                  (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 0xff);
      put_byte(s, (s.gzhead.time >> 8) & 0xff);
      put_byte(s, (s.gzhead.time >> 16) & 0xff);
      put_byte(s, (s.gzhead.time >> 24) & 0xff);
      put_byte(s, s.level === 9 ? 2 :
                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                   4 : 0));
      put_byte(s, s.gzhead.os & 0xff);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 0xff);
        put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let left = (s.gzhead.extra.length & 0xffff) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        // zmemcpy(s.pending_buf + s.pending,
        //    s.gzhead.extra + s.gzindex, copy);
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        //--- HCRC_UPDATE(beg) ---//
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        //---//
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK;
        }
        beg = 0;
        left -= copy;
      }
      // JS specific: s.gzhead.extra may be TypedArray or Array for backward compatibility
      //              TypedArray.slice and TypedArray.from don't exist in IE10-IE11
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      // zmemcpy(s->pending_buf + s->pending,
      //     s->gzhead->extra + s->gzindex, left);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          //--- HCRC_UPDATE(beg) ---//
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          //---//
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK;
          }
          beg = 0;
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          //--- HCRC_UPDATE(beg) ---//
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          //---//
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK;
          }
          beg = 0;
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
      put_byte(s, strm.adler & 0xff);
      put_byte(s, (strm.adler >> 8) & 0xff);
      strm.adler = 0; //crc32(0L, Z_NULL, 0);
    }
    s.status = BUSY_STATE;

    /* Compression must start with an empty pending buffer */
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK;
    }
  }
//#endif

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) :
                 s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
                 s.strategy === Z_RLE ? deflate_rle(s, flush) :
                 configuration_table[s.level].func(s, flush);

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        _tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
};


const deflateEnd = (strm) => {

  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR;
  }

  const status = strm.state.status;

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
};


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
const deflateSetDictionary = (strm, dictionary) => {

  let dictLength = dictionary.length;

  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR;
  }

  const s = strm.state;
  const wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
};


module.exports.deflateInit = deflateInit;
module.exports.deflateInit2 = deflateInit2;
module.exports.deflateReset = deflateReset;
module.exports.deflateResetKeep = deflateResetKeep;
module.exports.deflateSetHeader = deflateSetHeader;
module.exports.deflate = deflate;
module.exports.deflateEnd = deflateEnd;
module.exports.deflateSetDictionary = deflateSetDictionary;
module.exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
module.exports.deflateBound = deflateBound;
module.exports.deflateCopy = deflateCopy;
module.exports.deflateGetDictionary = deflateGetDictionary;
module.exports.deflateParams = deflateParams;
module.exports.deflatePending = deflatePending;
module.exports.deflatePrime = deflatePrime;
module.exports.deflateTune = deflateTune;
*/


/***/ }),

/***/ 35105:
/***/ ((module) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;


/***/ }),

/***/ 65349:
/***/ ((module) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD = 16209;       /* got a data error -- remain here until reset */
const TYPE = 16191;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  let _in;                    /* local strm.input */
  let last;                   /* have enough input while in < last */
  let _out;                   /* local strm.output */
  let beg;                    /* inflate()'s initial strm.output */
  let end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  let dmax;                   /* maximum distance from zlib header */
//#endif
  let wsize;                  /* window size or zero if not using window */
  let whave;                  /* valid bytes in the window */
  let wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window;               /* allocated sliding window, if wsize != 0 */
  let hold;                   /* local strm.hold */
  let bits;                   /* local strm.bits */
  let lcode;                  /* local strm.lencode */
  let dcode;                  /* local strm.distcode */
  let lmask;                  /* mask for first level of length codes */
  let dmask;                  /* mask for first level of distance codes */
  let here;                   /* retrieved table entry */
  let op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  let len;                    /* match length, unused bytes */
  let dist;                   /* match distance */
  let from;                   /* where to copy match from */
  let from_source;


  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};


/***/ }),

/***/ 90409:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32       = __webpack_require__(86924);
const crc32         = __webpack_require__(87242);
const inflate_fast  = __webpack_require__(65349);
const inflate_table = __webpack_require__(56895);

const CODES = 0;
const LENS = 1;
const DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_FINISH, Z_BLOCK, Z_TREES,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR, Z_BUF_ERROR,
  Z_DEFLATED
} = __webpack_require__(58282);


/* STATES ====================================================================*/
/* ===========================================================================*/


const    HEAD = 16180;       /* i: waiting for magic header */
const    FLAGS = 16181;      /* i: waiting for method and flags (gzip) */
const    TIME = 16182;       /* i: waiting for modification time (gzip) */
const    OS = 16183;         /* i: waiting for extra flags and operating system (gzip) */
const    EXLEN = 16184;      /* i: waiting for extra length (gzip) */
const    EXTRA = 16185;      /* i: waiting for extra bytes (gzip) */
const    NAME = 16186;       /* i: waiting for end of file name (gzip) */
const    COMMENT = 16187;    /* i: waiting for end of comment (gzip) */
const    HCRC = 16188;       /* i: waiting for header crc (gzip) */
const    DICTID = 16189;    /* i: waiting for dictionary check value */
const    DICT = 16190;      /* waiting for inflateSetDictionary() call */
const        TYPE = 16191;      /* i: waiting for type bits, including last-flag bit */
const        TYPEDO = 16192;    /* i: same, but skip check to exit inflate on new block */
const        STORED = 16193;    /* i: waiting for stored size (length and complement) */
const        COPY_ = 16194;     /* i/o: same as COPY below, but only first time in */
const        COPY = 16195;      /* i/o: waiting for input or output to copy stored block */
const        TABLE = 16196;     /* i: waiting for dynamic block table lengths */
const        LENLENS = 16197;   /* i: waiting for code length code lengths */
const        CODELENS = 16198;  /* i: waiting for length/lit and distance code lengths */
const            LEN_ = 16199;      /* i: same as LEN below, but only first time in */
const            LEN = 16200;       /* i: waiting for length/lit/eob code */
const            LENEXT = 16201;    /* i: waiting for length extra bits */
const            DIST = 16202;      /* i: waiting for distance code */
const            DISTEXT = 16203;   /* i: waiting for distance extra bits */
const            MATCH = 16204;     /* o: waiting for output space to copy string */
const            LIT = 16205;       /* o: waiting for output space to write literal */
const    CHECK = 16206;     /* i: waiting for 32-bit check value */
const    LENGTH = 16207;    /* i: waiting for 32-bit length (gzip) */
const    DONE = 16208;      /* finished check, done -- remain here until reset */
const    BAD = 16209;       /* got a data error -- remain here until reset */
const    MEM = 16210;       /* got an inflate() memory error -- remain here until reset */
const    SYNC = 16211;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_WBITS = MAX_WBITS;


const zswap32 = (q) => {

  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
};


function InflateState() {
  this.strm = null;           /* pointer back to this zlib stream */
  this.mode = 0;              /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip,
                                 bit 2 true to validate check value */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib), or
                                 -1 if raw or no header yet */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new Uint16Array(320); /* temporary storage for code lengths */
  this.work = new Uint16Array(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}


const inflateStateCheck = (strm) => {

  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm ||
    state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};


const inflateResetKeep = (strm) => {

  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR; }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
};


const inflateReset = (strm) => {

  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR; }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

};


const inflateReset2 = (strm, windowBits) => {
  let wrap;

  /* get the state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR; }
  const state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};


const inflateInit2 = (strm, windowBits) => {

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  const state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.strm = strm;
  state.window = null/*Z_NULL*/;
  state.mode = HEAD;     /* to pass state test in inflateReset2() */
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
};


const inflateInit = (strm) => {

  return inflateInit2(strm, DEF_WBITS);
};


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
let virgin = true;

let lenfix, distfix; // We have no pointers in JS, so keep tables separate


const fixedtables = (state) => {

  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);

    /* literal/length table */
    let sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
const updatewindow = (strm, src, end, copy) => {

  let dist;
  const state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new Uint8Array(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
};


const inflate = (strm, flush) => {

  let state;
  let input, output;          // input/output buffers
  let next;                   /* next input INDEX */
  let put;                    /* next output INDEX */
  let have, left;             /* available input and output */
  let hold;                   /* bit buffer */
  let bits;                   /* bits in bit buffer */
  let _in, _out;              /* save starting available input and output */
  let copy;                   /* number of stored or match bytes to copy */
  let from;                   /* where to copy match bytes from */
  let from_source;
  let here = 0;               /* current decoding table entry */
  let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //let last;                   /* parent table entry */
  let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  let len;                    /* length to copy for repeats, bits to drop */
  let ret;                    /* return code */
  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
  let opts;

  let n; // temporary variable for NEED_BITS

  const order = /* permutation of code lengths */
    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


  if (inflateStateCheck(strm) || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          if (state.wbits === 0) {
            state.wbits = 15;
          }
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        if (len > 15 || len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        // !!! pako patch. Force use `options.windowBits` if passed.
        // Required to always use max window size by default.
        state.dmax = 1 << state.wbits;
        //state.dmax = 1 << len;

        state.flags = 0;               /* indicate zlib header */
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Uint8Array(state.head.extra_len);
              }
              state.head.extra.set(
                input.subarray(
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  next + copy
                ),
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if ((state.flags & 0x0200) && (state.wrap & 4)) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((state.wrap & 4) && hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          output.set(input.subarray(next, next + copy), put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if ((state.wrap & 4) && _out) {
            strm.adler = state.check =
                /*UPDATE_CHECK(state.check, put - _out, _out);*/
                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.wrap & 4) && (state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((state.wrap & 4) && hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if ((state.wrap & 4) && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};


const inflateEnd = (strm) => {

  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR;
  }

  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
};


const inflateGetHeader = (strm, head) => {

  /* check state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR; }
  const state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
};


const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;

  let state;
  let dictid;
  let ret;

  /* check state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
};


module.exports.inflateReset = inflateReset;
module.exports.inflateReset2 = inflateReset2;
module.exports.inflateResetKeep = inflateResetKeep;
module.exports.inflateInit = inflateInit;
module.exports.inflateInit2 = inflateInit2;
module.exports.inflate = inflate;
module.exports.inflateEnd = inflateEnd;
module.exports.inflateGetHeader = inflateGetHeader;
module.exports.inflateSetDictionary = inflateSetDictionary;
module.exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
module.exports.inflateCodesUsed = inflateCodesUsed;
module.exports.inflateCopy = inflateCopy;
module.exports.inflateGetDictionary = inflateGetDictionary;
module.exports.inflateMark = inflateMark;
module.exports.inflatePrime = inflatePrime;
module.exports.inflateSync = inflateSync;
module.exports.inflateSyncPoint = inflateSyncPoint;
module.exports.inflateUndermine = inflateUndermine;
module.exports.inflateValidate = inflateValidate;
*/


/***/ }),

/***/ 56895:
/***/ ((module) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const MAXBITS = 15;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

const CODES = 0;
const LENS = 1;
const DISTS = 2;

const lbase = new Uint16Array([ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
]);

const lext = new Uint8Array([ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
]);

const dbase = new Uint16Array([ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
]);

const dext = new Uint8Array([ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
]);

const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
{
  const bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  let len = 0;               /* a code's length in bits */
  let sym = 0;               /* index of code symbols */
  let min = 0, max = 0;          /* minimum and maximum code lengths */
  let root = 0;              /* number of index bits for root table */
  let curr = 0;              /* number of index bits for current table */
  let drop = 0;              /* code bits to drop for sub-table */
  let left = 0;                   /* number of prefix codes available */
  let used = 0;              /* code entries in table used */
  let huff = 0;              /* Huffman code */
  let incr;              /* for incrementing code, index */
  let fill;              /* index for replicating entries */
  let low;               /* low bits for current root entry */
  let mask;              /* mask for low root bits */
  let next;             /* next available space in table */
  let base = null;     /* base value table to use */
//  let shoextra;    /* extra bits table to use */
  let match;                  /* use base and extra for symbol >= match */
  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  let extra = null;

  let here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    match = 20;

  } else if (type === LENS) {
    base = lbase;
    extra = lext;
    match = 257;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    match = 0;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


module.exports = inflate_table;


/***/ }),

/***/ 1890:
/***/ ((module) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};


/***/ }),

/***/ 78754:
/***/ ((module) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

/* Public constants ==========================================================*/
/* ===========================================================================*/


//const Z_FILTERED          = 1;
//const Z_HUFFMAN_ONLY      = 2;
//const Z_RLE               = 3;
const Z_FIXED               = 4;
//const Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
const Z_BINARY              = 0;
const Z_TEXT                = 1;
//const Z_ASCII             = 1; // = Z_TEXT
const Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES    = 2;
/* The three kinds of block type */

const MIN_MATCH    = 3;
const MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

const LITERALS      = 256;
/* number of literal bytes 0..255 */

const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

const D_CODES       = 30;
/* number of distance codes */

const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

const MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

const Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

const MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

const END_BLOCK   = 256;
/* end of block literal code */

const REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

const REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

const REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
const extra_lbits =   /* extra bits for each length code */
  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);

const extra_dbits =   /* extra bits for each distance code */
  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);

const extra_blbits =  /* extra bits for each bit length code */
  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);

const bl_order =
  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
const static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

const static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

const _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

const _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

const base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

const base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


let static_l_desc;
let static_d_desc;
let static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



const d_code = (dist) => {

  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
const put_short = (s, w) => {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
};


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
const send_bits = (s, value, length) => {

  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
};


const send_code = (s, c, tree) => {

  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
};


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
const bi_reverse = (code, len) => {

  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
const bi_flush = (s) => {

  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
const gen_bitlen = (s, desc) => {
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */

  const tree            = desc.dyn_tree;
  const max_code        = desc.max_code;
  const stree           = desc.stat_desc.static_tree;
  const has_stree       = desc.stat_desc.has_stree;
  const extra           = desc.stat_desc.extra_bits;
  const base            = desc.stat_desc.extra_base;
  const max_length      = desc.stat_desc.max_length;
  let h;              /* heap index */
  let n, m;           /* iterate over the tree elements */
  let bits;           /* bit length */
  let xbits;          /* extra bits */
  let f;              /* frequency */
  let overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Tracev((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
};


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
const gen_codes = (tree, max_code, bl_count) => {
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */

  const next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  let code = 0;              /* running code value */
  let bits;                  /* bit index */
  let n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    code = (code + bl_count[bits - 1]) << 1;
    next_code[bits] = code;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    let len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
};


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
const tr_static_init = () => {

  let n;        /* iterates over tree elements */
  let bits;     /* bit counter */
  let length;   /* length value */
  let code;     /* code value */
  let dist;     /* distance index */
  const bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
};


/* ===========================================================================
 * Initialize a new block.
 */
const init_block = (s) => {

  let n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
const bi_windup = (s) =>
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
const smaller = (tree, n, m, depth) => {

  const _n2 = n * 2;
  const _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
};

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
const pqdownheap = (s, tree, k) => {
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */

  const v = s.heap[k];
  let j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
};


// inlined manually
// const SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
const compress_block = (s, ltree, dtree) => {
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */

  let dist;           /* distance of matched string */
  let lc;             /* match length or unmatched char (if dist == 0) */
  let sx = 0;         /* running index in sym_buf */
  let code;           /* the code to send */
  let extra;          /* number of extra bits to send */

  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 0xff;
      dist += (s.pending_buf[s.sym_buf + sx++] & 0xff) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and sym_buf is ok: */
      //Assert(s->pending < s->lit_bufsize + sx, "pendingBuf overflow");

    } while (sx < s.sym_next);
  }

  send_code(s, END_BLOCK, ltree);
};


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
const build_tree = (s, desc) => {
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */

  const tree     = desc.dyn_tree;
  const stree    = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems    = desc.stat_desc.elems;
  let n, m;          /* iterate over heap elements */
  let max_code = -1; /* largest code with non zero frequency */
  let node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
};


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
const scan_tree = (s, tree, max_code) => {
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */

  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
const send_tree = (s, tree, max_code) => {
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */

  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
const build_bl_tree = (s) => {

  let max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
};


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
const send_all_trees = (s, lcodes, dcodes, blcodes) => {
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */

  let rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
};


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "block list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "allow list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
const detect_data_type = (s) => {
  /* block_mask is the bit mask of block-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  let block_mask = 0xf3ffc07f;
  let n;

  /* Check for non-textual ("block-listed") bytes. */
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if ((block_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("allow-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "block-listed" or "allow-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
};


let static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
const _tr_init = (s) =>
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
};


/* ===========================================================================
 * Send a stored block
 */
const _tr_stored_block = (s, buf, stored_len, last) => {
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */

  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  bi_windup(s);        /* align on byte boundary */
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
const _tr_align = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and write out the encoded block.
 */
const _tr_flush_block = (s, buf, stored_len, last) => {
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */

  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  let max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->sym_next / 3));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
};

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
const _tr_tally = (s, dist, lc) => {
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */

  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

  return (s.sym_next === s.sym_end);
};

module.exports._tr_init  = _tr_init;
module.exports._tr_stored_block = _tr_stored_block;
module.exports._tr_flush_block  = _tr_flush_block;
module.exports._tr_tally = _tr_tally;
module.exports._tr_align = _tr_align;


/***/ }),

/***/ 86442:
/***/ ((module) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;


/***/ }),

/***/ 13319:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;


/***/ }),

/***/ 44742:
/***/ ((module) => {

"use strict";


/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};


/***/ }),

/***/ 25682:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var required = __webpack_require__(44742)
  , qs = __webpack_require__(13319)
  , controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/
  , CRHTLF = /[\n\r\t]/g
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , port = /:\d+$/
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i
  , windowsDriveLetter = /^[a-zA-Z]:/;

/**
 * Remove control characters and whitespace from the beginning of a string.
 *
 * @param {Object|String} str String to trim.
 * @returns {String} A new string representing `str` stripped of control
 *     characters and whitespace from its beginning.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(controlOrWhitespace, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address, url) {     // Sanitize what is left of the address
    return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d*)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof global !== 'undefined') globalVar = global;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * Check whether a protocol scheme is special.
 *
 * @param {String} The protocol scheme of the URL
 * @return {Boolean} `true` if the protocol scheme is special, else `false`
 * @private
 */
function isSpecial(scheme) {
  return (
    scheme === 'file:' ||
    scheme === 'ftp:' ||
    scheme === 'http:' ||
    scheme === 'https:' ||
    scheme === 'ws:' ||
    scheme === 'wss:'
  );
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @param {Object} location
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address, location) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');
  location = location || {};

  var match = protocolre.exec(address);
  var protocol = match[1] ? match[1].toLowerCase() : '';
  var forwardSlashes = !!match[2];
  var otherSlashes = !!match[3];
  var slashesCount = 0;
  var rest;

  if (forwardSlashes) {
    if (otherSlashes) {
      rest = match[2] + match[3] + match[4];
      slashesCount = match[2].length + match[3].length;
    } else {
      rest = match[2] + match[4];
      slashesCount = match[2].length;
    }
  } else {
    if (otherSlashes) {
      rest = match[3] + match[4];
      slashesCount = match[3].length;
    } else {
      rest = match[4]
    }
  }

  if (protocol === 'file:') {
    if (slashesCount >= 2) {
      rest = rest.slice(2);
    }
  } else if (isSpecial(protocol)) {
    rest = match[4];
  } else if (protocol) {
    if (forwardSlashes) {
      rest = rest.slice(2);
    }
  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
    rest = match[4];
  }

  return {
    protocol: protocol,
    slashes: forwardSlashes || isSpecial(protocol),
    slashesCount: slashesCount,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '', location);
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (
    extracted.protocol === 'file:' && (
      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||
    (!extracted.slashes &&
      (extracted.protocol ||
        extracted.slashesCount < 2 ||
        !isSpecial(url.protocol)))
  ) {
    instructions[3] = [/(.*)/, 'pathname'];
  }

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address, url);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      index = parse === '@'
        ? address.lastIndexOf(parse)
        : address.indexOf(parse);

      if (~index) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';

  if (url.auth) {
    index = url.auth.indexOf(':');

    if (~index) {
      url.username = url.auth.slice(0, index);
      url.username = encodeURIComponent(decodeURIComponent(url.username));

      url.password = url.auth.slice(index + 1);
      url.password = encodeURIComponent(decodeURIComponent(url.password))
    } else {
      url.username = encodeURIComponent(decodeURIComponent(url.auth));
    }

    url.auth = url.password ? url.username +':'+ url.password : url.username;
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (port.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    case 'username':
    case 'password':
      url[part] = encodeURIComponent(value);
      break;

    case 'auth':
      var index = value.indexOf(':');

      if (~index) {
        url.username = value.slice(0, index);
        url.username = encodeURIComponent(decodeURIComponent(url.username));

        url.password = value.slice(index + 1);
        url.password = encodeURIComponent(decodeURIComponent(url.password));
      } else {
        url.username = encodeURIComponent(decodeURIComponent(value));
      }
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.auth = url.password ? url.username +':'+ url.password : url.username;

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , host = url.host
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result =
    protocol +
    ((url.protocol && url.slashes) || isSpecial(url.protocol) ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  } else if (url.password) {
    result += ':'+ url.password;
    result += '@';
  } else if (
    url.protocol !== 'file:' &&
    isSpecial(url.protocol) &&
    !host &&
    url.pathname !== '/'
  ) {
    //
    // Add back the empty userinfo, otherwise the original invalid URL
    // might be transformed into a valid one with `url.pathname` as host.
    //
    result += '@';
  }

  //
  // Trailing colon is removed from `url.host` when it is parsed. If it still
  // ends with a colon, then add back the trailing colon that was removed. This
  // prevents an invalid URL from being transformed into a valid one.
  //
  if (host[host.length - 1] === ':' || (port.test(url.hostname) && !url.port)) {
    host += ':';
  }

  result += host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;


/***/ })

};
;
//# sourceMappingURL=128.index.js.map