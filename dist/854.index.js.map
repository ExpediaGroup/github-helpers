{"version":3,"file":"854.index.js","mappings":";;;;;;;;;;;;AAAA;;;;;;;;;;;AAWA;AAEA;AAqCA;AASA;AARA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7OA;;;;;;;;;;;AAWA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChEA;;;;;;;;;;;AAWA;;;;;;;;;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;ACjHA;;;;;;;;;;;AAWA;AAEA;AAwCA;;;;;;;;;;;;;;;;;ACrDA;;;;;;;;;;;AAWA;;;;;;;;;;AAEA;AACA;AAEA;AACA;AAWA;;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;;AACA;AAEA;AACA;;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA","sources":["webpack://github-helpers/./src/core/multisigs-collector.ts","webpack://github-helpers/./src/core/filtered-collector.ts","webpack://github-helpers/./src/helpers/backstage-export.ts","webpack://github-helpers/./src/types/generated.ts","webpack://github-helpers/./src/utils/get-backstage-entities.ts"],"sourcesContent":["/*\nCopyright 2022 Aurora Labs\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {\n  Entity,\n  isApiEntity,\n  isResourceEntity,\n  stringifyEntityRef,\n  RELATION_OWNED_BY,\n  RELATION_API_CONSUMED_BY,\n  RELATION_HAS_PART,\n  parseEntityRef\n} from '@backstage/catalog-model';\n\ntype MultisigSigner = {\n  signer: Entity;\n  owner?: Entity;\n};\ntype MultisigSignerAndKeysComposed = MultisigSigner & { keys: Entity[] };\ntype MultisigSignerAndKeys = {\n  [K in keyof MultisigSignerAndKeysComposed]: MultisigSignerAndKeysComposed[K];\n};\n\ntype MultisigInfo = {\n  entity: Entity;\n  signers: MultisigSigner[];\n};\n\ntype ComponentMultisigs = {\n  title: string;\n  component: Entity;\n  multisigs: MultisigInfo[];\n};\n\ntype SystemComponents = {\n  title: string;\n  system: Entity;\n  components: ComponentMultisigs[];\n};\n\nexport class MultisigsCollector {\n  systemComponents: SystemComponents[] = [];\n  private entities: Entity[] = [];\n  private apiEntities: Entity[] = [];\n  private resourceEntities: Entity[] = [];\n  private multisigs: Entity[] = [];\n  private contracts: Entity[] = [];\n  private accessKeys: Entity[] = [];\n\n  constructor(entities: Entity[]) {\n    this.entities = entities;\n    this.apiEntities = this.entities.filter(isApiEntity);\n    this.resourceEntities = this.entities.filter(isResourceEntity);\n    this.multisigs = this.apiEntities.filter(item => item.spec?.type === 'multisig-deployment');\n    this.contracts = this.apiEntities.filter(item => item.spec?.type === 'contract-deployment');\n    this.accessKeys = this.resourceEntities.filter(item => item.spec?.type === 'access-key');\n    this.systemComponents = this.collectSystems();\n  }\n\n  normalizeEntities(list: string[]) {\n    return [...new Set(list)].sort((a, b) => a.localeCompare(b));\n  }\n\n  collectSystems() {\n    const systemRefs = this.normalizeEntities(this.multisigs.map(item => item.spec!.system! as string));\n    return systemRefs\n      .map(systemRef => {\n        const system = this.entities.find(item => stringifyEntityRef(item) === systemRef)!;\n        const components = this.collectComponents(system);\n\n        return {\n          title: system.metadata.title || system.metadata.name,\n          system,\n          components\n        };\n      })\n      .sort((a, b) => a.system.metadata.name.localeCompare(b.system.metadata.name));\n  }\n\n  collectComponents(system: Entity) {\n    const componentRefs = system.relations!.filter(r => r.type === RELATION_HAS_PART && parseEntityRef(r.targetRef).kind === 'component');\n    return componentRefs\n      .map(componentRef => {\n        const component = this.entities.find(item => stringifyEntityRef(item) === componentRef.targetRef)!;\n        return {\n          title: component.metadata.title || component.metadata.name,\n          component,\n          multisigs: this.multisigs\n            .filter(item => item.relations!.some(r => r.type === 'apiProvidedBy' && r.targetRef === componentRef.targetRef))\n            .map(ms => ({\n              entity: ms,\n              signers: this.collectSigners(ms)\n            }))\n        };\n      })\n      .sort((a, b) => a.component.metadata.name.localeCompare(b.component.metadata.name));\n  }\n\n  collectSigners(multisig: Entity) {\n    return multisig\n      .relations!.filter(r => r.type === RELATION_OWNED_BY && parseEntityRef(r.targetRef).kind !== 'group')\n      .map(r => {\n        const signer = this.entities.find(e => stringifyEntityRef(e) === r.targetRef)!;\n        const owner = this.entities.find(e => stringifyEntityRef(e) === signer.spec!.owner)!;\n        return {\n          signer,\n          owner\n        };\n      })\n      .sort((a, b) => a.owner.metadata.name.localeCompare(b.owner.metadata.name));\n  }\n\n  getAllApis() {\n    return this.apiEntities;\n  }\n\n  getAllResources() {\n    return this.resourceEntities;\n  }\n\n  getMultisigs() {\n    return this.systemComponents.flatMap(system => system.components.flatMap(component => component.multisigs));\n  }\n\n  getNearContracts() {\n    return this.contracts.filter(entity => entity.spec?.network === 'near');\n  }\n\n  getSigners() {\n    const allSigners = this.getMultisigs().flatMap(ms => ms.signers);\n    const uniqueSigners = allSigners.reduce<{ [uid: string]: MultisigSigner }>((acc, signer) => {\n      const uid = signer.signer.metadata.uid;\n      if (uid && uid in allSigners) {\n        return acc;\n      }\n      if (!this.isQualifiedEntity(signer.signer)) {\n        return acc;\n      }\n      return { ...acc, [uid as string]: signer };\n    }, {});\n    return Object.values(uniqueSigners);\n  }\n\n  getMultisigAccessKeys(): Entity[] {\n    const signers = this.getSigners().filter(value => value.signer.spec?.network === 'near');\n    const keys = signers.flatMap(value => {\n      if (!value.signer.relations) {\n        return [];\n      }\n      return value.signer.relations\n        .filter(r => r.type === RELATION_API_CONSUMED_BY && parseEntityRef(r.targetRef).kind === 'resource')\n        .map(relation => {\n          const key = this.entities.find(e => stringifyEntityRef(e) === relation.targetRef);\n          return key;\n        });\n    });\n\n    return keys.filter<Entity>(this.isEntity).filter(this.isQualifiedEntity);\n  }\n\n  getAccessKeysPerSigner() {\n    const signers = this.getSigners().filter(value => value.signer.spec?.network === 'near');\n    const keysPerSigner = signers.reduce<{ [s: string]: MultisigSignerAndKeys }>((acc, value) => {\n      if (!value.signer.relations) {\n        return acc;\n      }\n      const spec = JSON.parse(JSON.stringify(value.signer.spec));\n      const signer: string = spec.address;\n      const keys = value.signer.relations\n        .filter(r => r.type === RELATION_API_CONSUMED_BY && parseEntityRef(r.targetRef).kind === 'resource')\n        .map(relation => {\n          const key = this.entities.find(e => stringifyEntityRef(e) === relation.targetRef);\n          return key;\n        })\n        .filter<Entity>(this.isEntity);\n\n      return {\n        ...acc,\n        [signer]: {\n          owner: value.owner,\n          signer: value.signer,\n          keys\n        }\n      };\n    }, {});\n\n    return keysPerSigner;\n  }\n\n  getContractAccessKeys(): Entity[] {\n    const keys = this.contracts.flatMap(value => {\n      if (!value.relations) {\n        return [];\n      }\n      return value.relations\n        .filter(r => r.type === RELATION_API_CONSUMED_BY && parseEntityRef(r.targetRef).kind === 'resource')\n        .map(relation => {\n          const key = this.entities.find(e => stringifyEntityRef(e) === relation.targetRef);\n          return key;\n        });\n    });\n    return keys.filter<Entity>(this.isEntity);\n  }\n\n  getAllAccessKeys(): Entity[] {\n    return this.accessKeys;\n  }\n\n  getDeprecatedAccessKeys(): Entity[] {\n    const keys = this.getAllAccessKeys();\n    const deprecated = keys.filter(entity => entity.metadata.tags?.includes('deprecated'));\n    return deprecated;\n  }\n\n  getUnknownAccessKeys(): Entity[] {\n    const keys = this.getAllAccessKeys();\n    const unknown = keys.filter(entity => entity.metadata.tags?.includes('unknown'));\n    return unknown;\n  }\n\n  private isQualifiedEntity(entity: Entity) {\n    return !entity.metadata.tags?.includes('retired') && !entity.metadata.tags?.includes('allow-unknown');\n  }\n\n  private isEntity(entity: Entity | undefined): entity is Entity {\n    return entity !== undefined;\n  }\n}\n","/*\nCopyright 2022 Aurora Labs\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { JsonObject } from '@backstage/types';\nimport { Entity } from '@backstage/catalog-model';\n\nfunction pick<T extends {}, K extends keyof T>(obj: T, whitelist: K[]): Pick<T, K> {\n  return whitelist.reduce((newObj, key) => {\n    if (key in obj) {\n      // eslint-disable-next-line functional/immutable-data\n      newObj[key] = obj[key];\n    }\n    return newObj;\n  }, {} as Pick<T, K>);\n}\n\nconst ALLOWED_KINDS = ['Component', 'System'];\nconst ALLOWED_SPEC_FIELDS = ['type', 'deployedAt'];\nconst ALLOWED_METADATA_FIELDS = ['uid', 'namespace', 'name', 'title', 'annotations', 'tags'];\n\nexport class FilteredCollector {\n  entities: Entity[];\n  private srcEntities: Entity[];\n\n  constructor(entities: Entity[]) {\n    this.srcEntities = entities;\n    this.entities = this.filterEntities();\n  }\n\n  normalizeEntities(list: string[]) {\n    return [...new Set(list)].sort((a, b) => a.localeCompare(b));\n  }\n\n  filterSpec(spec?: JsonObject) {\n    if (!spec) return {};\n    return pick(spec, ALLOWED_SPEC_FIELDS);\n  }\n\n  filterMetadata(metadata: JsonObject) {\n    return pick(metadata, ALLOWED_METADATA_FIELDS);\n  }\n\n  filterEntities() {\n    return this.srcEntities\n      .filter(e => ALLOWED_KINDS.includes(e.kind))\n      .map(e => {\n        return {\n          apiVersion: e.apiVersion,\n          kind: e.kind,\n          metadata: this.filterMetadata(e.metadata),\n          spec: this.filterSpec(e.spec)\n        } as Entity;\n      });\n  }\n}\n","/*\nCopyright 2022 Aurora Labs\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport * as core from '@actions/core';\nimport * as glob from 'glob';\nimport { HelperInputs } from '../types/generated';\nimport { Entity } from '@backstage/catalog-model';\nimport * as fs from 'fs';\n//import YAML from 'yaml';\nimport { simpleGit } from 'simple-git';\nimport handlebars from 'handlebars';\n\nimport { MultisigsCollector } from '../core/multisigs-collector';\nimport { getBackstageEntities } from '../utils/get-backstage-entities';\nimport { FilteredCollector } from '../core/filtered-collector';\n\nexport class BackstageExport extends HelperInputs {\n  backstage_url?: string;\n  template_path?: string;\n  output_path?: string;\n  testing?: boolean;\n}\n\nfunction reexportTemplate(inputs: BackstageExport & { templatePath: string; templateData: {} }) {\n  const outputPath = inputs.output_path! + inputs.templatePath.replace(inputs.template_path!, '').replace('.hbs', '');\n\n  const compiledTemplate = handlebars.compile(fs.readFileSync(inputs.templatePath, { encoding: 'utf8' }), {\n    strict: true\n  });\n\n  const options = {\n    helpers: {\n      backstageLink: (entity: Entity) => {\n        if (!entity) return 'undefined';\n        const md = entity.metadata;\n        return `${inputs.backstage_url}/catalog/${md.namespace}/${entity.kind}/${md.name}`;\n      }\n    }\n  };\n\n  const compiledContent = compiledTemplate(inputs.templateData, options);\n\n  const existingContent =\n    fs.existsSync(outputPath) &&\n    fs.readFileSync(outputPath, {\n      encoding: 'utf-8'\n    });\n  if (compiledContent !== existingContent) {\n    core.info(`Writing ${outputPath}: changed content`);\n    fs.writeFileSync(outputPath, compiledContent);\n    return true;\n  }\n  return false;\n}\n\nasync function commitAndPushChanges(output_path: string) {\n  const git = simpleGit('.');\n  await git.addConfig('user.email', 'security@aurora.dev');\n  await git.addConfig('user.name', 'Backstage Exporter');\n  await git.add(output_path);\n  const msg = 'chore(backstage): 🥷🏽 automatic re-export';\n  await git.commit(msg, undefined);\n  await git.push();\n  core.info('Updated and pushed the changes');\n  return true;\n}\n\nexport const backstageExport = async ({ backstage_url, template_path, output_path, testing }: BackstageExport) => {\n  if (!template_path || !output_path) {\n    throw new Error('set template_path and output_path for handlebars templating');\n  }\n\n  const entities = await getBackstageEntities({ backstage_url });\n\n  const multisigsCollector = new MultisigsCollector(entities);\n  const filteredCollector = new FilteredCollector(entities);\n\n  // console.log(JSON.stringify(multisigsCollector.systemComponents[0], null, 2));\n  const changedFiles = glob.sync(`${template_path}**/*.hbs`).reduce((acc, templatePath) => {\n    const templateData = {\n      multisigSystemComponents: multisigsCollector.systemComponents,\n      filteredEntities: JSON.stringify(filteredCollector.entities, null, 2),\n      testing\n    };\n\n    if (reexportTemplate({ backstage_url, output_path, template_path, templatePath, templateData })) {\n      return [templatePath, ...acc];\n    }\n\n    return acc;\n  }, [] as string[]);\n\n  if (testing) {\n    core.info(`Testing mode: ${changedFiles.length} changed files, exiting`);\n    return true;\n  }\n\n  if (changedFiles.length === 0) {\n    core.info('No changed files, nothing to commit');\n    return false;\n  }\n\n  await commitAndPushChanges(output_path);\n};\n","/*\nCopyright 2021 Expedia, Inc.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nexport class HelperInputs {\n  helper?: string;\n  github_token?: string;\n  body?: string;\n  project_name?: string;\n  project_destination_column_name?: string;\n  note?: string;\n  project_origin_column_name?: string;\n  sha?: string;\n  context?: string;\n  state?: string;\n  description?: string;\n  target_url?: string;\n  environment?: string;\n  environment_url?: string;\n  label?: string;\n  labels?: string;\n  paths?: string;\n  extensions?: string;\n  override_filter_paths?: string;\n  batches?: string;\n  pattern?: string;\n  teams?: string;\n  login?: string;\n  paths_no_filter?: string;\n  slack_webhook_url?: string;\n  number_of_assignees?: string;\n  globs?: string;\n  override_filter_globs?: string;\n  title?: string;\n  seconds?: string;\n  pull_number?: string;\n  base?: string;\n  head?: string;\n  backstage_url?: string;\n  backstage_entities_repo?: string;\n  force_all_checks?: string;\n  ignore_failures?: string;\n  template_path?: string;\n  output_path?: string;\n}\n","/*\nCopyright 2022 Aurora Labs\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    https://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport * as core from '@actions/core';\nimport { CatalogClient } from '@backstage/catalog-client';\nimport { Entity } from '@backstage/catalog-model';\nimport { simpleGit } from 'simple-git';\nimport { now } from 'lodash';\n\ntype DiscoveryApi = {\n  getBaseUrl(pluginId: string): Promise<string>;\n};\n\ninterface GetBackstageEntities {\n  backstage_url?: string;\n  backstage_entities_repo?: string;\n}\n\nasync function getFileContentFromRepo(repoUrl: string, filePath: string): Promise<string> {\n  const cloneDir = `/tmp/github-helpers-${now()}`;\n  const git = simpleGit();\n\n  try {\n    await git.clone(repoUrl, cloneDir, ['--depth=1']);\n    await git.cwd(cloneDir);\n\n    const { current } = await git.branch();\n    const defaultBranch = current || 'main';\n    const fileContent: string = await git.show([`${defaultBranch}:${filePath}`]);\n\n    await git.raw(['rm', '-rf', '.']);\n    return fileContent;\n  } catch (error) {\n    throw new Error(`Failed to fetch ${repoUrl}/${filePath}: ${error}`);\n  }\n}\n\nasync function fetchBackstageEntitiesFromURL(backstage_url: string) {\n  core.info('Connecting to Backstage to fetch available entities');\n\n  const discoveryApi: DiscoveryApi = {\n    async getBaseUrl() {\n      return `${backstage_url}/api/catalog`;\n    }\n  };\n  const catalogClient = new CatalogClient({\n    discoveryApi\n  });\n\n  const entities = await catalogClient.getEntities({});\n  core.info(`Total backstage entities: ${entities.items.length}`);\n\n  return entities.items;\n}\n\nasync function fetchBackstageEntitiesFromRepo(backstage_entities_repo: string) {\n  const serverUrl = process.env.GITHUB_SERVER_URL || 'https://github.com';\n  const repoUrl = `${serverUrl}/${backstage_entities_repo}`;\n  core.info(`Cloning ${repoUrl}`);\n  const content = await getFileContentFromRepo(repoUrl, 'filteredEntities.json');\n  return JSON.parse(content) as Entity[];\n}\n\nexport const getBackstageEntities = async ({ backstage_url, backstage_entities_repo }: GetBackstageEntities) => {\n  // repo takes a priority over the URL in order to avoid unnecessary runtime\n  // dependency\n  if (backstage_entities_repo) {\n    return fetchBackstageEntitiesFromRepo(backstage_entities_repo);\n  } else if (backstage_url) {\n    return fetchBackstageEntitiesFromURL(backstage_url);\n  }\n  throw new Error(\n    'Backstage URL or entities repo is required. Set BACKSTAGE_URL (github secret) or pass backstage_entities_repo argument to this action'\n  );\n};\n"],"names":[],"sourceRoot":""}